/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _express = __webpack_require__(271);
	
	var _express2 = _interopRequireDefault(_express);
	
	var _bodyParser = __webpack_require__(269);
	
	var _bodyParser2 = _interopRequireDefault(_bodyParser);
	
	var _config = __webpack_require__(257);
	
	var _config2 = _interopRequireDefault(_config);
	
	var _routes = __webpack_require__(256);
	
	var _routes2 = _interopRequireDefault(_routes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// import mongoose from 'mongoose';
	
	var path = __webpack_require__(69);
	
	var server = (0, _express2.default)();
	
	if (process.env.NODE_ENV === 'dev') {
	  var webpackMiddleware = __webpack_require__(282);
	  var webpackHotMiddleware = __webpack_require__(283);
	  var webpack = __webpack_require__(107);
	  var webpackDevConfig = __webpack_require__(258);
	  var compiler = webpack(webpackDevConfig);
	  var middleware = webpackMiddleware(compiler, {
	    publicPath: webpackDevConfig.output.publicPath,
	    stats: { colors: true }
	  });
	  server.use(middleware);
	  server.use(webpackHotMiddleware(compiler));
	  server.get('/', function (req, res) {
	    res.sendFile(path.join(__dirname, '../dist/index.html'));
	  });
	} else {
	  server.use(_express2.default.static('dist'));
	  server.get('/', function (req, res) {
	    res.sendFile(path.join(__dirname, 'dist/index.html'));
	  });
	}
	
	// mongoose.Promise = global.Promise;
	// if (process.env.NODE_ENV !== 'test') {
	//   mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost/blog');
	// }
	
	server.use(_bodyParser2.default.json());
	
	(0, _routes2.default)(server);
	
	server.use(function (err, req, res, next) {
	  res.status(422).send({ error: err.message });
	  next();
	});
	
	server.listen(_config2.default.port, _config2.default.host, function () {
	  console.info('Express listening on port', _config2.default.port);
	  console.log(process.env.NODE_ENV);
	});
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(server, 'server', '/Users/byronhsu/Desktop/webpack-react-redux/server/server.js');
	}();

	;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

	module.exports = require("util");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var MongoError = __webpack_require__(3).MongoError,
	  ReadPreference = __webpack_require__(16),
	  CoreReadPreference = __webpack_require__(3).ReadPreference;
	
	var shallowClone = function(obj) {
	  var copy = {};
	  for(var name in obj) copy[name] = obj[name];
	  return copy;
	}
	
	// Figure out the read preference
	var getReadPreference = function(options) {
	  var r = null
	  if(options.readPreference) {
	    r = options.readPreference
	  } else {
	    return options;
	  }
	
	  if(r instanceof ReadPreference) {
	    options.readPreference = new CoreReadPreference(r.mode, r.tags, {maxStalenessSeconds: r.maxStalenessSeconds});
	  } else if(typeof r == 'string') {
	    options.readPreference = new CoreReadPreference(r);
	  } else if(r && !(r instanceof ReadPreference) && typeof r == 'object') {
	    var mode = r.mode || r.preference;
	    if (mode && typeof mode == 'string') {
	      options.readPreference = new CoreReadPreference(mode, r.tags, {maxStalenessSeconds: r.maxStalenessSeconds});
	    }
	  }
	
	  return options;
	}
	
	// Set simple property
	var getSingleProperty = function(obj, name, value) {
	  Object.defineProperty(obj, name, {
	    enumerable:true,
	    get: function() {
	      return value
	    }
	  });
	}
	
	var formatSortValue = exports.formatSortValue = function(sortDirection) {
	  var value = ("" + sortDirection).toLowerCase();
	
	  switch (value) {
	    case 'ascending':
	    case 'asc':
	    case '1':
	      return 1;
	    case 'descending':
	    case 'desc':
	    case '-1':
	      return -1;
	    default:
	      throw new Error("Illegal sort clause, must be of the form "
	                    + "[['field1', '(ascending|descending)'], "
	                    + "['field2', '(ascending|descending)']]");
	  }
	};
	
	var formattedOrderClause = exports.formattedOrderClause = function(sortValue) {
	  var orderBy = {};
	  if(sortValue == null) return null;
	  if (Array.isArray(sortValue)) {
	    if(sortValue.length === 0) {
	      return null;
	    }
	
	    for(var i = 0; i < sortValue.length; i++) {
	      if(sortValue[i].constructor == String) {
	        orderBy[sortValue[i]] = 1;
	      } else {
	        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);
	      }
	    }
	  } else if(sortValue != null && typeof sortValue == 'object') {
	    orderBy = sortValue;
	  } else if (typeof sortValue == 'string') {
	    orderBy[sortValue] = 1;
	  } else {
	    throw new Error("Illegal sort clause, must be of the form " +
	      "[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
	  }
	
	  return orderBy;
	};
	
	var checkCollectionName = function checkCollectionName (collectionName) {
	  if('string' !== typeof collectionName) {
	    throw new MongoError("collection name must be a String");
	  }
	
	  if(!collectionName || collectionName.indexOf('..') != -1) {
	    throw new MongoError("collection names cannot be empty");
	  }
	
	  if(collectionName.indexOf('$') != -1 &&
	      collectionName.match(/((^\$cmd)|(oplog\.\$main))/) == null) {
	    throw new MongoError("collection names must not contain '$'");
	  }
	
	  if(collectionName.match(/^\.|\.$/) != null) {
	    throw new MongoError("collection names must not start or end with '.'");
	  }
	
	  // Validate that we are not passing 0x00 in the colletion name
	  if(!!~collectionName.indexOf("\x00")) {
	    throw new MongoError("collection names cannot contain a null character");
	  }
	};
	
	var handleCallback = function(callback, err, value1, value2) {
	  try {
	    if(callback == null) return;
	    if(callback) {
	      return value2 ? callback(err, value1, value2) :  callback(err, value1);
	    }
	  } catch(err) {
	    process.nextTick(function() { throw err; });
	    return false;
	  }
	
	  return true;
	}
	
	/**
	 * Wrap a Mongo error document in an Error instance
	 * @ignore
	 * @api private
	 */
	var toError = function(error) {
	  if (error instanceof Error) return error;
	
	  var msg = error.err || error.errmsg || error.errMessage || error;
	  var e = MongoError.create({message: msg, driver:true});
	
	  // Get all object keys
	  var keys = typeof error == 'object'
	    ? Object.keys(error)
	    : [];
	
	  for(var i = 0; i < keys.length; i++) {
	    try {
	      e[keys[i]] = error[keys[i]];
	    } catch(err) {
	      // continue
	    }
	  }
	
	  return e;
	}
	
	/**
	 * @ignore
	 */
	var normalizeHintField = function normalizeHintField(hint) {
	  var finalHint = null;
	
	  if(typeof hint == 'string') {
	    finalHint = hint;
	  } else if(Array.isArray(hint)) {
	    finalHint = {};
	
	    hint.forEach(function(param) {
	      finalHint[param] = 1;
	    });
	  } else if(hint != null && typeof hint == 'object') {
	    finalHint = {};
	    for (var name in hint) {
	      finalHint[name] = hint[name];
	    }
	  }
	
	  return finalHint;
	};
	
	/**
	 * Create index name based on field spec
	 *
	 * @ignore
	 * @api private
	 */
	var parseIndexOptions = function(fieldOrSpec) {
	  var fieldHash = {};
	  var indexes = [];
	  var keys;
	
	  // Get all the fields accordingly
	  if('string' == typeof fieldOrSpec) {
	    // 'type'
	    indexes.push(fieldOrSpec + '_' + 1);
	    fieldHash[fieldOrSpec] = 1;
	  } else if(Array.isArray(fieldOrSpec)) {
	    fieldOrSpec.forEach(function(f) {
	      if('string' == typeof f) {
	        // [{location:'2d'}, 'type']
	        indexes.push(f + '_' + 1);
	        fieldHash[f] = 1;
	      } else if(Array.isArray(f)) {
	        // [['location', '2d'],['type', 1]]
	        indexes.push(f[0] + '_' + (f[1] || 1));
	        fieldHash[f[0]] = f[1] || 1;
	      } else if(isObject(f)) {
	        // [{location:'2d'}, {type:1}]
	        keys = Object.keys(f);
	        keys.forEach(function(k) {
	          indexes.push(k + '_' + f[k]);
	          fieldHash[k] = f[k];
	        });
	      } else {
	        // undefined (ignore)
	      }
	    });
	  } else if(isObject(fieldOrSpec)) {
	    // {location:'2d', type:1}
	    keys = Object.keys(fieldOrSpec);
	    keys.forEach(function(key) {
	      indexes.push(key + '_' + fieldOrSpec[key]);
	      fieldHash[key] = fieldOrSpec[key];
	    });
	  }
	
	  return {
	    name: indexes.join("_"), keys: keys, fieldHash: fieldHash
	  }
	}
	
	var isObject = exports.isObject = function (arg) {
	  return '[object Object]' == Object.prototype.toString.call(arg)
	}
	
	var debugOptions = function(debugFields, options) {
	  var finaloptions = {};
	  debugFields.forEach(function(n) {
	    finaloptions[n] = options[n];
	  });
	
	  return finaloptions;
	}
	
	var decorateCommand = function(command, options, exclude) {
	  for(var name in options) {
	    if(exclude[name] == null) command[name] = options[name];
	  }
	
	  return command;
	}
	
	var mergeOptions = function(target, source) {
	  for(var name in source) {
	    target[name] = source[name];
	  }
	
	  return target;
	}
	
	// Merge options with translation
	var translateOptions = function(target, source) {
	  var translations = {
	    // SSL translation options
	    'sslCA': 'ca', 'sslCRL': 'crl', 'sslValidate': 'rejectUnauthorized', 'sslKey': 'key',
	    'sslCert': 'cert', 'sslPass': 'passphrase',
	    // SocketTimeout translation options
	    'socketTimeoutMS': 'socketTimeout', 'connectTimeoutMS': 'connectionTimeout',
	    // Replicaset options
	    'replicaSet': 'setName', 'rs_name': 'setName', 'secondaryAcceptableLatencyMS': 'acceptableLatency',
	    'connectWithNoPrimary': 'secondaryOnlyConnectionAllowed',
	    // Mongos options
	    'acceptableLatencyMS': 'localThresholdMS'
	  }
	
	  for(var name in source) {
	    if(translations[name]) {
	      target[translations[name]] = source[name];
	    } else {
	      target[name] = source[name];
	    }
	  }
	
	  return target;
	}
	
	var filterOptions = function(options, names) {
	  var filterOptions =  {};
	
	  for(var name in options) {
	    if(names.indexOf(name) != -1) filterOptions[name] = options[name];
	  }
	
	  // Filtered options
	  return filterOptions;
	}
	
	// Object.assign method or polyfille
	var assign = Object.assign ? Object.assign : function assign(target) {
	  if (target === undefined || target === null) {
	    throw new TypeError('Cannot convert first argument to object');
	  }
	
	  var to = Object(target);
	  for (var i = 1; i < arguments.length; i++) {
	    var nextSource = arguments[i];
	    if (nextSource === undefined || nextSource === null) {
	      continue;
	    }
	
	    var keysArray = Object.keys(Object(nextSource));
	    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
	      var nextKey = keysArray[nextIndex];
	      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
	      if (desc !== undefined && desc.enumerable) {
	        to[nextKey] = nextSource[nextKey];
	      }
	    }
	  }
	  return to;
	}
	
	// Write concern keys
	var writeConcernKeys = ['w', 'j', 'wtimeout', 'fsync'];
	
	// Merge the write concern options
	var mergeOptionsAndWriteConcern = function(targetOptions, sourceOptions, keys, mergeWriteConcern) {
	  // Mix in any allowed options
	  for(var i = 0; i < keys.length; i++) {
	    if(!targetOptions[keys[i]] && sourceOptions[keys[i]] != undefined) {
	      targetOptions[keys[i]] = sourceOptions[keys[i]];
	    }
	  }
	
	  // No merging of write concern
	  if(!mergeWriteConcern) return targetOptions;
	
	  // Found no write Concern options
	  var found = false;
	  for(var i = 0; i < writeConcernKeys.length; i++) {
	    if(targetOptions[writeConcernKeys[i]]) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) {
	    for(var i = 0; i < writeConcernKeys.length; i++) {
	      if(sourceOptions[writeConcernKeys[i]]) {
	        targetOptions[writeConcernKeys[i]] = sourceOptions[writeConcernKeys[i]];
	      }
	    }
	  }
	
	  return targetOptions;
	}
	
	exports.filterOptions = filterOptions;
	exports.mergeOptions = mergeOptions;
	exports.translateOptions = translateOptions;
	exports.shallowClone = shallowClone;
	exports.getSingleProperty = getSingleProperty;
	exports.checkCollectionName = checkCollectionName;
	exports.toError = toError;
	exports.formattedOrderClause = formattedOrderClause;
	exports.parseIndexOptions = parseIndexOptions;
	exports.normalizeHintField = normalizeHintField;
	exports.handleCallback = handleCallback;
	exports.decorateCommand = decorateCommand;
	exports.isObject = isObject;
	exports.debugOptions = debugOptions;
	exports.MAX_JS_INT = 0x20000000000000;
	exports.assign = assign;
	exports.mergeOptionsAndWriteConcern = mergeOptionsAndWriteConcern;
	exports.getReadPreference = getReadPreference;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	var BSON = __webpack_require__(25);
	var require_optional = __webpack_require__(20);
	
	try {
	  // Attempt to grab the native BSON parser
	  var BSONNative = require_optional('bson-ext');
	  // If we got the native parser, use it instead of the
	  // Javascript one
	  if(BSONNative) {
	    BSON = BSONNative
	  }
	} catch(err) {}
	
	module.exports = {
	    MongoError: __webpack_require__(7)
	  , Connection: __webpack_require__(120)
	  , Server: __webpack_require__(76)
	  , ReplSet: __webpack_require__(196)
	  , Mongos: __webpack_require__(195)
	  , Logger: __webpack_require__(19)
	  , Cursor: __webpack_require__(57)
	  , ReadPreference: __webpack_require__(43)
	  , BSON: BSON
	  // Raw operations
	  , Query: __webpack_require__(9).Query
	  // Auth mechanisms
	  , MongoCR: __webpack_require__(53)
	  , X509: __webpack_require__(56)
	  , Plain: __webpack_require__(54)
	  , GSSAPI: __webpack_require__(52)
	  , ScramSHA1: __webpack_require__(55)
	}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var Decimal = __webpack_require__(102);
	var ObjectId = __webpack_require__(24);
	var cloneRegExp = __webpack_require__(150);
	var sliced = __webpack_require__(253);
	var mpath = __webpack_require__(67);
	var ms = __webpack_require__(275);
	var MongooseBuffer;
	var MongooseArray;
	var Document;
	
	/*!
	 * Produces a collection name from model `name`.
	 *
	 * @param {String} name a model name
	 * @return {String} a collection name
	 * @api private
	 */
	
	exports.toCollectionName = function(name, options) {
	  options = options || {};
	  if (name === 'system.profile') {
	    return name;
	  }
	  if (name === 'system.indexes') {
	    return name;
	  }
	  if (options.pluralization === false) {
	    return name;
	  }
	  return pluralize(name.toLowerCase());
	};
	
	/**
	 * Pluralization rules.
	 *
	 * These rules are applied while processing the argument to `toCollectionName`.
	 *
	 * @deprecated remove in 4.x gh-1350
	 */
	
	exports.pluralization = [
	  [/(m)an$/gi, '$1en'],
	  [/(pe)rson$/gi, '$1ople'],
	  [/(child)$/gi, '$1ren'],
	  [/^(ox)$/gi, '$1en'],
	  [/(ax|test)is$/gi, '$1es'],
	  [/(octop|vir)us$/gi, '$1i'],
	  [/(alias|status)$/gi, '$1es'],
	  [/(bu)s$/gi, '$1ses'],
	  [/(buffal|tomat|potat)o$/gi, '$1oes'],
	  [/([ti])um$/gi, '$1a'],
	  [/sis$/gi, 'ses'],
	  [/(?:([^f])fe|([lr])f)$/gi, '$1$2ves'],
	  [/(hive)$/gi, '$1s'],
	  [/([^aeiouy]|qu)y$/gi, '$1ies'],
	  [/(x|ch|ss|sh)$/gi, '$1es'],
	  [/(matr|vert|ind)ix|ex$/gi, '$1ices'],
	  [/([m|l])ouse$/gi, '$1ice'],
	  [/(kn|w|l)ife$/gi, '$1ives'],
	  [/(quiz)$/gi, '$1zes'],
	  [/s$/gi, 's'],
	  [/([^a-z])$/, '$1'],
	  [/$/gi, 's']
	];
	var rules = exports.pluralization;
	
	/**
	 * Uncountable words.
	 *
	 * These words are applied while processing the argument to `toCollectionName`.
	 * @api public
	 */
	
	exports.uncountables = [
	  'advice',
	  'energy',
	  'excretion',
	  'digestion',
	  'cooperation',
	  'health',
	  'justice',
	  'labour',
	  'machinery',
	  'equipment',
	  'information',
	  'pollution',
	  'sewage',
	  'paper',
	  'money',
	  'species',
	  'series',
	  'rain',
	  'rice',
	  'fish',
	  'sheep',
	  'moose',
	  'deer',
	  'news',
	  'expertise',
	  'status',
	  'media'
	];
	var uncountables = exports.uncountables;
	
	/*!
	 * Pluralize function.
	 *
	 * @author TJ Holowaychuk (extracted from _ext.js_)
	 * @param {String} string to pluralize
	 * @api private
	 */
	
	function pluralize(str) {
	  var found;
	  if (!~uncountables.indexOf(str.toLowerCase())) {
	    found = rules.filter(function(rule) {
	      return str.match(rule[0]);
	    });
	    if (found[0]) {
	      return str.replace(found[0][0], found[0][1]);
	    }
	  }
	  return str;
	}
	
	/*!
	 * Determines if `a` and `b` are deep equal.
	 *
	 * Modified from node/lib/assert.js
	 *
	 * @param {any} a a value to compare to `b`
	 * @param {any} b a value to compare to `a`
	 * @return {Boolean}
	 * @api private
	 */
	
	exports.deepEqual = function deepEqual(a, b) {
	  if (a === b) {
	    return true;
	  }
	
	  if (a instanceof Date && b instanceof Date) {
	    return a.getTime() === b.getTime();
	  }
	
	  if ((a instanceof ObjectId && b instanceof ObjectId) ||
	      (a instanceof Decimal && b instanceof Decimal)) {
	    return a.toString() === b.toString();
	  }
	
	  if (a instanceof RegExp && b instanceof RegExp) {
	    return a.source === b.source &&
	        a.ignoreCase === b.ignoreCase &&
	        a.multiline === b.multiline &&
	        a.global === b.global;
	  }
	
	  if (typeof a !== 'object' && typeof b !== 'object') {
	    return a == b;
	  }
	
	  if (a === null || b === null || a === undefined || b === undefined) {
	    return false;
	  }
	
	  if (a.prototype !== b.prototype) {
	    return false;
	  }
	
	  // Handle MongooseNumbers
	  if (a instanceof Number && b instanceof Number) {
	    return a.valueOf() === b.valueOf();
	  }
	
	  if (Buffer.isBuffer(a)) {
	    return exports.buffer.areEqual(a, b);
	  }
	
	  if (isMongooseObject(a)) {
	    a = a.toObject();
	  }
	  if (isMongooseObject(b)) {
	    b = b.toObject();
	  }
	
	  try {
	    var ka = Object.keys(a),
	        kb = Object.keys(b),
	        key, i;
	  } catch (e) {
	    // happens when one is a string literal and the other isn't
	    return false;
	  }
	
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length) {
	    return false;
	  }
	
	  // the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	
	  // ~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i]) {
	      return false;
	    }
	  }
	
	  // equivalent values for every corresponding key, and
	  // ~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key])) {
	      return false;
	    }
	  }
	
	  return true;
	};
	
	/*!
	 * Object clone with Mongoose natives support.
	 *
	 * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.
	 *
	 * Functions are never cloned.
	 *
	 * @param {Object} obj the object to clone
	 * @param {Object} options
	 * @return {Object} the cloned object
	 * @api private
	 */
	
	exports.clone = function clone(obj, options) {
	  if (obj === undefined || obj === null) {
	    return obj;
	  }
	
	  if (Array.isArray(obj)) {
	    return cloneArray(obj, options);
	  }
	
	  if (isMongooseObject(obj)) {
	    if (options && options.json && typeof obj.toJSON === 'function') {
	      return obj.toJSON(options);
	    }
	    return obj.toObject(options);
	  }
	
	  if (obj.constructor) {
	    switch (exports.getFunctionName(obj.constructor)) {
	      case 'Object':
	        return cloneObject(obj, options);
	      case 'Date':
	        return new obj.constructor(+obj);
	      case 'RegExp':
	        return cloneRegExp(obj);
	      default:
	        // ignore
	        break;
	    }
	  }
	
	  if (obj instanceof ObjectId) {
	    return new ObjectId(obj.id);
	  }
	  if (obj instanceof Decimal) {
	    if (options && options.flattenDecimals) {
	      return obj.toJSON();
	    }
	    return Decimal.fromString(obj.toString());
	  }
	
	  if (!obj.constructor && exports.isObject(obj)) {
	    // object created with Object.create(null)
	    return cloneObject(obj, options);
	  }
	
	  if (obj.valueOf) {
	    return obj.valueOf();
	  }
	};
	var clone = exports.clone;
	
	/*!
	 * TODO: replace with Object.assign() in 5.0
	 */
	
	exports.assign = function(target) {
	  for (var i = 1; i < arguments.length; ++i) {
	    var nextSource = arguments[i];
	
	    if (nextSource != null) {
	      for (var nextKey in nextSource) {
	        if (nextSource.hasOwnProperty(nextKey)) {
	          target[nextKey] = nextSource[nextKey];
	        }
	      }
	    }
	  }
	
	  return target;
	};
	
	/*!
	 * ignore
	 */
	
	function cloneObject(obj, options) {
	  var retainKeyOrder = options && options.retainKeyOrder,
	      minimize = options && options.minimize,
	      ret = {},
	      hasKeys,
	      keys,
	      val,
	      k,
	      i;
	
	  if (retainKeyOrder) {
	    for (k in obj) {
	      val = clone(obj[k], options);
	
	      if (!minimize || (typeof val !== 'undefined')) {
	        hasKeys || (hasKeys = true);
	        ret[k] = val;
	      }
	    }
	  } else {
	    // faster
	
	    keys = Object.keys(obj);
	    i = keys.length;
	
	    while (i--) {
	      k = keys[i];
	      val = clone(obj[k], options);
	
	      if (!minimize || (typeof val !== 'undefined')) {
	        if (!hasKeys) {
	          hasKeys = true;
	        }
	        ret[k] = val;
	      }
	    }
	  }
	
	  return minimize
	      ? hasKeys && ret
	      : ret;
	}
	
	function cloneArray(arr, options) {
	  var ret = [];
	  for (var i = 0, l = arr.length; i < l; i++) {
	    ret.push(clone(arr[i], options));
	  }
	  return ret;
	}
	
	/*!
	 * Shallow copies defaults into options.
	 *
	 * @param {Object} defaults
	 * @param {Object} options
	 * @return {Object} the merged object
	 * @api private
	 */
	
	exports.options = function(defaults, options) {
	  var keys = Object.keys(defaults),
	      i = keys.length,
	      k;
	
	  options = options || {};
	
	  while (i--) {
	    k = keys[i];
	    if (!(k in options)) {
	      options[k] = defaults[k];
	    }
	  }
	
	  return options;
	};
	
	/*!
	 * Generates a random string
	 *
	 * @api private
	 */
	
	exports.random = function() {
	  return Math.random().toString().substr(3);
	};
	
	/*!
	 * Merges `from` into `to` without overwriting existing properties.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 * @api private
	 */
	
	exports.merge = function merge(to, from, options) {
	  options = options || {};
	  var keys = Object.keys(from);
	  var i = 0;
	  var len = keys.length;
	  var key;
	
	  if (options.retainKeyOrder) {
	    while (i < len) {
	      key = keys[i++];
	      if (to[key] == null) {
	        to[key] = from[key];
	      } else if (exports.isObject(from[key])) {
	        merge(to[key], from[key], options);
	      } else if (options.overwrite) {
	        to[key] = from[key];
	      }
	    }
	  } else {
	    while (len--) {
	      key = keys[len];
	      if (to[key] == null) {
	        to[key] = from[key];
	      } else if (exports.isObject(from[key])) {
	        merge(to[key], from[key], options);
	      } else if (options.overwrite) {
	        to[key] = from[key];
	      }
	    }
	  }
	};
	
	/*!
	 * Applies toObject recursively.
	 *
	 * @param {Document|Array|Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	exports.toObject = function toObject(obj) {
	  Document || (Document = __webpack_require__(8));
	  var ret;
	
	  if (exports.isNullOrUndefined(obj)) {
	    return obj;
	  }
	
	  if (obj instanceof Document) {
	    return obj.toObject();
	  }
	
	  if (Array.isArray(obj)) {
	    ret = [];
	
	    for (var i = 0, len = obj.length; i < len; ++i) {
	      ret.push(toObject(obj[i]));
	    }
	
	    return ret;
	  }
	
	  if ((obj.constructor && exports.getFunctionName(obj.constructor) === 'Object') ||
	      (!obj.constructor && exports.isObject(obj))) {
	    ret = {};
	
	    for (var k in obj) {
	      ret[k] = toObject(obj[k]);
	    }
	
	    return ret;
	  }
	
	  return obj;
	};
	
	/*!
	 * Determines if `arg` is an object.
	 *
	 * @param {Object|Array|String|Function|RegExp|any} arg
	 * @api private
	 * @return {Boolean}
	 */
	
	exports.isObject = function(arg) {
	  if (Buffer.isBuffer(arg)) {
	    return true;
	  }
	  return Object.prototype.toString.call(arg) === '[object Object]';
	};
	
	/*!
	 * A faster Array.prototype.slice.call(arguments) alternative
	 * @api private
	 */
	
	exports.args = sliced;
	
	/*!
	 * process.nextTick helper.
	 *
	 * Wraps `callback` in a try/catch + nextTick.
	 *
	 * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.
	 *
	 * @param {Function} callback
	 * @api private
	 */
	
	exports.tick = function tick(callback) {
	  if (typeof callback !== 'function') {
	    return;
	  }
	  return function() {
	    try {
	      callback.apply(this, arguments);
	    } catch (err) {
	      // only nextTick on err to get out of
	      // the event loop and avoid state corruption.
	      process.nextTick(function() {
	        throw err;
	      });
	    }
	  };
	};
	
	/*!
	 * Returns if `v` is a mongoose object that has a `toObject()` method we can use.
	 *
	 * This is for compatibility with libs like Date.js which do foolish things to Natives.
	 *
	 * @param {any} v
	 * @api private
	 */
	
	exports.isMongooseObject = function(v) {
	  Document || (Document = __webpack_require__(8));
	  MongooseArray || (MongooseArray = __webpack_require__(31).Array);
	  MongooseBuffer || (MongooseBuffer = __webpack_require__(31).Buffer);
	
	  return v instanceof Document ||
	      (v && v.isMongooseArray) ||
	      (v && v.isMongooseBuffer);
	};
	var isMongooseObject = exports.isMongooseObject;
	
	/*!
	 * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.
	 *
	 * @param {Object} object
	 * @api private
	 */
	
	exports.expires = function expires(object) {
	  if (!(object && object.constructor.name === 'Object')) {
	    return;
	  }
	  if (!('expires' in object)) {
	    return;
	  }
	
	  var when;
	  if (typeof object.expires !== 'string') {
	    when = object.expires;
	  } else {
	    when = Math.round(ms(object.expires) / 1000);
	  }
	  object.expireAfterSeconds = when;
	  delete object.expires;
	};
	
	/*!
	 * Populate options constructor
	 */
	
	function PopulateOptions(path, select, match, options, model, subPopulate) {
	  this.path = path;
	  this.match = match;
	  this.select = select;
	  this.options = options;
	  this.model = model;
	  if (typeof subPopulate === 'object') {
	    this.populate = subPopulate;
	  }
	  this._docs = {};
	}
	
	// make it compatible with utils.clone
	PopulateOptions.prototype.constructor = Object;
	
	// expose
	exports.PopulateOptions = PopulateOptions;
	
	/*!
	 * populate helper
	 */
	
	exports.populate = function populate(path, select, model, match, options, subPopulate) {
	  // The order of select/conditions args is opposite Model.find but
	  // necessary to keep backward compatibility (select could be
	  // an array, string, or object literal).
	
	  // might have passed an object specifying all arguments
	  if (arguments.length === 1) {
	    if (path instanceof PopulateOptions) {
	      return [path];
	    }
	
	    if (Array.isArray(path)) {
	      return path.map(function(o) {
	        return exports.populate(o)[0];
	      });
	    }
	
	    if (exports.isObject(path)) {
	      match = path.match;
	      options = path.options;
	      select = path.select;
	      model = path.model;
	      subPopulate = path.populate;
	      path = path.path;
	    }
	  } else if (typeof model !== 'string' && typeof model !== 'function') {
	    options = match;
	    match = model;
	    model = undefined;
	  }
	
	  if (typeof path !== 'string') {
	    throw new TypeError('utils.populate: invalid path. Expected string. Got typeof `' + typeof path + '`');
	  }
	
	  if (typeof subPopulate === 'object') {
	    subPopulate = exports.populate(subPopulate);
	  }
	
	  var ret = [];
	  var paths = path.split(' ');
	  options = exports.clone(options, { retainKeyOrder: true });
	  for (var i = 0; i < paths.length; ++i) {
	    ret.push(new PopulateOptions(paths[i], select, match, options, model, subPopulate));
	  }
	
	  return ret;
	};
	
	/*!
	 * Return the value of `obj` at the given `path`.
	 *
	 * @param {String} path
	 * @param {Object} obj
	 */
	
	exports.getValue = function(path, obj, map) {
	  return mpath.get(path, obj, '_doc', map);
	};
	
	/*!
	 * Sets the value of `obj` at the given `path`.
	 *
	 * @param {String} path
	 * @param {Anything} val
	 * @param {Object} obj
	 */
	
	exports.setValue = function(path, val, obj, map) {
	  mpath.set(path, val, obj, '_doc', map);
	};
	
	/*!
	 * Returns an array of values from object `o`.
	 *
	 * @param {Object} o
	 * @return {Array}
	 * @private
	 */
	
	exports.object = {};
	exports.object.vals = function vals(o) {
	  var keys = Object.keys(o),
	      i = keys.length,
	      ret = [];
	
	  while (i--) {
	    ret.push(o[keys[i]]);
	  }
	
	  return ret;
	};
	
	/*!
	 * @see exports.options
	 */
	
	exports.object.shallowCopy = exports.options;
	
	/*!
	 * Safer helper for hasOwnProperty checks
	 *
	 * @param {Object} obj
	 * @param {String} prop
	 */
	
	var hop = Object.prototype.hasOwnProperty;
	exports.object.hasOwnProperty = function(obj, prop) {
	  return hop.call(obj, prop);
	};
	
	/*!
	 * Determine if `val` is null or undefined
	 *
	 * @return {Boolean}
	 */
	
	exports.isNullOrUndefined = function(val) {
	  return val === null || val === undefined;
	};
	
	/*!
	 * ignore
	 */
	
	exports.array = {};
	
	/*!
	 * Flattens an array.
	 *
	 * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]
	 *
	 * @param {Array} arr
	 * @param {Function} [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsey value, the item will not be included in the results.
	 * @return {Array}
	 * @private
	 */
	
	exports.array.flatten = function flatten(arr, filter, ret) {
	  ret || (ret = []);
	
	  arr.forEach(function(item) {
	    if (Array.isArray(item)) {
	      flatten(item, filter, ret);
	    } else {
	      if (!filter || filter(item)) {
	        ret.push(item);
	      }
	    }
	  });
	
	  return ret;
	};
	
	/*!
	 * Removes duplicate values from an array
	 *
	 * [1, 2, 3, 3, 5] => [1, 2, 3, 5]
	 * [ ObjectId("550988ba0c19d57f697dc45e"), ObjectId("550988ba0c19d57f697dc45e") ]
	 *    => [ObjectId("550988ba0c19d57f697dc45e")]
	 *
	 * @param {Array} arr
	 * @return {Array}
	 * @private
	 */
	
	exports.array.unique = function(arr) {
	  var primitives = {};
	  var ids = {};
	  var ret = [];
	  var length = arr.length;
	  for (var i = 0; i < length; ++i) {
	    if (typeof arr[i] === 'number' || typeof arr[i] === 'string') {
	      if (primitives[arr[i]]) {
	        continue;
	      }
	      ret.push(arr[i]);
	      primitives[arr[i]] = true;
	    } else if (arr[i] instanceof ObjectId) {
	      if (ids[arr[i].toString()]) {
	        continue;
	      }
	      ret.push(arr[i]);
	      ids[arr[i].toString()] = true;
	    } else {
	      ret.push(arr[i]);
	    }
	  }
	
	  return ret;
	};
	
	/*!
	 * Determines if two buffers are equal.
	 *
	 * @param {Buffer} a
	 * @param {Object} b
	 */
	
	exports.buffer = {};
	exports.buffer.areEqual = function(a, b) {
	  if (!Buffer.isBuffer(a)) {
	    return false;
	  }
	  if (!Buffer.isBuffer(b)) {
	    return false;
	  }
	  if (a.length !== b.length) {
	    return false;
	  }
	  for (var i = 0, len = a.length; i < len; ++i) {
	    if (a[i] !== b[i]) {
	      return false;
	    }
	  }
	  return true;
	};
	
	exports.getFunctionName = function(fn) {
	  if (fn.name) {
	    return fn.name;
	  }
	  return (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
	};
	
	exports.decorate = function(destination, source) {
	  for (var key in source) {
	    destination[key] = source[key];
	  }
	};
	
	/**
	 * merges to with a copy of from
	 *
	 * @param {Object} to
	 * @param {Object} fromObj
	 * @api private
	 */
	
	exports.mergeClone = function(to, fromObj) {
	  var keys = Object.keys(fromObj);
	  var len = keys.length;
	  var i = 0;
	  var key;
	
	  while (i < len) {
	    key = keys[i++];
	    if (typeof to[key] === 'undefined') {
	      // make sure to retain key order here because of a bug handling the $each
	      // operator in mongodb 2.4.4
	      to[key] = exports.clone(fromObj[key], {
	        retainKeyOrder: 1,
	        flattenDecimals: false
	      });
	    } else {
	      if (exports.isObject(fromObj[key])) {
	        var obj = fromObj[key];
	        if (isMongooseObject(fromObj[key]) && !fromObj[key].isMongooseBuffer) {
	          obj = obj.toObject({ transform: false, virtuals: false });
	        }
	        if (fromObj[key].isMongooseBuffer) {
	          obj = new Buffer(obj);
	        }
	        exports.mergeClone(to[key], obj);
	      } else {
	        // make sure to retain key order here because of a bug handling the
	        // $each operator in mongodb 2.4.4
	        to[key] = exports.clone(fromObj[key], {
	          retainKeyOrder: 1,
	          flattenDecimals: false
	        });
	      }
	    }
	  }
	};
	
	/**
	 * Executes a function on each element of an array (like _.each)
	 *
	 * @param {Array} arr
	 * @param {Function} fn
	 * @api private
	 */
	
	exports.each = function(arr, fn) {
	  for (var i = 0; i < arr.length; ++i) {
	    fn(arr[i]);
	  }
	};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	
	/**
	 * MongooseError constructor
	 *
	 * @param {String} msg Error message
	 * @inherits Error https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error
	 */
	
	function MongooseError(msg) {
	  Error.call(this);
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	  this.message = msg;
	  this.name = 'MongooseError';
	}
	
	/*!
	 * Inherits from Error.
	 */
	
	MongooseError.prototype = Object.create(Error.prototype);
	MongooseError.prototype.constructor = Error;
	
	/*!
	 * Module exports.
	 */
	
	module.exports = exports = MongooseError;
	
	/**
	 * The default built-in validator error messages.
	 *
	 * @see Error.messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	MongooseError.messages = __webpack_require__(215);
	
	// backward compat
	MongooseError.Messages = MongooseError.messages;
	
	/**
	 * This error will be called when `save()` fails because the underlying
	 * document was not found. The constructor takes one parameter, the
	 * conditions that mongoose passed to `update()` when trying to update
	 * the document.
	 *
	 * @api public
	 */
	
	MongooseError.DocumentNotFoundError = __webpack_require__(217);
	
	/*!
	 * Expose subclasses
	 */
	
	MongooseError.CastError = __webpack_require__(44);
	MongooseError.ValidationError = __webpack_require__(134);
	MongooseError.ValidatorError = __webpack_require__(221);
	MongooseError.VersionError = __webpack_require__(222);
	MongooseError.OverwriteModelError = __webpack_require__(220);
	MongooseError.MissingSchemaError = __webpack_require__(216);
	MongooseError.DivergentArrayError = __webpack_require__(214);


/***/ }),
/* 6 */
/***/ (function(module, exports) {

	module.exports = require("events");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	"use strict";
	
	/**
	 * Creates a new MongoError
	 * @class
	 * @augments Error
	 * @param {string} message The error message
	 * @return {MongoError} A MongoError instance
	 */
	function MongoError(message) {
	  this.name = 'MongoError';
	  this.message = message;
	  Error.captureStackTrace(this, MongoError);
	}
	
	/**
	 * Creates a new MongoError object
	 * @method
	 * @param {object} options The error options
	 * @return {MongoError} A MongoError instance
	 */
	MongoError.create = function(options) {
	  var err = null;
	
	  if(options instanceof Error) {
	    err = new MongoError(options.message);
	    err.stack = options.stack;
	  } else if(typeof options == 'string') {
	    err = new MongoError(options);
	  } else {
	    err = new MongoError(options.message || options.errmsg || options.$err || "n/a");
	    // Other options
	    for(var name in options) {
	      err[name] = options[name];
	    }
	  }
	
	  return err;
	}
	
	// Extend JavaScript error
	MongoError.prototype = new Error;
	
	module.exports = MongoError;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var EventEmitter = __webpack_require__(6).EventEmitter;
	var MongooseError = __webpack_require__(5);
	var MixedSchema = __webpack_require__(64);
	var Schema = __webpack_require__(45);
	var ObjectExpectedError = __webpack_require__(218);
	var StrictModeError = __webpack_require__(93);
	var ValidatorError = __webpack_require__(12).ValidatorError;
	var VirtualType = __webpack_require__(103);
	var utils = __webpack_require__(4);
	var clone = utils.clone;
	var isMongooseObject = utils.isMongooseObject;
	var inspect = __webpack_require__(1).inspect;
	var ValidationError = MongooseError.ValidationError;
	var InternalCache = __webpack_require__(135);
	var cleanModifiedSubpaths = __webpack_require__(145);
	var compile = __webpack_require__(99).compile;
	var deepEqual = utils.deepEqual;
	var defineKey = __webpack_require__(99).defineKey;
	var hooks = __webpack_require__(168);
	var PromiseProvider = __webpack_require__(14);
	var DocumentArray;
	var MongooseArray;
	var Embedded;
	var flatten = __webpack_require__(66).flatten;
	var mpath = __webpack_require__(67);
	var idGetter = __webpack_require__(225);
	
	/**
	 * Document constructor.
	 *
	 * @param {Object} obj the values to set
	 * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data
	 * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `init`: Emitted on a document after it has was retreived from the db and fully hydrated by Mongoose.
	 * @event `save`: Emitted when the document is successfully saved
	 * @api private
	 */
	
	function Document(obj, fields, skipId, options) {
	  this.$__ = new InternalCache;
	  this.$__.emitter = new EventEmitter();
	  this.isNew = true;
	  this.errors = undefined;
	  this.$__.$options = options || {};
	
	  var schema = this.schema;
	
	  if (typeof fields === 'boolean') {
	    this.$__.strictMode = fields;
	    fields = undefined;
	  } else {
	    this.$__.strictMode = schema.options && schema.options.strict;
	    this.$__.selected = fields;
	  }
	
	  var required = schema.requiredPaths(true);
	  for (var i = 0; i < required.length; ++i) {
	    this.$__.activePaths.require(required[i]);
	  }
	
	  this.$__.emitter.setMaxListeners(0);
	  this._doc = this.$__buildDoc(obj, fields, skipId);
	
	  if (obj) {
	    if (obj instanceof Document) {
	      this.isNew = obj.isNew;
	    }
	    // Skip set hooks
	    if (this.$__original_set) {
	      this.$__original_set(obj, undefined, true);
	    } else {
	      this.set(obj, undefined, true);
	    }
	  }
	
	  this.$__._id = this._id;
	
	  if (!schema.options.strict && obj) {
	    var _this = this,
	        keys = Object.keys(this._doc);
	
	    keys.forEach(function(key) {
	      if (!(key in schema.tree)) {
	        defineKey(key, null, _this);
	      }
	    });
	  }
	
	  applyQueue(this);
	}
	
	/*!
	 * Document exposes the NodeJS event emitter API, so you can use
	 * `on`, `once`, etc.
	 */
	utils.each(
	    ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',
	      'removeAllListeners', 'addListener'],
	    function(emitterFn) {
	      Document.prototype[emitterFn] = function() {
	        return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
	      };
	    });
	
	Document.prototype.constructor = Document;
	
	/**
	 * The documents schema.
	 *
	 * @api public
	 * @property schema
	 */
	
	Document.prototype.schema;
	
	/**
	 * Boolean flag specifying if the document is new.
	 *
	 * @api public
	 * @property isNew
	 */
	
	Document.prototype.isNew;
	
	/**
	 * The string version of this documents _id.
	 *
	 * ####Note:
	 *
	 * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.
	 *
	 *     new Schema({ name: String }, { id: false });
	 *
	 * @api public
	 * @see Schema options /docs/guide.html#options
	 * @property id
	 */
	
	Document.prototype.id;
	
	/**
	 * Hash containing current validation errors.
	 *
	 * @api public
	 * @property errors
	 */
	
	Document.prototype.errors;
	
	/**
	 * Builds the default doc structure
	 *
	 * @param {Object} obj
	 * @param {Object} [fields]
	 * @param {Boolean} [skipId]
	 * @return {Object}
	 * @api private
	 * @method $__buildDoc
	 * @memberOf Document
	 */
	
	Document.prototype.$__buildDoc = function(obj, fields, skipId) {
	  var doc = {};
	  var exclude = null;
	  var keys;
	  var ki;
	  var _this = this;
	
	  // determine if this doc is a result of a query with
	  // excluded fields
	
	  if (fields && utils.getFunctionName(fields.constructor) === 'Object') {
	    keys = Object.keys(fields);
	    ki = keys.length;
	
	    if (ki === 1 && keys[0] === '_id') {
	      exclude = !!fields[keys[ki]];
	    } else {
	      while (ki--) {
	        // Does this projection explicitly define inclusion/exclusion?
	        // Explicitly avoid `$meta` and `$slice`
	        var isDefiningProjection = !fields[keys[ki]] ||
	          typeof fields[keys[ki]] !== 'object' ||
	          fields[keys[ki]].$elemMatch != null;
	        if (keys[ki] !== '_id' && isDefiningProjection) {
	          exclude = !fields[keys[ki]];
	          break;
	        }
	      }
	    }
	  }
	
	  var paths = Object.keys(this.schema.paths);
	  var plen = paths.length;
	  var ii = 0;
	
	  var hasIncludedChildren = {};
	  if (exclude === false && fields) {
	    keys = Object.keys(fields);
	    for (var j = 0; j < keys.length; ++j) {
	      var parts = keys[j].split('.');
	      var c = [];
	      for (var k = 0; k < parts.length; ++k) {
	        c.push(parts[k]);
	        hasIncludedChildren[c.join('.')] = 1;
	      }
	    }
	  }
	
	  for (; ii < plen; ++ii) {
	    var p = paths[ii];
	
	    if (p === '_id') {
	      if (skipId) {
	        continue;
	      }
	      if (obj && '_id' in obj) {
	        continue;
	      }
	    }
	
	    var type = this.schema.paths[p];
	    var path = p.split('.');
	    var len = path.length;
	    var last = len - 1;
	    var curPath = '';
	    var doc_ = doc;
	    var i = 0;
	    var included = false;
	
	    for (; i < len; ++i) {
	      var piece = path[i],
	          def;
	
	      curPath += (!curPath.length ? '' : '.') + piece;
	
	      // support excluding intermediary levels
	      if (exclude === true) {
	        if (curPath in fields) {
	          break;
	        }
	      } else if (exclude === false && fields && !included) {
	        if (curPath in fields) {
	          included = true;
	        } else if (!hasIncludedChildren[curPath]) {
	          break;
	        }
	      }
	
	      if (i === last) {
	        if (fields && exclude !== null) {
	          if (exclude === true) {
	            // apply defaults to all non-excluded fields
	            if (p in fields) {
	              continue;
	            }
	
	            def = type.getDefault(_this, false);
	            if (typeof def !== 'undefined') {
	              doc_[piece] = def;
	              _this.$__.activePaths.default(p);
	            }
	          } else if (included) {
	            // selected field
	            def = type.getDefault(_this, false);
	            if (typeof def !== 'undefined') {
	              doc_[piece] = def;
	              _this.$__.activePaths.default(p);
	            }
	          }
	        } else {
	          def = type.getDefault(_this, false);
	          if (typeof def !== 'undefined') {
	            doc_[piece] = def;
	            _this.$__.activePaths.default(p);
	          }
	        }
	      } else {
	        doc_ = doc_[piece] || (doc_[piece] = {});
	      }
	    }
	  }
	
	  return doc;
	};
	
	/*!
	 * Converts to POJO when you use the document for querying
	 */
	
	Document.prototype.toBSON = function() {
	  return this.toObject({
	    transform: false,
	    virtuals: false,
	    _skipDepopulateTopLevel: true,
	    depopulate: true,
	    flattenDecimals: false
	  });
	};
	
	/**
	 * Initializes the document without setters or marking anything modified.
	 *
	 * Called internally after a document is returned from mongodb.
	 *
	 * @param {Object} doc document returned by mongo
	 * @param {Function} fn callback
	 * @api public
	 */
	
	Document.prototype.init = function(doc, opts, fn) {
	  // do not prefix this method with $__ since its
	  // used by public hooks
	
	  if (typeof opts === 'function') {
	    fn = opts;
	    opts = null;
	  }
	
	  this.isNew = false;
	  this.$init = true;
	
	  // handle docs with populated paths
	  // If doc._id is not null or undefined
	  if (doc._id !== null && doc._id !== undefined &&
	    opts && opts.populated && opts.populated.length) {
	    var id = String(doc._id);
	    for (var i = 0; i < opts.populated.length; ++i) {
	      var item = opts.populated[i];
	      if (item.isVirtual) {
	        this.populated(item.path, utils.getValue(item.path, doc), item);
	      } else {
	        this.populated(item.path, item._docs[id], item);
	      }
	    }
	  }
	
	  init(this, doc, this._doc);
	
	  this.emit('init', this);
	  this.constructor.emit('init', this);
	
	  this.$__._id = this._id;
	
	  if (fn) {
	    fn(null);
	  }
	  return this;
	};
	
	/*!
	 * Init helper.
	 *
	 * @param {Object} self document instance
	 * @param {Object} obj raw mongodb doc
	 * @param {Object} doc object we are initializing
	 * @api private
	 */
	
	function init(self, obj, doc, prefix) {
	  prefix = prefix || '';
	
	  var keys = Object.keys(obj);
	  var len = keys.length;
	  var schema;
	  var path;
	  var i;
	  var index = 0;
	
	  if (self.schema.options.retainKeyOrder) {
	    while (index < len) {
	      _init(index++);
	    }
	  } else {
	    while (len--) {
	      _init(len);
	    }
	  }
	
	  function _init(index) {
	    i = keys[index];
	    path = prefix + i;
	    schema = self.schema.path(path);
	
	    // Should still work if not a model-level discriminator, but should not be
	    // necessary. This is *only* to catch the case where we queried using the
	    // base model and the discriminated model has a projection
	    if (self.schema.$isRootDiscriminator && !self.isSelected(path)) {
	      return;
	    }
	
	    if (!schema && utils.isObject(obj[i]) &&
	        (!obj[i].constructor || utils.getFunctionName(obj[i].constructor) === 'Object')) {
	      // assume nested object
	      if (!doc[i]) {
	        doc[i] = {};
	      }
	      init(self, obj[i], doc[i], path + '.');
	    } else if (!schema) {
	      doc[i] = obj[i];
	    } else {
	      if (obj[i] === null) {
	        doc[i] = null;
	      } else if (obj[i] !== undefined) {
	        if (schema) {
	          try {
	            doc[i] = schema.cast(obj[i], self, true);
	          } catch (e) {
	            self.invalidate(e.path, new ValidatorError({
	              path: e.path,
	              message: e.message,
	              type: 'cast',
	              value: e.value
	            }));
	          }
	        } else {
	          doc[i] = obj[i];
	        }
	      }
	      // mark as hydrated
	      if (!self.isModified(path)) {
	        self.$__.activePaths.init(path);
	      }
	    }
	  }
	}
	
	/*!
	 * Set up middleware support
	 */
	
	for (var k in hooks) {
	  if (k === 'pre' || k === 'post') {
	    Document.prototype['$' + k] = Document['$' + k] = hooks[k];
	  } else {
	    Document.prototype[k] = Document[k] = hooks[k];
	  }
	}
	
	/**
	 * Sends an update command with this document `_id` as the query selector.
	 *
	 * ####Example:
	 *
	 *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);
	 *
	 * ####Valid options:
	 *
	 *  - same as in [Model.update](#model_Model.update)
	 *
	 * @see Model.update #model_Model.update
	 * @param {Object} doc
	 * @param {Object} options
	 * @param {Function} callback
	 * @return {Query}
	 * @api public
	 */
	
	Document.prototype.update = function update() {
	  var args = utils.args(arguments);
	  args.unshift({_id: this._id});
	  return this.constructor.update.apply(this.constructor, args);
	};
	
	/**
	 * Sets the value of a path, or many paths.
	 *
	 * ####Example:
	 *
	 *     // path, value
	 *     doc.set(path, value)
	 *
	 *     // object
	 *     doc.set({
	 *         path  : value
	 *       , path2 : {
	 *            path  : value
	 *         }
	 *     })
	 *
	 *     // on-the-fly cast to number
	 *     doc.set(path, value, Number)
	 *
	 *     // on-the-fly cast to string
	 *     doc.set(path, value, String)
	 *
	 *     // changing strict mode behavior
	 *     doc.set(path, value, { strict: false });
	 *
	 * @param {String|Object} path path or object of key/vals to set
	 * @param {Any} val the value to set
	 * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for "on-the-fly" attributes
	 * @param {Object} [options] optionally specify options that modify the behavior of the set
	 * @api public
	 */
	
	Document.prototype.set = function(path, val, type, options) {
	  if (type && utils.getFunctionName(type.constructor) === 'Object') {
	    options = type;
	    type = undefined;
	  }
	
	  options = options || {};
	  var merge = options.merge;
	  var adhoc = type && type !== true;
	  var constructing = type === true;
	  var adhocs;
	
	  var strict = 'strict' in options
	      ? options.strict
	      : this.$__.strictMode;
	
	  if (adhoc) {
	    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
	    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);
	  }
	
	  if (typeof path !== 'string') {
	    // new Document({ key: val })
	
	    if (path === null || path === void 0) {
	      var _ = path;
	      path = val;
	      val = _;
	    } else {
	      var prefix = val
	          ? val + '.'
	          : '';
	
	      if (path instanceof Document) {
	        if (path.$__isNested) {
	          path = path.toObject();
	        } else {
	          path = path._doc;
	        }
	      }
	
	      var keys = Object.keys(path);
	      var len = keys.length;
	      var i = 0;
	      var pathtype;
	      var key;
	
	      if (len === 0 && !this.schema.options.minimize) {
	        if (val) {
	          this.set(val, {});
	        }
	        return this;
	      }
	
	      if (this.schema.options.retainKeyOrder) {
	        while (i < len) {
	          _handleIndex.call(this, i++);
	        }
	      } else {
	        while (len--) {
	          _handleIndex.call(this, len);
	        }
	      }
	
	      return this;
	    }
	  }
	
	  function _handleIndex(i) {
	    key = keys[i];
	    var pathName = prefix + key;
	    pathtype = this.schema.pathType(pathName);
	
	    if (path[key] !== null
	        && path[key] !== void 0
	          // need to know if plain object - no Buffer, ObjectId, ref, etc
	        && utils.isObject(path[key])
	        && (!path[key].constructor || utils.getFunctionName(path[key].constructor) === 'Object')
	        && pathtype !== 'virtual'
	        && pathtype !== 'real'
	        && !(this.$__path(pathName) instanceof MixedSchema)
	        && !(this.schema.paths[pathName] &&
	        this.schema.paths[pathName].options &&
	        this.schema.paths[pathName].options.ref)) {
	      this.set(path[key], prefix + key, constructing);
	    } else if (strict) {
	      // Don't overwrite defaults with undefined keys (gh-3981)
	      if (constructing && path[key] === void 0 &&
	          this.get(key) !== void 0) {
	        return;
	      }
	
	      if (pathtype === 'real' || pathtype === 'virtual') {
	        // Check for setting single embedded schema to document (gh-3535)
	        var p = path[key];
	        if (this.schema.paths[pathName] &&
	            this.schema.paths[pathName].$isSingleNested &&
	            path[key] instanceof Document) {
	          p = p.toObject({ virtuals: false, transform: false });
	        }
	        this.set(prefix + key, p, constructing);
	      } else if (pathtype === 'nested' && path[key] instanceof Document) {
	        this.set(prefix + key,
	            path[key].toObject({transform: false}), constructing);
	      } else if (strict === 'throw') {
	        if (pathtype === 'nested') {
	          throw new ObjectExpectedError(key, path[key]);
	        } else {
	          throw new StrictModeError(key);
	        }
	      }
	    } else if (path[key] !== void 0) {
	      this.set(prefix + key, path[key], constructing);
	    }
	  }
	
	  var pathType = this.schema.pathType(path);
	  if (pathType === 'nested' && val) {
	    if (utils.isObject(val) &&
	        (!val.constructor || utils.getFunctionName(val.constructor) === 'Object')) {
	      if (!merge) {
	        this.setValue(path, null);
	        cleanModifiedSubpaths(this, path);
	      }
	
	      if (Object.keys(val).length === 0) {
	        this.setValue(path, {});
	        this.markModified(path);
	        cleanModifiedSubpaths(this, path);
	      } else {
	        this.set(val, path, constructing);
	      }
	      return this;
	    }
	    this.invalidate(path, new MongooseError.CastError('Object', val, path));
	    return this;
	  }
	
	  var schema;
	  var parts = path.split('.');
	
	  if (pathType === 'adhocOrUndefined' && strict) {
	    // check for roots that are Mixed types
	    var mixed;
	
	    for (i = 0; i < parts.length; ++i) {
	      var subpath = parts.slice(0, i + 1).join('.');
	      schema = this.schema.path(subpath);
	      if (schema instanceof MixedSchema) {
	        // allow changes to sub paths of mixed types
	        mixed = true;
	        break;
	      }
	
	      // If path is underneath a virtual, bypass everything and just set it.
	      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {
	        mpath.set(path, val, this);
	        return this;
	      }
	    }
	
	    if (!mixed) {
	      if (strict === 'throw') {
	        throw new StrictModeError(path);
	      }
	      return this;
	    }
	  } else if (pathType === 'virtual') {
	    schema = this.schema.virtualpath(path);
	    schema.applySetters(val, this);
	    return this;
	  } else {
	    schema = this.$__path(path);
	  }
	
	  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it
	  var cur = this._doc;
	  var curPath = '';
	  for (i = 0; i < parts.length - 1; ++i) {
	    cur = cur[parts[i]];
	    curPath += (curPath.length > 0 ? '.' : '') + parts[i];
	    if (!cur) {
	      this.set(curPath, {});
	      cur = this.getValue(curPath);
	    }
	  }
	
	  var pathToMark;
	
	  // When using the $set operator the path to the field must already exist.
	  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"
	
	  if (parts.length <= 1) {
	    pathToMark = path;
	  } else {
	    for (i = 0; i < parts.length; ++i) {
	      subpath = parts.slice(0, i + 1).join('.');
	      if (this.isDirectModified(subpath) // earlier prefixes that are already
	            // marked as dirty have precedence
	          || this.get(subpath) === null) {
	        pathToMark = subpath;
	        break;
	      }
	    }
	
	    if (!pathToMark) {
	      pathToMark = path;
	    }
	  }
	
	  // if this doc is being constructed we should not trigger getters
	  var priorVal = constructing ?
	    undefined :
	    this.getValue(path);
	
	  if (!schema) {
	    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
	    return this;
	  }
	
	  var shouldSet = true;
	  try {
	    // If the user is trying to set a ref path to a document with
	    // the correct model name, treat it as populated
	    var didPopulate = false;
	    if (schema.options &&
	        schema.options.ref &&
	        val instanceof Document &&
	        (schema.options.ref === val.constructor.modelName || schema.options.ref === val.constructor.baseModelName)) {
	      if (this.ownerDocument) {
	        this.ownerDocument().populated(this.$__fullPath(path),
	          val._id, {model: val.constructor});
	      } else {
	        this.populated(path, val._id, {model: val.constructor});
	      }
	      didPopulate = true;
	    }
	
	    var popOpts;
	    if (schema.options &&
	        Array.isArray(schema.options[this.schema.options.typeKey]) &&
	        schema.options[this.schema.options.typeKey].length &&
	        schema.options[this.schema.options.typeKey][0].ref &&
	        Array.isArray(val) &&
	        val.length > 0 &&
	        val[0] instanceof Document &&
	        val[0].constructor.modelName &&
	        (schema.options[this.schema.options.typeKey][0].ref === val[0].constructor.baseModelName || schema.options[this.schema.options.typeKey][0].ref === val[0].constructor.modelName)) {
	      if (this.ownerDocument) {
	        popOpts = { model: val[0].constructor };
	        this.ownerDocument().populated(this.$__fullPath(path),
	          val.map(function(v) { return v._id; }), popOpts);
	      } else {
	        popOpts = { model: val[0].constructor };
	        this.populated(path, val.map(function(v) { return v._id; }), popOpts);
	      }
	      didPopulate = true;
	    }
	
	    var setterContext = constructing && this.$__.$options.priorDoc ?
	      this.$__.$options.priorDoc :
	      this;
	    val = schema.applySetters(val, setterContext, false, priorVal);
	
	    if (!didPopulate && this.$__.populated) {
	      delete this.$__.populated[path];
	    }
	
	    this.$markValid(path);
	  } catch (e) {
	    this.invalidate(path,
	      new MongooseError.CastError(schema.instance, val, path, e));
	    shouldSet = false;
	  }
	
	  if (shouldSet) {
	    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
	  }
	
	  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
	    cleanModifiedSubpaths(this, path);
	  }
	
	  return this;
	};
	
	/**
	 * Determine if we should mark this change as modified.
	 *
	 * @return {Boolean}
	 * @api private
	 * @method $__shouldModify
	 * @memberOf Document
	 */
	
	Document.prototype.$__shouldModify = function(pathToMark, path, constructing, parts, schema, val, priorVal) {
	  if (this.isNew) {
	    return true;
	  }
	
	  if (undefined === val && !this.isSelected(path)) {
	    // when a path is not selected in a query, its initial
	    // value will be undefined.
	    return true;
	  }
	
	  if (undefined === val && path in this.$__.activePaths.states.default) {
	    // we're just unsetting the default value which was never saved
	    return false;
	  }
	
	  // gh-3992: if setting a populated field to a doc, don't mark modified
	  // if they have the same _id
	  if (this.populated(path) &&
	      val instanceof Document &&
	      deepEqual(val._id, priorVal)) {
	    return false;
	  }
	
	  if (!deepEqual(val, priorVal || this.get(path))) {
	    return true;
	  }
	
	  if (!constructing &&
	      val !== null &&
	      val !== undefined &&
	      path in this.$__.activePaths.states.default &&
	      deepEqual(val, schema.getDefault(this, constructing))) {
	    // a path with a default was $unset on the server
	    // and the user is setting it to the same value again
	    return true;
	  }
	  return false;
	};
	
	/**
	 * Handles the actual setting of the value and marking the path modified if appropriate.
	 *
	 * @api private
	 * @method $__set
	 * @memberOf Document
	 */
	
	Document.prototype.$__set = function(pathToMark, path, constructing, parts, schema, val, priorVal) {
	  Embedded = Embedded || __webpack_require__(30);
	
	  var shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,
	    schema, val, priorVal);
	  var _this = this;
	
	  if (shouldModify) {
	    this.markModified(pathToMark);
	
	    // handle directly setting arrays (gh-1126)
	    MongooseArray || (MongooseArray = __webpack_require__(101));
	    if (val && val.isMongooseArray) {
	      val._registerAtomic('$set', val);
	
	      // Update embedded document parent references (gh-5189)
	      if (val.isMongooseDocumentArray) {
	        val.forEach(function(item) {
	          item && item.__parentArray && (item.__parentArray = val);
	        });
	      }
	
	      // Small hack for gh-1638: if we're overwriting the entire array, ignore
	      // paths that were modified before the array overwrite
	      this.$__.activePaths.forEach(function(modifiedPath) {
	        if (modifiedPath.indexOf(path + '.') === 0) {
	          _this.$__.activePaths.ignore(modifiedPath);
	        }
	      });
	    }
	  }
	
	  var obj = this._doc;
	  var i = 0;
	  var l = parts.length;
	  var cur = '';
	
	  for (; i < l; i++) {
	    var next = i + 1;
	    var last = next === l;
	    cur += (cur ? '.' + parts[i] : parts[i]);
	
	    if (last) {
	      obj[parts[i]] = val;
	    } else {
	      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === 'Object') {
	        obj = obj[parts[i]];
	      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {
	        obj = obj[parts[i]];
	      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {
	        obj = obj[parts[i]];
	      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {
	        obj = obj[parts[i]];
	      } else {
	        obj[parts[i]] = obj[parts[i]] || {};
	        obj = obj[parts[i]];
	      }
	    }
	  }
	};
	
	/**
	 * Gets a raw value from a path (no getters)
	 *
	 * @param {String} path
	 * @api private
	 */
	
	Document.prototype.getValue = function(path) {
	  return utils.getValue(path, this._doc);
	};
	
	/**
	 * Sets a raw value for a path (no casting, setters, transformations)
	 *
	 * @param {String} path
	 * @param {Object} value
	 * @api private
	 */
	
	Document.prototype.setValue = function(path, val) {
	  utils.setValue(path, val, this._doc);
	  return this;
	};
	
	/**
	 * Returns the value of a path.
	 *
	 * ####Example
	 *
	 *     // path
	 *     doc.get('age') // 47
	 *
	 *     // dynamic casting to a string
	 *     doc.get('age', String) // "47"
	 *
	 * @param {String} path
	 * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes
	 * @api public
	 */
	
	Document.prototype.get = function(path, type) {
	  var adhoc;
	  if (type) {
	    adhoc = Schema.interpretAsType(path, type, this.schema.options);
	  }
	
	  var schema = this.$__path(path) || this.schema.virtualpath(path);
	  var pieces = path.split('.');
	  var obj = this._doc;
	
	  if (schema instanceof VirtualType) {
	    return schema.applyGetters(null, this);
	  }
	
	  for (var i = 0, l = pieces.length; i < l; i++) {
	    obj = obj === null || obj === void 0
	        ? undefined
	        : obj[pieces[i]];
	  }
	
	  if (adhoc) {
	    obj = adhoc.cast(obj);
	  }
	
	  if (schema) {
	    obj = schema.applyGetters(obj, this);
	  }
	
	  return obj;
	};
	
	/**
	 * Returns the schematype for the given `path`.
	 *
	 * @param {String} path
	 * @api private
	 * @method $__path
	 * @memberOf Document
	 */
	
	Document.prototype.$__path = function(path) {
	  var adhocs = this.$__.adhocPaths,
	      adhocType = adhocs && adhocs[path];
	
	  if (adhocType) {
	    return adhocType;
	  }
	  return this.schema.path(path);
	};
	
	/**
	 * Marks the path as having pending changes to write to the db.
	 *
	 * _Very helpful when using [Mixed](./schematypes.html#mixed) types._
	 *
	 * ####Example:
	 *
	 *     doc.mixed.type = 'changed';
	 *     doc.markModified('mixed.type');
	 *     doc.save() // changes to mixed.type are now persisted
	 *
	 * @param {String} path the path to mark modified
	 * @param {Document} [scope] the scope to run validators with
	 * @api public
	 */
	
	Document.prototype.markModified = function(path, scope) {
	  this.$__.activePaths.modify(path);
	  if (scope != null && !this.ownerDocument) {
	    this.$__.pathsToScopes[path] = scope;
	  }
	};
	
	/**
	 * Clears the modified state on the specified path.
	 *
	 * ####Example:
	 *
	 *     doc.foo = 'bar';
	 *     doc.unmarkModified('foo');
	 *     doc.save() // changes to foo will not be persisted
	 *
	 * @param {String} path the path to unmark modified
	 * @api public
	 */
	
	Document.prototype.unmarkModified = function(path) {
	  this.$__.activePaths.init(path);
	  delete this.$__.pathsToScopes[path];
	};
	
	/**
	 * Don't run validation on this path or persist changes to this path.
	 *
	 * ####Example:
	 *
	 *     doc.foo = null;
	 *     doc.$ignore('foo');
	 *     doc.save() // changes to foo will not be persisted and validators won't be run
	 *
	 * @memberOf Document
	 * @method $ignore
	 * @param {String} path the path to ignore
	 * @api public
	 */
	
	Document.prototype.$ignore = function(path) {
	  this.$__.activePaths.ignore(path);
	};
	
	/**
	 * Returns the list of paths that have been modified.
	 *
	 * @return {Array}
	 * @api public
	 */
	
	Document.prototype.modifiedPaths = function() {
	  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
	  return directModifiedPaths.reduce(function(list, path) {
	    var parts = path.split('.');
	    return list.concat(parts.reduce(function(chains, part, i) {
	      return chains.concat(parts.slice(0, i).concat(part).join('.'));
	    }, []).filter(function(chain) {
	      return (list.indexOf(chain) === -1);
	    }));
	  }, []);
	};
	
	/**
	 * Returns true if this document was modified, else false.
	 *
	 * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.
	 *
	 * ####Example
	 *
	 *     doc.set('documents.0.title', 'changed');
	 *     doc.isModified()                      // true
	 *     doc.isModified('documents')           // true
	 *     doc.isModified('documents.0.title')   // true
	 *     doc.isModified('documents otherProp') // true
	 *     doc.isDirectModified('documents')     // false
	 *
	 * @param {String} [path] optional
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.isModified = function(paths) {
	  if (paths) {
	    if (!Array.isArray(paths)) {
	      paths = paths.split(' ');
	    }
	    var modified = this.modifiedPaths();
	    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
	    var isModifiedChild = paths.some(function(path) {
	      return !!~modified.indexOf(path);
	    });
	    return isModifiedChild || paths.some(function(path) {
	      return directModifiedPaths.some(function(mod) {
	        return mod === path || path.indexOf(mod + '.') === 0;
	      });
	    });
	  }
	  return this.$__.activePaths.some('modify');
	};
	
	/**
	 * Checks if a path is set to its default.
	 *
	 * ####Example
	 *
	 *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });
	 *     var m = new MyModel();
	 *     m.$isDefault('name'); // true
	 *
	 * @memberOf Document
	 * @method $isDefault
	 * @param {String} [path]
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.$isDefault = function(path) {
	  return (path in this.$__.activePaths.states.default);
	};
	
	/**
	 * Getter/setter, determines whether the document was removed or not.
	 *
	 * ####Example:
	 *     product.remove(function (err, product) {
	 *       product.isDeleted(); // true
	 *       product.remove(); // no-op, doesn't send anything to the db
	 *
	 *       product.isDeleted(false);
	 *       product.isDeleted(); // false
	 *       product.remove(); // will execute a remove against the db
	 *     })
	 *
	 * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted
	 * @return {Boolean} whether mongoose thinks this doc is deleted.
	 * @api public
	 */
	
	Document.prototype.$isDeleted = function(val) {
	  if (arguments.length === 0) {
	    return !!this.$__.isDeleted;
	  }
	
	  this.$__.isDeleted = !!val;
	  return this;
	};
	
	/**
	 * Returns true if `path` was directly set and modified, else false.
	 *
	 * ####Example
	 *
	 *     doc.set('documents.0.title', 'changed');
	 *     doc.isDirectModified('documents.0.title') // true
	 *     doc.isDirectModified('documents') // false
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.isDirectModified = function(path) {
	  return (path in this.$__.activePaths.states.modify);
	};
	
	/**
	 * Checks if `path` was initialized.
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.isInit = function(path) {
	  return (path in this.$__.activePaths.states.init);
	};
	
	/**
	 * Checks if `path` was selected in the source query which initialized this document.
	 *
	 * ####Example
	 *
	 *     Thing.findOne().select('name').exec(function (err, doc) {
	 *        doc.isSelected('name') // true
	 *        doc.isSelected('age')  // false
	 *     })
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.isSelected = function isSelected(path) {
	  if (this.$__.selected) {
	    if (path === '_id') {
	      return this.$__.selected._id !== 0;
	    }
	
	    var paths = Object.keys(this.$__.selected);
	    var i = paths.length;
	    var inclusive = null;
	    var cur;
	
	    if (i === 1 && paths[0] === '_id') {
	      // only _id was selected.
	      return this.$__.selected._id === 0;
	    }
	
	    while (i--) {
	      cur = paths[i];
	      if (cur === '_id') {
	        continue;
	      }
	      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {
	        continue;
	      }
	      inclusive = !!this.$__.selected[cur];
	      break;
	    }
	
	    if (inclusive === null) {
	      return true;
	    }
	
	    if (path in this.$__.selected) {
	      return inclusive;
	    }
	
	    i = paths.length;
	    var pathDot = path + '.';
	
	    while (i--) {
	      cur = paths[i];
	      if (cur === '_id') {
	        continue;
	      }
	
	      if (cur.indexOf(pathDot) === 0) {
	        return inclusive || cur !== pathDot;
	      }
	
	      if (pathDot.indexOf(cur + '.') === 0) {
	        return inclusive;
	      }
	    }
	
	    return !inclusive;
	  }
	
	  return true;
	};
	
	/**
	 * Checks if `path` was explicitly selected. If no projection, always returns
	 * true.
	 *
	 * ####Example
	 *
	 *     Thing.findOne().select('nested.name').exec(function (err, doc) {
	 *        doc.isDirectSelected('nested.name') // true
	 *        doc.isDirectSelected('nested.otherName') // false
	 *        doc.isDirectSelected('nested')  // false
	 *     })
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.isDirectSelected = function isDirectSelected(path) {
	  if (this.$__.selected) {
	    if (path === '_id') {
	      return this.$__.selected._id !== 0;
	    }
	
	    var paths = Object.keys(this.$__.selected);
	    var i = paths.length;
	    var inclusive = null;
	    var cur;
	
	    if (i === 1 && paths[0] === '_id') {
	      // only _id was selected.
	      return this.$__.selected._id === 0;
	    }
	
	    while (i--) {
	      cur = paths[i];
	      if (cur === '_id') {
	        continue;
	      }
	      if (this.$__.selected[cur] && this.$__.selected[cur].$meta) {
	        continue;
	      }
	      inclusive = !!this.$__.selected[cur];
	      break;
	    }
	
	    if (inclusive === null) {
	      return true;
	    }
	
	    if (path in this.$__.selected) {
	      return inclusive;
	    }
	
	    return !inclusive;
	  }
	
	  return true;
	};
	
	/**
	 * Executes registered validation rules for this document.
	 *
	 * ####Note:
	 *
	 * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.
	 *
	 * ####Example:
	 *
	 *     doc.validate(function (err) {
	 *       if (err) handleError(err);
	 *       else // validation passed
	 *     });
	 *
	 * @param {Object} optional options internal options
	 * @param {Function} callback optional callback called after validation completes, passing an error if one occurred
	 * @return {Promise} Promise
	 * @api public
	 */
	
	Document.prototype.validate = function(options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = null;
	  }
	
	  this.$__validate(callback || function() {});
	};
	
	/*!
	 * ignore
	 */
	
	function _getPathsToValidate(doc) {
	  var i;
	  var len;
	
	  // only validate required fields when necessary
	  var paths = Object.keys(doc.$__.activePaths.states.require).filter(function(path) {
	    if (!doc.isSelected(path) && !doc.isModified(path)) {
	      return false;
	    }
	    var p = doc.schema.path(path);
	    if (typeof p.originalRequiredValue === 'function') {
	      return p.originalRequiredValue.call(doc);
	    }
	    return true;
	  });
	
	  paths = paths.concat(Object.keys(doc.$__.activePaths.states.init));
	  paths = paths.concat(Object.keys(doc.$__.activePaths.states.modify));
	  paths = paths.concat(Object.keys(doc.$__.activePaths.states.default));
	
	  if (!doc.ownerDocument) {
	    var subdocs = doc.$__getAllSubdocs();
	    var subdoc;
	    len = subdocs.length;
	    for (i = 0; i < len; ++i) {
	      subdoc = subdocs[i];
	      if (subdoc.$isSingleNested &&
	          doc.isModified(subdoc.$basePath) &&
	          !doc.isDirectModified(subdoc.$basePath)) {
	        paths.push(subdoc.$basePath);
	      }
	    }
	  }
	
	  // gh-661: if a whole array is modified, make sure to run validation on all
	  // the children as well
	  len = paths.length;
	  for (i = 0; i < len; ++i) {
	    var path = paths[i];
	
	    var _pathType = doc.schema.path(path);
	    if (!_pathType || !_pathType.$isMongooseArray || _pathType.$isMongooseDocumentArray) {
	      continue;
	    }
	
	    var val = doc.getValue(path);
	    if (val) {
	      var numElements = val.length;
	      for (var j = 0; j < numElements; ++j) {
	        paths.push(path + '.' + j);
	      }
	    }
	  }
	
	  var flattenOptions = { skipArrays: true };
	  len = paths.length;
	  for (i = 0; i < len; ++i) {
	    var pathToCheck = paths[i];
	    if (doc.schema.nested[pathToCheck]) {
	      var _v = doc.getValue(pathToCheck);
	      if (isMongooseObject(_v)) {
	        _v = _v.toObject({ transform: false });
	      }
	      var flat = flatten(_v, '', flattenOptions);
	      var _subpaths = Object.keys(flat).map(function(p) {
	        return pathToCheck + '.' + p;
	      });
	      paths = paths.concat(_subpaths);
	    }
	  }
	
	  return paths;
	}
	
	/*!
	 * ignore
	 */
	
	Document.prototype.$__validate = function(callback) {
	  var _this = this;
	  var _complete = function() {
	    var err = _this.$__.validationError;
	    _this.$__.validationError = undefined;
	    _this.emit('validate', _this);
	    _this.constructor.emit('validate', _this);
	    if (err) {
	      for (var key in err.errors) {
	        // Make sure cast errors persist
	        if (!_this.__parent && err.errors[key] instanceof MongooseError.CastError) {
	          _this.invalidate(key, err.errors[key]);
	        }
	      }
	
	      return err;
	    }
	  };
	
	  // only validate required fields when necessary
	  var paths = _getPathsToValidate(this);
	
	  if (paths.length === 0) {
	    return process.nextTick(function() {
	      var error = _complete();
	      if (error) {
	        return _this.schema.s.hooks.execPost('validate:error', _this, [ _this], { error: error }, function(error) {
	          callback(error);
	        });
	      }
	      callback();
	    });
	  }
	
	  var validating = {},
	      total = 0;
	
	  var complete = function() {
	    var error = _complete();
	    if (error) {
	      return _this.schema.s.hooks.execPost('validate:error', _this, [ _this], { error: error }, function(error) {
	        callback(error);
	      });
	    }
	    callback();
	  };
	
	  var validatePath = function(path) {
	    if (validating[path]) {
	      return;
	    }
	
	    validating[path] = true;
	    total++;
	
	    process.nextTick(function() {
	      var p = _this.schema.path(path);
	      if (!p) {
	        return --total || complete();
	      }
	
	      // If user marked as invalid or there was a cast error, don't validate
	      if (!_this.$isValid(path)) {
	        --total || complete();
	        return;
	      }
	
	      var val = _this.getValue(path);
	      var scope = path in _this.$__.pathsToScopes ?
	        _this.$__.pathsToScopes[path] :
	        _this;
	      p.doValidate(val, function(err) {
	        if (err) {
	          _this.invalidate(path, err, undefined, true);
	        }
	        --total || complete();
	      }, scope);
	    });
	  };
	
	  var numPaths = paths.length;
	  for (var i = 0; i < numPaths; ++i) {
	    validatePath(paths[i]);
	  }
	};
	
	/**
	 * Executes registered validation rules (skipping asynchronous validators) for this document.
	 *
	 * ####Note:
	 *
	 * This method is useful if you need synchronous validation.
	 *
	 * ####Example:
	 *
	 *     var err = doc.validateSync();
	 *     if ( err ){
	 *       handleError( err );
	 *     } else {
	 *       // validation passed
	 *     }
	 *
	 * @param {Array|string} pathsToValidate only validate the given paths
	 * @return {MongooseError|undefined} MongooseError if there are errors during validation, or undefined if there is no error.
	 * @api public
	 */
	
	Document.prototype.validateSync = function(pathsToValidate) {
	  var _this = this;
	
	  if (typeof pathsToValidate === 'string') {
	    pathsToValidate = pathsToValidate.split(' ');
	  }
	
	  // only validate required fields when necessary
	  var paths = _getPathsToValidate(this);
	
	  if (pathsToValidate && pathsToValidate.length) {
	    var tmp = [];
	    for (var i = 0; i < paths.length; ++i) {
	      if (pathsToValidate.indexOf(paths[i]) !== -1) {
	        tmp.push(paths[i]);
	      }
	    }
	    paths = tmp;
	  }
	
	  var validating = {};
	
	  paths.forEach(function(path) {
	    if (validating[path]) {
	      return;
	    }
	
	    validating[path] = true;
	
	    var p = _this.schema.path(path);
	    if (!p) {
	      return;
	    }
	    if (!_this.$isValid(path)) {
	      return;
	    }
	
	    var val = _this.getValue(path);
	    var err = p.doValidateSync(val, _this);
	    if (err) {
	      _this.invalidate(path, err, undefined, true);
	    }
	  });
	
	  var err = _this.$__.validationError;
	  _this.$__.validationError = undefined;
	  _this.emit('validate', _this);
	  _this.constructor.emit('validate', _this);
	
	  if (err) {
	    for (var key in err.errors) {
	      // Make sure cast errors persist
	      if (err.errors[key] instanceof MongooseError.CastError) {
	        _this.invalidate(key, err.errors[key]);
	      }
	    }
	  }
	
	  return err;
	};
	
	/**
	 * Marks a path as invalid, causing validation to fail.
	 *
	 * The `errorMsg` argument will become the message of the `ValidationError`.
	 *
	 * The `value` argument (if passed) will be available through the `ValidationError.value` property.
	 *
	 *     doc.invalidate('size', 'must be less than 20', 14);
	
	 *     doc.validate(function (err) {
	 *       console.log(err)
	 *       // prints
	 *       { message: 'Validation failed',
	 *         name: 'ValidationError',
	 *         errors:
	 *          { size:
	 *             { message: 'must be less than 20',
	 *               name: 'ValidatorError',
	 *               path: 'size',
	 *               type: 'user defined',
	 *               value: 14 } } }
	 *     })
	 *
	 * @param {String} path the field to invalidate
	 * @param {String|Error} errorMsg the error which states the reason `path` was invalid
	 * @param {Object|String|Number|any} value optional invalid value
	 * @param {String} [kind] optional `kind` property for the error
	 * @return {ValidationError} the current ValidationError, with all currently invalidated paths
	 * @api public
	 */
	
	Document.prototype.invalidate = function(path, err, val, kind) {
	  if (!this.$__.validationError) {
	    this.$__.validationError = new ValidationError(this);
	  }
	
	  if (this.$__.validationError.errors[path]) {
	    return;
	  }
	
	  if (!err || typeof err === 'string') {
	    err = new ValidatorError({
	      path: path,
	      message: err,
	      type: kind || 'user defined',
	      value: val
	    });
	  }
	
	  if (this.$__.validationError === err) {
	    return this.$__.validationError;
	  }
	
	  this.$__.validationError.addError(path, err);
	  return this.$__.validationError;
	};
	
	/**
	 * Marks a path as valid, removing existing validation errors.
	 *
	 * @param {String} path the field to mark as valid
	 * @api private
	 * @method $markValid
	 * @receiver Document
	 */
	
	Document.prototype.$markValid = function(path) {
	  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {
	    return;
	  }
	
	  delete this.$__.validationError.errors[path];
	  if (Object.keys(this.$__.validationError.errors).length === 0) {
	    this.$__.validationError = null;
	  }
	};
	
	/**
	 * Saves this document.
	 *
	 * ####Example:
	 *
	 *     product.sold = Date.now();
	 *     product.save(function (err, product, numAffected) {
	 *       if (err) ..
	 *     })
	 *
	 * The callback will receive three parameters
	 *
	 * 1. `err` if an error occurred
	 * 2. `product` which is the saved `product`
	 * 3. `numAffected` will be 1 when the document was successfully persisted to MongoDB, otherwise 0. Unless you tweak mongoose's internals, you don't need to worry about checking this parameter for errors - checking `err` is sufficient to make sure your document was properly saved.
	 *
	 * As an extra measure of flow control, save will return a Promise.
	 * ####Example:
	 *     product.save().then(function(product) {
	 *        ...
	 *     });
	 *
	 * For legacy reasons, mongoose stores object keys in reverse order on initial
	 * save. That is, `{ a: 1, b: 2 }` will be saved as `{ b: 2, a: 1 }` in
	 * MongoDB. To override this behavior, set
	 * [the `toObject.retainKeyOrder` option](http://mongoosejs.com/docs/api.html#document_Document-toObject)
	 * to true on your schema.
	 *
	 * @param {Object} [options] options optional options
	 * @param {Object} [options.safe] overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe)
	 * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.
	 * @param {Function} [fn] optional callback
	 * @method save
	 * @return {Promise} Promise
	 * @api public
	 * @see middleware http://mongoosejs.com/docs/middleware.html
	 */
	
	/**
	 * Checks if a path is invalid
	 *
	 * @param {String} path the field to check
	 * @method $isValid
	 * @api private
	 * @receiver Document
	 */
	
	Document.prototype.$isValid = function(path) {
	  return !this.$__.validationError || !this.$__.validationError.errors[path];
	};
	
	/**
	 * Resets the internal modified state of this document.
	 *
	 * @api private
	 * @return {Document}
	 * @method $__reset
	 * @memberOf Document
	 */
	
	Document.prototype.$__reset = function reset() {
	  var _this = this;
	  DocumentArray || (DocumentArray = __webpack_require__(46));
	
	  this.$__.activePaths
	  .map('init', 'modify', function(i) {
	    return _this.getValue(i);
	  })
	  .filter(function(val) {
	    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
	  })
	  .forEach(function(array) {
	    var i = array.length;
	    while (i--) {
	      var doc = array[i];
	      if (!doc) {
	        continue;
	      }
	      doc.$__reset();
	    }
	  });
	
	  this.$__.activePaths.
	    map('init', 'modify', function(i) {
	      return _this.getValue(i);
	    }).
	    filter(function(val) {
	      return val && val.$isSingleNested;
	    }).
	    forEach(function(doc) {
	      doc.$__reset();
	    });
	
	  // clear atomics
	  this.$__dirty().forEach(function(dirt) {
	    var type = dirt.value;
	    if (type && type._atomics) {
	      type._atomics = {};
	    }
	  });
	
	  // Clear 'dirty' cache
	  this.$__.activePaths.clear('modify');
	  this.$__.activePaths.clear('default');
	  this.$__.validationError = undefined;
	  this.errors = undefined;
	  _this = this;
	  this.schema.requiredPaths().forEach(function(path) {
	    _this.$__.activePaths.require(path);
	  });
	
	  return this;
	};
	
	/**
	 * Returns this documents dirty paths / vals.
	 *
	 * @api private
	 * @method $__dirty
	 * @memberOf Document
	 */
	
	Document.prototype.$__dirty = function() {
	  var _this = this;
	
	  var all = this.$__.activePaths.map('modify', function(path) {
	    return {
	      path: path,
	      value: _this.getValue(path),
	      schema: _this.$__path(path)
	    };
	  });
	
	  // gh-2558: if we had to set a default and the value is not undefined,
	  // we have to save as well
	  all = all.concat(this.$__.activePaths.map('default', function(path) {
	    if (path === '_id' || !_this.getValue(path)) {
	      return;
	    }
	    return {
	      path: path,
	      value: _this.getValue(path),
	      schema: _this.$__path(path)
	    };
	  }));
	
	  // Sort dirty paths in a flat hierarchy.
	  all.sort(function(a, b) {
	    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));
	  });
	
	  // Ignore "foo.a" if "foo" is dirty already.
	  var minimal = [],
	      lastPath,
	      top;
	
	  all.forEach(function(item) {
	    if (!item) {
	      return;
	    }
	    if (item.path.indexOf(lastPath) !== 0) {
	      lastPath = item.path + '.';
	      minimal.push(item);
	      top = item;
	    } else {
	      // special case for top level MongooseArrays
	      if (top.value && top.value._atomics && top.value.hasAtomics()) {
	        // the `top` array itself and a sub path of `top` are being modified.
	        // the only way to honor all of both modifications is through a $set
	        // of entire array.
	        top.value._atomics = {};
	        top.value._atomics.$set = top.value;
	      }
	    }
	  });
	
	  top = lastPath = null;
	  return minimal;
	};
	
	/**
	 * Assigns/compiles `schema` into this documents prototype.
	 *
	 * @param {Schema} schema
	 * @api private
	 * @method $__setSchema
	 * @memberOf Document
	 */
	
	Document.prototype.$__setSchema = function(schema) {
	  schema.plugin(idGetter, { deduplicate: true });
	  compile(schema.tree, this, undefined, schema.options);
	  this.schema = schema;
	};
	
	
	/**
	 * Get active path that were changed and are arrays
	 *
	 * @api private
	 * @method $__getArrayPathsToValidate
	 * @memberOf Document
	 */
	
	Document.prototype.$__getArrayPathsToValidate = function() {
	  DocumentArray || (DocumentArray = __webpack_require__(46));
	
	  // validate all document arrays.
	  return this.$__.activePaths
	  .map('init', 'modify', function(i) {
	    return this.getValue(i);
	  }.bind(this))
	  .filter(function(val) {
	    return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
	  }).reduce(function(seed, array) {
	    return seed.concat(array);
	  }, [])
	  .filter(function(doc) {
	    return doc;
	  });
	};
	
	
	/**
	 * Get all subdocs (by bfs)
	 *
	 * @api private
	 * @method $__getAllSubdocs
	 * @memberOf Document
	 */
	
	Document.prototype.$__getAllSubdocs = function() {
	  DocumentArray || (DocumentArray = __webpack_require__(46));
	  Embedded = Embedded || __webpack_require__(30);
	
	  function docReducer(doc, seed, path) {
	    var val = doc[path];
	
	    if (val instanceof Embedded) {
	      seed.push(val);
	    }
	    if (val && val.$isSingleNested) {
	      seed = Object.keys(val._doc).reduce(function(seed, path) {
	        return docReducer(val._doc, seed, path);
	      }, seed);
	      seed.push(val);
	    }
	    if (val && val.isMongooseDocumentArray) {
	      val.forEach(function _docReduce(doc) {
	        if (!doc || !doc._doc) {
	          return;
	        }
	        if (doc instanceof Embedded) {
	          seed.push(doc);
	        }
	        seed = Object.keys(doc._doc).reduce(function(seed, path) {
	          return docReducer(doc._doc, seed, path);
	        }, seed);
	      });
	    } else if (val instanceof Document && val.$__isNested) {
	      if (val) {
	        seed = Object.keys(val).reduce(function(seed, path) {
	          return docReducer(val, seed, path);
	        }, seed);
	      }
	    }
	    return seed;
	  }
	
	  var _this = this;
	  var subDocs = Object.keys(this._doc).reduce(function(seed, path) {
	    return docReducer(_this, seed, path);
	  }, []);
	
	  return subDocs;
	};
	
	/*!
	 * Runs queued functions
	 */
	
	function applyQueue(doc) {
	  var q = doc.schema && doc.schema.callQueue;
	  if (!q.length) {
	    return;
	  }
	  var pair;
	
	  for (var i = 0; i < q.length; ++i) {
	    pair = q[i];
	    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {
	      doc[pair[0]].apply(doc, pair[1]);
	    }
	  }
	}
	
	Document.prototype.$__handleReject = function handleReject(err) {
	  // emit on the Model if listening
	  if (this.listeners('error').length) {
	    this.emit('error', err);
	  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {
	    this.constructor.emit('error', err);
	  } else if (this.listeners && this.listeners('error').length) {
	    this.emit('error', err);
	  }
	};
	
	/**
	 * Internal helper for toObject() and toJSON() that doesn't manipulate options
	 *
	 * @api private
	 * @method $toObject
	 * @memberOf Document
	 */
	
	Document.prototype.$toObject = function(options, json) {
	  var defaultOptions = {
	    transform: true,
	    json: json,
	    retainKeyOrder: this.schema.options.retainKeyOrder,
	    flattenDecimals: true
	  };
	
	  // _isNested will only be true if this is not the top level document, we
	  // should never depopulate
	  if (options && options.depopulate && options._isNested && this.$__.wasPopulated) {
	    // populated paths that we set to a document
	    return clone(this._id, options);
	  }
	
	  // When internally saving this document we always pass options,
	  // bypassing the custom schema options.
	  if (!(options && utils.getFunctionName(options.constructor) === 'Object') ||
	      (options && options._useSchemaOptions)) {
	    if (json) {
	      options = this.schema.options.toJSON ?
	        clone(this.schema.options.toJSON) :
	        {};
	      options.json = true;
	      options._useSchemaOptions = true;
	    } else {
	      options = this.schema.options.toObject ?
	        clone(this.schema.options.toObject) :
	        {};
	      options.json = false;
	      options._useSchemaOptions = true;
	    }
	  }
	
	  for (var key in defaultOptions) {
	    if (options[key] === undefined) {
	      options[key] = defaultOptions[key];
	    }
	  }
	
	  ('minimize' in options) || (options.minimize = this.schema.options.minimize);
	
	  // remember the root transform function
	  // to save it from being overwritten by sub-transform functions
	  var originalTransform = options.transform;
	
	  options._isNested = true;
	
	  var ret = clone(this._doc, options) || {};
	
	  if (options.getters) {
	    applyGetters(this, ret, 'paths', options);
	    // applyGetters for paths will add nested empty objects;
	    // if minimize is set, we need to remove them.
	    if (options.minimize) {
	      ret = minimize(ret) || {};
	    }
	  }
	
	  if (options.virtuals || options.getters && options.virtuals !== false) {
	    applyGetters(this, ret, 'virtuals', options);
	  }
	
	  if (options.versionKey === false && this.schema.options.versionKey) {
	    delete ret[this.schema.options.versionKey];
	  }
	
	  var transform = options.transform;
	
	  // In the case where a subdocument has its own transform function, we need to
	  // check and see if the parent has a transform (options.transform) and if the
	  // child schema has a transform (this.schema.options.toObject) In this case,
	  // we need to adjust options.transform to be the child schema's transform and
	  // not the parent schema's
	  if (transform === true ||
	      (this.schema.options.toObject && transform)) {
	    var opts = options.json ? this.schema.options.toJSON : this.schema.options.toObject;
	
	    if (opts) {
	      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);
	    }
	  } else {
	    options.transform = originalTransform;
	  }
	
	  if (typeof transform === 'function') {
	    var xformed = transform(this, ret, options);
	    if (typeof xformed !== 'undefined') {
	      ret = xformed;
	    }
	  }
	
	  return ret;
	};
	
	/**
	 * Converts this document into a plain javascript object, ready for storage in MongoDB.
	 *
	 * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.
	 *
	 * ####Options:
	 *
	 * - `getters` apply all getters (path and virtual getters)
	 * - `virtuals` apply virtual getters (can override `getters` option)
	 * - `minimize` remove empty objects (defaults to true)
	 * - `transform` a transform function to apply to the resulting document before returning
	 * - `depopulate` depopulate any populated paths, replacing them with their original refs (defaults to false)
	 * - `versionKey` whether to include the version key (defaults to true)
	 * - `retainKeyOrder` keep the order of object keys. If this is set to true, `Object.keys(new Doc({ a: 1, b: 2}).toObject())` will always produce `['a', 'b']` (defaults to false)
	 *
	 * ####Getters/Virtuals
	 *
	 * Example of only applying path getters
	 *
	 *     doc.toObject({ getters: true, virtuals: false })
	 *
	 * Example of only applying virtual getters
	 *
	 *     doc.toObject({ virtuals: true })
	 *
	 * Example of applying both path and virtual getters
	 *
	 *     doc.toObject({ getters: true })
	 *
	 * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.
	 *
	 *     schema.set('toObject', { virtuals: true })
	 *
	 * ####Transform
	 *
	 * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.
	 *
	 * Transform functions receive three arguments
	 *
	 *     function (doc, ret, options) {}
	 *
	 * - `doc` The mongoose document which is being converted
	 * - `ret` The plain object representation which has been converted
	 * - `options` The options in use (either schema options or the options passed inline)
	 *
	 * ####Example
	 *
	 *     // specify the transform schema option
	 *     if (!schema.options.toObject) schema.options.toObject = {};
	 *     schema.options.toObject.transform = function (doc, ret, options) {
	 *       // remove the _id of every document before returning the result
	 *       delete ret._id;
	 *       return ret;
	 *     }
	 *
	 *     // without the transformation in the schema
	 *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }
	 *
	 *     // with the transformation
	 *     doc.toObject(); // { name: 'Wreck-it Ralph' }
	 *
	 * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:
	 *
	 *     if (!schema.options.toObject) schema.options.toObject = {};
	 *     schema.options.toObject.transform = function (doc, ret, options) {
	 *       return { movie: ret.name }
	 *     }
	 *
	 *     // without the transformation in the schema
	 *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }
	 *
	 *     // with the transformation
	 *     doc.toObject(); // { movie: 'Wreck-it Ralph' }
	 *
	 * _Note: if a transform function returns `undefined`, the return value will be ignored._
	 *
	 * Transformations may also be applied inline, overridding any transform set in the options:
	 *
	 *     function xform (doc, ret, options) {
	 *       return { inline: ret.name, custom: true }
	 *     }
	 *
	 *     // pass the transform as an inline option
	 *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }
	 *
	 * If you want to skip transformations, use `transform: false`:
	 *
	 *     if (!schema.options.toObject) schema.options.toObject = {};
	 *     schema.options.toObject.hide = '_id';
	 *     schema.options.toObject.transform = function (doc, ret, options) {
	 *       if (options.hide) {
	 *         options.hide.split(' ').forEach(function (prop) {
	 *           delete ret[prop];
	 *         });
	 *       }
	 *       return ret;
	 *     }
	 *
	 *     var doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });
	 *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }
	 *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }
	 *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }
	 *
	 * Transforms are applied _only to the document and are not applied to sub-documents_.
	 *
	 * Transforms, like all of these options, are also available for `toJSON`.
	 *
	 * See [schema options](/docs/guide.html#toObject) for some more details.
	 *
	 * _During save, no custom options are applied to the document before being sent to the database._
	 *
	 * @param {Object} [options]
	 * @return {Object} js object
	 * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html
	 * @api public
	 */
	
	Document.prototype.toObject = function(options) {
	  return this.$toObject(options);
	};
	
	/*!
	 * Minimizes an object, removing undefined values and empty objects
	 *
	 * @param {Object} object to minimize
	 * @return {Object}
	 */
	
	function minimize(obj) {
	  var keys = Object.keys(obj),
	      i = keys.length,
	      hasKeys,
	      key,
	      val;
	
	  while (i--) {
	    key = keys[i];
	    val = obj[key];
	
	    if (utils.isObject(val) && !Buffer.isBuffer(val)) {
	      obj[key] = minimize(val);
	    }
	
	    if (undefined === obj[key]) {
	      delete obj[key];
	      continue;
	    }
	
	    hasKeys = true;
	  }
	
	  return hasKeys
	      ? obj
	      : undefined;
	}
	
	/*!
	 * Applies virtuals properties to `json`.
	 *
	 * @param {Document} self
	 * @param {Object} json
	 * @param {String} type either `virtuals` or `paths`
	 * @return {Object} `json`
	 */
	
	function applyGetters(self, json, type, options) {
	  var schema = self.schema;
	  var paths = Object.keys(schema[type]);
	  var i = paths.length;
	  var numPaths = i;
	  var path;
	  var cur = self._doc;
	  var v;
	
	  if (!cur) {
	    return json;
	  }
	
	  if (type === 'virtuals') {
	    for (i = 0; i < numPaths; ++i) {
	      path = paths[i];
	      parts = path.split('.');
	      v = clone(self.get(path), options);
	      if (v === void 0) {
	        continue;
	      }
	      plen = parts.length;
	      cur = json;
	      for (var j = 0; j < plen - 1; ++j) {
	        cur[parts[j]] = cur[parts[j]] || {};
	        cur = cur[parts[j]];
	      }
	      cur[parts[plen - 1]] = v;
	    }
	
	    return json;
	  }
	
	  while (i--) {
	    path = paths[i];
	
	    var parts = path.split('.');
	    var plen = parts.length;
	    var last = plen - 1;
	    var branch = json;
	    var part;
	    cur = self._doc;
	
	    for (var ii = 0; ii < plen; ++ii) {
	      part = parts[ii];
	      v = cur[part];
	      if (ii === last) {
	        branch[part] = clone(self.get(path), options);
	      } else if (v == null) {
	        if (part in cur) {
	          branch[part] = v;
	        }
	        break;
	      } else {
	        branch = branch[part] || (branch[part] = {});
	      }
	      cur = v;
	    }
	  }
	
	  return json;
	}
	
	/**
	 * The return value of this method is used in calls to JSON.stringify(doc).
	 *
	 * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.
	 *
	 *     schema.set('toJSON', { virtuals: true })
	 *
	 * See [schema options](/docs/guide.html#toJSON) for details.
	 *
	 * @param {Object} options
	 * @return {Object}
	 * @see Document#toObject #document_Document-toObject
	 * @api public
	 */
	
	Document.prototype.toJSON = function(options) {
	  return this.$toObject(options, true);
	};
	
	/**
	 * Helper for console.log
	 *
	 * @api public
	 */
	
	Document.prototype.inspect = function(options) {
	  var isPOJO = options &&
	    utils.getFunctionName(options.constructor) === 'Object';
	  var opts;
	  if (isPOJO) {
	    opts = options;
	    opts.minimize = false;
	    opts.retainKeyOrder = true;
	  }
	  return this.toObject(opts);
	};
	
	/**
	 * Helper for console.log
	 *
	 * @api public
	 * @method toString
	 */
	
	Document.prototype.toString = function() {
	  return inspect(this.inspect());
	};
	
	/**
	 * Returns true if the Document stores the same data as doc.
	 *
	 * Documents are considered equal when they have matching `_id`s, unless neither
	 * document has an `_id`, in which case this function falls back to using
	 * `deepEqual()`.
	 *
	 * @param {Document} doc a document to compare
	 * @return {Boolean}
	 * @api public
	 */
	
	Document.prototype.equals = function(doc) {
	  if (!doc) {
	    return false;
	  }
	
	  var tid = this.get('_id');
	  var docid = doc.get ? doc.get('_id') : doc;
	  if (!tid && !docid) {
	    return deepEqual(this, doc);
	  }
	  return tid && tid.equals
	      ? tid.equals(docid)
	      : tid === docid;
	};
	
	/**
	 * Populates document references, executing the `callback` when complete.
	 * If you want to use promises instead, use this function with
	 * [`execPopulate()`](#document_Document-execPopulate)
	 *
	 * ####Example:
	 *
	 *     doc
	 *     .populate('company')
	 *     .populate({
	 *       path: 'notes',
	 *       match: /airline/,
	 *       select: 'text',
	 *       model: 'modelName'
	 *       options: opts
	 *     }, function (err, user) {
	 *       assert(doc._id === user._id) // the document itself is passed
	 *     })
	 *
	 *     // summary
	 *     doc.populate(path)                   // not executed
	 *     doc.populate(options);               // not executed
	 *     doc.populate(path, callback)         // executed
	 *     doc.populate(options, callback);     // executed
	 *     doc.populate(callback);              // executed
	 *     doc.populate(options).execPopulate() // executed, returns promise
	 *
	 *
	 * ####NOTE:
	 *
	 * Population does not occur unless a `callback` is passed *or* you explicitly
	 * call `execPopulate()`.
	 * Passing the same path a second time will overwrite the previous path options.
	 * See [Model.populate()](#model_Model.populate) for explaination of options.
	 *
	 * @see Model.populate #model_Model.populate
	 * @see Document.execPopulate #document_Document-execPopulate
	 * @param {String|Object} [path] The path to populate or an options object
	 * @param {Function} [callback] When passed, population is invoked
	 * @api public
	 * @return {Document} this
	 */
	
	Document.prototype.populate = function populate() {
	  if (arguments.length === 0) {
	    return this;
	  }
	
	  var pop = this.$__.populate || (this.$__.populate = {});
	  var args = utils.args(arguments);
	  var fn;
	
	  if (typeof args[args.length - 1] === 'function') {
	    fn = args.pop();
	  }
	
	  // allow `doc.populate(callback)`
	  if (args.length) {
	    // use hash to remove duplicate paths
	    var res = utils.populate.apply(null, args);
	    for (var i = 0; i < res.length; ++i) {
	      pop[res[i].path] = res[i];
	    }
	  }
	
	  if (fn) {
	    var paths = utils.object.vals(pop);
	    this.$__.populate = undefined;
	    paths.__noPromise = true;
	    this.constructor.populate(this, paths, fn);
	  }
	
	  return this;
	};
	
	/**
	 * Explicitly executes population and returns a promise. Useful for ES2015
	 * integration.
	 *
	 * ####Example:
	 *
	 *     var promise = doc.
	 *       populate('company').
	 *       populate({
	 *         path: 'notes',
	 *         match: /airline/,
	 *         select: 'text',
	 *         model: 'modelName'
	 *         options: opts
	 *       }).
	 *       execPopulate();
	 *
	 *     // summary
	 *     doc.execPopulate().then(resolve, reject);
	 *
	 *
	 * @see Document.populate #document_Document-populate
	 * @api public
	 * @return {Promise} promise that resolves to the document when population is done
	 */
	
	Document.prototype.execPopulate = function() {
	  var Promise = PromiseProvider.get();
	  var _this = this;
	  return new Promise.ES6(function(resolve, reject) {
	    _this.populate(function(error, res) {
	      if (error) {
	        reject(error);
	      } else {
	        resolve(res);
	      }
	    });
	  });
	};
	
	/**
	 * Gets _id(s) used during population of the given `path`.
	 *
	 * ####Example:
	 *
	 *     Model.findOne().populate('author').exec(function (err, doc) {
	 *       console.log(doc.author.name)         // Dr.Seuss
	 *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'
	 *     })
	 *
	 * If the path was not populated, undefined is returned.
	 *
	 * @param {String} path
	 * @return {Array|ObjectId|Number|Buffer|String|undefined}
	 * @api public
	 */
	
	Document.prototype.populated = function(path, val, options) {
	  // val and options are internal
	
	  if (val === null || val === void 0) {
	    if (!this.$__.populated) {
	      return undefined;
	    }
	    var v = this.$__.populated[path];
	    if (v) {
	      return v.value;
	    }
	    return undefined;
	  }
	
	  // internal
	
	  if (val === true) {
	    if (!this.$__.populated) {
	      return undefined;
	    }
	    return this.$__.populated[path];
	  }
	
	  this.$__.populated || (this.$__.populated = {});
	  this.$__.populated[path] = {value: val, options: options};
	  return val;
	};
	
	/**
	 * Takes a populated field and returns it to its unpopulated state.
	 *
	 * ####Example:
	 *
	 *     Model.findOne().populate('author').exec(function (err, doc) {
	 *       console.log(doc.author.name); // Dr.Seuss
	 *       console.log(doc.depopulate('author'));
	 *       console.log(doc.author); // '5144cf8050f071d979c118a7'
	 *     })
	 *
	 * If the path was not populated, this is a no-op.
	 *
	 * @param {String} path
	 * @return {Document} this
	 * @see Document.populate #document_Document-populate
	 * @api public
	 */
	
	Document.prototype.depopulate = function(path) {
	  var populatedIds = this.populated(path);
	  if (!populatedIds) {
	    return;
	  }
	  delete this.$__.populated[path];
	  this.set(path, populatedIds);
	  return this;
	};
	
	
	/**
	 * Returns the full path to this document.
	 *
	 * @param {String} [path]
	 * @return {String}
	 * @api private
	 * @method $__fullPath
	 * @memberOf Document
	 */
	
	Document.prototype.$__fullPath = function(path) {
	  // overridden in SubDocuments
	  return path || '';
	};
	
	/*!
	 * Module exports.
	 */
	
	Document.ValidationError = ValidationError;
	module.exports = exports = Document;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var retrieveBSON = __webpack_require__(11).retrieveBSON;
	var BSON = retrieveBSON();
	var Long = BSON.Long;
	
	// Incrementing request id
	var _requestId = 0;
	
	// Wire command operation ids
	var OP_QUERY = 2004;
	var OP_GETMORE = 2005;
	var OP_KILL_CURSORS = 2007;
	
	// Query flags
	var OPTS_TAILABLE_CURSOR = 2;
	var OPTS_SLAVE = 4;
	var OPTS_OPLOG_REPLAY = 8;
	var OPTS_NO_CURSOR_TIMEOUT = 16;
	var OPTS_AWAIT_DATA = 32;
	var OPTS_EXHAUST = 64;
	var OPTS_PARTIAL = 128;
	
	// Response flags
	var CURSOR_NOT_FOUND = 0;
	var QUERY_FAILURE = 2;
	var SHARD_CONFIG_STALE = 4;
	var AWAIT_CAPABLE = 8;
	
	/**************************************************************
	 * QUERY
	 **************************************************************/
	var Query = function(bson, ns, query, options) {
	  var self = this;
	  // Basic options needed to be passed in
	  if(ns == null) throw new Error("ns must be specified for query");
	  if(query == null) throw new Error("query must be specified for query");
	
	  // Validate that we are not passing 0x00 in the collection name
	  if(!!~ns.indexOf("\x00")) {
	    throw new Error("namespace cannot contain a null character");
	  }
	
	  // Basic options
	  this.bson = bson;
	  this.ns = ns;
	  this.query = query;
	
	  // Ensure empty options
	  this.options = options || {};
	
	  // Additional options
	  this.numberToSkip = options.numberToSkip || 0;
	  this.numberToReturn = options.numberToReturn || 0;
	  this.returnFieldSelector = options.returnFieldSelector || null;
	  this.requestId = Query.getRequestId();
	
	  // Serialization option
	  this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
	  this.ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
	  this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
	  this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : true;
	  this.batchSize = self.numberToReturn;
	
	  // Flags
	  this.tailable = false;
	  this.slaveOk = typeof options.slaveOk == 'boolean'? options.slaveOk : false;
	  this.oplogReplay = false;
	  this.noCursorTimeout = false;
	  this.awaitData = false;
	  this.exhaust = false;
	  this.partial = false;
	}
	
	//
	// Assign a new request Id
	Query.prototype.incRequestId = function() {
	  this.requestId = _requestId++;
	}
	
	//
	// Assign a new request Id
	Query.nextRequestId = function() {
	  return _requestId + 1;
	}
	
	//
	// Uses a single allocated buffer for the process, avoiding multiple memory allocations
	Query.prototype.toBin = function() {
	  var self = this;
	  var buffers = [];
	  var projection = null;
	
	  // Set up the flags
	  var flags = 0;
	  if(this.tailable) {
	    flags |= OPTS_TAILABLE_CURSOR;
	  }
	
	  if(this.slaveOk) {
	    flags |= OPTS_SLAVE;
	  }
	
	  if(this.oplogReplay) {
	    flags |= OPTS_OPLOG_REPLAY;
	  }
	
	  if(this.noCursorTimeout) {
	    flags |= OPTS_NO_CURSOR_TIMEOUT;
	  }
	
	  if(this.awaitData) {
	    flags |= OPTS_AWAIT_DATA;
	  }
	
	  if(this.exhaust) {
	    flags |= OPTS_EXHAUST;
	  }
	
	  if(this.partial) {
	    flags |= OPTS_PARTIAL;
	  }
	
	  // If batchSize is different to self.numberToReturn
	  if(self.batchSize != self.numberToReturn) self.numberToReturn = self.batchSize;
	
	  // Allocate write protocol header buffer
	  var header = new Buffer(
	    4 * 4 // Header
	    + 4   // Flags
	    + Buffer.byteLength(self.ns) + 1 // namespace
	    + 4 // numberToSkip
	    + 4 // numberToReturn
	  );
	
	  // Add header to buffers
	  buffers.push(header);
	
	  // Serialize the query
	  var query = self.bson.serialize(this.query, {
	    checkKeys: this.checkKeys,
	    serializeFunctions: this.serializeFunctions,
	    ignoreUndefined: this.ignoreUndefined,
	  });
	
	  // Add query document
	  buffers.push(query);
	
	  if(self.returnFieldSelector && Object.keys(self.returnFieldSelector).length > 0) {
	    // Serialize the projection document
	    projection = self.bson.serialize(this.returnFieldSelector, {
	      checkKeys: this.checkKeys,
	      serializeFunctions: this.serializeFunctions,
	      ignoreUndefined: this.ignoreUndefined,
	    });
	    // Add projection document
	    buffers.push(projection);
	  }
	
	  // Total message size
	  var totalLength = header.length + query.length + (projection ? projection.length : 0);
	
	  // Set up the index
	  var index = 4;
	
	  // Write total document length
	  header[3] = (totalLength >> 24) & 0xff;
	  header[2] = (totalLength >> 16) & 0xff;
	  header[1] = (totalLength >> 8) & 0xff;
	  header[0] = (totalLength) & 0xff;
	
	  // Write header information requestId
	  header[index + 3] = (this.requestId >> 24) & 0xff;
	  header[index + 2] = (this.requestId >> 16) & 0xff;
	  header[index + 1] = (this.requestId >> 8) & 0xff;
	  header[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // Write header information responseTo
	  header[index + 3] = (0 >> 24) & 0xff;
	  header[index + 2] = (0 >> 16) & 0xff;
	  header[index + 1] = (0 >> 8) & 0xff;
	  header[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Write header information OP_QUERY
	  header[index + 3] = (OP_QUERY >> 24) & 0xff;
	  header[index + 2] = (OP_QUERY >> 16) & 0xff;
	  header[index + 1] = (OP_QUERY >> 8) & 0xff;
	  header[index] = (OP_QUERY) & 0xff;
	  index = index + 4;
	
	  // Write header information flags
	  header[index + 3] = (flags >> 24) & 0xff;
	  header[index + 2] = (flags >> 16) & 0xff;
	  header[index + 1] = (flags >> 8) & 0xff;
	  header[index] = (flags) & 0xff;
	  index = index + 4;
	
	  // Write collection name
	  index = index + header.write(this.ns, index, 'utf8') + 1;
	  header[index - 1] = 0;
	
	  // Write header information flags numberToSkip
	  header[index + 3] = (this.numberToSkip >> 24) & 0xff;
	  header[index + 2] = (this.numberToSkip >> 16) & 0xff;
	  header[index + 1] = (this.numberToSkip >> 8) & 0xff;
	  header[index] = (this.numberToSkip) & 0xff;
	  index = index + 4;
	
	  // Write header information flags numberToReturn
	  header[index + 3] = (this.numberToReturn >> 24) & 0xff;
	  header[index + 2] = (this.numberToReturn >> 16) & 0xff;
	  header[index + 1] = (this.numberToReturn >> 8) & 0xff;
	  header[index] = (this.numberToReturn) & 0xff;
	  index = index + 4;
	
	  // Return the buffers
	  return buffers;
	}
	
	Query.getRequestId = function() {
	  return ++_requestId;
	}
	
	/**************************************************************
	 * GETMORE
	 **************************************************************/
	var GetMore = function(bson, ns, cursorId, opts) {
	  opts = opts || {};
	  this.numberToReturn = opts.numberToReturn || 0;
	  this.requestId = _requestId++;
	  this.bson = bson;
	  this.ns = ns;
	  this.cursorId = cursorId;
	}
	
	//
	// Uses a single allocated buffer for the process, avoiding multiple memory allocations
	GetMore.prototype.toBin = function() {
	  var length = 4 + Buffer.byteLength(this.ns) + 1 + 4 + 8 + (4 * 4);
	  // Create command buffer
	  var index = 0;
	  // Allocate buffer
	  var _buffer = new Buffer(length);
	
	  // Write header information
	  // index = write32bit(index, _buffer, length);
	  _buffer[index + 3] = (length >> 24) & 0xff;
	  _buffer[index + 2] = (length >> 16) & 0xff;
	  _buffer[index + 1] = (length >> 8) & 0xff;
	  _buffer[index] = (length) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, requestId);
	  _buffer[index + 3] = (this.requestId >> 24) & 0xff;
	  _buffer[index + 2] = (this.requestId >> 16) & 0xff;
	  _buffer[index + 1] = (this.requestId >> 8) & 0xff;
	  _buffer[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, 0);
	  _buffer[index + 3] = (0 >> 24) & 0xff;
	  _buffer[index + 2] = (0 >> 16) & 0xff;
	  _buffer[index + 1] = (0 >> 8) & 0xff;
	  _buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, OP_GETMORE);
	  _buffer[index + 3] = (OP_GETMORE >> 24) & 0xff;
	  _buffer[index + 2] = (OP_GETMORE >> 16) & 0xff;
	  _buffer[index + 1] = (OP_GETMORE >> 8) & 0xff;
	  _buffer[index] = (OP_GETMORE) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, 0);
	  _buffer[index + 3] = (0 >> 24) & 0xff;
	  _buffer[index + 2] = (0 >> 16) & 0xff;
	  _buffer[index + 1] = (0 >> 8) & 0xff;
	  _buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Write collection name
	  index = index + _buffer.write(this.ns, index, 'utf8') + 1;
	  _buffer[index - 1] = 0;
	
	  // Write batch size
	  // index = write32bit(index, _buffer, numberToReturn);
	  _buffer[index + 3] = (this.numberToReturn >> 24) & 0xff;
	  _buffer[index + 2] = (this.numberToReturn >> 16) & 0xff;
	  _buffer[index + 1] = (this.numberToReturn >> 8) & 0xff;
	  _buffer[index] = (this.numberToReturn) & 0xff;
	  index = index + 4;
	
	  // Write cursor id
	  // index = write32bit(index, _buffer, cursorId.getLowBits());
	  _buffer[index + 3] = (this.cursorId.getLowBits() >> 24) & 0xff;
	  _buffer[index + 2] = (this.cursorId.getLowBits() >> 16) & 0xff;
	  _buffer[index + 1] = (this.cursorId.getLowBits() >> 8) & 0xff;
	  _buffer[index] = (this.cursorId.getLowBits()) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, cursorId.getHighBits());
	  _buffer[index + 3] = (this.cursorId.getHighBits() >> 24) & 0xff;
	  _buffer[index + 2] = (this.cursorId.getHighBits() >> 16) & 0xff;
	  _buffer[index + 1] = (this.cursorId.getHighBits() >> 8) & 0xff;
	  _buffer[index] = (this.cursorId.getHighBits()) & 0xff;
	  index = index + 4;
	
	  // Return buffer
	  return _buffer;
	}
	
	/**************************************************************
	 * KILLCURSOR
	 **************************************************************/
	var KillCursor = function(bson, cursorIds) {
	  this.requestId = _requestId++;
	  this.cursorIds = cursorIds;
	}
	
	//
	// Uses a single allocated buffer for the process, avoiding multiple memory allocations
	KillCursor.prototype.toBin = function() {
	  var length = 4 + 4 + (4 * 4) + (this.cursorIds.length * 8);
	
	  // Create command buffer
	  var index = 0;
	  var _buffer = new Buffer(length);
	
	  // Write header information
	  // index = write32bit(index, _buffer, length);
	  _buffer[index + 3] = (length >> 24) & 0xff;
	  _buffer[index + 2] = (length >> 16) & 0xff;
	  _buffer[index + 1] = (length >> 8) & 0xff;
	  _buffer[index] = (length) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, requestId);
	  _buffer[index + 3] = (this.requestId >> 24) & 0xff;
	  _buffer[index + 2] = (this.requestId >> 16) & 0xff;
	  _buffer[index + 1] = (this.requestId >> 8) & 0xff;
	  _buffer[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, 0);
	  _buffer[index + 3] = (0 >> 24) & 0xff;
	  _buffer[index + 2] = (0 >> 16) & 0xff;
	  _buffer[index + 1] = (0 >> 8) & 0xff;
	  _buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, OP_KILL_CURSORS);
	  _buffer[index + 3] = (OP_KILL_CURSORS >> 24) & 0xff;
	  _buffer[index + 2] = (OP_KILL_CURSORS >> 16) & 0xff;
	  _buffer[index + 1] = (OP_KILL_CURSORS >> 8) & 0xff;
	  _buffer[index] = (OP_KILL_CURSORS) & 0xff;
	  index = index + 4;
	
	  // index = write32bit(index, _buffer, 0);
	  _buffer[index + 3] = (0 >> 24) & 0xff;
	  _buffer[index + 2] = (0 >> 16) & 0xff;
	  _buffer[index + 1] = (0 >> 8) & 0xff;
	  _buffer[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Write batch size
	  // index = write32bit(index, _buffer, this.cursorIds.length);
	  _buffer[index + 3] = (this.cursorIds.length >> 24) & 0xff;
	  _buffer[index + 2] = (this.cursorIds.length >> 16) & 0xff;
	  _buffer[index + 1] = (this.cursorIds.length >> 8) & 0xff;
	  _buffer[index] = (this.cursorIds.length) & 0xff;
	  index = index + 4;
	
	  // Write all the cursor ids into the array
	  for(var i = 0; i < this.cursorIds.length; i++) {
	    // Write cursor id
	    // index = write32bit(index, _buffer, cursorIds[i].getLowBits());
	    _buffer[index + 3] = (this.cursorIds[i].getLowBits() >> 24) & 0xff;
	    _buffer[index + 2] = (this.cursorIds[i].getLowBits() >> 16) & 0xff;
	    _buffer[index + 1] = (this.cursorIds[i].getLowBits() >> 8) & 0xff;
	    _buffer[index] = (this.cursorIds[i].getLowBits()) & 0xff;
	    index = index + 4;
	
	    // index = write32bit(index, _buffer, cursorIds[i].getHighBits());
	    _buffer[index + 3] = (this.cursorIds[i].getHighBits() >> 24) & 0xff;
	    _buffer[index + 2] = (this.cursorIds[i].getHighBits() >> 16) & 0xff;
	    _buffer[index + 1] = (this.cursorIds[i].getHighBits() >> 8) & 0xff;
	    _buffer[index] = (this.cursorIds[i].getHighBits()) & 0xff;
	    index = index + 4;
	  }
	
	  // Return buffer
	  return _buffer;
	}
	
	var Response = function(bson, data, opts) {
	  opts = opts || {promoteLongs: true, promoteValues: true, promoteBuffers: false};
	  this.parsed = false;
	
	  //
	  // Parse Header
	  //
	  this.index = 0;
	  this.raw = data;
	  this.data = data;
	  this.bson = bson;
	  this.opts = opts;
	
	  // Read the message length
	  this.length = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	
	  // Fetch the request id for this reply
	  this.requestId = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	
	  // Fetch the id of the request that triggered the response
	  this.responseTo = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	
	  // Skip op-code field
	  this.index = this.index + 4;
	
	  // Unpack flags
	  this.responseFlags = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	
	  // Unpack the cursor
	  var lowBits = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	  var highBits = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	  // Create long object
	  this.cursorId = new Long(lowBits, highBits);
	
	  // Unpack the starting from
	  this.startingFrom = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	
	  // Unpack the number of objects returned
	  this.numberReturned = data[this.index] | data[this.index + 1] << 8 | data[this.index + 2] << 16 | data[this.index + 3] << 24;
	  this.index = this.index + 4;
	
	  // Preallocate document array
	  this.documents = new Array(this.numberReturned);
	
	  // Flag values
	  this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) != 0;
	  this.queryFailure = (this.responseFlags & QUERY_FAILURE) != 0;
	  this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) != 0;
	  this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) != 0;
	  this.promoteLongs = typeof opts.promoteLongs == 'boolean' ? opts.promoteLongs : true;
	  this.promoteValues = typeof opts.promoteValues == 'boolean' ? opts.promoteValues : true;
	  this.promoteBuffers = typeof opts.promoteBuffers == 'boolean' ? opts.promoteBuffers : false;
	}
	
	Response.prototype.isParsed = function() {
	  return this.parsed;
	}
	
	Response.prototype.parse = function(options) {
	  // Don't parse again if not needed
	  if(this.parsed) return;
	  options = options || {};
	
	  // Allow the return of raw documents instead of parsing
	  var raw = options.raw || false;
	  var documentsReturnedIn = options.documentsReturnedIn || null;
	  var promoteLongs = typeof options.promoteLongs == 'boolean'
	    ? options.promoteLongs
	    : this.opts.promoteLongs;
	  var promoteValues = typeof options.promoteValues == 'boolean'
	    ? options.promoteValues
	    : this.opts.promoteValues;
	  var promoteBuffers = typeof options.promoteBuffers == 'boolean'
	    ? options.promoteBuffers
	    : this.opts.promoteBuffers
	  var bsonSize, _options;
	
	  // Set up the options
	  _options = {
	    promoteLongs: promoteLongs,
	    promoteValues: promoteValues,
	    promoteBuffers: promoteBuffers
	  };
	
	  //
	  // Single document and documentsReturnedIn set
	  //
	  if(this.numberReturned == 1 && documentsReturnedIn != null && raw) {
	    // Calculate the bson size
	    bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
	    // Slice out the buffer containing the command result document
	    var document = this.data.slice(this.index, this.index + bsonSize);
	    // Set up field we wish to keep as raw
	    var fieldsAsRaw = {}
	    fieldsAsRaw[documentsReturnedIn] = true;
	    _options.fieldsAsRaw = fieldsAsRaw;
	
	    // Deserialize but keep the array of documents in non-parsed form
	    var doc = this.bson.deserialize(document, _options);
	
	    // Get the documents
	    this.documents = doc.cursor[documentsReturnedIn];
	    this.numberReturned = this.documents.length;
	    // Ensure we have a Long valie cursor id
	    this.cursorId = typeof doc.cursor.id == 'number'
	      ? Long.fromNumber(doc.cursor.id)
	      : doc.cursor.id;
	
	    // Adjust the index
	    this.index = this.index + bsonSize;
	
	    // Set as parsed
	    this.parsed = true
	    return;
	  }
	
	  //
	  // Parse Body
	  //
	  for(var i = 0; i < this.numberReturned; i++) {
	    bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
	
	    // If we have raw results specified slice the return document
	    if(raw) {
	      this.documents[i] = this.data.slice(this.index, this.index + bsonSize);
	    } else {
	      this.documents[i] = this.bson.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);
	    }
	
	    // Adjust the index
	    this.index = this.index + bsonSize;
	  }
	
	  // Set parsed
	  this.parsed = true;
	}
	
	module.exports = {
	    Query: Query
	  , GetMore: GetMore
	  , Response: Response
	  , KillCursor: KillCursor
	}


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   3.2.1
	 */
	
	(function() {
	    "use strict";
	    function lib$es6$promise$utils$$objectOrFunction(x) {
	      return typeof x === 'function' || (typeof x === 'object' && x !== null);
	    }
	
	    function lib$es6$promise$utils$$isFunction(x) {
	      return typeof x === 'function';
	    }
	
	    function lib$es6$promise$utils$$isMaybeThenable(x) {
	      return typeof x === 'object' && x !== null;
	    }
	
	    var lib$es6$promise$utils$$_isArray;
	    if (!Array.isArray) {
	      lib$es6$promise$utils$$_isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    } else {
	      lib$es6$promise$utils$$_isArray = Array.isArray;
	    }
	
	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
	    var lib$es6$promise$asap$$len = 0;
	    var lib$es6$promise$asap$$vertxNext;
	    var lib$es6$promise$asap$$customSchedulerFn;
	
	    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
	      lib$es6$promise$asap$$len += 2;
	      if (lib$es6$promise$asap$$len === 2) {
	        // If len is 2, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        if (lib$es6$promise$asap$$customSchedulerFn) {
	          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
	        } else {
	          lib$es6$promise$asap$$scheduleFlush();
	        }
	      }
	    }
	
	    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
	      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
	    }
	
	    function lib$es6$promise$asap$$setAsap(asapFn) {
	      lib$es6$promise$asap$$asap = asapFn;
	    }
	
	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
	    var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	    // test for web worker but not in IE10
	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
	      typeof importScripts !== 'undefined' &&
	      typeof MessageChannel !== 'undefined';
	
	    // node
	    function lib$es6$promise$asap$$useNextTick() {
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // see https://github.com/cujojs/when/issues/410 for details
	      return function() {
	        process.nextTick(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    // vertx
	    function lib$es6$promise$asap$$useVertxTimer() {
	      return function() {
	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    function lib$es6$promise$asap$$useMutationObserver() {
	      var iterations = 0;
	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
	      var node = document.createTextNode('');
	      observer.observe(node, { characterData: true });
	
	      return function() {
	        node.data = (iterations = ++iterations % 2);
	      };
	    }
	
	    // web worker
	    function lib$es6$promise$asap$$useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = lib$es6$promise$asap$$flush;
	      return function () {
	        channel.port2.postMessage(0);
	      };
	    }
	
	    function lib$es6$promise$asap$$useSetTimeout() {
	      return function() {
	        setTimeout(lib$es6$promise$asap$$flush, 1);
	      };
	    }
	
	    var lib$es6$promise$asap$$queue = new Array(1000);
	    function lib$es6$promise$asap$$flush() {
	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
	        var callback = lib$es6$promise$asap$$queue[i];
	        var arg = lib$es6$promise$asap$$queue[i+1];
	
	        callback(arg);
	
	        lib$es6$promise$asap$$queue[i] = undefined;
	        lib$es6$promise$asap$$queue[i+1] = undefined;
	      }
	
	      lib$es6$promise$asap$$len = 0;
	    }
	
	    function lib$es6$promise$asap$$attemptVertx() {
	      try {
	        var r = require;
	        var vertx = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"vertx\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return lib$es6$promise$asap$$useVertxTimer();
	      } catch(e) {
	        return lib$es6$promise$asap$$useSetTimeout();
	      }
	    }
	
	    var lib$es6$promise$asap$$scheduleFlush;
	    // Decide what async method to use to triggering processing of queued callbacks:
	    if (lib$es6$promise$asap$$isNode) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
	    } else if (lib$es6$promise$asap$$isWorker) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
	    } else if (lib$es6$promise$asap$$browserWindow === undefined && "function" === 'function') {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
	    } else {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
	    }
	    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
	      var parent = this;
	
	      var child = new this.constructor(lib$es6$promise$$internal$$noop);
	
	      if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {
	        lib$es6$promise$$internal$$makePromise(child);
	      }
	
	      var state = parent._state;
	
	      if (state) {
	        var callback = arguments[state - 1];
	        lib$es6$promise$asap$$asap(function(){
	          lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);
	        });
	      } else {
	        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	      }
	
	      return child;
	    }
	    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;
	    function lib$es6$promise$promise$resolve$$resolve(object) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }
	
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$resolve(promise, object);
	      return promise;
	    }
	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
	    var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);
	
	    function lib$es6$promise$$internal$$noop() {}
	
	    var lib$es6$promise$$internal$$PENDING   = void 0;
	    var lib$es6$promise$$internal$$FULFILLED = 1;
	    var lib$es6$promise$$internal$$REJECTED  = 2;
	
	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$selfFulfillment() {
	      return new TypeError("You cannot resolve a promise with itself");
	    }
	
	    function lib$es6$promise$$internal$$cannotReturnOwn() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }
	
	    function lib$es6$promise$$internal$$getThen(promise) {
	      try {
	        return promise.then;
	      } catch(error) {
	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
	        return lib$es6$promise$$internal$$GET_THEN_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then.call(value, fulfillmentHandler, rejectionHandler);
	      } catch(e) {
	        return e;
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
	       lib$es6$promise$asap$$asap(function(promise) {
	        var sealed = false;
	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
	          if (sealed) { return; }
	          sealed = true;
	          if (thenable !== value) {
	            lib$es6$promise$$internal$$resolve(promise, value);
	          } else {
	            lib$es6$promise$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          if (sealed) { return; }
	          sealed = true;
	
	          lib$es6$promise$$internal$$reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	        if (!sealed && error) {
	          sealed = true;
	          lib$es6$promise$$internal$$reject(promise, error);
	        }
	      }, promise);
	    }
	
	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, thenable._result);
	      } else {
	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
	      if (maybeThenable.constructor === promise.constructor &&
	          then === lib$es6$promise$then$$default &&
	          constructor.resolve === lib$es6$promise$promise$resolve$$default) {
	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
	      } else {
	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
	        } else if (then === undefined) {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        } else if (lib$es6$promise$utils$$isFunction(then)) {
	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
	        } else {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        }
	      }
	    }
	
	    function lib$es6$promise$$internal$$resolve(promise, value) {
	      if (promise === value) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));
	      } else {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publishRejection(promise) {
	      if (promise._onerror) {
	        promise._onerror(promise._result);
	      }
	
	      lib$es6$promise$$internal$$publish(promise);
	    }
	
	    function lib$es6$promise$$internal$$fulfill(promise, value) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	
	      promise._result = value;
	      promise._state = lib$es6$promise$$internal$$FULFILLED;
	
	      if (promise._subscribers.length !== 0) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
	      }
	    }
	
	    function lib$es6$promise$$internal$$reject(promise, reason) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	      promise._state = lib$es6$promise$$internal$$REJECTED;
	      promise._result = reason;
	
	      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
	    }
	
	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	      var subscribers = parent._subscribers;
	      var length = subscribers.length;
	
	      parent._onerror = null;
	
	      subscribers[length] = child;
	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;
	
	      if (length === 0 && parent._state) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;
	
	      if (subscribers.length === 0) { return; }
	
	      var child, callback, detail = promise._result;
	
	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];
	
	        if (child) {
	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }
	
	      promise._subscribers.length = 0;
	    }
	
	    function lib$es6$promise$$internal$$ErrorObject() {
	      this.error = null;
	    }
	
	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
	      try {
	        return callback(detail);
	      } catch(e) {
	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
	          value, error, succeeded, failed;
	
	      if (hasCallback) {
	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);
	
	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
	          failed = true;
	          error = value.error;
	          value = null;
	        } else {
	          succeeded = true;
	        }
	
	        if (promise === value) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
	          return;
	        }
	
	      } else {
	        value = detail;
	        succeeded = true;
	      }
	
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	        // noop
	      } else if (hasCallback && succeeded) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$es6$promise$$internal$$reject(promise, error);
	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
	      try {
	        resolver(function resolvePromise(value){
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function rejectPromise(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      } catch(e) {
	        lib$es6$promise$$internal$$reject(promise, e);
	      }
	    }
	
	    var lib$es6$promise$$internal$$id = 0;
	    function lib$es6$promise$$internal$$nextId() {
	      return lib$es6$promise$$internal$$id++;
	    }
	
	    function lib$es6$promise$$internal$$makePromise(promise) {
	      promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;
	      promise._state = undefined;
	      promise._result = undefined;
	      promise._subscribers = [];
	    }
	
	    function lib$es6$promise$promise$all$$all(entries) {
	      return new lib$es6$promise$enumerator$$default(this, entries).promise;
	    }
	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
	    function lib$es6$promise$promise$race$$race(entries) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (!lib$es6$promise$utils$$isArray(entries)) {
	        return new Constructor(function(resolve, reject) {
	          reject(new TypeError('You must pass an array to race.'));
	        });
	      } else {
	        return new Constructor(function(resolve, reject) {
	          var length = entries.length;
	          for (var i = 0; i < length; i++) {
	            Constructor.resolve(entries[i]).then(resolve, reject);
	          }
	        });
	      }
	    }
	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
	    function lib$es6$promise$promise$reject$$reject(reason) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$reject(promise, reason);
	      return promise;
	    }
	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;
	
	
	    function lib$es6$promise$promise$$needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }
	
	    function lib$es6$promise$promise$$needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }
	
	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
	    /**
	      Promise objects represent the eventual result of an asynchronous operation. The
	      primary way of interacting with a promise is through its `then` method, which
	      registers callbacks to receive either a promise's eventual value or the reason
	      why the promise cannot be fulfilled.
	
	      Terminology
	      -----------
	
	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	      - `thenable` is an object or function that defines a `then` method.
	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	      - `exception` is a value that is thrown using the throw statement.
	      - `reason` is a value that indicates why a promise was rejected.
	      - `settled` the final resting state of a promise, fulfilled or rejected.
	
	      A promise can be in one of three states: pending, fulfilled, or rejected.
	
	      Promises that are fulfilled have a fulfillment value and are in the fulfilled
	      state.  Promises that are rejected have a rejection reason and are in the
	      rejected state.  A fulfillment value is never a thenable.
	
	      Promises can also be said to *resolve* a value.  If this value is also a
	      promise, then the original promise's settled state will match the value's
	      settled state.  So a promise that *resolves* a promise that rejects will
	      itself reject, and a promise that *resolves* a promise that fulfills will
	      itself fulfill.
	
	
	      Basic Usage:
	      ------------
	
	      ```js
	      var promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);
	
	        // on failure
	        reject(reason);
	      });
	
	      promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Advanced Usage:
	      ---------------
	
	      Promises shine when abstracting away asynchronous interactions such as
	      `XMLHttpRequest`s.
	
	      ```js
	      function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          var xhr = new XMLHttpRequest();
	
	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();
	
	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }
	
	      getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Unlike callbacks, promises are great composable primitives.
	
	      ```js
	      Promise.all([
	        getJSON('/posts'),
	        getJSON('/comments')
	      ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON
	
	        return values;
	      });
	      ```
	
	      @class Promise
	      @param {function} resolver
	      Useful for tooling.
	      @constructor
	    */
	    function lib$es6$promise$promise$$Promise(resolver) {
	      this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();
	      this._result = this._state = undefined;
	      this._subscribers = [];
	
	      if (lib$es6$promise$$internal$$noop !== resolver) {
	        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();
	        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();
	      }
	    }
	
	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
	    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
	    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
	    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
	
	    lib$es6$promise$promise$$Promise.prototype = {
	      constructor: lib$es6$promise$promise$$Promise,
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	
	      Chaining
	      --------
	
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	
	      Assimilation
	      ------------
	
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	
	      If the assimliated promise rejects, then the downstream promise will also reject.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	
	      Simple Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var result;
	
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	
	      Advanced Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var author, books;
	
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	
	      function foundBooks(books) {
	
	      }
	
	      function failure(reason) {
	
	      }
	
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	      then: lib$es6$promise$then$$default,
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	      'catch': function(onRejection) {
	        return this.then(null, onRejection);
	      }
	    };
	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
	      this._instanceConstructor = Constructor;
	      this.promise = new Constructor(lib$es6$promise$$internal$$noop);
	
	      if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {
	        lib$es6$promise$$internal$$makePromise(this.promise);
	      }
	
	      if (lib$es6$promise$utils$$isArray(input)) {
	        this._input     = input;
	        this.length     = input.length;
	        this._remaining = input.length;
	
	        this._result = new Array(this.length);
	
	        if (this.length === 0) {
	          lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	        } else {
	          this.length = this.length || 0;
	          this._enumerate();
	          if (this._remaining === 0) {
	            lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	          }
	        }
	      } else {
	        lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());
	      }
	    }
	
	    function lib$es6$promise$enumerator$$validationError() {
	      return new Error('Array Methods must be provided an Array');
	    }
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
	      var length  = this.length;
	      var input   = this._input;
	
	      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        this._eachEntry(input[i], i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
	      var c = this._instanceConstructor;
	      var resolve = c.resolve;
	
	      if (resolve === lib$es6$promise$promise$resolve$$default) {
	        var then = lib$es6$promise$$internal$$getThen(entry);
	
	        if (then === lib$es6$promise$then$$default &&
	            entry._state !== lib$es6$promise$$internal$$PENDING) {
	          this._settledAt(entry._state, i, entry._result);
	        } else if (typeof then !== 'function') {
	          this._remaining--;
	          this._result[i] = entry;
	        } else if (c === lib$es6$promise$promise$$default) {
	          var promise = new c(lib$es6$promise$$internal$$noop);
	          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);
	          this._willSettleAt(promise, i);
	        } else {
	          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);
	        }
	      } else {
	        this._willSettleAt(resolve(entry), i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
	      var promise = this.promise;
	
	      if (promise._state === lib$es6$promise$$internal$$PENDING) {
	        this._remaining--;
	
	        if (state === lib$es6$promise$$internal$$REJECTED) {
	          lib$es6$promise$$internal$$reject(promise, value);
	        } else {
	          this._result[i] = value;
	        }
	      }
	
	      if (this._remaining === 0) {
	        lib$es6$promise$$internal$$fulfill(promise, this._result);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
	      var enumerator = this;
	
	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
	      }, function(reason) {
	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
	      });
	    };
	    function lib$es6$promise$polyfill$$polyfill() {
	      var local;
	
	      if (typeof global !== 'undefined') {
	          local = global;
	      } else if (typeof self !== 'undefined') {
	          local = self;
	      } else {
	          try {
	              local = Function('return this')();
	          } catch (e) {
	              throw new Error('polyfill failed because global object is unavailable in this environment');
	          }
	      }
	
	      var P = local.Promise;
	
	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
	        return;
	      }
	
	      local.Promise = lib$es6$promise$promise$$default;
	    }
	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;
	
	    var lib$es6$promise$umd$$ES6Promise = {
	      'Promise': lib$es6$promise$promise$$default,
	      'polyfill': lib$es6$promise$polyfill$$default
	    };
	
	    /* global define:true module:true window: true */
	    if ("function" === 'function' && __webpack_require__(266)['amd']) {
	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module['exports']) {
	      module['exports'] = lib$es6$promise$umd$$ES6Promise;
	    } else if (typeof this !== 'undefined') {
	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
	    }
	
	    lib$es6$promise$polyfill$$default();
	}).call(this);
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(47)(module)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var f = __webpack_require__(1).format,
	  require_optional = __webpack_require__(20);
	
	// Set property function
	var setProperty = function(obj, prop, flag, values) {
	  Object.defineProperty(obj, prop.name, {
	      enumerable:true,
	      set: function(value) {
	        if(typeof value != 'boolean') throw new Error(f("%s required a boolean", prop.name));
	        // Flip the bit to 1
	        if(value == true) values.flags |= flag;
	        // Flip the bit to 0 if it's set, otherwise ignore
	        if(value == false && (values.flags & flag) == flag) values.flags ^= flag;
	        prop.value = value;
	      }
	    , get: function() { return prop.value; }
	  });
	}
	
	// Set property function
	var getProperty = function(obj, propName, fieldName, values, func) {
	  Object.defineProperty(obj, propName, {
	    enumerable:true,
	    get: function() {
	      // Not parsed yet, parse it
	      if(values[fieldName] == null && obj.isParsed && !obj.isParsed()) {
	        obj.parse();
	      }
	
	      // Do we have a post processing function
	      if(typeof func == 'function') return func(values[fieldName]);
	      // Return raw value
	      return values[fieldName];
	    }
	  });
	}
	
	// Set simple property
	var getSingleProperty = function(obj, name, value) {
	  Object.defineProperty(obj, name, {
	    enumerable:true,
	    get: function() {
	      return value
	    }
	  });
	}
	
	// Shallow copy
	var copy = function(fObj, tObj) {
	  tObj = tObj || {};
	  for(var name in fObj) tObj[name] = fObj[name];
	  return tObj;
	}
	
	var debugOptions = function(debugFields, options) {
	  var finaloptions = {};
	  debugFields.forEach(function(n) {
	    finaloptions[n] = options[n];
	  });
	
	  return finaloptions;
	}
	
	var retrieveBSON = function() {
	  var BSON = __webpack_require__(25);
	  BSON.native = false;
	
	  try {
	    var optionalBSON = require_optional('bson-ext');
	    if(optionalBSON) {
	      optionalBSON.native = true;
	      return optionalBSON;
	    }
	  } catch(err) {}
	
	  return BSON;
	}
	
	exports.setProperty = setProperty;
	exports.getProperty = getProperty;
	exports.getSingleProperty = getSingleProperty;
	exports.copy = copy;
	exports.debugOptions = debugOptions;
	exports.retrieveBSON = retrieveBSON;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var $exists = __webpack_require__(98);
	var $type = __webpack_require__(142);
	var utils = __webpack_require__(4);
	var MongooseError = __webpack_require__(5);
	var CastError = MongooseError.CastError;
	var ValidatorError = MongooseError.ValidatorError;
	
	/**
	 * SchemaType constructor
	 *
	 * @param {String} path
	 * @param {Object} [options]
	 * @param {String} [instance]
	 * @api public
	 */
	
	function SchemaType(path, options, instance) {
	  this.path = path;
	  this.instance = instance;
	  this.validators = [];
	  this.setters = [];
	  this.getters = [];
	  this.options = options;
	  this._index = null;
	  this.selected;
	
	  for (var i in options) {
	    if (this[i] && typeof this[i] === 'function') {
	      // { unique: true, index: true }
	      if (i === 'index' && this._index) {
	        continue;
	      }
	
	      var opts = Array.isArray(options[i])
	          ? options[i]
	          : [options[i]];
	
	      this[i].apply(this, opts);
	    }
	  }
	}
	
	/**
	 * Sets a default value for this SchemaType.
	 *
	 * ####Example:
	 *
	 *     var schema = new Schema({ n: { type: Number, default: 10 })
	 *     var M = db.model('M', schema)
	 *     var m = new M;
	 *     console.log(m.n) // 10
	 *
	 * Defaults can be either `functions` which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.
	 *
	 * ####Example:
	 *
	 *     // values are cast:
	 *     var schema = new Schema({ aNumber: { type: Number, default: 4.815162342 }})
	 *     var M = db.model('M', schema)
	 *     var m = new M;
	 *     console.log(m.aNumber) // 4.815162342
	 *
	 *     // default unique objects for Mixed types:
	 *     var schema = new Schema({ mixed: Schema.Types.Mixed });
	 *     schema.path('mixed').default(function () {
	 *       return {};
	 *     });
	 *
	 *     // if we don't use a function to return object literals for Mixed defaults,
	 *     // each document will receive a reference to the same object literal creating
	 *     // a "shared" object instance:
	 *     var schema = new Schema({ mixed: Schema.Types.Mixed });
	 *     schema.path('mixed').default({});
	 *     var M = db.model('M', schema);
	 *     var m1 = new M;
	 *     m1.mixed.added = 1;
	 *     console.log(m1.mixed); // { added: 1 }
	 *     var m2 = new M;
	 *     console.log(m2.mixed); // { added: 1 }
	 *
	 * @param {Function|any} val the default value
	 * @return {defaultValue}
	 * @api public
	 */
	
	SchemaType.prototype.default = function(val) {
	  if (arguments.length === 1) {
	    if (val === void 0) {
	      this.defaultValue = void 0;
	      return void 0;
	    }
	    this.defaultValue = val;
	    return this.defaultValue;
	  } else if (arguments.length > 1) {
	    this.defaultValue = utils.args(arguments);
	  }
	  return this.defaultValue;
	};
	
	/**
	 * Declares the index options for this schematype.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ name: { type: String, index: true })
	 *     var s = new Schema({ loc: { type: [Number], index: 'hashed' })
	 *     var s = new Schema({ loc: { type: [Number], index: '2d', sparse: true })
	 *     var s = new Schema({ loc: { type: [Number], index: { type: '2dsphere', sparse: true }})
	 *     var s = new Schema({ date: { type: Date, index: { unique: true, expires: '1d' }})
	 *     Schema.path('my.path').index(true);
	 *     Schema.path('my.date').index({ expires: 60 });
	 *     Schema.path('my.path').index({ unique: true, sparse: true });
	 *
	 * ####NOTE:
	 *
	 * _Indexes are created in the background by default. Specify `background: false` to override._
	 *
	 * [Direction doesn't matter for single key indexes](http://www.mongodb.org/display/DOCS/Indexes#Indexes-CompoundKeysIndexes)
	 *
	 * @param {Object|Boolean|String} options
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.index = function(options) {
	  this._index = options;
	  utils.expires(this._index);
	  return this;
	};
	
	/**
	 * Declares an unique index.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ name: { type: String, unique: true }});
	 *     Schema.path('name').index({ unique: true });
	 *
	 * _NOTE: violating the constraint returns an `E11000` error from MongoDB when saving, not a Mongoose validation error._
	 *
	 * @param {Boolean} bool
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.unique = function(bool) {
	  if (this._index === false) {
	    if (!bool) {
	      return;
	    }
	    throw new Error('Path "' + this.path + '" may not have `index` set to ' +
	      'false and `unique` set to true');
	  }
	  if (this._index == null || this._index === true) {
	    this._index = {};
	  } else if (typeof this._index === 'string') {
	    this._index = {type: this._index};
	  }
	
	  this._index.unique = bool;
	  return this;
	};
	
	/**
	 * Declares a full text index.
	 *
	 * ###Example:
	 *
	 *      var s = new Schema({name : {type: String, text : true })
	 *      Schema.path('name').index({text : true});
	 * @param {Boolean} bool
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.text = function(bool) {
	  if (this._index === null || this._index === undefined ||
	    typeof this._index === 'boolean') {
	    this._index = {};
	  } else if (typeof this._index === 'string') {
	    this._index = {type: this._index};
	  }
	
	  this._index.text = bool;
	  return this;
	};
	
	/**
	 * Declares a sparse index.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ name: { type: String, sparse: true })
	 *     Schema.path('name').index({ sparse: true });
	 *
	 * @param {Boolean} bool
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.sparse = function(bool) {
	  if (this._index === null || this._index === undefined ||
	    typeof this._index === 'boolean') {
	    this._index = {};
	  } else if (typeof this._index === 'string') {
	    this._index = {type: this._index};
	  }
	
	  this._index.sparse = bool;
	  return this;
	};
	
	/**
	 * Adds a setter to this schematype.
	 *
	 * ####Example:
	 *
	 *     function capitalize (val) {
	 *       if (typeof val !== 'string') val = '';
	 *       return val.charAt(0).toUpperCase() + val.substring(1);
	 *     }
	 *
	 *     // defining within the schema
	 *     var s = new Schema({ name: { type: String, set: capitalize }})
	 *
	 *     // or by retreiving its SchemaType
	 *     var s = new Schema({ name: String })
	 *     s.path('name').set(capitalize)
	 *
	 * Setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.
	 *
	 * Suppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise, avenue@q.com can be registered for 2 accounts via avenue@q.com and AvEnUe@Q.CoM.
	 *
	 * You can set up email lower case normalization easily via a Mongoose setter.
	 *
	 *     function toLower (v) {
	 *       return v.toLowerCase();
	 *     }
	 *
	 *     var UserSchema = new Schema({
	 *       email: { type: String, set: toLower }
	 *     })
	 *
	 *     var User = db.model('User', UserSchema)
	 *
	 *     var user = new User({email: 'AVENUE@Q.COM'})
	 *     console.log(user.email); // 'avenue@q.com'
	 *
	 *     // or
	 *     var user = new User
	 *     user.email = 'Avenue@Q.com'
	 *     console.log(user.email) // 'avenue@q.com'
	 *
	 * As you can see above, setters allow you to transform the data before it gets to the raw mongodb document and is set as a value on an actual key.
	 *
	 * _NOTE: we could have also just used the built-in `lowercase: true` SchemaType option instead of defining our own function._
	 *
	 *     new Schema({ email: { type: String, lowercase: true }})
	 *
	 * Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.
	 *
	 *     function inspector (val, schematype) {
	 *       if (schematype.options.required) {
	 *         return schematype.path + ' is required';
	 *       } else {
	 *         return val;
	 *       }
	 *     }
	 *
	 *     var VirusSchema = new Schema({
	 *       name: { type: String, required: true, set: inspector },
	 *       taxonomy: { type: String, set: inspector }
	 *     })
	 *
	 *     var Virus = db.model('Virus', VirusSchema);
	 *     var v = new Virus({ name: 'Parvoviridae', taxonomy: 'Parvovirinae' });
	 *
	 *     console.log(v.name);     // name is required
	 *     console.log(v.taxonomy); // Parvovirinae
	 *
	 * @param {Function} fn
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.set = function(fn) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('A setter must be a function.');
	  }
	  this.setters.push(fn);
	  return this;
	};
	
	/**
	 * Adds a getter to this schematype.
	 *
	 * ####Example:
	 *
	 *     function dob (val) {
	 *       if (!val) return val;
	 *       return (val.getMonth() + 1) + "/" + val.getDate() + "/" + val.getFullYear();
	 *     }
	 *
	 *     // defining within the schema
	 *     var s = new Schema({ born: { type: Date, get: dob })
	 *
	 *     // or by retreiving its SchemaType
	 *     var s = new Schema({ born: Date })
	 *     s.path('born').get(dob)
	 *
	 * Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.
	 *
	 * Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:
	 *
	 *     function obfuscate (cc) {
	 *       return '****-****-****-' + cc.slice(cc.length-4, cc.length);
	 *     }
	 *
	 *     var AccountSchema = new Schema({
	 *       creditCardNumber: { type: String, get: obfuscate }
	 *     });
	 *
	 *     var Account = db.model('Account', AccountSchema);
	 *
	 *     Account.findById(id, function (err, found) {
	 *       console.log(found.creditCardNumber); // '****-****-****-1234'
	 *     });
	 *
	 * Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.
	 *
	 *     function inspector (val, schematype) {
	 *       if (schematype.options.required) {
	 *         return schematype.path + ' is required';
	 *       } else {
	 *         return schematype.path + ' is not';
	 *       }
	 *     }
	 *
	 *     var VirusSchema = new Schema({
	 *       name: { type: String, required: true, get: inspector },
	 *       taxonomy: { type: String, get: inspector }
	 *     })
	 *
	 *     var Virus = db.model('Virus', VirusSchema);
	 *
	 *     Virus.findById(id, function (err, virus) {
	 *       console.log(virus.name);     // name is required
	 *       console.log(virus.taxonomy); // taxonomy is not
	 *     })
	 *
	 * @param {Function} fn
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.get = function(fn) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('A getter must be a function.');
	  }
	  this.getters.push(fn);
	  return this;
	};
	
	/**
	 * Adds validator(s) for this document path.
	 *
	 * Validators always receive the value to validate as their first argument and must return `Boolean`. Returning `false` means validation failed.
	 *
	 * The error message argument is optional. If not passed, the [default generic error message template](#error_messages_MongooseError-messages) will be used.
	 *
	 * ####Examples:
	 *
	 *     // make sure every value is equal to "something"
	 *     function validator (val) {
	 *       return val == 'something';
	 *     }
	 *     new Schema({ name: { type: String, validate: validator }});
	 *
	 *     // with a custom error message
	 *
	 *     var custom = [validator, 'Uh oh, {PATH} does not equal "something".']
	 *     new Schema({ name: { type: String, validate: custom }});
	 *
	 *     // adding many validators at a time
	 *
	 *     var many = [
	 *         { validator: validator, msg: 'uh oh' }
	 *       , { validator: anotherValidator, msg: 'failed' }
	 *     ]
	 *     new Schema({ name: { type: String, validate: many }});
	 *
	 *     // or utilizing SchemaType methods directly:
	 *
	 *     var schema = new Schema({ name: 'string' });
	 *     schema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');
	 *
	 * ####Error message templates:
	 *
	 * From the examples above, you may have noticed that error messages support basic templating. There are a few other template keywords besides `{PATH}` and `{VALUE}` too. To find out more, details are available [here](#error_messages_MongooseError.messages)
	 *
	 * ####Asynchronous validation:
	 *
	 * Passing a validator function that receives two arguments tells mongoose that the validator is an asynchronous validator. The first argument passed to the validator function is the value being validated. The second argument is a callback function that must called when you finish validating the value and passed either `true` or `false` to communicate either success or failure respectively.
	 *
	 *     schema.path('name').validate({
	 *       isAsync: true,
	 *       validator: function (value, respond) {
	 *         doStuff(value, function () {
	 *           ...
	 *           respond(false); // validation failed
	 *         });
	 *       },
	 *       message: 'Custom error message!' // Optional
	 *     });
	 *
	 *     // Can also return a promise
	 *     schema.path('name').validate({
	 *       validator: function (value) {
	 *         return new Promise(function (resolve, reject) {
	 *           resolve(false); // validation failed
	 *         });
	 *       }
	 *     });
	 *
	 * You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.
	 *
	 * Validation occurs `pre('save')` or whenever you manually execute [document#validate](#document_Document-validate).
	 *
	 * If validation fails during `pre('save')` and no callback was passed to receive the error, an `error` event will be emitted on your Models associated db [connection](#connection_Connection), passing the validation error object along.
	 *
	 *     var conn = mongoose.createConnection(..);
	 *     conn.on('error', handleError);
	 *
	 *     var Product = conn.model('Product', yourSchema);
	 *     var dvd = new Product(..);
	 *     dvd.save(); // emits error on the `conn` above
	 *
	 * If you desire handling these errors at the Model level, attach an `error` listener to your Model and the event will instead be emitted there.
	 *
	 *     // registering an error listener on the Model lets us handle errors more locally
	 *     Product.on('error', handleError);
	 *
	 * @param {RegExp|Function|Object} obj validator
	 * @param {String} [errorMsg] optional error message
	 * @param {String} [type] optional validator type
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.validate = function(obj, message, type) {
	  if (typeof obj === 'function' || obj && utils.getFunctionName(obj.constructor) === 'RegExp') {
	    var properties;
	    if (message instanceof Object && !type) {
	      properties = utils.clone(message);
	      if (!properties.message) {
	        properties.message = properties.msg;
	      }
	      properties.validator = obj;
	      properties.type = properties.type || 'user defined';
	    } else {
	      if (!message) {
	        message = MongooseError.messages.general.default;
	      }
	      if (!type) {
	        type = 'user defined';
	      }
	      properties = {message: message, type: type, validator: obj};
	    }
	    this.validators.push(properties);
	    return this;
	  }
	
	  var i,
	      length,
	      arg;
	
	  for (i = 0, length = arguments.length; i < length; i++) {
	    arg = arguments[i];
	    if (!(arg && utils.getFunctionName(arg.constructor) === 'Object')) {
	      var msg = 'Invalid validator. Received (' + typeof arg + ') '
	          + arg
	          + '. See http://mongoosejs.com/docs/api.html#schematype_SchemaType-validate';
	
	      throw new Error(msg);
	    }
	    this.validate(arg.validator, arg);
	  }
	
	  return this;
	};
	
	/**
	 * Adds a required validator to this SchemaType. The validator gets added
	 * to the front of this SchemaType's validators array using `unshift()`.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ born: { type: Date, required: true })
	 *
	 *     // or with custom error message
	 *
	 *     var s = new Schema({ born: { type: Date, required: '{PATH} is required!' })
	 *
	 *     // or with a function
	 *
	 *     var s = new Schema({
	 *       userId: ObjectId,
	 *       username: {
	 *         type: String,
	 *         required: function() { return this.userId != null; }
	 *       }
	 *     })
	 *
	 *     // or with a function and a custom message
	 *     var s = new Schema({
	 *       userId: ObjectId,
	 *       username: {
	 *         type: String,
	 *         required: [
	 *           function() { return this.userId != null; },
	 *           'username is required if id is specified'
	 *         ]
	 *       }
	 *     })
	 *
	 *     // or through the path API
	 *
	 *     Schema.path('name').required(true);
	 *
	 *     // with custom error messaging
	 *
	 *     Schema.path('name').required(true, 'grrr :( ');
	 *
	 *     // or make a path conditionally required based on a function
	 *     var isOver18 = function() { return this.age >= 18; };
	 *     Schema.path('voterRegistrationId').required(isOver18);
	 *
	 * The required validator uses the SchemaType's `checkRequired` function to
	 * determine whether a given value satisfies the required validator. By default,
	 * a value satisfies the required validator if `val != null` (that is, if
	 * the value is not null nor undefined). However, most built-in mongoose schema
	 * types override the default `checkRequired` function:
	 *
	 * @param {Boolean|Function|Object} required enable/disable the validator, or function that returns required boolean, or options object
	 * @param {Boolean|Function} [options.isRequired] enable/disable the validator, or function that returns required boolean
	 * @param {Function} [options.ErrorConstructor] custom error constructor. The constructor receives 1 parameter, an object containing the validator properties.
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @see SchemaArray#checkRequired #schema_array_SchemaArray.checkRequired
	 * @see SchemaBoolean#checkRequired #schema_boolean_SchemaBoolean-checkRequired
	 * @see SchemaBuffer#checkRequired #schema_buffer_SchemaBuffer.schemaName
	 * @see SchemaNumber#checkRequired #schema_number_SchemaNumber-min
	 * @see SchemaObjectId#checkRequired #schema_objectid_ObjectId-auto
	 * @see SchemaString#checkRequired #schema_string_SchemaString-checkRequired
	 * @api public
	 */
	
	SchemaType.prototype.required = function(required, message) {
	  var customOptions = {};
	  if (typeof required === 'object') {
	    customOptions = required;
	    message = customOptions.message || message;
	    required = required.isRequired;
	  }
	
	  if (required === false) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator !== this.requiredValidator;
	    }, this);
	
	    this.isRequired = false;
	    return this;
	  }
	
	  var _this = this;
	  this.isRequired = true;
	
	  this.requiredValidator = function(v) {
	    // in here, `this` refers to the validating document.
	    // no validation when this path wasn't selected in the query.
	    if ('isSelected' in this && !this.isSelected(_this.path) && !this.isModified(_this.path)) {
	      return true;
	    }
	
	    return ((typeof required === 'function') && !required.apply(this)) ||
	        _this.checkRequired(v, this);
	  };
	  this.originalRequiredValue = required;
	
	  if (typeof required === 'string') {
	    message = required;
	    required = undefined;
	  }
	
	  var msg = message || MongooseError.messages.general.required;
	  this.validators.unshift(utils.assign({}, customOptions, {
	    validator: this.requiredValidator,
	    message: msg,
	    type: 'required'
	  }));
	
	  return this;
	};
	
	/**
	 * Gets the default value
	 *
	 * @param {Object} scope the scope which callback are executed
	 * @param {Boolean} init
	 * @api private
	 */
	
	SchemaType.prototype.getDefault = function(scope, init) {
	  var ret = typeof this.defaultValue === 'function'
	      ? this.defaultValue.call(scope)
	      : this.defaultValue;
	
	  if (ret !== null && ret !== undefined) {
	    if (typeof ret === 'object' && (!this.options || !this.options.shared)) {
	      ret = utils.clone(ret, { retainKeyOrder: true });
	    }
	
	    var casted = this.cast(ret, scope, init);
	    if (casted && casted.$isSingleNested) {
	      casted.$parent = scope;
	    }
	    return casted;
	  }
	  return ret;
	};
	
	/*!
	 * Applies setters without casting
	 *
	 * @api private
	 */
	
	SchemaType.prototype._applySetters = function(value, scope, init, priorVal) {
	  var v = value;
	  var setters = this.setters;
	  var len = setters.length;
	  var caster = this.caster;
	
	  while (len--) {
	    v = setters[len].call(scope, v, this);
	  }
	
	  if (Array.isArray(v) && caster && caster.setters) {
	    var newVal = [];
	    for (var i = 0; i < v.length; i++) {
	      newVal.push(caster.applySetters(v[i], scope, init, priorVal));
	    }
	    v = newVal;
	  }
	
	  return v;
	};
	
	/**
	 * Applies setters
	 *
	 * @param {Object} value
	 * @param {Object} scope
	 * @param {Boolean} init
	 * @api private
	 */
	
	SchemaType.prototype.applySetters = function(value, scope, init, priorVal, options) {
	  var v = this._applySetters(value, scope, init, priorVal, options);
	
	  if (v == null) {
	    return v;
	  }
	
	  // do not cast until all setters are applied #665
	  v = this.cast(v, scope, init, priorVal, options);
	
	  return v;
	};
	
	/**
	 * Applies getters to a value
	 *
	 * @param {Object} value
	 * @param {Object} scope
	 * @api private
	 */
	
	SchemaType.prototype.applyGetters = function(value, scope) {
	  var v = value,
	      getters = this.getters,
	      len = getters.length;
	
	  if (!len) {
	    return v;
	  }
	
	  while (len--) {
	    v = getters[len].call(scope, v, this);
	  }
	
	  return v;
	};
	
	/**
	 * Sets default `select()` behavior for this path.
	 *
	 * Set to `true` if this path should always be included in the results, `false` if it should be excluded by default. This setting can be overridden at the query level.
	 *
	 * ####Example:
	 *
	 *     T = db.model('T', new Schema({ x: { type: String, select: true }}));
	 *     T.find(..); // field x will always be selected ..
	 *     // .. unless overridden;
	 *     T.find().select('-x').exec(callback);
	 *
	 * @param {Boolean} val
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaType.prototype.select = function select(val) {
	  this.selected = !!val;
	  return this;
	};
	
	/**
	 * Performs a validation of `value` using the validators declared for this SchemaType.
	 *
	 * @param {any} value
	 * @param {Function} callback
	 * @param {Object} scope
	 * @api private
	 */
	
	SchemaType.prototype.doValidate = function(value, fn, scope) {
	  var err = false;
	  var path = this.path;
	  var count = this.validators.length;
	
	  if (!count) {
	    return fn(null);
	  }
	
	  var validate = function(ok, validatorProperties) {
	    if (err) {
	      return;
	    }
	    if (ok === undefined || ok) {
	      --count || fn(null);
	    } else {
	      var ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
	      err = new ErrorConstructor(validatorProperties);
	      err.$isValidatorError = true;
	      fn(err);
	    }
	  };
	
	  var _this = this;
	  this.validators.forEach(function(v) {
	    if (err) {
	      return;
	    }
	
	    var validator = v.validator;
	    var ok;
	
	    var validatorProperties = utils.clone(v);
	    validatorProperties.path = path;
	    validatorProperties.value = value;
	
	    if (validator instanceof RegExp) {
	      validate(validator.test(value), validatorProperties);
	    } else if (typeof validator === 'function') {
	      if (value === undefined && validator !== _this.requiredValidator) {
	        validate(true, validatorProperties);
	        return;
	      }
	      if (validatorProperties.isAsync) {
	        asyncValidate(validator, scope, value, validatorProperties, validate);
	      } else if (validator.length === 2 && !('isAsync' in validatorProperties)) {
	        legacyAsyncValidate(validator, scope, value, validatorProperties,
	          validate);
	      } else {
	        try {
	          ok = validator.call(scope, value);
	        } catch (error) {
	          ok = false;
	          validatorProperties.reason = error;
	        }
	        if (ok && typeof ok.then === 'function') {
	          ok.then(
	            function(ok) { validate(ok, validatorProperties); },
	            function(error) {
	              validatorProperties.reason = error;
	              ok = false;
	              validate(ok, validatorProperties);
	            });
	        } else {
	          validate(ok, validatorProperties);
	        }
	      }
	    }
	  });
	};
	
	/*!
	 * Handle async validators
	 */
	
	function asyncValidate(validator, scope, value, props, cb) {
	  var called = false;
	  var returnVal = validator.call(scope, value, function(ok, customMsg) {
	    if (called) {
	      return;
	    }
	    called = true;
	    if (typeof returnVal === 'boolean') {
	      return;
	    }
	    if (customMsg) {
	      props.message = customMsg;
	    }
	    cb(ok, props);
	  });
	  if (typeof returnVal === 'boolean') {
	    called = true;
	    cb(returnVal, props);
	  } else if (returnVal && typeof returnVal.then === 'function') {
	    // Promise
	    returnVal.then(
	      function(ok) {
	        if (called) {
	          return;
	        }
	        called = true;
	        cb(ok, props);
	      },
	      function(error) {
	        if (called) {
	          return;
	        }
	        called = true;
	
	        props.reason = error;
	        cb(false, props);
	      });
	  }
	}
	
	var legacyAsyncValidate = __webpack_require__(1).deprecate(asyncValidate,
	  'Implicit async custom validators (custom validators that take 2 ' +
	  'arguments) are deprecated in mongoose >= 4.9.0. See ' +
	  'http://mongoosejs.com/docs/validation.html#async-custom-validators for ' +
	  'more info.');
	
	/**
	 * Performs a validation of `value` using the validators declared for this SchemaType.
	 *
	 * ####Note:
	 *
	 * This method ignores the asynchronous validators.
	 *
	 * @param {any} value
	 * @param {Object} scope
	 * @return {MongooseError|undefined}
	 * @api private
	 */
	
	SchemaType.prototype.doValidateSync = function(value, scope) {
	  var err = null,
	      path = this.path,
	      count = this.validators.length;
	
	  if (!count) {
	    return null;
	  }
	
	  var validate = function(ok, validatorProperties) {
	    if (err) {
	      return;
	    }
	    if (ok !== undefined && !ok) {
	      var ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
	      err = new ErrorConstructor(validatorProperties);
	      err.$isValidatorError = true;
	    }
	  };
	
	  var validators = this.validators;
	  if (value === void 0) {
	    if (this.validators.length > 0 && this.validators[0].type === 'required') {
	      validators = [this.validators[0]];
	    } else {
	      return null;
	    }
	  }
	
	  validators.forEach(function(v) {
	    if (err) {
	      return;
	    }
	
	    var validator = v.validator;
	    var validatorProperties = utils.clone(v);
	    validatorProperties.path = path;
	    validatorProperties.value = value;
	    var ok;
	
	    if (validator instanceof RegExp) {
	      validate(validator.test(value), validatorProperties);
	    } else if (typeof validator === 'function') {
	      // if not async validators
	      if (validator.length !== 2 && !validatorProperties.isAsync) {
	        try {
	          ok = validator.call(scope, value);
	        } catch (error) {
	          ok = false;
	          validatorProperties.reason = error;
	        }
	        validate(ok, validatorProperties);
	      }
	    }
	  });
	
	  return err;
	};
	
	/**
	 * Determines if value is a valid Reference.
	 *
	 * @param {SchemaType} self
	 * @param {Object} value
	 * @param {Document} doc
	 * @param {Boolean} init
	 * @return {Boolean}
	 * @api private
	 */
	
	SchemaType._isRef = function(self, value, doc, init) {
	  // fast path
	  var ref = init && self.options && self.options.ref;
	
	  if (!ref && doc && doc.$__fullPath) {
	    // checks for
	    // - this populated with adhoc model and no ref was set in schema OR
	    // - setting / pushing values after population
	    var path = doc.$__fullPath(self.path);
	    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
	    ref = owner.populated(path);
	  }
	
	  if (ref) {
	    if (value == null) {
	      return true;
	    }
	    if (!Buffer.isBuffer(value) &&  // buffers are objects too
	        value._bsontype !== 'Binary' // raw binary value from the db
	        && utils.isObject(value)    // might have deselected _id in population query
	    ) {
	      return true;
	    }
	  }
	
	  return false;
	};
	
	/*!
	 * ignore
	 */
	
	function handleSingle(val) {
	  return this.castForQuery(val);
	}
	
	/*!
	 * ignore
	 */
	
	function handleArray(val) {
	  var _this = this;
	  if (!Array.isArray(val)) {
	    return [this.castForQuery(val)];
	  }
	  return val.map(function(m) {
	    return _this.castForQuery(m);
	  });
	}
	
	/*!
	 * ignore
	 */
	
	SchemaType.prototype.$conditionalHandlers = {
	  $all: handleArray,
	  $eq: handleSingle,
	  $in: handleArray,
	  $ne: handleSingle,
	  $nin: handleArray,
	  $exists: $exists,
	  $type: $type
	};
	
	/*!
	 * Wraps `castForQuery` to handle context
	 */
	
	SchemaType.prototype.castForQueryWrapper = function(params) {
	  this.$$context = params.context;
	  if ('$conditional' in params) {
	    return this.castForQuery(params.$conditional, params.val);
	  }
	  if (params.$skipQueryCastForUpdate) {
	    return this._castForQuery(params.val);
	  }
	  return this.castForQuery(params.val);
	};
	
	/**
	 * Cast the given value with the given optional query operator.
	 *
	 * @param {String} [$conditional] query operator, like `$eq` or `$in`
	 * @param {any} val
	 * @api private
	 */
	
	SchemaType.prototype.castForQuery = function($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	    if (!handler) {
	      throw new Error('Can\'t use ' + $conditional);
	    }
	    return handler.call(this, val);
	  }
	  val = $conditional;
	  return this._castForQuery(val);
	};
	
	/*!
	 * Internal switch for runSetters
	 *
	 * @api private
	 */
	
	SchemaType.prototype._castForQuery = function(val) {
	  var runSettersOnQuery = false;
	  if (this.$$context &&
	      this.$$context.options &&
	      'runSettersOnQuery' in this.$$context.options) {
	    runSettersOnQuery = this.$$context.options.runSettersOnQuery;
	  } else if (this.options && 'runSettersOnQuery' in this.options) {
	    runSettersOnQuery = this.options.runSettersOnQuery;
	  }
	
	  if (runSettersOnQuery) {
	    return this.applySetters(val, this.$$context);
	  }
	  return this.cast(val);
	};
	
	/**
	 * Default check for if this path satisfies the `required` validator.
	 *
	 * @param {any} val
	 * @api private
	 */
	
	SchemaType.prototype.checkRequired = function(val) {
	  return val != null;
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = exports = SchemaType;
	
	exports.CastError = CastError;
	
	exports.ValidatorError = ValidatorError;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	var f = __webpack_require__(1).format;
	
	var Define = function(name, object, stream) {
	  this.name = name;
	  this.object = object;
	  this.stream = typeof stream == 'boolean' ? stream : false;
	  this.instrumentations = {};
	}
	
	Define.prototype.classMethod = function(name, options) {
	  var keys = Object.keys(options).sort();
	  var key = generateKey(keys, options);
	
	  // Add a list of instrumentations
	  if(this.instrumentations[key] == null) {
	    this.instrumentations[key] = {
	      methods: [], options: options
	    }
	  }
	
	  // Push to list of method for this instrumentation
	  this.instrumentations[key].methods.push(name);
	}
	
	var generateKey = function(keys, options) {
	  var parts = [];
	  for(var i = 0; i < keys.length; i++) {
	    parts.push(f('%s=%s', keys[i], options[keys[i]]));
	  }
	
	  return parts.join();
	}
	
	Define.prototype.staticMethod = function(name, options) {
	  options.static = true;
	  var keys = Object.keys(options).sort();
	  var key = generateKey(keys, options);
	
	  // Add a list of instrumentations
	  if(this.instrumentations[key] == null) {
	    this.instrumentations[key] = {
	      methods: [], options: options
	    }
	  }
	
	  // Push to list of method for this instrumentation
	  this.instrumentations[key].methods.push(name);
	}
	
	Define.prototype.generate = function() {
	  // Generate the return object
	  var object = {
	    name: this.name, obj: this.object, stream: this.stream,
	    instrumentations: []
	  }
	
	  for(var name in this.instrumentations) {
	    object.instrumentations.push(this.instrumentations[name]);
	  }
	
	  return object;
	}
	
	module.exports = Define;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MPromise = __webpack_require__(229);
	
	/**
	 * Helper for multiplexing promise implementations
	 *
	 * @api private
	 */
	
	var Promise = {
	  _promise: MPromise
	};
	
	/**
	 * Get the current promise constructor
	 *
	 * @api private
	 */
	Promise.get = function() {
	  return Promise._promise;
	};
	
	/**
	 * Set the current promise constructor
	 *
	 * @api private
	 */
	
	Promise.set = function(lib) {
	  if (lib === MPromise) {
	    return Promise.reset();
	  }
	  Promise._promise = __webpack_require__(208);
	  Promise._promise.use(lib);
	  __webpack_require__(104).Promise = Promise._promise.ES6;
	};
	
	/**
	 * Resets to using mpromise
	 *
	 * @api private
	 */
	
	Promise.reset = function() {
	  Promise._promise = MPromise;
	};
	
	module.exports = Promise;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict"
	
	var os = __webpack_require__(49),
	  f = __webpack_require__(1).format;
	
	/**
	 * Emit event if it exists
	 * @method
	 */
	function emitSDAMEvent(self, event, description) {
	  if(self.listeners(event).length > 0) {
	    self.emit(event, description);
	  }
	}
	
	// Get package.json variable
	var driverVersion = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../../package.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).version;
	var nodejsversion = f('Node.js %s, %s', process.version, os.endianness());
	var type = os.type();
	var name = process.platform;
	var architecture = process.arch;
	var release = os.release();
	
	function createClientInfo(options) {
	  // Build default client information
	  var clientInfo = options.clientInfo ? clone(options.clientInfo) : {
	    driver: {
	      name: "nodejs-core",
	      version: driverVersion
	    },
	    os: {
	      type: type,
	      name: name,
	      architecture: architecture,
	      version: release
	    }
	  }
	
	  // Is platform specified
	  if(clientInfo.platform && clientInfo.platform.indexOf('mongodb-core') == -1) {
	    clientInfo.platform = f('%s, mongodb-core: %s', clientInfo.platform, driverVersion);
	  } else if(!clientInfo.platform){
	    clientInfo.platform = nodejsversion;
	  }
	
	  // Do we have an application specific string
	  if(options.appname) {
	    // Cut at 128 bytes
	    var buffer = new Buffer(options.appname);
	    // Return the truncated appname
	    var appname = buffer.length > 128 ? buffer.slice(0, 128).toString('utf8') : options.appname;
	    // Add to the clientInfo
	    clientInfo.application = { name: appname };
	  }
	
	  return clientInfo;
	}
	
	function clone(object) {
	  return JSON.parse(JSON.stringify(object));
	}
	
	var getPreviousDescription = function(self) {
	  if(!self.s.serverDescription) {
	    self.s.serverDescription = {
	      address: self.name,
	      arbiters: [], hosts: [], passives: [], type: 'Unknown'
	    }
	  }
	
	  return self.s.serverDescription;
	}
	
	var emitServerDescriptionChanged = function(self, description) {
	  if(self.listeners('serverDescriptionChanged').length > 0) {
	    // Emit the server description changed events
	    self.emit('serverDescriptionChanged', {
	      topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.id, address: self.name,
	      previousDescription: getPreviousDescription(self),
	      newDescription: description
	    });
	
	    self.s.serverDescription = description;
	  }
	}
	
	var getPreviousTopologyDescription = function(self) {
	  if(!self.s.topologyDescription) {
	    self.s.topologyDescription = {
	      topologyType: 'Unknown',
	      servers: [{
	        address: self.name, arbiters: [], hosts: [], passives: [], type: 'Unknown'
	      }]
	    }
	  }
	
	  return self.s.topologyDescription;
	}
	
	var emitTopologyDescriptionChanged = function(self, description) {
	  if(self.listeners('topologyDescriptionChanged').length > 0) {
	    // Emit the server description changed events
	    self.emit('topologyDescriptionChanged', {
	      topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.id, address: self.name,
	      previousDescription: getPreviousTopologyDescription(self),
	      newDescription: description
	    });
	
	    self.s.serverDescription = description;
	  }
	}
	
	var changedIsMaster = function(self, currentIsmaster, ismaster) {
	  var currentType = getTopologyType(self, currentIsmaster);
	  var newType = getTopologyType(self, ismaster);
	  if(newType != currentType) return true;
	  return false;
	}
	
	var getTopologyType = function(self, ismaster) {
	  if(!ismaster) {
	    ismaster = self.ismaster;
	  }
	
	  if(!ismaster) return 'Unknown';
	  if(ismaster.ismaster && ismaster.msg == 'isdbgrid') return 'Mongos';
	  if(ismaster.ismaster && !ismaster.hosts) return 'Standalone';
	  if(ismaster.ismaster) return 'RSPrimary';
	  if(ismaster.secondary) return 'RSSecondary';
	  if(ismaster.arbiterOnly) return 'RSArbiter';
	  return 'Unknown';
	}
	
	var inquireServerState = function(self) {
	  return function(callback) {
	    if(self.s.state == 'destroyed') return;
	    // Record response time
	    var start = new Date().getTime();
	
	    // emitSDAMEvent
	    emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: self.name });
	
	    // Attempt to execute ismaster command
	    self.command('admin.$cmd', { ismaster:true },  { monitoring:true }, function(err, r) {
	      if(!err) {
	        // Legacy event sender
	        self.emit('ismaster', r, self);
	
	        // Calculate latencyMS
	        var latencyMS = new Date().getTime() - start;
	
	        // Server heart beat event
	        emitSDAMEvent(self, 'serverHeartbeatSucceeded', { durationMS: latencyMS, reply: r.result, connectionId: self.name });
	
	        // Did the server change
	        if(changedIsMaster(self, self.s.ismaster, r.result)) {
	          // Emit server description changed if something listening
	          emitServerDescriptionChanged(self, {
	            address: self.name, arbiters: [], hosts: [], passives: [], type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)
	          });
	        }
	
	        // Updat ismaster view
	        self.s.ismaster = r.result;
	
	        // Set server response time
	        self.s.isMasterLatencyMS = latencyMS;
	      } else {
	        emitSDAMEvent(self, 'serverHeartbeatFailed', { durationMS: latencyMS, failure: err, connectionId: self.name });
	      }
	
	      // Peforming an ismaster monitoring callback operation
	      if(typeof callback == 'function') {
	        return callback(err, r);
	      }
	
	      // Perform another sweep
	      self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);
	    });
	  };
	}
	
	//
	// Clone the options
	var cloneOptions = function(options) {
	  var opts = {};
	  for(var name in options) {
	    opts[name] = options[name];
	  }
	  return opts;
	}
	
	function Interval(fn, time) {
	  var timer = false;
	
	  this.start = function () {
	    if (!this.isRunning()) {
	      timer = setInterval(fn, time);
	    }
	
	    return this;
	  };
	
	  this.stop = function () {
	    clearInterval(timer);
	    timer = false;
	    return this;
	  };
	
	  this.isRunning = function () {
	    return timer !== false;
	  };
	}
	
	function Timeout(fn, time) {
	  var timer = false;
	
	  this.start = function () {
	    if (!this.isRunning()) {
	      timer = setTimeout(fn, time);
	    }
	    return this;
	  };
	
	  this.stop = function () {
	    clearTimeout(timer);
	    timer = false;
	    return this;
	  };
	
	  this.isRunning = function () {
	    if(timer && timer._called) return false;
	    return timer !== false;
	  };
	}
	
	function diff(previous, current) {
	  // Difference document
	  var diff = {
	    servers: []
	  }
	
	  // Previous entry
	  if(!previous) {
	    previous = { servers: [] };
	  }
	
	  // Check if we have any previous servers missing in the current ones
	  for(var i = 0; i < previous.servers.length; i++) {
	    var found = false;
	
	    for(var j = 0; j < current.servers.length; j++) {
	      if(current.servers[j].address.toLowerCase()
	        === previous.servers[i].address.toLowerCase()) {
	          found = true;
	          break;
	        }
	    }
	
	    if(!found) {
	      // Add to the diff
	      diff.servers.push({
	        address: previous.servers[i].address,
	        from: previous.servers[i].type,
	        to: 'Unknown',
	      });
	    }
	  }
	
	  // Check if there are any severs that don't exist
	  for(var j = 0; j < current.servers.length; j++) {
	    var found = false;
	
	    // Go over all the previous servers
	    for(var i = 0; i < previous.servers.length; i++) {
	      if(previous.servers[i].address.toLowerCase()
	        === current.servers[j].address.toLowerCase()) {
	        found = true;
	        break;
	      }
	    }
	
	    // Add the server to the diff
	    if(!found) {
	      diff.servers.push({
	        address: current.servers[j].address,
	        from: 'Unknown',
	        to: current.servers[j].type,
	      });
	    }
	  }
	
	  // Got through all the servers
	  for(var i = 0; i < previous.servers.length; i++) {
	    var prevServer = previous.servers[i];
	
	    // Go through all current servers
	    for(var j = 0; j < current.servers.length; j++) {
	      var currServer = current.servers[j];
	
	      // Matching server
	      if(prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {
	        // We had a change in state
	        if(prevServer.type != currServer.type) {
	          diff.servers.push({
	            address: prevServer.address,
	            from: prevServer.type,
	            to: currServer.type
	          });
	        }
	      }
	    }
	  }
	
	  // Return difference
	  return diff;
	}
	
	module.exports.inquireServerState = inquireServerState
	module.exports.getTopologyType = getTopologyType;
	module.exports.emitServerDescriptionChanged = emitServerDescriptionChanged;
	module.exports.emitTopologyDescriptionChanged = emitTopologyDescriptionChanged;
	module.exports.cloneOptions = cloneOptions;
	module.exports.createClientInfo = createClientInfo;
	module.exports.clone = clone;
	module.exports.diff = diff;
	module.exports.Interval = Interval;
	module.exports.Timeout = Timeout;


/***/ }),
/* 16 */
/***/ (function(module, exports) {

	"use strict";
	
	/**
	 * @fileOverview The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is
	 * used to construct connections.
	 *
	 * @example
	 * var Db = require('mongodb').Db,
	 *   ReplSet = require('mongodb').ReplSet,
	 *   Server = require('mongodb').Server,
	 *   ReadPreference = require('mongodb').ReadPreference,
	 *   test = require('assert');
	 * // Connect using ReplSet
	 * var server = new Server('localhost', 27017);
	 * var db = new Db('test', new ReplSet([server]));
	 * db.open(function(err, db) {
	 *   test.equal(null, err);
	 *   // Perform a read
	 *   var cursor = db.collection('t').find({});
	 *   cursor.setReadPreference(ReadPreference.PRIMARY);
	 *   cursor.toArray(function(err, docs) {
	 *     test.equal(null, err);
	 *     db.close();
	 *   });
	 * });
	 */
	
	/**
	 * Creates a new ReadPreference instance
	 *
	 * Read Preferences
	 *  - **ReadPreference.PRIMARY**, Read from primary only. All operations produce an error (throw an exception where applicable) if primary is unavailable. Cannot be combined with tags (This is the default.).
	 *  - **ReadPreference.PRIMARY_PREFERRED**, Read from primary if available, otherwise a secondary.
	 *  - **ReadPreference.SECONDARY**, Read from secondary if available, otherwise error.
	 *  - **ReadPreference.SECONDARY_PREFERRED**, Read from a secondary if available, otherwise read from the primary.
	 *  - **ReadPreference.NEAREST**, All modes read from among the nearest candidates, but unlike other modes, NEAREST will include both the primary and all secondaries in the random selection.
	 *
	 * @class
	 * @param {string} mode The ReadPreference mode as listed above.
	 * @param {array|object} tags An object representing read preference tags.
	 * @param {object} [options] Additional read preference options
	 * @param {number} [options.maxStalenessSeconds] Max Secondary Read Stalleness in Seconds
	 * @return {ReadPreference} a ReadPreference instance.
	 */
	var ReadPreference = function(mode, tags, options) {
	  if(!(this instanceof ReadPreference)) {
	    return new ReadPreference(mode, tags, options);
	  }
	
	  this._type = 'ReadPreference';
	  this.mode = mode;
	  this.tags = tags;
	  this.options =  options;
	
	  // If no tags were passed in
	  if(tags && typeof tags == 'object' && !Array.isArray(tags)) {
	    if(tags.maxStalenessSeconds) {
	      this.options = tags;
	      this.tags = null;
	    }
	  }
	
	  // Add the maxStalenessSeconds value to the read Preference
	  if(this.options && this.options.maxStalenessSeconds) {
	    this.maxStalenessSeconds = this.options.maxStalenessSeconds;
	  }
	}
	
	/**
	 * Validate if a mode is legal
	 *
	 * @method
	 * @param {string} mode The string representing the read preference mode.
	 * @return {boolean}
	 */
	ReadPreference.isValid = function(_mode) {
	  return (_mode == ReadPreference.PRIMARY || _mode == ReadPreference.PRIMARY_PREFERRED
	    || _mode == ReadPreference.SECONDARY || _mode == ReadPreference.SECONDARY_PREFERRED
	    || _mode == ReadPreference.NEAREST
	    || _mode == true || _mode == false || _mode == null);
	}
	
	/**
	 * Validate if a mode is legal
	 *
	 * @method
	 * @param {string} mode The string representing the read preference mode.
	 * @return {boolean}
	 */
	ReadPreference.prototype.isValid = function(mode) {
	  var _mode = typeof mode == 'string' ? mode : this.mode;
	  return ReadPreference.isValid(_mode);
	}
	
	/**
	 * @ignore
	 */
	ReadPreference.prototype.toObject = function() {
	  var object = {mode:this.mode};
	
	  if(this.tags != null) {
	    object['tags'] = this.tags;
	  }
	
	  if(this.maxStalenessSeconds) {
	    object['maxStalenessSeconds'] = this.maxStalenessSeconds;
	  }
	
	  return object;
	}
	
	/**
	 * @ignore
	 */
	ReadPreference.prototype.toJSON = function() {
	  return this.toObject();
	}
	
	/**
	 * @ignore
	 */
	ReadPreference.PRIMARY = 'primary';
	ReadPreference.PRIMARY_PREFERRED = 'primaryPreferred';
	ReadPreference.SECONDARY = 'secondary';
	ReadPreference.SECONDARY_PREFERRED = 'secondaryPreferred';
	ReadPreference.NEAREST = 'nearest'
	
	/**
	 * @ignore
	 */
	module.exports = ReadPreference;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var inherits = __webpack_require__(1).inherits
	  , f = __webpack_require__(1).format
	  , formattedOrderClause = __webpack_require__(2).formattedOrderClause
	  , handleCallback = __webpack_require__(2).handleCallback
	  , ReadPreference = __webpack_require__(16)
	  , MongoError = __webpack_require__(3).MongoError
	  , Readable = __webpack_require__(18).Readable || __webpack_require__(70).Readable
	  , Define = __webpack_require__(13)
	  , CoreCursor = __webpack_require__(3).Cursor
	  , Map = __webpack_require__(3).BSON.Map
	  , CoreReadPreference = __webpack_require__(3).ReadPreference;
	
	/**
	 * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB
	 * allowing for iteration over the results returned from the underlying query. It supports
	 * one by one document iteration, conversion to an array or can be iterated as a Node 0.10.X
	 * or higher stream
	 *
	 * **CURSORS Cannot directly be instantiated**
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Create a collection we want to drop later
	 *   var col = db.collection('createIndexExample1');
	 *   // Insert a bunch of documents
	 *   col.insert([{a:1, b:1}
	 *     , {a:2, b:2}, {a:3, b:3}
	 *     , {a:4, b:4}], {w:1}, function(err, result) {
	 *     test.equal(null, err);
	 *
	 *     // Show that duplicate records got dropped
	 *     col.find({}).toArray(function(err, items) {
	 *       test.equal(null, err);
	 *       test.equal(4, items.length);
	 *       db.close();
	 *     });
	 *   });
	 * });
	 */
	
	/**
	 * Namespace provided by the mongodb-core and node.js
	 * @external CoreCursor
	 * @external Readable
	 */
	
	// Flags allowed for cursor
	var flags = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];
	var fields = ['numberOfRetries', 'tailableRetryInterval'];
	var push = Array.prototype.push;
	
	/**
	 * Creates a new Cursor instance (INTERNAL TYPE, do not instantiate directly)
	 * @class Cursor
	 * @extends external:CoreCursor
	 * @extends external:Readable
	 * @property {string} sortValue Cursor query sort setting.
	 * @property {boolean} timeout Is Cursor able to time out.
	 * @property {ReadPreference} readPreference Get cursor ReadPreference.
	 * @fires Cursor#data
	 * @fires Cursor#end
	 * @fires Cursor#close
	 * @fires Cursor#readable
	 * @return {Cursor} a Cursor instance.
	 * @example
	 * Cursor cursor options.
	 *
	 * collection.find({}).project({a:1})                             // Create a projection of field a
	 * collection.find({}).skip(1).limit(10)                          // Skip 1 and limit 10
	 * collection.find({}).batchSize(5)                               // Set batchSize on cursor to 5
	 * collection.find({}).filter({a:1})                              // Set query on the cursor
	 * collection.find({}).comment('add a comment')                   // Add a comment to the query, allowing to correlate queries
	 * collection.find({}).addCursorFlag('tailable', true)            // Set cursor as tailable
	 * collection.find({}).addCursorFlag('oplogReplay', true)         // Set cursor as oplogReplay
	 * collection.find({}).addCursorFlag('noCursorTimeout', true)     // Set cursor as noCursorTimeout
	 * collection.find({}).addCursorFlag('awaitData', true)           // Set cursor as awaitData
	 * collection.find({}).addCursorFlag('partial', true)             // Set cursor as partial
	 * collection.find({}).addQueryModifier('$orderby', {a:1})        // Set $orderby {a:1}
	 * collection.find({}).max(10)                                    // Set the cursor maxScan
	 * collection.find({}).maxScan(10)                                // Set the cursor maxScan
	 * collection.find({}).maxTimeMS(1000)                            // Set the cursor maxTimeMS
	 * collection.find({}).min(100)                                   // Set the cursor min
	 * collection.find({}).returnKey(10)                              // Set the cursor returnKey
	 * collection.find({}).setReadPreference(ReadPreference.PRIMARY)  // Set the cursor readPreference
	 * collection.find({}).showRecordId(true)                         // Set the cursor showRecordId
	 * collection.find({}).snapshot(true)                             // Set the cursor snapshot
	 * collection.find({}).sort([['a', 1]])                           // Sets the sort order of the cursor query
	 * collection.find({}).hint('a_1')                                // Set the cursor hint
	 *
	 * All options are chainable, so one can do the following.
	 *
	 * collection.find({}).maxTimeMS(1000).maxScan(100).skip(1).toArray(..)
	 */
	var Cursor = function(bson, ns, cmd, options, topology, topologyOptions) {
	  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));
	  var self = this;
	  var state = Cursor.INIT;
	  var streamOptions = {};
	
	  // Tailable cursor options
	  var numberOfRetries = options.numberOfRetries || 5;
	  var tailableRetryInterval = options.tailableRetryInterval || 500;
	  var currentNumberOfRetries = numberOfRetries;
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(10).Promise;
	  }
	
	  // Set up
	  Readable.call(this, {objectMode: true});
	
	  // Internal cursor state
	  this.s = {
	    // Tailable cursor options
	      numberOfRetries: numberOfRetries
	    , tailableRetryInterval: tailableRetryInterval
	    , currentNumberOfRetries: currentNumberOfRetries
	    // State
	    , state: state
	    // Stream options
	    , streamOptions: streamOptions
	    // BSON
	    , bson: bson
	    // Namespace
	    , ns: ns
	    // Command
	    , cmd: cmd
	    // Options
	    , options: options
	    // Topology
	    , topology: topology
	    // Topology options
	    , topologyOptions: topologyOptions
	    // Promise library
	    , promiseLibrary: promiseLibrary
	    // Current doc
	    , currentDoc: null
	  }
	
	  // Translate correctly
	  if(self.s.options.noCursorTimeout == true) {
	    self.addCursorFlag('noCursorTimeout', true);
	  }
	
	  // Set the sort value
	  this.sortValue = self.s.cmd.sort;
	
	  // Get the batchSize
	  var batchSize = cmd.cursor && cmd.cursor.batchSize
	    ? cmd.cursor && cmd.cursor.batchSize
	    : (options.cursor && options.cursor.batchSize ? options.cursor.batchSize : 1000);
	
	  // Set the batchSize
	  this.setCursorBatchSize(batchSize);
	}
	
	/**
	 * Cursor stream data event, fired for each document in the cursor.
	 *
	 * @event Cursor#data
	 * @type {object}
	 */
	
	/**
	 * Cursor stream end event
	 *
	 * @event Cursor#end
	 * @type {null}
	 */
	
	/**
	 * Cursor stream close event
	 *
	 * @event Cursor#close
	 * @type {null}
	 */
	
	/**
	 * Cursor stream readable event
	 *
	 * @event Cursor#readable
	 * @type {null}
	 */
	
	// Inherit from Readable
	inherits(Cursor, Readable);
	
	// Map core cursor _next method so we can apply mapping
	CoreCursor.prototype._next = CoreCursor.prototype.next;
	
	for(var name in CoreCursor.prototype) {
	  Cursor.prototype[name] = CoreCursor.prototype[name];
	}
	
	var define = Cursor.define = new Define('Cursor', Cursor, true);
	
	/**
	 * Check if there is any document still available in the cursor
	 * @method
	 * @param {Cursor~resultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	Cursor.prototype.hasNext = function(callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') {
	    if(self.s.currentDoc){
	      return callback(null, true);
	    } else {
	      return nextObject(self, function(err, doc) {
	        if(!doc) return callback(null, false);
	        self.s.currentDoc = doc;
	        callback(null, true);
	      });
	    }
	  }
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    if(self.s.currentDoc){
	      resolve(true);
	    } else {
	      nextObject(self, function(err, doc) {
	        if(self.s.state == Cursor.CLOSED || self.isDead()) return resolve(false);
	        if(err) return reject(err);
	        if(!doc) return resolve(false);
	        self.s.currentDoc = doc;
	        resolve(true);
	      });
	    }
	  });
	}
	
	define.classMethod('hasNext', {callback: true, promise:true});
	
	/**
	 * Get the next available document from the cursor, returns null if no more documents are available.
	 * @method
	 * @param {Cursor~resultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	Cursor.prototype.next = function(callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') {
	    // Return the currentDoc if someone called hasNext first
	    if(self.s.currentDoc) {
	      var doc = self.s.currentDoc;
	      self.s.currentDoc = null;
	      return callback(null, doc);
	    }
	
	    // Return the next object
	    return nextObject(self, callback)
	  }
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    // Return the currentDoc if someone called hasNext first
	    if(self.s.currentDoc) {
	      var doc = self.s.currentDoc;
	      self.s.currentDoc = null;
	      return resolve(doc);
	    }
	
	    nextObject(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('next', {callback: true, promise:true});
	
	/**
	 * Set the cursor query
	 * @method
	 * @param {object} filter The filter object used for the cursor.
	 * @return {Cursor}
	 */
	Cursor.prototype.filter = function(filter) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.query = filter;
	  return this;
	}
	
	define.classMethod('filter', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the cursor maxScan
	 * @method
	 * @param {object} maxScan Constrains the query to only scan the specified number of documents when fulfilling the query
	 * @return {Cursor}
	 */
	Cursor.prototype.maxScan = function(maxScan) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.maxScan = maxScan;
	  return this;
	}
	
	define.classMethod('maxScan', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the cursor hint
	 * @method
	 * @param {object} hint If specified, then the query system will only consider plans using the hinted index.
	 * @return {Cursor}
	 */
	Cursor.prototype.hint = function(hint) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.hint = hint;
	  return this;
	}
	
	define.classMethod('hint', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the cursor min
	 * @method
	 * @param {object} min Specify a $min value to specify the inclusive lower bound for a specific index in order to constrain the results of find(). The $min specifies the lower bound for all keys of a specific index in order.
	 * @return {Cursor}
	 */
	Cursor.prototype.min = function(min) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.min = min;
	  return this;
	}
	
	define.classMethod('min', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the cursor max
	 * @method
	 * @param {object} max Specify a $max value to specify the exclusive upper bound for a specific index in order to constrain the results of find(). The $max specifies the upper bound for all keys of a specific index in order.
	 * @return {Cursor}
	 */
	Cursor.prototype.max = function(max) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.max = max;
	  return this;
	}
	
	define.classMethod('max', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the cursor returnKey
	 * @method
	 * @param {object} returnKey Only return the index field or fields for the results of the query. If $returnKey is set to true and the query does not use an index to perform the read operation, the returned documents will not contain any fields. Use one of the following forms:
	 * @return {Cursor}
	 */
	Cursor.prototype.returnKey = function(value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.returnKey = value;
	  return this;
	}
	
	define.classMethod('returnKey', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the cursor showRecordId
	 * @method
	 * @param {object} showRecordId The $showDiskLoc option has now been deprecated and replaced with the showRecordId field. $showDiskLoc will still be accepted for OP_QUERY stye find.
	 * @return {Cursor}
	 */
	Cursor.prototype.showRecordId = function(value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.showDiskLoc = value;
	  return this;
	}
	
	define.classMethod('showRecordId', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the cursor snapshot
	 * @method
	 * @param {object} snapshot The $snapshot operator prevents the cursor from returning a document more than once because an intervening write operation results in a move of the document.
	 * @return {Cursor}
	 */
	Cursor.prototype.snapshot = function(value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.snapshot = value;
	  return this;
	}
	
	define.classMethod('snapshot', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set a node.js specific cursor option
	 * @method
	 * @param {string} field The cursor option to set ['numberOfRetries', 'tailableRetryInterval'].
	 * @param {object} value The field value.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.setCursorOption = function(field, value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  if(fields.indexOf(field) == -1) throw MongoError.create({message: f("option %s not a supported option %s", field, fields), driver:true });
	  this.s[field] = value;
	  if(field == 'numberOfRetries')
	    this.s.currentNumberOfRetries = value;
	  return this;
	}
	
	define.classMethod('setCursorOption', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Add a cursor flag to the cursor
	 * @method
	 * @param {string} flag The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial'].
	 * @param {boolean} value The flag boolean value.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.addCursorFlag = function(flag, value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  if(flags.indexOf(flag) == -1) throw MongoError.create({message: f("flag %s not a supported flag %s", flag, flags), driver:true });
	  if(typeof value != 'boolean') throw MongoError.create({message: f("flag %s must be a boolean value", flag), driver:true});
	  this.s.cmd[flag] = value;
	  return this;
	}
	
	define.classMethod('addCursorFlag', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Add a query modifier to the cursor query
	 * @method
	 * @param {string} name The query modifier (must start with $, such as $orderby etc)
	 * @param {boolean} value The flag boolean value.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.addQueryModifier = function(name, value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  if(name[0] != '$') throw MongoError.create({message: f("%s is not a valid query modifier"), driver:true});
	  // Strip of the $
	  var field = name.substr(1);
	  // Set on the command
	  this.s.cmd[field] = value;
	  // Deal with the special case for sort
	  if(field == 'orderby') this.s.cmd.sort = this.s.cmd[field];
	  return this;
	}
	
	define.classMethod('addQueryModifier', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Add a comment to the cursor query allowing for tracking the comment in the log.
	 * @method
	 * @param {string} value The comment attached to this query.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.comment = function(value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.comment = value;
	  return this;
	}
	
	define.classMethod('comment', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set a maxAwaitTimeMS on a tailing cursor query to allow to customize the timeout value for the option awaitData (Only supported on MongoDB 3.2 or higher, ignored otherwise)
	 * @method
	 * @param {number} value Number of milliseconds to wait before aborting the tailed query.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.maxAwaitTimeMS = function(value) {
	  if(typeof value != 'number') throw MongoError.create({message: "maxAwaitTimeMS must be a number", driver:true});
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.maxAwaitTimeMS = value;
	  return this;
	}
	
	define.classMethod('maxAwaitTimeMS', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
	 * @method
	 * @param {number} value Number of milliseconds to wait before aborting the query.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.maxTimeMS = function(value) {
	  if(typeof value != 'number') throw MongoError.create({message: "maxTimeMS must be a number", driver:true});
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.maxTimeMS = value;
	  return this;
	}
	
	define.classMethod('maxTimeMS', {callback: false, promise:false, returns: [Cursor]});
	
	Cursor.prototype.maxTimeMs = Cursor.prototype.maxTimeMS;
	
	define.classMethod('maxTimeMs', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Sets a field projection for the query.
	 * @method
	 * @param {object} value The field projection object.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.project = function(value) {
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  this.s.cmd.fields = value;
	  return this;
	}
	
	define.classMethod('project', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Sets the sort order of the cursor query.
	 * @method
	 * @param {(string|array|object)} keyOrList The key or keys set for the sort.
	 * @param {number} [direction] The direction of the sorting (1 or -1).
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.sort = function(keyOrList, direction) {
	  if(this.s.options.tailable) throw MongoError.create({message: "Tailable cursor doesn't support sorting", driver:true});
	  if(this.s.state == Cursor.CLOSED || this.s.state == Cursor.OPEN || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  var order = keyOrList;
	
	  // We have an array of arrays, we need to preserve the order of the sort
	  // so we will us a Map
	  if(Array.isArray(order) && Array.isArray(order[0])) {
	    order = new Map(order.map(function(x) {
	      var value = [x[0], null];
	      if(x[1] == 'asc') {
	        value[1] = 1;
	      } else if(x[1] == 'desc') {
	        value[1] = -1;
	      } else if(x[1] == 1 || x[1] == -1) {
	        value[1] = x[1];
	      } else {
	        throw new MongoError("Illegal sort clause, must be of the form [['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]");
	      }
	
	      return value;
	    }));
	  }
	
	  if(direction != null) {
	    order = [[keyOrList, direction]];
	  }
	
	  this.s.cmd.sort = order;
	  this.sortValue = order;
	  return this;
	}
	
	define.classMethod('sort', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the batch size for the cursor.
	 * @method
	 * @param {number} value The batchSize for the cursor.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.batchSize = function(value) {
	  if(this.s.options.tailable) throw MongoError.create({message: "Tailable cursor doesn't support batchSize", driver:true});
	  if(this.s.state == Cursor.CLOSED || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  if(typeof value != 'number') throw MongoError.create({message: "batchSize requires an integer", driver:true});
	  this.s.cmd.batchSize = value;
	  this.setCursorBatchSize(value);
	  return this;
	}
	
	define.classMethod('batchSize', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the collation options for the cursor.
	 * @method
	 * @param {object} value The cursor collation options (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.collation = function(value) {
	  this.s.cmd.collation = value;
	  return this;
	}
	
	define.classMethod('collation', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the limit for the cursor.
	 * @method
	 * @param {number} value The limit for the cursor query.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.limit = function(value) {
	  if(this.s.options.tailable) throw MongoError.create({message: "Tailable cursor doesn't support limit", driver:true});
	  if(this.s.state == Cursor.OPEN || this.s.state == Cursor.CLOSED || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  if(typeof value != 'number') throw MongoError.create({message: "limit requires an integer", driver:true});
	  this.s.cmd.limit = value;
	  // this.cursorLimit = value;
	  this.setCursorLimit(value);
	  return this;
	}
	
	define.classMethod('limit', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Set the skip for the cursor.
	 * @method
	 * @param {number} value The skip for the cursor query.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.skip = function(value) {
	  if(this.s.options.tailable) throw MongoError.create({message: "Tailable cursor doesn't support skip", driver:true});
	  if(this.s.state == Cursor.OPEN || this.s.state == Cursor.CLOSED || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  if(typeof value != 'number') throw MongoError.create({message: "skip requires an integer", driver:true});
	  this.s.cmd.skip = value;
	  this.setCursorSkip(value);
	  return this;
	}
	
	define.classMethod('skip', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * The callback format for results
	 * @callback Cursor~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {(object|null|boolean)} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Clone the cursor
	 * @function external:CoreCursor#clone
	 * @return {Cursor}
	 */
	
	/**
	 * Resets the cursor
	 * @function external:CoreCursor#rewind
	 * @return {null}
	 */
	
	/**
	 * Get the next available document from the cursor, returns null if no more documents are available.
	 * @method
	 * @param {Cursor~resultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @deprecated
	 * @return {Promise} returns Promise if no callback passed
	 */
	Cursor.prototype.nextObject = Cursor.prototype.next;
	
	var nextObject = function(self, callback) {
	  if(self.s.state == Cursor.CLOSED || self.isDead && self.isDead()) return handleCallback(callback, MongoError.create({message: "Cursor is closed", driver:true}));
	  if(self.s.state == Cursor.INIT && self.s.cmd.sort) {
	    try {
	      self.s.cmd.sort = formattedOrderClause(self.s.cmd.sort);
	    } catch(err) {
	      return handleCallback(callback, err);
	    }
	  }
	
	  // Get the next object
	  self._next(function(err, doc) {
	    self.s.state = Cursor.OPEN;
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, null, doc);
	  });
	}
	
	define.classMethod('nextObject', {callback: true, promise:true});
	
	// Trampoline emptying the number of retrieved items
	// without incurring a nextTick operation
	var loop = function(self, callback) {
	  // No more items we are done
	  if(self.bufferedCount() == 0) return;
	  // Get the next document
	  self._next(callback);
	  // Loop
	  return loop;
	}
	
	Cursor.prototype.next = Cursor.prototype.nextObject;
	
	define.classMethod('next', {callback: true, promise:true});
	
	/**
	 * Iterates over all the documents for this cursor. As with **{cursor.toArray}**,
	 * not all of the elements will be iterated if this cursor had been previouly accessed.
	 * In that case, **{cursor.rewind}** can be used to reset the cursor. However, unlike
	 * **{cursor.toArray}**, the cursor will only hold a maximum of batch size elements
	 * at any given time if batch size is specified. Otherwise, the caller is responsible
	 * for making sure that the entire result can fit the memory.
	 * @method
	 * @deprecated
	 * @param {Cursor~resultCallback} callback The result callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	Cursor.prototype.each = function(callback) {
	  // Rewind cursor state
	  this.rewind();
	  // Set current cursor to INIT
	  this.s.state = Cursor.INIT;
	  // Run the query
	  _each(this, callback);
	};
	
	define.classMethod('each', {callback: true, promise:false});
	
	// Run the each loop
	var _each = function(self, callback) {
	  if(!callback) throw MongoError.create({message: 'callback is mandatory', driver:true});
	  if(self.isNotified()) return;
	  if(self.s.state == Cursor.CLOSED || self.isDead()) {
	    return handleCallback(callback, MongoError.create({message: "Cursor is closed", driver:true}));
	  }
	
	  if(self.s.state == Cursor.INIT) self.s.state = Cursor.OPEN;
	
	  // Define function to avoid global scope escape
	  var fn = null;
	  // Trampoline all the entries
	  if(self.bufferedCount() > 0) {
	    while(fn = loop(self, callback)) fn(self, callback);
	    _each(self, callback);
	  } else {
	    self.next(function(err, item) {
	      if(err) return handleCallback(callback, err);
	      if(item == null) {
	        self.s.state = Cursor.CLOSED;
	        return handleCallback(callback, null, null);
	      }
	
	      if(handleCallback(callback, null, item) == false) return;
	      _each(self, callback);
	    })
	  }
	}
	
	/**
	 * The callback format for the forEach iterator method
	 * @callback Cursor~iteratorCallback
	 * @param {Object} doc An emitted document for the iterator
	 */
	
	/**
	 * The callback error format for the forEach iterator method
	 * @callback Cursor~endCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 */
	
	/**
	 * Iterates over all the documents for this cursor using the iterator, callback pattern.
	 * @method
	 * @param {Cursor~iteratorCallback} iterator The iteration callback.
	 * @param {Cursor~endCallback} callback The end callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	Cursor.prototype.forEach = function(iterator, callback) {
	  this.each(function(err, doc){
	    if(err) { callback(err); return false; }
	    if(doc != null) { iterator(doc); return true; }
	    if(doc == null && callback) {
	      var internalCallback = callback;
	      callback = null;
	      internalCallback(null);
	      return false;
	    }
	  });
	}
	
	define.classMethod('forEach', {callback: true, promise:false});
	
	/**
	 * Set the ReadPreference for the cursor.
	 * @method
	 * @param {(string|ReadPreference)} readPreference The new read preference for the cursor.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Cursor.prototype.setReadPreference = function(r) {
	  if(this.s.state != Cursor.INIT) throw MongoError.create({message: 'cannot change cursor readPreference after cursor has been accessed', driver:true});
	  if(r instanceof ReadPreference) {
	    this.s.options.readPreference = new CoreReadPreference(r.mode, r.tags, {maxStalenessSeconds: r.maxStalenessSeconds});
	  } else if(typeof r == 'string'){
	    this.s.options.readPreference = new CoreReadPreference(r);
	  } else if(r instanceof CoreReadPreference) {
	    this.s.options.readPreference = r;
	  }
	
	  return this;
	}
	
	define.classMethod('setReadPreference', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * The callback format for results
	 * @callback Cursor~toArrayResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object[]} documents All the documents the satisfy the cursor.
	 */
	
	/**
	 * Returns an array of documents. The caller is responsible for making sure that there
	 * is enough memory to store the results. Note that the array only contain partial
	 * results when this cursor had been previouly accessed. In that case,
	 * cursor.rewind() can be used to reset the cursor.
	 * @method
	 * @param {Cursor~toArrayResultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	Cursor.prototype.toArray = function(callback) {
	  var self = this;
	  if(self.s.options.tailable) throw MongoError.create({message: 'Tailable cursor cannot be converted to array', driver:true});
	
	  // Execute using callback
	  if(typeof callback == 'function') return toArray(self, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    toArray(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var toArray = function(self, callback) {
	  var items = [];
	
	  // Reset cursor
	  self.rewind();
	  self.s.state = Cursor.INIT;
	
	  // Fetch all the documents
	  var fetchDocs = function() {
	    self._next(function(err, doc) {
	      if(err) return handleCallback(callback, err);
	      if(doc == null) {
	        self.s.state = Cursor.CLOSED;
	        return handleCallback(callback, null, items);
	      }
	
	      // Add doc to items
	      items.push(doc)
	
	      // Get all buffered objects
	      if(self.bufferedCount() > 0) {
	        var docs = self.readBufferedDocuments(self.bufferedCount())
	
	        // Transform the doc if transform method added
	        if(self.s.transforms && typeof self.s.transforms.doc == 'function') {
	          docs = docs.map(self.s.transforms.doc);
	        }
	
	        push.apply(items, docs);
	      }
	
	      // Attempt a fetch
	      fetchDocs();
	    })
	  }
	
	  fetchDocs();
	}
	
	define.classMethod('toArray', {callback: true, promise:true});
	
	/**
	 * The callback format for results
	 * @callback Cursor~countResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {number} count The count of documents.
	 */
	
	/**
	 * Get the count of documents for this cursor
	 * @method
	 * @param {boolean} [applySkipLimit=true] Should the count command apply limit and skip settings on the cursor or in the passed in options.
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.skip=null] The number of documents to skip.
	 * @param {number} [options.limit=null] The maximum amounts to count before aborting.
	 * @param {number} [options.maxTimeMS=null] Number of miliseconds to wait before aborting the query.
	 * @param {string} [options.hint=null] An index name hint for the query.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {Cursor~countResultCallback} [callback] The result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	Cursor.prototype.count = function(applySkipLimit, opts, callback) {
	  var self = this;
	  if(self.s.cmd.query == null) throw MongoError.create({message: "count can only be used with find command", driver:true});
	  if(typeof opts == 'function') callback = opts, opts = {};
	  opts = opts || {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return count(self, applySkipLimit, opts, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    count(self, applySkipLimit, opts, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var count = function(self, applySkipLimit, opts, callback) {
	  if(typeof applySkipLimit == 'function') {
	    callback = applySkipLimit;
	    applySkipLimit = true;
	  }
	
	  if(applySkipLimit) {
	    if(typeof self.cursorSkip() == 'number') opts.skip = self.cursorSkip();
	    if(typeof self.cursorLimit() == 'number') opts.limit = self.cursorLimit();
	  }
	
	  // Command
	  var delimiter = self.s.ns.indexOf('.');
	
	  var command = {
	    'count': self.s.ns.substr(delimiter+1), 'query': self.s.cmd.query
	  }
	
	  // Apply a readConcern if set
	  if(self.s.cmd.readConcern) {
	    command.readConcern = self.s.cmd.readConcern;
	  }
	
	  // Apply a hint if set
	  if(self.s.cmd.hint) {
	    command.hint = self.s.cmd.hint;
	  }
	
	  if(typeof opts.maxTimeMS == 'number') {
	    command.maxTimeMS = opts.maxTimeMS;
	  } else if(self.s.cmd && typeof self.s.cmd.maxTimeMS == 'number') {
	    command.maxTimeMS = self.s.cmd.maxTimeMS;
	  }
	
	  // Merge in any options
	  if(opts.skip) command.skip = opts.skip;
	  if(opts.limit) command.limit = opts.limit;
	  if(self.s.options.hint) command.hint = self.s.options.hint;
	
	  // Set cursor server to the same as the topology
	  self.server = self.topology;
	
	  // Execute the command
	  self.topology.command(f("%s.$cmd", self.s.ns.substr(0, delimiter))
	    , command, function(err, result) {
	      callback(err, result ? result.result.n : null)
	    }, self.options);
	}
	
	define.classMethod('count', {callback: true, promise:true});
	
	/**
	 * Close the cursor, sending a KillCursor command and emitting close.
	 * @method
	 * @param {Cursor~resultCallback} [callback] The result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	Cursor.prototype.close = function(callback) {
	  this.s.state = Cursor.CLOSED;
	  // Kill the cursor
	  this.kill();
	  // Emit the close event for the cursor
	  this.emit('close');
	  // Callback if provided
	  if(typeof callback == 'function') return handleCallback(callback, null, this);
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve) {
	    resolve();
	  });
	}
	
	define.classMethod('close', {callback: true, promise:true});
	
	/**
	 * Map all documents using the provided function
	 * @method
	 * @param {function} [transform] The mapping transformation method.
	 * @return {Cursor}
	 */
	Cursor.prototype.map = function(transform) {
	  if(this.cursorState.transforms && this.cursorState.transforms.doc) {
	    var oldTransform = this.cursorState.transforms.doc;
	    this.cursorState.transforms.doc = function (doc) { return transform(oldTransform(doc)); };
	  } else {
	    this.cursorState.transforms = { doc: transform };
	  }
	  return this;
	}
	
	define.classMethod('map', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Is the cursor closed
	 * @method
	 * @return {boolean}
	 */
	Cursor.prototype.isClosed = function() {
	  return this.isDead();
	}
	
	define.classMethod('isClosed', {callback: false, promise:false, returns: [Boolean]});
	
	Cursor.prototype.destroy = function(err) {
	  if(err) this.emit('error', err);
	  this.pause();
	  this.close();
	}
	
	define.classMethod('destroy', {callback: false, promise:false});
	
	/**
	 * Return a modified Readable stream including a possible transform method.
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {function} [options.transform=null] A transformation method applied to each document emitted by the stream.
	 * @return {Cursor}
	 */
	Cursor.prototype.stream = function(options) {
	  this.s.streamOptions = options || {};
	  return this;
	}
	
	define.classMethod('stream', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Execute the explain for the cursor
	 * @method
	 * @param {Cursor~resultCallback} [callback] The result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	Cursor.prototype.explain = function(callback) {
	  var self = this;
	  this.s.cmd.explain = true;
	
	  // Do we have a readConcern
	  if(this.s.cmd.readConcern) {
	    delete this.s.cmd['readConcern'];
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return this._next(callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self._next(function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('explain', {callback: true, promise:true});
	
	Cursor.prototype._read = function() {
	  var self = this;
	  if(self.s.state == Cursor.CLOSED || self.isDead()) {
	    return self.push(null);
	  }
	
	  // Get the next item
	  self.nextObject(function(err, result) {
	    if(err) {
	      if(self.listeners('error') && self.listeners('error').length > 0) {
	        self.emit('error', err);
	      }
	      if(!self.isDead()) self.close();
	
	      // Emit end event
	      self.emit('end');
	      return self.emit('finish');
	    }
	
	    // If we provided a transformation method
	    if(typeof self.s.streamOptions.transform == 'function' && result != null) {
	      return self.push(self.s.streamOptions.transform(result));
	    }
	
	    // If we provided a map function
	    if(self.cursorState.transforms && typeof self.cursorState.transforms.doc == 'function' && result != null) {
	      return self.push(self.cursorState.transforms.doc(result));
	    }
	
	    // Return the result
	    self.push(result);
	  });
	}
	
	Object.defineProperty(Cursor.prototype, 'readPreference', {
	  enumerable:true,
	  get: function() {
	    if (!this || !this.s) {
	      return null;
	    }
	
	    return this.s.options.readPreference;
	  }
	});
	
	Object.defineProperty(Cursor.prototype, 'namespace', {
	  enumerable: true,
	  get: function() {
	    if (!this || !this.s) {
	      return null;
	    }
	
	    // TODO: refactor this logic into core
	    var ns = this.s.ns || '';
	    var firstDot = ns.indexOf('.');
	    if (firstDot < 0) {
	      return {
	        database: this.s.ns,
	        collection: ''
	      };
	    }
	    return {
	      database: ns.substr(0, firstDot),
	      collection: ns.substr(firstDot + 1)
	    };
	  }
	});
	
	/**
	 * The read() method pulls some data out of the internal buffer and returns it. If there is no data available, then it will return null.
	 * @function external:Readable#read
	 * @param {number} size Optional argument to specify how much data to read.
	 * @return {(String | Buffer | null)}
	 */
	
	/**
	 * Call this function to cause the stream to return strings of the specified encoding instead of Buffer objects.
	 * @function external:Readable#setEncoding
	 * @param {string} encoding The encoding to use.
	 * @return {null}
	 */
	
	/**
	 * This method will cause the readable stream to resume emitting data events.
	 * @function external:Readable#resume
	 * @return {null}
	 */
	
	/**
	 * This method will cause a stream in flowing-mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.
	 * @function external:Readable#pause
	 * @return {null}
	 */
	
	/**
	 * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.
	 * @function external:Readable#pipe
	 * @param {Writable} destination The destination for writing data
	 * @param {object} [options] Pipe options
	 * @return {null}
	 */
	
	/**
	 * This method will remove the hooks set up for a previous pipe() call.
	 * @function external:Readable#unpipe
	 * @param {Writable} [destination] The destination for writing data
	 * @return {null}
	 */
	
	/**
	 * This is useful in certain cases where a stream is being consumed by a parser, which needs to "un-consume" some data that it has optimistically pulled out of the source, so that the stream can be passed on to some other party.
	 * @function external:Readable#unshift
	 * @param {(Buffer|string)} chunk Chunk of data to unshift onto the read queue.
	 * @return {null}
	 */
	
	/**
	 * Versions of Node prior to v0.10 had streams that did not implement the entire Streams API as it is today. (See "Compatibility" below for more information.)
	 * @function external:Readable#wrap
	 * @param {Stream} stream An "old style" readable stream.
	 * @return {null}
	 */
	
	Cursor.INIT = 0;
	Cursor.OPEN = 1;
	Cursor.CLOSED = 2;
	Cursor.GET_MORE = 3;
	
	module.exports = Cursor;


/***/ }),
/* 18 */
/***/ (function(module, exports) {

	module.exports = require("stream");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var f = __webpack_require__(1).format
	  , MongoError = __webpack_require__(7);
	
	// Filters for classes
	var classFilters = {};
	var filteredClasses = {};
	var level = null;
	// Save the process id
	var pid = process.pid;
	// current logger
	var currentLogger = null;
	
	/**
	 * Creates a new Logger instance
	 * @class
	 * @param {string} className The Class name associated with the logging instance
	 * @param {object} [options=null] Optional settings.
	 * @param {Function} [options.logger=null] Custom logger function;
	 * @param {string} [options.loggerLevel=error] Override default global log level.
	 * @return {Logger} a Logger instance.
	 */
	var Logger = function(className, options) {
	  if(!(this instanceof Logger)) return new Logger(className, options);
	  options = options || {};
	
	  // Current reference
	  this.className = className;
	
	  // Current logger
	  if(options.logger) {
	    currentLogger = options.logger;
	  } else if(currentLogger == null) {
	    currentLogger = console.log;
	  }
	
	  // Set level of logging, default is error
	  if(options.loggerLevel) {
	    level = options.loggerLevel || 'error';
	  }
	
	  // Add all class names
	  if(filteredClasses[this.className] == null) classFilters[this.className] =  true;
	}
	
	/**
	 * Log a message at the debug level
	 * @method
	 * @param {string} message The message to log
	 * @param {object} object additional meta data to log
	 * @return {null}
	 */
	Logger.prototype.debug = function(message, object) {
	  if(this.isDebug()
	    && ((Object.keys(filteredClasses).length > 0 && filteredClasses[this.className])
	      || (Object.keys(filteredClasses).length == 0 && classFilters[this.className]))) {
	    var dateTime = new Date().getTime();
	    var msg = f("[%s-%s:%s] %s %s", 'DEBUG', this.className, pid, dateTime, message);
	    var state = {
	      type: 'debug', message: message, className: this.className, pid: pid, date: dateTime
	    };
	    if(object) state.meta = object;
	    currentLogger(msg, state);
	  }
	}
	
	/**
	 * Log a message at the warn level
	 * @method
	 * @param {string} message The message to log
	 * @param {object} object additional meta data to log
	 * @return {null}
	 */
	Logger.prototype.warn = function(message, object) {
	  if(this.isWarn()
	    && ((Object.keys(filteredClasses).length > 0 && filteredClasses[this.className])
	      || (Object.keys(filteredClasses).length == 0 && classFilters[this.className]))) {
	    var dateTime = new Date().getTime();
	    var msg = f("[%s-%s:%s] %s %s", 'WARN', this.className, pid, dateTime, message);
	    var state = {
	      type: 'warn', message: message, className: this.className, pid: pid, date: dateTime
	    };
	    if(object) state.meta = object;
	    currentLogger(msg, state);
	  }
	},
	
	/**
	 * Log a message at the info level
	 * @method
	 * @param {string} message The message to log
	 * @param {object} object additional meta data to log
	 * @return {null}
	 */
	Logger.prototype.info = function(message, object) {
	  if(this.isInfo()
	    && ((Object.keys(filteredClasses).length > 0 && filteredClasses[this.className])
	      || (Object.keys(filteredClasses).length == 0 && classFilters[this.className]))) {
	    var dateTime = new Date().getTime();
	    var msg = f("[%s-%s:%s] %s %s", 'INFO', this.className, pid, dateTime, message);
	    var state = {
	      type: 'info', message: message, className: this.className, pid: pid, date: dateTime
	    };
	    if(object) state.meta = object;
	    currentLogger(msg, state);
	  }
	},
	
	/**
	 * Log a message at the error level
	 * @method
	 * @param {string} message The message to log
	 * @param {object} object additional meta data to log
	 * @return {null}
	 */
	Logger.prototype.error = function(message, object) {
	  if(this.isError()
	    && ((Object.keys(filteredClasses).length > 0 && filteredClasses[this.className])
	      || (Object.keys(filteredClasses).length == 0 && classFilters[this.className]))) {
	    var dateTime = new Date().getTime();
	    var msg = f("[%s-%s:%s] %s %s", 'ERROR', this.className, pid, dateTime, message);
	    var state = {
	      type: 'error', message: message, className: this.className, pid: pid, date: dateTime
	    };
	    if(object) state.meta = object;
	    currentLogger(msg, state);
	  }
	},
	
	/**
	 * Is the logger set at info level
	 * @method
	 * @return {boolean}
	 */
	Logger.prototype.isInfo = function() {
	  return level == 'info' || level == 'debug';
	},
	
	/**
	 * Is the logger set at error level
	 * @method
	 * @return {boolean}
	 */
	Logger.prototype.isError = function() {
	  return level == 'error' || level == 'info' || level == 'debug';
	},
	
	/**
	 * Is the logger set at error level
	 * @method
	 * @return {boolean}
	 */
	Logger.prototype.isWarn = function() {
	  return level == 'error' || level == 'warn' || level == 'info' || level == 'debug';
	},
	
	/**
	 * Is the logger set at debug level
	 * @method
	 * @return {boolean}
	 */
	Logger.prototype.isDebug = function() {
	  return level == 'debug';
	}
	
	/**
	 * Resets the logger to default settings, error and no filtered classes
	 * @method
	 * @return {null}
	 */
	Logger.reset = function() {
	  level = 'error';
	  filteredClasses = {};
	}
	
	/**
	 * Get the current logger function
	 * @method
	 * @return {function}
	 */
	Logger.currentLogger = function() {
	  return currentLogger;
	}
	
	/**
	 * Set the current logger function
	 * @method
	 * @param {function} logger Logger function.
	 * @return {null}
	 */
	Logger.setCurrentLogger = function(logger) {
	  if(typeof logger != 'function') throw new MongoError("current logger must be a function");
	  currentLogger = logger;
	}
	
	/**
	 * Set what classes to log.
	 * @method
	 * @param {string} type The type of filter (currently only class)
	 * @param {string[]} values The filters to apply
	 * @return {null}
	 */
	Logger.filter = function(type, values) {
	  if(type == 'class' && Array.isArray(values)) {
	    filteredClasses = {};
	
	    values.forEach(function(x) {
	      filteredClasses[x] = true;
	    });
	  }
	}
	
	/**
	 * Set the current log level
	 * @method
	 * @param {string} level Set current log level (debug, info, error)
	 * @return {null}
	 */
	Logger.setLevel = function(_level) {
	  if(_level != 'info' && _level != 'error' && _level != 'debug' && _level != 'warn') {
	    throw new Error(f("%s is an illegal logging level", _level));
	  }
	
	  level = _level;
	}
	
	module.exports = Logger;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var path = __webpack_require__(69),
	  fs = __webpack_require__(154),
	  f = __webpack_require__(1).format,
	  resolveFrom = __webpack_require__(277),
	  semver = __webpack_require__(278);
	
	var exists = fs.existsSync || path.existsSync;
	
	// Find the location of a package.json file near or above the given location
	var find_package_json = function(location) {
	  var found = false;
	
	  while(!found) {
	    if (exists(location + '/package.json')) {
	      found = location;
	    } else if (location !== '/') {
	      location = path.dirname(location);
	    } else {
	      return false;
	    }
	  }
	
	  return location;
	}
	
	// Find the package.json object of the module closest up the module call tree that contains name in that module's peerOptionalDependencies
	var find_package_json_with_name = function(name) {
	  // Walk up the module call tree until we find a module containing name in its peerOptionalDependencies
	  var currentModule = module;
	  var found = false;
	  while (currentModule) {
	    // Check currentModule has a package.json
	    location = currentModule.filename;
	    var location = find_package_json(location)
	    if (!location) {
	      currentModule = currentModule.parent;
	      continue;
	    }
	
	    // Read the package.json file
	    var object = JSON.parse(fs.readFileSync(f('%s/package.json', location)));
	    // Is the name defined by interal file references
	    var parts = name.split(/\//);
	
	    // Check whether this package.json contains peerOptionalDependencies containing the name we're searching for
	    if (!object.peerOptionalDependencies || (object.peerOptionalDependencies && !object.peerOptionalDependencies[parts[0]])) {
	      currentModule = currentModule.parent;
	      continue;
	    }
	    found = true;
	    break;
	  }
	
	  // Check whether name has been found in currentModule's peerOptionalDependencies
	  if (!found) {
	    throw new Error(f('no optional dependency [%s] defined in peerOptionalDependencies in any package.json', parts[0]));
	  }
	
	  return {
	    object: object,
	    parts: parts
	  }
	}
	
	var require_optional = function(name, options) {
	  options = options || {};
	  options.strict = typeof options.strict == 'boolean' ? options.strict : true;
	
	  var res = find_package_json_with_name(name)
	  var object = res.object;
	  var parts = res.parts;
	
	  // Unpack the expected version
	  var expectedVersions = object.peerOptionalDependencies[parts[0]];
	  // The resolved package
	  var moduleEntry = undefined;
	  // Module file
	  var moduleEntryFile = name;
	
	  try {
	    // Validate if it's possible to read the module
	    moduleEntry = __webpack_require__(105)(moduleEntryFile);
	  } catch(err) {
	    // Attempt to resolve in top level package
	    try {
	      // Get the module entry file
	      moduleEntryFile = resolveFrom(process.cwd(), name);
	      if(moduleEntryFile == null) return undefined;
	      // Attempt to resolve the module
	      moduleEntry = __webpack_require__(105)(moduleEntryFile);
	    } catch(err) {
	      if(err.code === 'MODULE_NOT_FOUND') return undefined;
	    }
	  }
	
	  // Resolve the location of the module's package.json file
	  var location = find_package_json(/*require.resolve*/(__webpack_require__(105).resolve(moduleEntryFile)));
	  if(!location) {
	    throw new Error('package.json can not be located');
	  }
	
	  // Read the module file
	  var dependentOnModule = JSON.parse(fs.readFileSync(f('%s/package.json', location)));
	  // Get the version
	  var version = dependentOnModule.version;
	  // Validate if the found module satisfies the version id
	  if(semver.satisfies(version, expectedVersions) == false
	    && options.strict) {
	      var error = new Error(f('optional dependency [%s] found but version [%s] did not satisfy constraint [%s]', parts[0], version, expectedVersions));
	      error.code = 'OPTIONAL_MODULE_NOT_FOUND';
	      throw error;
	  }
	
	  // Satifies the module requirement
	  return moduleEntry;
	}
	
	require_optional.exists = function(name) {
	  try {
	    var m = require_optional(name);
	    if(m === undefined) return false;
	    return true;
	  } catch(err) {
	    return false;
	  }
	}
	
	module.exports = require_optional;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(47)(module)))

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	// Copyright (c) 2008, Fair Oaks Labs, Inc.
	// All rights reserved.
	// 
	// Redistribution and use in source and binary forms, with or without
	// modification, are permitted provided that the following conditions are met:
	// 
	//  * Redistributions of source code must retain the above copyright notice,
	//    this list of conditions and the following disclaimer.
	// 
	//  * Redistributions in binary form must reproduce the above copyright notice,
	//    this list of conditions and the following disclaimer in the documentation
	//    and/or other materials provided with the distribution.
	// 
	//  * Neither the name of Fair Oaks Labs, Inc. nor the names of its contributors
	//    may be used to endorse or promote products derived from this software
	//    without specific prior written permission.
	// 
	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
	// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	// POSSIBILITY OF SUCH DAMAGE.
	//
	//
	// Modifications to writeIEEE754 to support negative zeroes made by Brian White
	
	var readIEEE754 = function(buffer, offset, endian, mLen, nBytes) {
	  var e, m,
	      bBE = (endian === 'big'),
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      nBits = -7,
	      i = bBE ? 0 : (nBytes - 1),
	      d = bBE ? 1 : -1,
	      s = buffer[offset + i];
	
	  i += d;
	
	  e = s & ((1 << (-nBits)) - 1);
	  s >>= (-nBits);
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
	
	  m = e & ((1 << (-nBits)) - 1);
	  e >>= (-nBits);
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
	
	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity);
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
	};
	
	var writeIEEE754 = function(buffer, value, offset, endian, mLen, nBytes) {
	  var e, m, c,
	      bBE = (endian === 'big'),
	      eLen = nBytes * 8 - mLen - 1,
	      eMax = (1 << eLen) - 1,
	      eBias = eMax >> 1,
	      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
	      i = bBE ? (nBytes-1) : 0,
	      d = bBE ? -1 : 1,
	      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
	
	  value = Math.abs(value);
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e+eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
	
	  e = (e << mLen) | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
	
	  buffer[offset + i - d] |= s * 128;
	};
	
	exports.readIEEE754 = readIEEE754;
	exports.writeIEEE754 = writeIEEE754;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	// Core module
	var core = __webpack_require__(3),
	  Instrumentation = __webpack_require__(201);
	
	// Set up the connect function
	var connect = __webpack_require__(125).connect;
	
	// Expose error class
	connect.MongoError = core.MongoError;
	
	// Actual driver classes exported
	connect.Admin = __webpack_require__(121);
	connect.MongoClient = __webpack_require__(125);
	connect.Db = __webpack_require__(82);
	connect.Collection = __webpack_require__(59);
	connect.Server = __webpack_require__(60);
	connect.ReplSet = __webpack_require__(127);
	connect.Mongos = __webpack_require__(126);
	connect.ReadPreference = __webpack_require__(16);
	connect.GridStore = __webpack_require__(124);
	connect.Chunk = __webpack_require__(123);
	connect.Logger = core.Logger;
	connect.Cursor = __webpack_require__(17);
	connect.GridFSBucket = __webpack_require__(203);
	// Exported to be used in tests not to be used anywhere else
	connect.CoreServer = __webpack_require__(3).Server;
	connect.CoreConnection = __webpack_require__(3).Connection;
	
	// BSON types exported
	connect.Binary = core.BSON.Binary;
	connect.Code = core.BSON.Code;
	connect.Map = core.BSON.Map;
	connect.DBRef = core.BSON.DBRef;
	connect.Double = core.BSON.Double;
	connect.Int32 = core.BSON.Int32;
	connect.Long = core.BSON.Long;
	connect.MinKey = core.BSON.MinKey;
	connect.MaxKey = core.BSON.MaxKey;
	connect.ObjectID = core.BSON.ObjectID;
	connect.ObjectId = core.BSON.ObjectID;
	connect.Symbol = core.BSON.Symbol;
	connect.Timestamp = core.BSON.Timestamp;
	connect.BSONRegExp = core.BSON.BSONRegExp;
	connect.Decimal128 = core.BSON.Decimal128;
	
	// Add connect method
	connect.connect = connect;
	
	// Set up the instrumentation method
	connect.instrument = function(options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  return new Instrumentation(core, options, callback);
	}
	
	// Set our exports to be the connect function
	module.exports = connect;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var inherits = __webpack_require__(1).inherits
	  , ReadPreference = __webpack_require__(16)
	  , MongoError = __webpack_require__(3).MongoError
	  , Readable = __webpack_require__(18).Readable || __webpack_require__(70).Readable
	  , Define = __webpack_require__(13)
	  , CoreCursor = __webpack_require__(17)
	  , CoreReadPreference = __webpack_require__(3).ReadPreference;
	
	/**
	 * @fileOverview The **CommandCursor** class is an internal class that embodies a
	 * generalized cursor based on a MongoDB command allowing for iteration over the
	 * results returned. It supports one by one document iteration, conversion to an
	 * array or can be iterated as a Node 0.10.X or higher stream
	 *
	 * **CommandCursor Cannot directly be instantiated**
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Create a collection we want to drop later
	 *   var col = db.collection('listCollectionsExample1');
	 *   // Insert a bunch of documents
	 *   col.insert([{a:1, b:1}
	 *     , {a:2, b:2}, {a:3, b:3}
	 *     , {a:4, b:4}], {w:1}, function(err, result) {
	 *     test.equal(null, err);
	 *
	 *     // List the database collections available
	 *     db.listCollections().toArray(function(err, items) {
	 *       test.equal(null, err);
	 *       db.close();
	 *     });
	 *   });
	 * });
	 */
	
	/**
	 * Namespace provided by the browser.
	 * @external Readable
	 */
	
	/**
	 * Creates a new Command Cursor instance (INTERNAL TYPE, do not instantiate directly)
	 * @class CommandCursor
	 * @extends external:Readable
	 * @fires CommandCursor#data
	 * @fires CommandCursor#end
	 * @fires CommandCursor#close
	 * @fires CommandCursor#readable
	 * @return {CommandCursor} an CommandCursor instance.
	 */
	var CommandCursor = function(bson, ns, cmd, options, topology, topologyOptions) {
	  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));
	  var state = CommandCursor.INIT;
	  var streamOptions = {};
	
	  // MaxTimeMS
	  var maxTimeMS = null;
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(10).Promise;
	  }
	
	  // Set up
	  Readable.call(this, {objectMode: true});
	
	  // Internal state
	  this.s = {
	    // MaxTimeMS
	      maxTimeMS: maxTimeMS
	    // State
	    , state: state
	    // Stream options
	    , streamOptions: streamOptions
	    // BSON
	    , bson: bson
	    // Namespace
	    , ns: ns
	    // Command
	    , cmd: cmd
	    // Options
	    , options: options
	    // Topology
	    , topology: topology
	    // Topology Options
	    , topologyOptions: topologyOptions
	    // Promise library
	    , promiseLibrary: promiseLibrary
	  }
	}
	
	/**
	 * CommandCursor stream data event, fired for each document in the cursor.
	 *
	 * @event CommandCursor#data
	 * @type {object}
	 */
	
	/**
	 * CommandCursor stream end event
	 *
	 * @event CommandCursor#end
	 * @type {null}
	 */
	
	/**
	 * CommandCursor stream close event
	 *
	 * @event CommandCursor#close
	 * @type {null}
	 */
	
	/**
	 * CommandCursor stream readable event
	 *
	 * @event CommandCursor#readable
	 * @type {null}
	 */
	
	// Inherit from Readable
	inherits(CommandCursor, Readable);
	
	// Set the methods to inherit from prototype
	var methodsToInherit = ['_next', 'next', 'hasNext', 'each', 'forEach', 'toArray'
	  , 'rewind', 'bufferedCount', 'readBufferedDocuments', 'close', 'isClosed', 'kill', 'setCursorBatchSize'
	  , '_find', '_getmore', '_killcursor', 'isDead', 'explain', 'isNotified', 'isKilled'];
	
	// Only inherit the types we need
	for(var i = 0; i < methodsToInherit.length; i++) {
	  CommandCursor.prototype[methodsToInherit[i]] = CoreCursor.prototype[methodsToInherit[i]];
	}
	
	var define = CommandCursor.define = new Define('CommandCursor', CommandCursor, true);
	
	/**
	 * Set the ReadPreference for the cursor.
	 * @method
	 * @param {(string|ReadPreference)} readPreference The new read preference for the cursor.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	CommandCursor.prototype.setReadPreference = function(r) {
	  if(this.s.state == CommandCursor.CLOSED || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  if(this.s.state != CommandCursor.INIT) throw MongoError.create({message: 'cannot change cursor readPreference after cursor has been accessed', driver:true});
	
	  if(r instanceof ReadPreference) {
	    this.s.options.readPreference = new CoreReadPreference(r.mode, r.tags, {maxStalenessSeconds: r.maxStalenessSeconds});
	  } else if(typeof r == 'string') {
	    this.s.options.readPreference = new CoreReadPreference(r);
	  } else if(r instanceof CoreReadPreference) {
	    this.s.options.readPreference = r;
	  }
	
	  return this;
	}
	
	define.classMethod('setReadPreference', {callback: false, promise:false, returns: [CommandCursor]});
	
	/**
	 * Set the batch size for the cursor.
	 * @method
	 * @param {number} value The batchSize for the cursor.
	 * @throws {MongoError}
	 * @return {CommandCursor}
	 */
	CommandCursor.prototype.batchSize = function(value) {
	  if(this.s.state == CommandCursor.CLOSED || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true});
	  if(typeof value != 'number') throw MongoError.create({message: "batchSize requires an integer", driver:true});
	  if(this.s.cmd.cursor) this.s.cmd.cursor.batchSize = value;
	  this.setCursorBatchSize(value);
	  return this;
	}
	
	define.classMethod('batchSize', {callback: false, promise:false, returns: [CommandCursor]});
	
	/**
	 * Add a maxTimeMS stage to the aggregation pipeline
	 * @method
	 * @param {number} value The state maxTimeMS value.
	 * @return {CommandCursor}
	 */
	CommandCursor.prototype.maxTimeMS = function(value) {
	  if(this.s.topology.lastIsMaster().minWireVersion > 2) {
	    this.s.cmd.maxTimeMS = value;
	  }
	  return this;
	}
	
	define.classMethod('maxTimeMS', {callback: false, promise:false, returns: [CommandCursor]});
	
	CommandCursor.prototype.get = CommandCursor.prototype.toArray;
	
	define.classMethod('get', {callback: true, promise:false});
	
	// Inherited methods
	define.classMethod('toArray', {callback: true, promise:true});
	define.classMethod('each', {callback: true, promise:false});
	define.classMethod('forEach', {callback: true, promise:false});
	define.classMethod('next', {callback: true, promise:true});
	define.classMethod('hasNext', {callback: true, promise:true});
	define.classMethod('close', {callback: true, promise:true});
	define.classMethod('isClosed', {callback: false, promise:false, returns: [Boolean]});
	define.classMethod('rewind', {callback: false, promise:false});
	define.classMethod('bufferedCount', {callback: false, promise:false, returns: [Number]});
	define.classMethod('readBufferedDocuments', {callback: false, promise:false, returns: [Array]});
	
	/**
	 * Get the next available document from the cursor, returns null if no more documents are available.
	 * @function CommandCursor.prototype.next
	 * @param {CommandCursor~resultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	
	/**
	 * Check if there is any document still available in the cursor
	 * @function CommandCursor.prototype.hasNext
	 * @param {CommandCursor~resultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	
	/**
	 * The callback format for results
	 * @callback CommandCursor~toArrayResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object[]} documents All the documents the satisfy the cursor.
	 */
	
	/**
	 * Returns an array of documents. The caller is responsible for making sure that there
	 * is enough memory to store the results. Note that the array only contain partial
	 * results when this cursor had been previouly accessed.
	 * @method CommandCursor.prototype.toArray
	 * @param {CommandCursor~toArrayResultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	
	/**
	 * The callback format for results
	 * @callback CommandCursor~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {(object|null)} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Iterates over all the documents for this cursor. As with **{cursor.toArray}**,
	 * not all of the elements will be iterated if this cursor had been previouly accessed.
	 * In that case, **{cursor.rewind}** can be used to reset the cursor. However, unlike
	 * **{cursor.toArray}**, the cursor will only hold a maximum of batch size elements
	 * at any given time if batch size is specified. Otherwise, the caller is responsible
	 * for making sure that the entire result can fit the memory.
	 * @method CommandCursor.prototype.each
	 * @param {CommandCursor~resultCallback} callback The result callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	/**
	 * Close the cursor, sending a KillCursor command and emitting close.
	 * @method CommandCursor.prototype.close
	 * @param {CommandCursor~resultCallback} [callback] The result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	
	/**
	 * Is the cursor closed
	 * @method CommandCursor.prototype.isClosed
	 * @return {boolean}
	 */
	
	/**
	 * Clone the cursor
	 * @function CommandCursor.prototype.clone
	 * @return {CommandCursor}
	 */
	
	/**
	 * Resets the cursor
	 * @function CommandCursor.prototype.rewind
	 * @return {CommandCursor}
	 */
	
	/**
	 * The callback format for the forEach iterator method
	 * @callback CommandCursor~iteratorCallback
	 * @param {Object} doc An emitted document for the iterator
	 */
	
	/**
	 * The callback error format for the forEach iterator method
	 * @callback CommandCursor~endCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 */
	
	/*
	 * Iterates over all the documents for this cursor using the iterator, callback pattern.
	 * @method CommandCursor.prototype.forEach
	 * @param {CommandCursor~iteratorCallback} iterator The iteration callback.
	 * @param {CommandCursor~endCallback} callback The end callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	CommandCursor.INIT = 0;
	CommandCursor.OPEN = 1;
	CommandCursor.CLOSED = 2;
	
	module.exports = CommandCursor;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * ObjectId type constructor
	 *
	 * ####Example
	 *
	 *     var id = new mongoose.Types.ObjectId;
	 *
	 * @constructor ObjectId
	 */
	
	var ObjectId = __webpack_require__(29).ObjectId;
	
	module.exports = ObjectId;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var BSON = __webpack_require__(164),
	  Binary = __webpack_require__(32),
	  Code = __webpack_require__(33),
	  DBRef = __webpack_require__(34),
	  Decimal128 = __webpack_require__(35),
	  Double = __webpack_require__(36),
	  Int32 = __webpack_require__(50),
	  Long = __webpack_require__(26),
	  Map = __webpack_require__(71),
	  MaxKey = __webpack_require__(37),
	  MinKey = __webpack_require__(38),
	  ObjectId = __webpack_require__(39),
	  BSONRegExp = __webpack_require__(40),
	  Symbol = __webpack_require__(41),
	  Timestamp = __webpack_require__(42);
	
	// BSON MAX VALUES
	BSON.BSON_INT32_MAX = 0x7FFFFFFF;
	BSON.BSON_INT32_MIN = -0x80000000;
	
	BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
	BSON.BSON_INT64_MIN = -Math.pow(2, 63);
	
	// JS MAX PRECISE VALUES
	BSON.JS_INT_MAX = 0x20000000000000;  // Any integer up to 2^53 can be precisely represented by a double.
	BSON.JS_INT_MIN = -0x20000000000000;  // Any integer down to -2^53 can be precisely represented by a double.
	
	// Add BSON types to function creation
	BSON.Binary = Binary;
	BSON.Code = Code;
	BSON.DBRef = DBRef;
	BSON.Decimal128 = Decimal128;
	BSON.Double = Double;
	BSON.Int32 = Int32;
	BSON.Long = Long;
	BSON.Map = Map;
	BSON.MaxKey = MaxKey;
	BSON.MinKey = MinKey;
	BSON.ObjectId = ObjectId;
	BSON.ObjectID = ObjectId;
	BSON.BSONRegExp = BSONRegExp;
	BSON.Symbol = Symbol;
	BSON.Timestamp = Timestamp;
	
	// Return the BSON
	module.exports = BSON;


/***/ }),
/* 26 */
/***/ (function(module, exports) {

	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//     http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// Copyright 2009 Google Inc. All Rights Reserved
	
	/**
	 * Defines a Long class for representing a 64-bit two's-complement
	 * integer value, which faithfully simulates the behavior of a Java "Long". This
	 * implementation is derived from LongLib in GWT.
	 *
	 * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
	 * values as *signed* integers.  See the from* functions below for more
	 * convenient ways of constructing Longs.
	 *
	 * The internal representation of a Long is the two given signed, 32-bit values.
	 * We use 32-bit pieces because these are the size of integers on which
	 * Javascript performs bit-operations.  For operations like addition and
	 * multiplication, we split each number into 16-bit pieces, which can easily be
	 * multiplied within Javascript's floating-point representation without overflow
	 * or change in sign.
	 *
	 * In the algorithms below, we frequently reduce the negative case to the
	 * positive case by negating the input(s) and then post-processing the result.
	 * Note that we must ALWAYS check specially whether those values are MIN_VALUE
	 * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
	 * a positive number, it overflows back into a negative).  Not handling this
	 * case would often result in infinite recursion.
	 *
	 * @class
	 * @param {number} low  the low (signed) 32 bits of the Long.
	 * @param {number} high the high (signed) 32 bits of the Long.
	 * @return {Long}
	 */
	function Long(low, high) {
	  if(!(this instanceof Long)) return new Long(low, high);
	  
	  this._bsontype = 'Long';
	  /**
	   * @type {number}
	   * @ignore
	   */
	  this.low_ = low | 0;  // force into 32 signed bits.
	
	  /**
	   * @type {number}
	   * @ignore
	   */
	  this.high_ = high | 0;  // force into 32 signed bits.
	};
	
	/**
	 * Return the int value.
	 *
	 * @method
	 * @return {number} the value, assuming it is a 32-bit integer.
	 */
	Long.prototype.toInt = function() {
	  return this.low_;
	};
	
	/**
	 * Return the Number value.
	 *
	 * @method
	 * @return {number} the closest floating-point representation to this value.
	 */
	Long.prototype.toNumber = function() {
	  return this.high_ * Long.TWO_PWR_32_DBL_ +
	         this.getLowBitsUnsigned();
	};
	
	/**
	 * Return the JSON value.
	 *
	 * @method
	 * @return {string} the JSON representation.
	 */
	Long.prototype.toJSON = function() {
	  return this.toString();
	}
	
	/**
	 * Return the String value.
	 *
	 * @method
	 * @param {number} [opt_radix] the radix in which the text should be written.
	 * @return {string} the textual representation of this value.
	 */
	Long.prototype.toString = function(opt_radix) {
	  var radix = opt_radix || 10;
	  if (radix < 2 || 36 < radix) {
	    throw Error('radix out of range: ' + radix);
	  }
	
	  if (this.isZero()) {
	    return '0';
	  }
	
	  if (this.isNegative()) {
	    if (this.equals(Long.MIN_VALUE)) {
	      // We need to change the Long value before it can be negated, so we remove
	      // the bottom-most digit in this base and then recurse to do the rest.
	      var radixLong = Long.fromNumber(radix);
	      var div = this.div(radixLong);
	      var rem = div.multiply(radixLong).subtract(this);
	      return div.toString(radix) + rem.toInt().toString(radix);
	    } else {
	      return '-' + this.negate().toString(radix);
	    }
	  }
	
	  // Do several (6) digits each time through the loop, so as to
	  // minimize the calls to the very expensive emulated div.
	  var radixToPower = Long.fromNumber(Math.pow(radix, 6));
	
	  var rem = this;
	  var result = '';
	  while (true) {
	    var remDiv = rem.div(radixToPower);
	    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
	    var digits = intval.toString(radix);
	
	    rem = remDiv;
	    if (rem.isZero()) {
	      return digits + result;
	    } else {
	      while (digits.length < 6) {
	        digits = '0' + digits;
	      }
	      result = '' + digits + result;
	    }
	  }
	};
	
	/**
	 * Return the high 32-bits value.
	 *
	 * @method
	 * @return {number} the high 32-bits as a signed value.
	 */
	Long.prototype.getHighBits = function() {
	  return this.high_;
	};
	
	/**
	 * Return the low 32-bits value.
	 *
	 * @method
	 * @return {number} the low 32-bits as a signed value.
	 */
	Long.prototype.getLowBits = function() {
	  return this.low_;
	};
	
	/**
	 * Return the low unsigned 32-bits value.
	 *
	 * @method
	 * @return {number} the low 32-bits as an unsigned value.
	 */
	Long.prototype.getLowBitsUnsigned = function() {
	  return (this.low_ >= 0) ?
	      this.low_ : Long.TWO_PWR_32_DBL_ + this.low_;
	};
	
	/**
	 * Returns the number of bits needed to represent the absolute value of this Long.
	 *
	 * @method
	 * @return {number} Returns the number of bits needed to represent the absolute value of this Long.
	 */
	Long.prototype.getNumBitsAbs = function() {
	  if (this.isNegative()) {
	    if (this.equals(Long.MIN_VALUE)) {
	      return 64;
	    } else {
	      return this.negate().getNumBitsAbs();
	    }
	  } else {
	    var val = this.high_ != 0 ? this.high_ : this.low_;
	    for (var bit = 31; bit > 0; bit--) {
	      if ((val & (1 << bit)) != 0) {
	        break;
	      }
	    }
	    return this.high_ != 0 ? bit + 33 : bit + 1;
	  }
	};
	
	/**
	 * Return whether this value is zero.
	 *
	 * @method
	 * @return {boolean} whether this value is zero.
	 */
	Long.prototype.isZero = function() {
	  return this.high_ == 0 && this.low_ == 0;
	};
	
	/**
	 * Return whether this value is negative.
	 *
	 * @method
	 * @return {boolean} whether this value is negative.
	 */
	Long.prototype.isNegative = function() {
	  return this.high_ < 0;
	};
	
	/**
	 * Return whether this value is odd.
	 *
	 * @method
	 * @return {boolean} whether this value is odd.
	 */
	Long.prototype.isOdd = function() {
	  return (this.low_ & 1) == 1;
	};
	
	/**
	 * Return whether this Long equals the other
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long equals the other
	 */
	Long.prototype.equals = function(other) {
	  return (this.high_ == other.high_) && (this.low_ == other.low_);
	};
	
	/**
	 * Return whether this Long does not equal the other.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long does not equal the other.
	 */
	Long.prototype.notEquals = function(other) {
	  return (this.high_ != other.high_) || (this.low_ != other.low_);
	};
	
	/**
	 * Return whether this Long is less than the other.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long is less than the other.
	 */
	Long.prototype.lessThan = function(other) {
	  return this.compare(other) < 0;
	};
	
	/**
	 * Return whether this Long is less than or equal to the other.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long is less than or equal to the other.
	 */
	Long.prototype.lessThanOrEqual = function(other) {
	  return this.compare(other) <= 0;
	};
	
	/**
	 * Return whether this Long is greater than the other.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long is greater than the other.
	 */
	Long.prototype.greaterThan = function(other) {
	  return this.compare(other) > 0;
	};
	
	/**
	 * Return whether this Long is greater than or equal to the other.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} whether this Long is greater than or equal to the other.
	 */
	Long.prototype.greaterThanOrEqual = function(other) {
	  return this.compare(other) >= 0;
	};
	
	/**
	 * Compares this Long with the given one.
	 *
	 * @method
	 * @param {Long} other Long to compare against.
	 * @return {boolean} 0 if they are the same, 1 if the this is greater, and -1 if the given one is greater.
	 */
	Long.prototype.compare = function(other) {
	  if (this.equals(other)) {
	    return 0;
	  }
	
	  var thisNeg = this.isNegative();
	  var otherNeg = other.isNegative();
	  if (thisNeg && !otherNeg) {
	    return -1;
	  }
	  if (!thisNeg && otherNeg) {
	    return 1;
	  }
	
	  // at this point, the signs are the same, so subtraction will not overflow
	  if (this.subtract(other).isNegative()) {
	    return -1;
	  } else {
	    return 1;
	  }
	};
	
	/**
	 * The negation of this value.
	 *
	 * @method
	 * @return {Long} the negation of this value.
	 */
	Long.prototype.negate = function() {
	  if (this.equals(Long.MIN_VALUE)) {
	    return Long.MIN_VALUE;
	  } else {
	    return this.not().add(Long.ONE);
	  }
	};
	
	/**
	 * Returns the sum of this and the given Long.
	 *
	 * @method
	 * @param {Long} other Long to add to this one.
	 * @return {Long} the sum of this and the given Long.
	 */
	Long.prototype.add = function(other) {
	  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
	
	  var a48 = this.high_ >>> 16;
	  var a32 = this.high_ & 0xFFFF;
	  var a16 = this.low_ >>> 16;
	  var a00 = this.low_ & 0xFFFF;
	
	  var b48 = other.high_ >>> 16;
	  var b32 = other.high_ & 0xFFFF;
	  var b16 = other.low_ >>> 16;
	  var b00 = other.low_ & 0xFFFF;
	
	  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	  c00 += a00 + b00;
	  c16 += c00 >>> 16;
	  c00 &= 0xFFFF;
	  c16 += a16 + b16;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c32 += a32 + b32;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c48 += a48 + b48;
	  c48 &= 0xFFFF;
	  return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
	};
	
	/**
	 * Returns the difference of this and the given Long.
	 *
	 * @method
	 * @param {Long} other Long to subtract from this.
	 * @return {Long} the difference of this and the given Long.
	 */
	Long.prototype.subtract = function(other) {
	  return this.add(other.negate());
	};
	
	/**
	 * Returns the product of this and the given Long.
	 *
	 * @method
	 * @param {Long} other Long to multiply with this.
	 * @return {Long} the product of this and the other.
	 */
	Long.prototype.multiply = function(other) {
	  if (this.isZero()) {
	    return Long.ZERO;
	  } else if (other.isZero()) {
	    return Long.ZERO;
	  }
	
	  if (this.equals(Long.MIN_VALUE)) {
	    return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
	  } else if (other.equals(Long.MIN_VALUE)) {
	    return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
	  }
	
	  if (this.isNegative()) {
	    if (other.isNegative()) {
	      return this.negate().multiply(other.negate());
	    } else {
	      return this.negate().multiply(other).negate();
	    }
	  } else if (other.isNegative()) {
	    return this.multiply(other.negate()).negate();
	  }
	
	  // If both Longs are small, use float multiplication
	  if (this.lessThan(Long.TWO_PWR_24_) &&
	      other.lessThan(Long.TWO_PWR_24_)) {
	    return Long.fromNumber(this.toNumber() * other.toNumber());
	  }
	
	  // Divide each Long into 4 chunks of 16 bits, and then add up 4x4 products.
	  // We can skip products that would overflow.
	
	  var a48 = this.high_ >>> 16;
	  var a32 = this.high_ & 0xFFFF;
	  var a16 = this.low_ >>> 16;
	  var a00 = this.low_ & 0xFFFF;
	
	  var b48 = other.high_ >>> 16;
	  var b32 = other.high_ & 0xFFFF;
	  var b16 = other.low_ >>> 16;
	  var b00 = other.low_ & 0xFFFF;
	
	  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	  c00 += a00 * b00;
	  c16 += c00 >>> 16;
	  c00 &= 0xFFFF;
	  c16 += a16 * b00;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c16 += a00 * b16;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c32 += a32 * b00;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c32 += a16 * b16;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c32 += a00 * b32;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
	  c48 &= 0xFFFF;
	  return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
	};
	
	/**
	 * Returns this Long divided by the given one.
	 *
	 * @method
	 * @param {Long} other Long by which to divide.
	 * @return {Long} this Long divided by the given one.
	 */
	Long.prototype.div = function(other) {
	  if (other.isZero()) {
	    throw Error('division by zero');
	  } else if (this.isZero()) {
	    return Long.ZERO;
	  }
	
	  if (this.equals(Long.MIN_VALUE)) {
	    if (other.equals(Long.ONE) ||
	        other.equals(Long.NEG_ONE)) {
	      return Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
	    } else if (other.equals(Long.MIN_VALUE)) {
	      return Long.ONE;
	    } else {
	      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
	      var halfThis = this.shiftRight(1);
	      var approx = halfThis.div(other).shiftLeft(1);
	      if (approx.equals(Long.ZERO)) {
	        return other.isNegative() ? Long.ONE : Long.NEG_ONE;
	      } else {
	        var rem = this.subtract(other.multiply(approx));
	        var result = approx.add(rem.div(other));
	        return result;
	      }
	    }
	  } else if (other.equals(Long.MIN_VALUE)) {
	    return Long.ZERO;
	  }
	
	  if (this.isNegative()) {
	    if (other.isNegative()) {
	      return this.negate().div(other.negate());
	    } else {
	      return this.negate().div(other).negate();
	    }
	  } else if (other.isNegative()) {
	    return this.div(other.negate()).negate();
	  }
	
	  // Repeat the following until the remainder is less than other:  find a
	  // floating-point that approximates remainder / other *from below*, add this
	  // into the result, and subtract it from the remainder.  It is critical that
	  // the approximate value is less than or equal to the real value so that the
	  // remainder never becomes negative.
	  var res = Long.ZERO;
	  var rem = this;
	  while (rem.greaterThanOrEqual(other)) {
	    // Approximate the result of division. This may be a little greater or
	    // smaller than the actual value.
	    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
	
	    // We will tweak the approximate result by changing it in the 48-th digit or
	    // the smallest non-fractional digit, whichever is larger.
	    var log2 = Math.ceil(Math.log(approx) / Math.LN2);
	    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);
	
	    // Decrease the approximation until it is smaller than the remainder.  Note
	    // that if it is too large, the product overflows and is negative.
	    var approxRes = Long.fromNumber(approx);
	    var approxRem = approxRes.multiply(other);
	    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
	      approx -= delta;
	      approxRes = Long.fromNumber(approx);
	      approxRem = approxRes.multiply(other);
	    }
	
	    // We know the answer can't be zero... and actually, zero would cause
	    // infinite recursion since we would make no progress.
	    if (approxRes.isZero()) {
	      approxRes = Long.ONE;
	    }
	
	    res = res.add(approxRes);
	    rem = rem.subtract(approxRem);
	  }
	  return res;
	};
	
	/**
	 * Returns this Long modulo the given one.
	 *
	 * @method
	 * @param {Long} other Long by which to mod.
	 * @return {Long} this Long modulo the given one.
	 */
	Long.prototype.modulo = function(other) {
	  return this.subtract(this.div(other).multiply(other));
	};
	
	/**
	 * The bitwise-NOT of this value.
	 *
	 * @method
	 * @return {Long} the bitwise-NOT of this value.
	 */
	Long.prototype.not = function() {
	  return Long.fromBits(~this.low_, ~this.high_);
	};
	
	/**
	 * Returns the bitwise-AND of this Long and the given one.
	 *
	 * @method
	 * @param {Long} other the Long with which to AND.
	 * @return {Long} the bitwise-AND of this and the other.
	 */
	Long.prototype.and = function(other) {
	  return Long.fromBits(this.low_ & other.low_, this.high_ & other.high_);
	};
	
	/**
	 * Returns the bitwise-OR of this Long and the given one.
	 *
	 * @method
	 * @param {Long} other the Long with which to OR.
	 * @return {Long} the bitwise-OR of this and the other.
	 */
	Long.prototype.or = function(other) {
	  return Long.fromBits(this.low_ | other.low_, this.high_ | other.high_);
	};
	
	/**
	 * Returns the bitwise-XOR of this Long and the given one.
	 *
	 * @method
	 * @param {Long} other the Long with which to XOR.
	 * @return {Long} the bitwise-XOR of this and the other.
	 */
	Long.prototype.xor = function(other) {
	  return Long.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
	};
	
	/**
	 * Returns this Long with bits shifted to the left by the given amount.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Long} this shifted to the left by the given amount.
	 */
	Long.prototype.shiftLeft = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var low = this.low_;
	    if (numBits < 32) {
	      var high = this.high_;
	      return Long.fromBits(
	                 low << numBits,
	                 (high << numBits) | (low >>> (32 - numBits)));
	    } else {
	      return Long.fromBits(0, low << (numBits - 32));
	    }
	  }
	};
	
	/**
	 * Returns this Long with bits shifted to the right by the given amount.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Long} this shifted to the right by the given amount.
	 */
	Long.prototype.shiftRight = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var high = this.high_;
	    if (numBits < 32) {
	      var low = this.low_;
	      return Long.fromBits(
	                 (low >>> numBits) | (high << (32 - numBits)),
	                 high >> numBits);
	    } else {
	      return Long.fromBits(
	                 high >> (numBits - 32),
	                 high >= 0 ? 0 : -1);
	    }
	  }
	};
	
	/**
	 * Returns this Long with bits shifted to the right by the given amount, with the new top bits matching the current sign bit.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Long} this shifted to the right by the given amount, with zeros placed into the new leading bits.
	 */
	Long.prototype.shiftRightUnsigned = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var high = this.high_;
	    if (numBits < 32) {
	      var low = this.low_;
	      return Long.fromBits(
	                 (low >>> numBits) | (high << (32 - numBits)),
	                 high >>> numBits);
	    } else if (numBits == 32) {
	      return Long.fromBits(high, 0);
	    } else {
	      return Long.fromBits(high >>> (numBits - 32), 0);
	    }
	  }
	};
	
	/**
	 * Returns a Long representing the given (32-bit) integer value.
	 *
	 * @method
	 * @param {number} value the 32-bit integer in question.
	 * @return {Long} the corresponding Long value.
	 */
	Long.fromInt = function(value) {
	  if (-128 <= value && value < 128) {
	    var cachedObj = Long.INT_CACHE_[value];
	    if (cachedObj) {
	      return cachedObj;
	    }
	  }
	
	  var obj = new Long(value | 0, value < 0 ? -1 : 0);
	  if (-128 <= value && value < 128) {
	    Long.INT_CACHE_[value] = obj;
	  }
	  return obj;
	};
	
	/**
	 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
	 *
	 * @method
	 * @param {number} value the number in question.
	 * @return {Long} the corresponding Long value.
	 */
	Long.fromNumber = function(value) {
	  if (isNaN(value) || !isFinite(value)) {
	    return Long.ZERO;
	  } else if (value <= -Long.TWO_PWR_63_DBL_) {
	    return Long.MIN_VALUE;
	  } else if (value + 1 >= Long.TWO_PWR_63_DBL_) {
	    return Long.MAX_VALUE;
	  } else if (value < 0) {
	    return Long.fromNumber(-value).negate();
	  } else {
	    return new Long(
	               (value % Long.TWO_PWR_32_DBL_) | 0,
	               (value / Long.TWO_PWR_32_DBL_) | 0);
	  }
	};
	
	/**
	 * Returns a Long representing the 64-bit integer that comes by concatenating the given high and low bits. Each is assumed to use 32 bits.
	 *
	 * @method
	 * @param {number} lowBits the low 32-bits.
	 * @param {number} highBits the high 32-bits.
	 * @return {Long} the corresponding Long value.
	 */
	Long.fromBits = function(lowBits, highBits) {
	  return new Long(lowBits, highBits);
	};
	
	/**
	 * Returns a Long representation of the given string, written using the given radix.
	 *
	 * @method
	 * @param {string} str the textual representation of the Long.
	 * @param {number} opt_radix the radix in which the text is written.
	 * @return {Long} the corresponding Long value.
	 */
	Long.fromString = function(str, opt_radix) {
	  if (str.length == 0) {
	    throw Error('number format error: empty string');
	  }
	
	  var radix = opt_radix || 10;
	  if (radix < 2 || 36 < radix) {
	    throw Error('radix out of range: ' + radix);
	  }
	
	  if (str.charAt(0) == '-') {
	    return Long.fromString(str.substring(1), radix).negate();
	  } else if (str.indexOf('-') >= 0) {
	    throw Error('number format error: interior "-" character: ' + str);
	  }
	
	  // Do several (8) digits each time through the loop, so as to
	  // minimize the calls to the very expensive emulated div.
	  var radixToPower = Long.fromNumber(Math.pow(radix, 8));
	
	  var result = Long.ZERO;
	  for (var i = 0; i < str.length; i += 8) {
	    var size = Math.min(8, str.length - i);
	    var value = parseInt(str.substring(i, i + size), radix);
	    if (size < 8) {
	      var power = Long.fromNumber(Math.pow(radix, size));
	      result = result.multiply(power).add(Long.fromNumber(value));
	    } else {
	      result = result.multiply(radixToPower);
	      result = result.add(Long.fromNumber(value));
	    }
	  }
	  return result;
	};
	
	// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
	// from* methods on which they depend.
	
	
	/**
	 * A cache of the Long representations of small integer values.
	 * @type {Object}
	 * @ignore
	 */
	Long.INT_CACHE_ = {};
	
	// NOTE: the compiler should inline these constant values below and then remove
	// these variables, so there should be no runtime penalty for these.
	
	/**
	 * Number used repeated below in calculations.  This must appear before the
	 * first call to any from* function below.
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_16_DBL_ = 1 << 16;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_24_DBL_ = 1 << 24;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_32_DBL_ = Long.TWO_PWR_16_DBL_ * Long.TWO_PWR_16_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_31_DBL_ = Long.TWO_PWR_32_DBL_ / 2;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_48_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_16_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_64_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_32_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Long.TWO_PWR_63_DBL_ = Long.TWO_PWR_64_DBL_ / 2;
	
	/** @type {Long} */
	Long.ZERO = Long.fromInt(0);
	
	/** @type {Long} */
	Long.ONE = Long.fromInt(1);
	
	/** @type {Long} */
	Long.NEG_ONE = Long.fromInt(-1);
	
	/** @type {Long} */
	Long.MAX_VALUE =
	    Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);
	
	/** @type {Long} */
	Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0);
	
	/**
	 * @type {Long}
	 * @ignore
	 */
	Long.TWO_PWR_24_ = Long.fromInt(1 << 24);
	
	/**
	 * Expose.
	 */
	module.exports = Long;
	module.exports.Long = Long;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var inherits = __webpack_require__(1).inherits
	  , MongoError = __webpack_require__(3).MongoError
	  , Readable = __webpack_require__(18).Readable || __webpack_require__(70).Readable
	  , Define = __webpack_require__(13)
	  , CoreCursor = __webpack_require__(17);
	
	/**
	 * @fileOverview The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB
	 * allowing for iteration over the results returned from the underlying query. It supports
	 * one by one document iteration, conversion to an array or can be iterated as a Node 0.10.X
	 * or higher stream
	 *
	 * **AGGREGATIONCURSOR Cannot directly be instantiated**
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Create a collection we want to drop later
	 *   var col = db.collection('createIndexExample1');
	 *   // Insert a bunch of documents
	 *   col.insert([{a:1, b:1}
	 *     , {a:2, b:2}, {a:3, b:3}
	 *     , {a:4, b:4}], {w:1}, function(err, result) {
	 *     test.equal(null, err);
	 *     // Show that duplicate records got dropped
	 *     col.aggregation({}, {cursor: {}}).toArray(function(err, items) {
	 *       test.equal(null, err);
	 *       test.equal(4, items.length);
	 *       db.close();
	 *     });
	 *   });
	 * });
	 */
	
	/**
	 * Namespace provided by the browser.
	 * @external Readable
	 */
	
	/**
	 * Creates a new Aggregation Cursor instance (INTERNAL TYPE, do not instantiate directly)
	 * @class AggregationCursor
	 * @extends external:Readable
	 * @fires AggregationCursor#data
	 * @fires AggregationCursor#end
	 * @fires AggregationCursor#close
	 * @fires AggregationCursor#readable
	 * @return {AggregationCursor} an AggregationCursor instance.
	 */
	var AggregationCursor = function(bson, ns, cmd, options, topology, topologyOptions) {
	  CoreCursor.apply(this, Array.prototype.slice.call(arguments, 0));
	  var state = AggregationCursor.INIT;
	  var streamOptions = {};
	
	  // MaxTimeMS
	  var maxTimeMS = null;
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(10).Promise;
	  }
	
	  // Set up
	  Readable.call(this, {objectMode: true});
	
	  // Internal state
	  this.s = {
	    // MaxTimeMS
	      maxTimeMS: maxTimeMS
	    // State
	    , state: state
	    // Stream options
	    , streamOptions: streamOptions
	    // BSON
	    , bson: bson
	    // Namespace
	    , ns: ns
	    // Command
	    , cmd: cmd
	    // Options
	    , options: options
	    // Topology
	    , topology: topology
	    // Topology Options
	    , topologyOptions: topologyOptions
	    // Promise library
	    , promiseLibrary: promiseLibrary
	  }
	}
	
	/**
	 * AggregationCursor stream data event, fired for each document in the cursor.
	 *
	 * @event AggregationCursor#data
	 * @type {object}
	 */
	
	/**
	 * AggregationCursor stream end event
	 *
	 * @event AggregationCursor#end
	 * @type {null}
	 */
	
	/**
	 * AggregationCursor stream close event
	 *
	 * @event AggregationCursor#close
	 * @type {null}
	 */
	
	/**
	 * AggregationCursor stream readable event
	 *
	 * @event AggregationCursor#readable
	 * @type {null}
	 */
	
	// Inherit from Readable
	inherits(AggregationCursor, Readable);
	
	// Extend the Cursor
	for(var name in CoreCursor.prototype) {
	  AggregationCursor.prototype[name] = CoreCursor.prototype[name];
	}
	
	var define = AggregationCursor.define = new Define('AggregationCursor', AggregationCursor, true);
	
	/**
	 * Set the batch size for the cursor.
	 * @method
	 * @param {number} value The batchSize for the cursor.
	 * @throws {MongoError}
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.batchSize = function(value) {
	  if(this.s.state == AggregationCursor.CLOSED || this.isDead()) throw MongoError.create({message: "Cursor is closed", driver:true });
	  if(typeof value != 'number') throw MongoError.create({message: "batchSize requires an integer", drvier:true });
	  if(this.s.cmd.cursor) this.s.cmd.cursor.batchSize = value;
	  this.setCursorBatchSize(value);
	  return this;
	}
	
	define.classMethod('batchSize', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a geoNear stage to the aggregation pipeline
	 * @method
	 * @param {object} document The geoNear stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.geoNear = function(document) {
	  this.s.cmd.pipeline.push({$geoNear: document});
	  return this;
	}
	
	define.classMethod('geoNear', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a group stage to the aggregation pipeline
	 * @method
	 * @param {object} document The group stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.group = function(document) {
	  this.s.cmd.pipeline.push({$group: document});
	  return this;
	}
	
	define.classMethod('group', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a limit stage to the aggregation pipeline
	 * @method
	 * @param {number} value The state limit value.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.limit = function(value) {
	  this.s.cmd.pipeline.push({$limit: value});
	  return this;
	}
	
	define.classMethod('limit', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a match stage to the aggregation pipeline
	 * @method
	 * @param {object} document The match stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.match = function(document) {
	  this.s.cmd.pipeline.push({$match: document});
	  return this;
	}
	
	define.classMethod('match', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a maxTimeMS stage to the aggregation pipeline
	 * @method
	 * @param {number} value The state maxTimeMS value.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.maxTimeMS = function(value) {
	  if(this.s.topology.lastIsMaster().minWireVersion > 2) {
	    this.s.cmd.maxTimeMS = value;
	  }
	  return this;
	}
	
	define.classMethod('maxTimeMS', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a out stage to the aggregation pipeline
	 * @method
	 * @param {number} destination The destination name.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.out = function(destination) {
	  this.s.cmd.pipeline.push({$out: destination});
	  return this;
	}
	
	define.classMethod('out', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a project stage to the aggregation pipeline
	 * @method
	 * @param {object} document The project stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.project = function(document) {
	  this.s.cmd.pipeline.push({$project: document});
	  return this;
	}
	
	define.classMethod('project', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a lookup stage to the aggregation pipeline
	 * @method
	 * @param {object} document The lookup stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.lookup = function(document) {
	  this.s.cmd.pipeline.push({$lookup: document});
	  return this;
	}
	
	define.classMethod('lookup', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a redact stage to the aggregation pipeline
	 * @method
	 * @param {object} document The redact stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.redact = function(document) {
	  this.s.cmd.pipeline.push({$redact: document});
	  return this;
	}
	
	define.classMethod('redact', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a skip stage to the aggregation pipeline
	 * @method
	 * @param {number} value The state skip value.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.skip = function(value) {
	  this.s.cmd.pipeline.push({$skip: value});
	  return this;
	}
	
	define.classMethod('skip', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a sort stage to the aggregation pipeline
	 * @method
	 * @param {object} document The sort stage document.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.sort = function(document) {
	  this.s.cmd.pipeline.push({$sort: document});
	  return this;
	}
	
	define.classMethod('sort', {callback: false, promise:false, returns: [AggregationCursor]});
	
	/**
	 * Add a unwind stage to the aggregation pipeline
	 * @method
	 * @param {number} field The unwind field name.
	 * @return {AggregationCursor}
	 */
	AggregationCursor.prototype.unwind = function(field) {
	  this.s.cmd.pipeline.push({$unwind: field});
	  return this;
	}
	
	define.classMethod('unwind', {callback: false, promise:false, returns: [AggregationCursor]});
	
	AggregationCursor.prototype.get = AggregationCursor.prototype.toArray;
	
	// Inherited methods
	define.classMethod('toArray', {callback: true, promise:true});
	define.classMethod('each', {callback: true, promise:false});
	define.classMethod('forEach', {callback: true, promise:false});
	define.classMethod('hasNext', {callback: true, promise:true});
	define.classMethod('next', {callback: true, promise:true});
	define.classMethod('close', {callback: true, promise:true});
	define.classMethod('isClosed', {callback: false, promise:false, returns: [Boolean]});
	define.classMethod('rewind', {callback: false, promise:false});
	define.classMethod('bufferedCount', {callback: false, promise:false, returns: [Number]});
	define.classMethod('readBufferedDocuments', {callback: false, promise:false, returns: [Array]});
	
	/**
	 * Get the next available document from the cursor, returns null if no more documents are available.
	 * @function AggregationCursor.prototype.next
	 * @param {AggregationCursor~resultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	
	/**
	 * Check if there is any document still available in the cursor
	 * @function AggregationCursor.prototype.hasNext
	 * @param {AggregationCursor~resultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	
	/**
	 * The callback format for results
	 * @callback AggregationCursor~toArrayResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object[]} documents All the documents the satisfy the cursor.
	 */
	
	/**
	 * Returns an array of documents. The caller is responsible for making sure that there
	 * is enough memory to store the results. Note that the array only contain partial
	 * results when this cursor had been previouly accessed. In that case,
	 * cursor.rewind() can be used to reset the cursor.
	 * @method AggregationCursor.prototype.toArray
	 * @param {AggregationCursor~toArrayResultCallback} [callback] The result callback.
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	
	/**
	 * The callback format for results
	 * @callback AggregationCursor~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {(object|null)} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Iterates over all the documents for this cursor. As with **{cursor.toArray}**,
	 * not all of the elements will be iterated if this cursor had been previouly accessed.
	 * In that case, **{cursor.rewind}** can be used to reset the cursor. However, unlike
	 * **{cursor.toArray}**, the cursor will only hold a maximum of batch size elements
	 * at any given time if batch size is specified. Otherwise, the caller is responsible
	 * for making sure that the entire result can fit the memory.
	 * @method AggregationCursor.prototype.each
	 * @param {AggregationCursor~resultCallback} callback The result callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	/**
	 * Close the cursor, sending a AggregationCursor command and emitting close.
	 * @method AggregationCursor.prototype.close
	 * @param {AggregationCursor~resultCallback} [callback] The result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	
	/**
	 * Is the cursor closed
	 * @method AggregationCursor.prototype.isClosed
	 * @return {boolean}
	 */
	
	/**
	 * Execute the explain for the cursor
	 * @method AggregationCursor.prototype.explain
	 * @param {AggregationCursor~resultCallback} [callback] The result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	
	/**
	 * Clone the cursor
	 * @function AggregationCursor.prototype.clone
	 * @return {AggregationCursor}
	 */
	
	/**
	 * Resets the cursor
	 * @function AggregationCursor.prototype.rewind
	 * @return {AggregationCursor}
	 */
	
	/**
	 * The callback format for the forEach iterator method
	 * @callback AggregationCursor~iteratorCallback
	 * @param {Object} doc An emitted document for the iterator
	 */
	
	/**
	 * The callback error format for the forEach iterator method
	 * @callback AggregationCursor~endCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 */
	
	/*
	 * Iterates over all the documents for this cursor using the iterator, callback pattern.
	 * @method AggregationCursor.prototype.forEach
	 * @param {AggregationCursor~iteratorCallback} iterator The iteration callback.
	 * @param {AggregationCursor~endCallback} callback The end callback.
	 * @throws {MongoError}
	 * @return {null}
	 */
	
	AggregationCursor.INIT = 0;
	AggregationCursor.OPEN = 1;
	AggregationCursor.CLOSED = 2;
	
	module.exports = AggregationCursor;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var MongoError = __webpack_require__(3).MongoError
	  , f = __webpack_require__(1).format;
	
	// The store of ops
	var Store = function(topology, storeOptions) {
	  var self = this;
	  var storedOps = [];
	  storeOptions = storeOptions || {force:false, bufferMaxEntries: -1}
	
	  // Internal state
	  this.s = {
	      storedOps: storedOps
	    , storeOptions: storeOptions
	    , topology: topology
	  }
	
	  Object.defineProperty(this, 'length', {
	    enumerable:true, get: function() { return self.s.storedOps.length; }
	  });
	}
	
	Store.prototype.add = function(opType, ns, ops, options, callback) {
	  if(this.s.storeOptions.force) {
	    return callback(MongoError.create({message: "db closed by application", driver:true}));
	  }
	
	  if(this.s.storeOptions.bufferMaxEntries == 0) {
	    return callback(MongoError.create({message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries), driver:true }));
	  }
	
	  if(this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
	    while(this.s.storedOps.length > 0) {
	      var op = this.s.storedOps.shift();
	      op.c(MongoError.create({message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries), driver:true }));
	    }
	
	    return;
	  }
	
	  this.s.storedOps.push({t: opType, n: ns, o: ops, op: options, c: callback})
	}
	
	Store.prototype.addObjectAndMethod = function(opType, object, method, params, callback) {
	  if(this.s.storeOptions.force) {
	    return callback(MongoError.create({message: "db closed by application", driver:true }));
	  }
	
	  if(this.s.storeOptions.bufferMaxEntries == 0) {
	    return callback(MongoError.create({message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries), driver:true }));
	  }
	
	  if(this.s.storeOptions.bufferMaxEntries > 0 && this.s.storedOps.length > this.s.storeOptions.bufferMaxEntries) {
	    while(this.s.storedOps.length > 0) {
	      var op = this.s.storedOps.shift();
	      op.c(MongoError.create({message: f("no connection available for operation and number of stored operation > %s", this.s.storeOptions.bufferMaxEntries), driver:true }));
	    }
	
	    return;
	  }
	
	  this.s.storedOps.push({t: opType, m: method, o: object, p: params, c: callback})
	}
	
	Store.prototype.flush = function(err) {
	  while(this.s.storedOps.length > 0) {
	    this.s.storedOps.shift().c(err || MongoError.create({message: f("no connection available for operation"), driver:true }));
	  }
	}
	
	var primaryOptions = ['primary', 'primaryPreferred', 'nearest', 'secondaryPreferred'];
	var secondaryOptions = ['secondary', 'secondaryPreferred'];
	
	Store.prototype.execute = function(options) {
	  options = options || {};
	  // Get current ops
	  var ops = this.s.storedOps;
	  // Reset the ops
	  this.s.storedOps = [];
	
	  // Unpack options
	  var executePrimary = typeof options.executePrimary === 'boolean'
	    ? options.executePrimary : true;
	  var executeSecondary = typeof options.executeSecondary === 'boolean'
	    ? options.executeSecondary : true;
	
	  // Execute all the stored ops
	  while(ops.length > 0) {
	    var op = ops.shift();
	
	    if(op.t == 'cursor') {
	      if(executePrimary && executeSecondary) {
	        op.o[op.m].apply(op.o, op.p);
	      } else if(executePrimary && op.o.options
	        && op.o.options.readPreference
	        && primaryOptions.indexOf(op.o.options.readPreference.mode) != -1) {
	          op.o[op.m].apply(op.o, op.p);
	      } else if(!executePrimary && executeSecondary && op.o.options
	        && op.o.options.readPreference
	        && secondaryOptions.indexOf(op.o.options.readPreference.mode) != -1) {
	          op.o[op.m].apply(op.o, op.p);
	      }
	    } else if(op.t == 'auth') {
	      this.s.topology[op.t].apply(this.s.topology, op.o);
	    } else {
	      if(executePrimary && executeSecondary) {
	        this.s.topology[op.t](op.n, op.o, op.op, op.c);
	      } else if(executePrimary && op.op && op.op.readPreference
	        && primaryOptions.indexOf(op.op.readPreference.mode) != -1) {
	          this.s.topology[op.t](op.n, op.o, op.op, op.c);
	      } else if(!executePrimary && executeSecondary && op.op && op.op.readPreference
	        && secondaryOptions.indexOf(op.op.readPreference.mode) != -1) {
	          this.s.topology[op.t](op.n, op.o, op.op, op.c);
	      }
	    }
	  }
	}
	
	Store.prototype.all = function() {
	  return this.s.storedOps;
	}
	
	// Server capabilities
	var ServerCapabilities = function(ismaster) {
	  var setup_get_property = function(object, name, value) {
	    Object.defineProperty(object, name, {
	        enumerable: true
	      , get: function () { return value; }
	    });
	  }
	
	  // Capabilities
	  var aggregationCursor = false;
	  var writeCommands = false;
	  var textSearch = false;
	  var authCommands = false;
	  var listCollections = false;
	  var listIndexes = false;
	  var maxNumberOfDocsInBatch = ismaster.maxWriteBatchSize || 1000;
	  var commandsTakeWriteConcern = false;
	  var commandsTakeCollation = false;
	
	  if(ismaster.minWireVersion >= 0) {
	    textSearch = true;
	  }
	
	  if(ismaster.maxWireVersion >= 1) {
	    aggregationCursor = true;
	    authCommands = true;
	  }
	
	  if(ismaster.maxWireVersion >= 2) {
	    writeCommands = true;
	  }
	
	  if(ismaster.maxWireVersion >= 3) {
	    listCollections = true;
	    listIndexes = true;
	  }
	
	  if(ismaster.maxWireVersion >= 5) {
	    commandsTakeWriteConcern = true;
	    commandsTakeCollation = true;
	  }
	
	  // If no min or max wire version set to 0
	  if(ismaster.minWireVersion == null) {
	    ismaster.minWireVersion = 0;
	  }
	
	  if(ismaster.maxWireVersion == null) {
	    ismaster.maxWireVersion = 0;
	  }
	
	  // Map up read only parameters
	  setup_get_property(this, "hasAggregationCursor", aggregationCursor);
	  setup_get_property(this, "hasWriteCommands", writeCommands);
	  setup_get_property(this, "hasTextSearch", textSearch);
	  setup_get_property(this, "hasAuthCommands", authCommands);
	  setup_get_property(this, "hasListCollectionsCommand", listCollections);
	  setup_get_property(this, "hasListIndexesCommand", listIndexes);
	  setup_get_property(this, "minWireVersion", ismaster.minWireVersion);
	  setup_get_property(this, "maxWireVersion", ismaster.maxWireVersion);
	  setup_get_property(this, "maxNumberOfDocsInBatch", maxNumberOfDocsInBatch);
	  setup_get_property(this, "commandsTakeWriteConcern", commandsTakeWriteConcern);
	  setup_get_property(this, "commandsTakeCollation", commandsTakeCollation);
	}
	
	exports.Store = Store;
	exports.ServerCapabilities = ServerCapabilities;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * ignore
	 */
	
	var driver;
	
	if (typeof window === 'undefined') {
	  driver = __webpack_require__(91);
	  if (global.MONGOOSE_DRIVER_PATH) {
	    driver = __webpack_require__(212)(global.MONGOOSE_DRIVER_PATH);
	  }
	} else {
	  driver = __webpack_require__(62);
	}
	
	/*!
	 * ignore
	 */
	
	module.exports = driver;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint no-func-assign: 1 */
	
	/*!
	 * Module dependencies.
	 */
	
	var Document = __webpack_require__(132)();
	var EventEmitter = __webpack_require__(6).EventEmitter;
	var PromiseProvider = __webpack_require__(14);
	
	/**
	 * EmbeddedDocument constructor.
	 *
	 * @param {Object} obj js object returned from the db
	 * @param {MongooseDocumentArray} parentArr the parent array of this document
	 * @param {Boolean} skipId
	 * @inherits Document
	 * @api private
	 */
	
	function EmbeddedDocument(obj, parentArr, skipId, fields, index) {
	  if (parentArr) {
	    this.__parentArray = parentArr;
	    this.__parent = parentArr._parent;
	  } else {
	    this.__parentArray = undefined;
	    this.__parent = undefined;
	  }
	  this.__index = index;
	
	  Document.call(this, obj, fields, skipId);
	
	  var _this = this;
	  this.on('isNew', function(val) {
	    _this.isNew = val;
	  });
	
	  _this.on('save', function() {
	    _this.constructor.emit('save', _this);
	  });
	}
	
	/*!
	 * Inherit from Document
	 */
	EmbeddedDocument.prototype = Object.create(Document.prototype);
	EmbeddedDocument.prototype.constructor = EmbeddedDocument;
	
	for (var i in EventEmitter.prototype) {
	  EmbeddedDocument[i] = EventEmitter.prototype[i];
	}
	
	EmbeddedDocument.prototype.toBSON = function() {
	  return this.toObject({
	    transform: false,
	    virtuals: false,
	    _skipDepopulateTopLevel: true,
	    depopulate: true,
	    flattenDecimals: false
	  });
	};
	
	/**
	 * Marks the embedded doc modified.
	 *
	 * ####Example:
	 *
	 *     var doc = blogpost.comments.id(hexstring);
	 *     doc.mixed.type = 'changed';
	 *     doc.markModified('mixed.type');
	 *
	 * @param {String} path the path which changed
	 * @api public
	 * @receiver EmbeddedDocument
	 */
	
	EmbeddedDocument.prototype.markModified = function(path) {
	  this.$__.activePaths.modify(path);
	  if (!this.__parentArray) {
	    return;
	  }
	
	  if (this.isNew) {
	    // Mark the WHOLE parent array as modified
	    // if this is a new document (i.e., we are initializing
	    // a document),
	    this.__parentArray._markModified();
	  } else {
	    this.__parentArray._markModified(this, path);
	  }
	};
	
	/*!
	 * ignore
	 */
	
	EmbeddedDocument.prototype.populate = function() {
	  throw new Error('Mongoose does not support calling populate() on nested ' +
	    'docs. Instead of `doc.arr[0].populate("path")`, use ' +
	    '`doc.populate("arr.0.path")`');
	};
	
	/**
	 * Used as a stub for [hooks.js](https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3)
	 *
	 * ####NOTE:
	 *
	 * _This is a no-op. Does not actually save the doc to the db._
	 *
	 * @param {Function} [fn]
	 * @return {Promise} resolved Promise
	 * @api private
	 */
	
	EmbeddedDocument.prototype.save = function(fn) {
	  var Promise = PromiseProvider.get();
	  return new Promise.ES6(function(resolve) {
	    fn && fn();
	    resolve();
	  });
	};
	
	/*!
	 * Registers remove event listeners for triggering
	 * on subdocuments.
	 *
	 * @param {EmbeddedDocument} sub
	 * @api private
	 */
	
	function registerRemoveListener(sub) {
	  var owner = sub.ownerDocument();
	
	  function emitRemove() {
	    owner.removeListener('save', emitRemove);
	    owner.removeListener('remove', emitRemove);
	    sub.emit('remove', sub);
	    sub.constructor.emit('remove', sub);
	    owner = sub = null;
	  }
	
	  owner.on('save', emitRemove);
	  owner.on('remove', emitRemove);
	}
	
	/**
	 * Removes the subdocument from its parent array.
	 *
	 * @param {Object} [options]
	 * @param {Function} [fn]
	 * @api public
	 */
	
	EmbeddedDocument.prototype.remove = function(options, fn) {
	  if ( typeof options === 'function' && !fn ) {
	    fn = options;
	    options = undefined;
	  }
	  if (!this.__parentArray || (options && options.noop)) {
	    fn && fn(null);
	    return this;
	  }
	
	  var _id;
	  if (!this.willRemove) {
	    _id = this._doc._id;
	    if (!_id) {
	      throw new Error('For your own good, Mongoose does not know ' +
	          'how to remove an EmbeddedDocument that has no _id');
	    }
	    this.__parentArray.pull({_id: _id});
	    this.willRemove = true;
	    registerRemoveListener(this);
	  }
	
	  if (fn) {
	    fn(null);
	  }
	
	  return this;
	};
	
	/**
	 * Override #update method of parent documents.
	 * @api private
	 */
	
	EmbeddedDocument.prototype.update = function() {
	  throw new Error('The #update method is not available on EmbeddedDocuments');
	};
	
	/**
	 * Helper for console.log
	 *
	 * @api public
	 */
	
	EmbeddedDocument.prototype.inspect = function() {
	  return this.toObject({
	    transform: false,
	    retainKeyOrder: true,
	    virtuals: false,
	    flattenDecimals: false
	  });
	};
	
	/**
	 * Marks a path as invalid, causing validation to fail.
	 *
	 * @param {String} path the field to invalidate
	 * @param {String|Error} err error which states the reason `path` was invalid
	 * @return {Boolean}
	 * @api public
	 */
	
	EmbeddedDocument.prototype.invalidate = function(path, err, val, first) {
	  if (!this.__parent) {
	    Document.prototype.invalidate.call(this, path, err, val);
	    if (err.$isValidatorError) {
	      return true;
	    }
	    throw err;
	  }
	
	  var index = this.__index;
	  if (typeof index !== 'undefined') {
	    var parentPath = this.__parentArray._path;
	    var fullPath = [parentPath, index, path].join('.');
	    this.__parent.invalidate(fullPath, err, val);
	  }
	
	  if (first) {
	    this.$__.validationError = this.ownerDocument().$__.validationError;
	  }
	
	  return true;
	};
	
	/**
	 * Marks a path as valid, removing existing validation errors.
	 *
	 * @param {String} path the field to mark as valid
	 * @api private
	 * @method $markValid
	 * @receiver EmbeddedDocument
	 */
	
	EmbeddedDocument.prototype.$markValid = function(path) {
	  if (!this.__parent) {
	    return;
	  }
	
	  var index = this.__index;
	  if (typeof index !== 'undefined') {
	    var parentPath = this.__parentArray._path;
	    var fullPath = [parentPath, index, path].join('.');
	    this.__parent.$markValid(fullPath);
	  }
	};
	
	/**
	 * Checks if a path is invalid
	 *
	 * @param {String} path the field to check
	 * @api private
	 * @method $isValid
	 * @receiver EmbeddedDocument
	 */
	
	EmbeddedDocument.prototype.$isValid = function(path) {
	  var index = this.__index;
	  if (typeof index !== 'undefined' && this.__parent) {
	    return !this.__parent.$__.validationError ||
	      !this.__parent.$__.validationError.errors[this.$__fullPath(path)];
	  }
	
	  return true;
	};
	
	/**
	 * Returns the top level document of this sub-document.
	 *
	 * @return {Document}
	 */
	
	EmbeddedDocument.prototype.ownerDocument = function() {
	  if (this.$__.ownerDocument) {
	    return this.$__.ownerDocument;
	  }
	
	  var parent = this.__parent;
	  if (!parent) {
	    return this;
	  }
	
	  while (parent.__parent || parent.$parent) {
	    parent = parent.__parent || parent.$parent;
	  }
	
	  this.$__.ownerDocument = parent;
	  return this.$__.ownerDocument;
	};
	
	/**
	 * Returns the full path to this document. If optional `path` is passed, it is appended to the full path.
	 *
	 * @param {String} [path]
	 * @return {String}
	 * @api private
	 * @method $__fullPath
	 * @memberOf EmbeddedDocument
	 */
	
	EmbeddedDocument.prototype.$__fullPath = function(path) {
	  if (!this.$__.fullPath) {
	    var parent = this; // eslint-disable-line consistent-this
	    if (!parent.__parent) {
	      return path;
	    }
	
	    var paths = [];
	    while (parent.__parent || parent.$parent) {
	      if (parent.__parent) {
	        paths.unshift(parent.__parentArray._path);
	      } else {
	        paths.unshift(parent.$basePath);
	      }
	      parent = parent.__parent || parent.$parent;
	    }
	
	    this.$__.fullPath = paths.join('.');
	
	    if (!this.$__.ownerDocument) {
	      // optimization
	      this.$__.ownerDocument = parent;
	    }
	  }
	
	  return path
	      ? this.$__.fullPath + '.' + path
	      : this.$__.fullPath;
	};
	
	/**
	 * Returns this sub-documents parent document.
	 *
	 * @api public
	 */
	
	EmbeddedDocument.prototype.parent = function() {
	  return this.__parent;
	};
	
	/**
	 * Returns this sub-documents parent array.
	 *
	 * @api public
	 */
	
	EmbeddedDocument.prototype.parentArray = function() {
	  return this.__parentArray;
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = EmbeddedDocument;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	
	/*!
	 * Module exports.
	 */
	
	exports.Array = __webpack_require__(101);
	exports.Buffer = __webpack_require__(243);
	
	exports.Document = // @deprecate
	exports.Embedded = __webpack_require__(30);
	
	exports.DocumentArray = __webpack_require__(46);
	exports.Decimal128 = __webpack_require__(102);
	exports.ObjectId = __webpack_require__(24);
	
	exports.Subdocument = __webpack_require__(147);


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 * @ignore
	 */
	
	// Test if we're in Node via presence of "global" not absence of "window"
	// to support hybrid environments like Electron
	if(typeof global !== 'undefined') {
	  var Buffer = __webpack_require__(153).Buffer; // TODO just use global Buffer
	}
	
	/**
	 * A class representation of the BSON Binary type.
	 *
	 * Sub types
	 *  - **BSON.BSON_BINARY_SUBTYPE_DEFAULT**, default BSON type.
	 *  - **BSON.BSON_BINARY_SUBTYPE_FUNCTION**, BSON function type.
	 *  - **BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY**, BSON byte array type.
	 *  - **BSON.BSON_BINARY_SUBTYPE_UUID**, BSON uuid type.
	 *  - **BSON.BSON_BINARY_SUBTYPE_MD5**, BSON md5 type.
	 *  - **BSON.BSON_BINARY_SUBTYPE_USER_DEFINED**, BSON user defined type.
	 *
	 * @class
	 * @param {Buffer} buffer a buffer object containing the binary data.
	 * @param {Number} [subType] the option binary type.
	 * @return {Binary}
	 */
	function Binary(buffer, subType) {
	  if(!(this instanceof Binary)) return new Binary(buffer, subType);
	
	  this._bsontype = 'Binary';
	
	  if(buffer instanceof Number) {
	    this.sub_type = buffer;
	    this.position = 0;
	  } else {
	    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
	    this.position = 0;
	  }
	
	  if(buffer != null && !(buffer instanceof Number)) {
	    // Only accept Buffer, Uint8Array or Arrays
	    if(typeof buffer == 'string') {
	      // Different ways of writing the length of the string for the different types
	      if(typeof Buffer != 'undefined') {
	        this.buffer = new Buffer(buffer);
	      } else if(typeof Uint8Array != 'undefined' || (Object.prototype.toString.call(buffer) == '[object Array]')) {
	        this.buffer = writeStringToArray(buffer);
	      } else {
	        throw new Error("only String, Buffer, Uint8Array or Array accepted");
	      }
	    } else {
	      this.buffer = buffer;
	    }
	    this.position = buffer.length;
	  } else {
	    if(typeof Buffer != 'undefined') {
	      this.buffer =  new Buffer(Binary.BUFFER_SIZE);
	    } else if(typeof Uint8Array != 'undefined'){
	      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
	    } else {
	      this.buffer = new Array(Binary.BUFFER_SIZE);
	    }
	    // Set position to start of buffer
	    this.position = 0;
	  }
	};
	
	/**
	 * Updates this binary with byte_value.
	 *
	 * @method
	 * @param {string} byte_value a single byte we wish to write.
	 */
	Binary.prototype.put = function put(byte_value) {
	  // If it's a string and a has more than one character throw an error
	  if(byte_value['length'] != null && typeof byte_value != 'number' && byte_value.length != 1) throw new Error("only accepts single character String, Uint8Array or Array");
	  if(typeof byte_value != 'number' && byte_value < 0 || byte_value > 255) throw new Error("only accepts number in a valid unsigned byte range 0-255");
	
	  // Decode the byte value once
	  var decoded_byte = null;
	  if(typeof byte_value == 'string') {
	    decoded_byte = byte_value.charCodeAt(0);
	  } else if(byte_value['length'] != null) {
	    decoded_byte = byte_value[0];
	  } else {
	    decoded_byte = byte_value;
	  }
	
	  if(this.buffer.length > this.position) {
	    this.buffer[this.position++] = decoded_byte;
	  } else {
	    if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {
	      // Create additional overflow buffer
	      var buffer = new Buffer(Binary.BUFFER_SIZE + this.buffer.length);
	      // Combine the two buffers together
	      this.buffer.copy(buffer, 0, 0, this.buffer.length);
	      this.buffer = buffer;
	      this.buffer[this.position++] = decoded_byte;
	    } else {
	      var buffer = null;
	      // Create a new buffer (typed or normal array)
	      if(Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') {
	        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));
	      } else {
	        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);
	      }
	
	      // We need to copy all the content to the new array
	      for(var i = 0; i < this.buffer.length; i++) {
	        buffer[i] = this.buffer[i];
	      }
	
	      // Reassign the buffer
	      this.buffer = buffer;
	      // Write the byte
	      this.buffer[this.position++] = decoded_byte;
	    }
	  }
	};
	
	/**
	 * Writes a buffer or string to the binary.
	 *
	 * @method
	 * @param {(Buffer|string)} string a string or buffer to be written to the Binary BSON object.
	 * @param {number} offset specify the binary of where to write the content.
	 * @return {null}
	 */
	Binary.prototype.write = function write(string, offset) {
	  offset = typeof offset == 'number' ? offset : this.position;
	
	  // If the buffer is to small let's extend the buffer
	  if(this.buffer.length < offset + string.length) {
	    var buffer = null;
	    // If we are in node.js
	    if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {
	      buffer = new Buffer(this.buffer.length + string.length);
	      this.buffer.copy(buffer, 0, 0, this.buffer.length);
	    } else if(Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') {
	      // Create a new buffer
	      buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length))
	      // Copy the content
	      for(var i = 0; i < this.position; i++) {
	        buffer[i] = this.buffer[i];
	      }
	    }
	
	    // Assign the new buffer
	    this.buffer = buffer;
	  }
	
	  if(typeof Buffer != 'undefined' && Buffer.isBuffer(string) && Buffer.isBuffer(this.buffer)) {
	    string.copy(this.buffer, offset, 0, string.length);
	    this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;
	    // offset = string.length
	  } else if(typeof Buffer != 'undefined' && typeof string == 'string' && Buffer.isBuffer(this.buffer)) {
	    this.buffer.write(string, offset, 'binary');
	    this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;
	    // offset = string.length;
	  } else if(Object.prototype.toString.call(string) == '[object Uint8Array]'
	    || Object.prototype.toString.call(string) == '[object Array]' && typeof string != 'string') {
	    for(var i = 0; i < string.length; i++) {
	      this.buffer[offset++] = string[i];
	    }
	
	    this.position = offset > this.position ? offset : this.position;
	  } else if(typeof string == 'string') {
	    for(var i = 0; i < string.length; i++) {
	      this.buffer[offset++] = string.charCodeAt(i);
	    }
	
	    this.position = offset > this.position ? offset : this.position;
	  }
	};
	
	/**
	 * Reads **length** bytes starting at **position**.
	 *
	 * @method
	 * @param {number} position read from the given position in the Binary.
	 * @param {number} length the number of bytes to read.
	 * @return {Buffer}
	 */
	Binary.prototype.read = function read(position, length) {
	  length = length && length > 0
	    ? length
	    : this.position;
	
	  // Let's return the data based on the type we have
	  if(this.buffer['slice']) {
	    return this.buffer.slice(position, position + length);
	  } else {
	    // Create a buffer to keep the result
	    var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
	    for(var i = 0; i < length; i++) {
	      buffer[i] = this.buffer[position++];
	    }
	  }
	  // Return the buffer
	  return buffer;
	};
	
	/**
	 * Returns the value of this binary as a string.
	 *
	 * @method
	 * @return {string}
	 */
	Binary.prototype.value = function value(asRaw) {
	  asRaw = asRaw == null ? false : asRaw;
	
	  // Optimize to serialize for the situation where the data == size of buffer
	  if(asRaw && typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer) && this.buffer.length == this.position)
	    return this.buffer;
	
	  // If it's a node.js buffer object
	  if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {
	    return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString('binary', 0, this.position);
	  } else {
	    if(asRaw) {
	      // we support the slice command use it
	      if(this.buffer['slice'] != null) {
	        return this.buffer.slice(0, this.position);
	      } else {
	        // Create a new buffer to copy content to
	        var newBuffer = Object.prototype.toString.call(this.buffer) == '[object Uint8Array]' ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);
	        // Copy content
	        for(var i = 0; i < this.position; i++) {
	          newBuffer[i] = this.buffer[i];
	        }
	        // Return the buffer
	        return newBuffer;
	      }
	    } else {
	      return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
	    }
	  }
	};
	
	/**
	 * Length.
	 *
	 * @method
	 * @return {number} the length of the binary.
	 */
	Binary.prototype.length = function length() {
	  return this.position;
	};
	
	/**
	 * @ignore
	 */
	Binary.prototype.toJSON = function() {
	  return this.buffer != null ? this.buffer.toString('base64') : '';
	}
	
	/**
	 * @ignore
	 */
	Binary.prototype.toString = function(format) {
	  return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : '';
	}
	
	/**
	 * Binary default subtype
	 * @ignore
	 */
	var BSON_BINARY_SUBTYPE_DEFAULT = 0;
	
	/**
	 * @ignore
	 */
	var writeStringToArray = function(data) {
	  // Create a buffer
	  var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);
	  // Write the content to the buffer
	  for(var i = 0; i < data.length; i++) {
	    buffer[i] = data.charCodeAt(i);
	  }
	  // Write the string to the buffer
	  return buffer;
	}
	
	/**
	 * Convert Array ot Uint8Array to Binary String
	 *
	 * @ignore
	 */
	var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
	  var result = "";
	  for(var i = startIndex; i < endIndex; i++) {
	   result = result + String.fromCharCode(byteArray[i]);
	  }
	  return result;
	};
	
	Binary.BUFFER_SIZE = 256;
	
	/**
	 * Default BSON type
	 *
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_DEFAULT = 0;
	/**
	 * Function BSON type
	 *
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_FUNCTION = 1;
	/**
	 * Byte Array BSON type
	 *
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_BYTE_ARRAY = 2;
	/**
	 * OLD UUID BSON type
	 *
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_UUID_OLD = 3;
	/**
	 * UUID BSON type
	 *
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_UUID = 4;
	/**
	 * MD5 BSON type
	 *
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_MD5 = 5;
	/**
	 * User BSON type
	 *
	 * @classconstant SUBTYPE_DEFAULT
	 **/
	Binary.SUBTYPE_USER_DEFINED = 128;
	
	/**
	 * Expose.
	 */
	module.exports = Binary;
	module.exports.Binary = Binary;


/***/ }),
/* 33 */
/***/ (function(module, exports) {

	/**
	 * A class representation of the BSON Code type.
	 *
	 * @class
	 * @param {(string|function)} code a string or function.
	 * @param {Object} [scope] an optional scope for the function.
	 * @return {Code}
	 */
	var Code = function Code(code, scope) {
	  if(!(this instanceof Code)) return new Code(code, scope);
	  this._bsontype = 'Code';
	  this.code = code;
	  this.scope = scope;
	};
	
	/**
	 * @ignore
	 */
	Code.prototype.toJSON = function() {
	  return {scope:this.scope, code:this.code};
	}
	
	module.exports = Code;
	module.exports.Code = Code;


/***/ }),
/* 34 */
/***/ (function(module, exports) {

	/**
	 * A class representation of the BSON DBRef type.
	 *
	 * @class
	 * @param {string} namespace the collection name.
	 * @param {ObjectID} oid the reference ObjectID.
	 * @param {string} [db] optional db name, if omitted the reference is local to the current db.
	 * @return {DBRef}
	 */
	function DBRef(namespace, oid, db) {
	  if(!(this instanceof DBRef)) return new DBRef(namespace, oid, db);
	  
	  this._bsontype = 'DBRef';
	  this.namespace = namespace;
	  this.oid = oid;
	  this.db = db;
	};
	
	/**
	 * @ignore
	 * @api private
	 */
	DBRef.prototype.toJSON = function() {
	  return {
	    '$ref':this.namespace,
	    '$id':this.oid,
	    '$db':this.db == null ? '' : this.db
	  };
	}
	
	module.exports = DBRef;
	module.exports.DBRef = DBRef;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict"
	
	var Long = __webpack_require__(26);
	
	var PARSE_STRING_REGEXP = /^(\+|\-)?(\d+|(\d*\.\d*))?(E|e)?([\-\+])?(\d+)?$/;
	var PARSE_INF_REGEXP = /^(\+|\-)?(Infinity|inf)$/i;
	var PARSE_NAN_REGEXP = /^(\+|\-)?NaN$/i;
	
	var EXPONENT_MAX = 6111;
	var EXPONENT_MIN = -6176;
	var EXPONENT_BIAS = 6176;
	var MAX_DIGITS = 34;
	
	// Nan value bits as 32 bit values (due to lack of longs)
	var NAN_BUFFER = [0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse();
	// Infinity value bits 32 bit values (due to lack of longs)
	var INF_NEGATIVE_BUFFER = [0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse();
	var INF_POSITIVE_BUFFER = [0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse();
	
	var EXPONENT_REGEX = /^([\-\+])?(\d+)?$/;
	
	
	// Detect if the value is a digit
	var isDigit = function(value) {
	  return !isNaN(parseInt(value, 10));
	}
	
	// Divide two uint128 values
	var divideu128 = function(value) {
	  var DIVISOR = Long.fromNumber(1000 * 1000 * 1000);
	  var _rem = Long.fromNumber(0);
	  var i = 0;
	
	  if(!value.parts[0] && !value.parts[1] &&
	     !value.parts[2] && !value.parts[3]) {
	    return { quotient: value, rem: _rem };
	  }
	
	  for(var i = 0; i <= 3; i++) {
	    // Adjust remainder to match value of next dividend
	    _rem = _rem.shiftLeft(32);
	    // Add the divided to _rem
	    _rem = _rem.add(new Long(value.parts[i], 0));
	    value.parts[i] = _rem.div(DIVISOR).low_;
	    _rem = _rem.modulo(DIVISOR);
	  }
	
	  return { quotient: value, rem: _rem };
	}
	
	// Multiply two Long values and return the 128 bit value
	var multiply64x2 = function(left, right) {
	  if(!left && !right) {
	    return {high: Long.fromNumber(0), low: Long.fromNumber(0)};
	  }
	
	  var leftHigh = left.shiftRightUnsigned(32);
	  var leftLow = new Long(left.getLowBits(), 0);
	  var rightHigh = right.shiftRightUnsigned(32);
	  var rightLow = new Long(right.getLowBits(), 0);
	
	  var productHigh = leftHigh.multiply(rightHigh);
	  var productMid = leftHigh.multiply(rightLow);
	  var productMid2 = leftLow.multiply(rightHigh);
	  var productLow = leftLow.multiply(rightLow);
	
	  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
	  productMid = new Long(productMid.getLowBits(), 0)
	                .add(productMid2)
	                .add(productLow.shiftRightUnsigned(32));
	
	  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
	  productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));
	
	  // Return the 128 bit result
	  return {high: productHigh, low: productLow};
	}
	
	var lessThan = function(left, right) {
	  // Make values unsigned
	  var uhleft = left.high_ >>> 0;
	  var uhright = right.high_ >>> 0;
	
	  // Compare high bits first
	  if(uhleft < uhright) {
	    return true
	  } else if(uhleft == uhright) {
	    var ulleft = left.low_ >>> 0;
	    var ulright = right.low_ >>> 0;
	    if(ulleft < ulright) return true;
	  }
	
	  return false;
	}
	
	var longtoHex = function(value) {
	  var buffer = new Buffer(8);
	  var index = 0;
	  // Encode the low 64 bits of the decimal
	  // Encode low bits
	  buffer[index++] = value.low_ & 0xff;
	  buffer[index++] = (value.low_ >> 8) & 0xff;
	  buffer[index++] = (value.low_ >> 16) & 0xff;
	  buffer[index++] = (value.low_ >> 24) & 0xff;
	  // Encode high bits
	  buffer[index++] = value.high_ & 0xff;
	  buffer[index++] = (value.high_ >> 8) & 0xff;
	  buffer[index++] = (value.high_ >> 16) & 0xff;
	  buffer[index++] = (value.high_ >> 24) & 0xff;
	  return buffer.reverse().toString('hex');
	}
	
	var int32toHex = function(value) {
	  var buffer = new Buffer(4);
	  var index = 0;
	  // Encode the low 64 bits of the decimal
	  // Encode low bits
	  buffer[index++] = value & 0xff;
	  buffer[index++] = (value >> 8) & 0xff;
	  buffer[index++] = (value >> 16) & 0xff;
	  buffer[index++] = (value >> 24) & 0xff;
	  return buffer.reverse().toString('hex');
	}
	
	var Decimal128 = function(bytes) {
	  this._bsontype = 'Decimal128';
	  this.bytes = bytes;
	}
	
	Decimal128.fromString = function(string) {
	  // Parse state tracking
	  var isNegative = false;
	  var sawRadix = false;
	  var foundNonZero = false;
	
	  // Total number of significant digits (no leading or trailing zero)
	  var significantDigits = 0;
	  // Total number of significand digits read
	  var nDigitsRead = 0;
	  // Total number of digits (no leading zeros)
	  var nDigits = 0;
	  // The number of the digits after radix
	  var radixPosition = 0;
	  // The index of the first non-zero in *str*
	  var firstNonZero = 0;
	
	  // Digits Array
	  var digits = [0];
	  // The number of digits in digits
	  var nDigitsStored = 0;
	  // Insertion pointer for digits
	  var digitsInsert = 0;
	  // The index of the first non-zero digit
	  var firstDigit = 0;
	  // The index of the last digit
	  var lastDigit = 0;
	
	  // Exponent
	  var exponent = 0;
	  // loop index over array
	  var i = 0;
	  // The high 17 digits of the significand
	  var significandHigh = [0, 0];
	  // The low 17 digits of the significand
	  var significandLow = [0, 0];
	  // The biased exponent
	  var biasedExponent = 0;
	
	  // Read index
	  var index = 0;
	
	  // Trim the string
	  string = string.trim();
	
	  // Results
	  var stringMatch = string.match(PARSE_STRING_REGEXP);
	  var infMatch = string.match(PARSE_INF_REGEXP);
	  var nanMatch = string.match(PARSE_NAN_REGEXP);
	
	  // Validate the string
	  if(!stringMatch
	    && ! infMatch
	    && ! nanMatch || string.length == 0) {
	      throw new Error("" + string + " not a valid Decimal128 string");
	  }
	
	  // Check if we have an illegal exponent format
	  if(stringMatch && stringMatch[4] && stringMatch[2] === undefined) {
	    throw new Error("" + string + " not a valid Decimal128 string");
	  }
	
	  // Get the negative or positive sign
	  if(string[index] == '+' || string[index] == '-') {
	    isNegative = string[index++] == '-';
	  }
	
	  // Check if user passed Infinity or NaN
	  if(!isDigit(string[index]) && string[index] != '.') {
	    if(string[index] == 'i' || string[index] == 'I') {
	      return new Decimal128(new Buffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
	    } else if(string[index] == 'N') {
	      return new Decimal128(new Buffer(NAN_BUFFER));
	    }
	  }
	
	  // Read all the digits
	  while(isDigit(string[index]) || string[index] == '.') {
	    if(string[index] == '.') {
	      if(sawRadix) {
	        return new Decimal128(new Buffer(NAN_BUFFER));
	      }
	
	      sawRadix = true;
	      index = index + 1;
	      continue;
	    }
	
	    if(nDigitsStored < 34) {
	      if(string[index] != '0' || foundNonZero) {
	        if(!foundNonZero) {
	          firstNonZero = nDigitsRead;
	        }
	
	        foundNonZero = true;
	
	        // Only store 34 digits
	        digits[digitsInsert++] = parseInt(string[index], 10);
	        nDigitsStored = nDigitsStored + 1;
	      }
	    }
	
	    if(foundNonZero) {
	      nDigits = nDigits + 1;
	    }
	
	    if(sawRadix) {
	      radixPosition = radixPosition + 1;
	    }
	
	    nDigitsRead = nDigitsRead + 1;
	    index = index + 1;
	  }
	
	  if(sawRadix && !nDigitsRead) {
	    throw new Error("" + string + " not a valid Decimal128 string");
	  }
	
	  // Read exponent if exists
	  if(string[index] == 'e' || string[index] == 'E') {
	    // Read exponent digits
	    var match = string.substr(++index).match(EXPONENT_REGEX);
	
	    // No digits read
	    if(!match || !match[2]) {
	      return new Decimal128(new Buffer(NAN_BUFFER));
	    }
	
	    // Get exponent
	    exponent = parseInt(match[0], 10);
	
	    // Adjust the index
	    index = index + match[0].length;
	  }
	
	  // Return not a number
	  if(string[index]) {
	    return new Decimal128(new Buffer(NAN_BUFFER));
	  }
	
	  // Done reading input
	  // Find first non-zero digit in digits
	  firstDigit = 0;
	
	  if(!nDigitsStored) {
	    firstDigit = 0;
	    lastDigit = 0;
	    digits[0] = 0;
	    nDigits = 1;
	    nDigitsStored = 1;
	    significantDigits = 0;
	  } else {
	    lastDigit = nDigitsStored - 1;
	    significantDigits = nDigits;
	
	    if(exponent != 0 && significantDigits != 1) {
	      while(string[firstNonZero + significantDigits - 1] == '0') {
	        significantDigits = significantDigits - 1;
	      }
	    }
	  }
	
	  // Normalization of exponent
	  // Correct exponent based on radix position, and shift significand as needed
	  // to represent user input
	
	  // Overflow prevention
	  if(exponent <= radixPosition && radixPosition - exponent > (1 << 14)) {
	    exponent = EXPONENT_MIN;
	  } else {
	    exponent = exponent - radixPosition;
	  }
	
	  // Attempt to normalize the exponent
	  while(exponent > EXPONENT_MAX) {
	    // Shift exponent to significand and decrease
	    lastDigit = lastDigit + 1;
	
	    if(lastDigit - firstDigit > MAX_DIGITS) {
	      // Check if we have a zero then just hard clamp, otherwise fail
	      var digitsString = digits.join('');
	      if(digitsString.match(/^0+$/)) {
	        exponent = EXPONENT_MAX;
	        break;
	      } else {
	        return new Decimal128(new Buffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
	      }
	    }
	
	    exponent = exponent - 1;
	  }
	
	  while(exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
	    // Shift last digit
	    if(lastDigit == 0) {
	      exponent = EXPONENT_MIN;
	      significantDigits = 0;
	      break;
	    }
	
	    if(nDigitsStored < nDigits) {
	      // adjust to match digits not stored
	      nDigits = nDigits - 1;
	    } else {
	      // adjust to round
	      lastDigit = lastDigit - 1;
	    }
	
	    if(exponent < EXPONENT_MAX) {
	      exponent = exponent + 1;
	    } else {
	      // Check if we have a zero then just hard clamp, otherwise fail
	      var digitsString = digits.join('');
	      if(digitsString.match(/^0+$/)) {
	        exponent = EXPONENT_MAX;
	        break;
	      } else {
	        return new Decimal128(new Buffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER))
	      }
	    }
	  }
	
	
	  // Round
	  // We've normalized the exponent, but might still need to round.
	  if((lastDigit - firstDigit + 1 < significantDigits) && string[significantDigits] != '0') {
	    var endOfString = nDigitsRead;
	
	    // If we have seen a radix point, 'string' is 1 longer than we have
	    // documented with ndigits_read, so inc the position of the first nonzero
	    // digit and the position that digits are read to.
	    if(sawRadix && exponent == EXPONENT_MIN) {
	      firstNonZero = firstNonZero + 1;
	      endOfString = endOfString + 1;
	    }
	
	    var roundDigit = parseInt(string[firstNonZero + lastDigit + 1], 10);
	    var roundBit = 0;
	
	    if(roundDigit >= 5) {
	      roundBit = 1;
	
	      if(roundDigit == 5) {
	        roundBit = digits[lastDigit] % 2 == 1;
	
	        for(var i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
	          if(parseInt(string[i], 10)) {
	            roundBit = 1;
	            break;
	          }
	        }
	      }
	    }
	
	    if(roundBit) {
	      var dIdx = lastDigit;
	
	      for(; dIdx >= 0; dIdx--) {
	        if(++digits[dIdx] > 9) {
	          digits[dIdx] = 0;
	
	          // overflowed most significant digit
	          if(dIdx == 0) {
	            if(exponent < EXPONENT_MAX) {
	              exponent = exponent + 1;
	              digits[dIdx] = 1;
	            } else {
	              return new Decimal128(new Buffer(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER))
	            }
	          }
	        } else {
	          break;
	        }
	      }
	    }
	  }
	
	  // Encode significand
	  // The high 17 digits of the significand
	  significandHigh = Long.fromNumber(0);
	  // The low 17 digits of the significand
	  significandLow = Long.fromNumber(0);
	
	  // read a zero
	  if(significantDigits == 0) {
	    significandHigh = Long.fromNumber(0);
	    significandLow = Long.fromNumber(0);
	  } else if(lastDigit - firstDigit < 17) {
	    var dIdx = firstDigit;
	    significandLow = Long.fromNumber(digits[dIdx++]);
	    significandHigh = new Long(0, 0);
	
	    for(; dIdx <= lastDigit; dIdx++) {
	      significandLow = significandLow.multiply(Long.fromNumber(10));
	      significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
	    }
	  } else {
	    var dIdx = firstDigit;
	    significandHigh = Long.fromNumber(digits[dIdx++]);
	
	    for(; dIdx <= lastDigit - 17; dIdx++) {
	      significandHigh = significandHigh.multiply(Long.fromNumber(10));
	      significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));
	    }
	
	    significandLow = Long.fromNumber(digits[dIdx++]);
	
	    for(; dIdx <= lastDigit; dIdx++) {
	      significandLow = significandLow.multiply(Long.fromNumber(10));
	      significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
	    }
	  }
	
	  var significand = multiply64x2(significandHigh, Long.fromString("100000000000000000"));
	
	  significand.low = significand.low.add(significandLow);
	
	  if(lessThan(significand.low, significandLow)) {
	    significand.high = significand.high.add(Long.fromNumber(1));
	  }
	
	  // Biased exponent
	  var biasedExponent = (exponent + EXPONENT_BIAS);
	  var dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };
	
	  // Encode combination, exponent, and significand.
	  if(significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber)) {
	    // Encode '11' into bits 1 to 3
	    dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));
	    dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));
	    dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));
	  } else {
	    dec.high = dec.high.or(Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));
	    dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));
	  }
	
	  dec.low = significand.low;
	
	  // Encode sign
	  if(isNegative) {
	    dec.high = dec.high.or(Long.fromString('9223372036854775808'));
	  }
	
	  // Encode into a buffer
	  var buffer = new Buffer(16);
	  var index = 0;
	
	  // Encode the low 64 bits of the decimal
	  // Encode low bits
	  buffer[index++] = dec.low.low_ & 0xff;
	  buffer[index++] = (dec.low.low_ >> 8) & 0xff;
	  buffer[index++] = (dec.low.low_ >> 16) & 0xff;
	  buffer[index++] = (dec.low.low_ >> 24) & 0xff;
	  // Encode high bits
	  buffer[index++] = dec.low.high_ & 0xff;
	  buffer[index++] = (dec.low.high_ >> 8) & 0xff;
	  buffer[index++] = (dec.low.high_ >> 16) & 0xff;
	  buffer[index++] = (dec.low.high_ >> 24) & 0xff;
	
	  // Encode the high 64 bits of the decimal
	  // Encode low bits
	  buffer[index++] = dec.high.low_ & 0xff;
	  buffer[index++] = (dec.high.low_ >> 8) & 0xff;
	  buffer[index++] = (dec.high.low_ >> 16) & 0xff;
	  buffer[index++] = (dec.high.low_ >> 24) & 0xff;
	  // Encode high bits
	  buffer[index++] = dec.high.high_ & 0xff;
	  buffer[index++] = (dec.high.high_ >> 8) & 0xff;
	  buffer[index++] = (dec.high.high_ >> 16) & 0xff;
	  buffer[index++] = (dec.high.high_ >> 24) & 0xff;
	
	  // Return the new Decimal128
	  return new Decimal128(buffer);
	}
	
	// Extract least significant 5 bits
	var COMBINATION_MASK = 0x1f;
	// Extract least significant 14 bits
	var EXPONENT_MASK = 0x3fff;
	// Value of combination field for Inf
	var COMBINATION_INFINITY = 30;
	// Value of combination field for NaN
	var COMBINATION_NAN = 31;
	// Value of combination field for NaN
	var COMBINATION_SNAN = 32;
	// decimal128 exponent bias
	var EXPONENT_BIAS = 6176;
	
	Decimal128.prototype.toString = function() {
	  // Note: bits in this routine are referred to starting at 0,
	  // from the sign bit, towards the coefficient.
	
	  // bits 0 - 31
	  var high;
	  // bits 32 - 63
	  var midh;
	  // bits 64 - 95
	  var midl;
	  // bits 96 - 127
	  var low;
	  // bits 1 - 5
	  var combination;
	  // decoded biased exponent (14 bits)
	  var biased_exponent;
	  // the number of significand digits
	  var significand_digits = 0;
	  // the base-10 digits in the significand
	  var significand = new Array(36);
	  for(var i = 0; i < significand.length; i++) significand[i] = 0;
	  // read pointer into significand
	  var index = 0;
	
	  // unbiased exponent
	  var exponent;
	  // the exponent if scientific notation is used
	  var scientific_exponent;
	
	  // true if the number is zero
	  var is_zero = false;
	
	  // the most signifcant significand bits (50-46)
	  var significand_msb;
	  // temporary storage for significand decoding
	  var significand128 = {parts: new Array(4)};
	  // indexing variables
	  var i;
	  var j, k;
	
	  // Output string
	  var string = [];
	
	  // Unpack index
	  var index = 0;
	
	  // Buffer reference
	  var buffer = this.bytes;
	
	  // Unpack the low 64bits into a long
	  low = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	  midl = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	
	  // Unpack the high 64bits into a long
	  midh = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	  high = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	
	  // Unpack index
	  var index = 0;
	
	  // Create the state of the decimal
	  var dec = {
	    low: new Long(low, midl),
	    high: new Long(midh, high) };
	
	  if(dec.high.lessThan(Long.ZERO)) {
	    string.push('-');
	  }
	
	  // Decode combination field and exponent
	  combination = (high >> 26) & COMBINATION_MASK;
	
	  if((combination >> 3) == 3) {
	    // Check for 'special' values
	    if(combination == COMBINATION_INFINITY) {
	      return string.join('') + "Infinity";
	    } else if(combination == COMBINATION_NAN) {
	      return "NaN";
	    } else {
	      biased_exponent = (high >> 15) & EXPONENT_MASK;
	      significand_msb = 0x08 + ((high >> 14) & 0x01);
	    }
	  } else {
	    significand_msb = (high >> 14) & 0x07;
	    biased_exponent = (high >> 17) & EXPONENT_MASK;
	  }
	
	  exponent = biased_exponent - EXPONENT_BIAS;
	
	  // Create string of significand digits
	
	  // Convert the 114-bit binary number represented by
	  // (significand_high, significand_low) to at most 34 decimal
	  // digits through modulo and division.
	  significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);
	  significand128.parts[1] = midh;
	  significand128.parts[2] = midl;
	  significand128.parts[3] = low;
	
	  if(significand128.parts[0] == 0 && significand128.parts[1] == 0
	    && significand128.parts[2] == 0 && significand128.parts[3] == 0) {
	      is_zero = true;
	  } else {
	    for(var k = 3; k >= 0; k--) {
	      var least_digits = 0;
	      // Peform the divide
	      var result = divideu128(significand128);
	      significand128 = result.quotient;
	      least_digits = result.rem.low_;
	
	      // We now have the 9 least significant digits (in base 2).
	      // Convert and output to string.
	      if(!least_digits) continue;
	
	      for(var j = 8; j >= 0; j--) {
	        // significand[k * 9 + j] = Math.round(least_digits % 10);
	        significand[k * 9 + j] = least_digits % 10;
	        // least_digits = Math.round(least_digits / 10);
	        least_digits = Math.floor(least_digits / 10);
	      }
	    }
	  }
	
	  // Output format options:
	  // Scientific - [-]d.dddE(+/-)dd or [-]dE(+/-)dd
	  // Regular    - ddd.ddd
	
	  if(is_zero) {
	    significand_digits = 1;
	    significand[index] = 0;
	  } else {
	    significand_digits = 36;
	    var i = 0;
	
	    while(!significand[index]) {
	      i++;
	      significand_digits = significand_digits - 1;
	      index = index + 1;
	    }
	  }
	
	  scientific_exponent = significand_digits - 1 + exponent;
	
	  // The scientific exponent checks are dictated by the string conversion
	  // specification and are somewhat arbitrary cutoffs.
	  //
	  // We must check exponent > 0, because if this is the case, the number
	  // has trailing zeros.  However, we *cannot* output these trailing zeros,
	  // because doing so would change the precision of the value, and would
	  // change stored data if the string converted number is round tripped.
	
	  if(scientific_exponent >= 34 || scientific_exponent <= -7 ||
	    exponent > 0) {
	    // Scientific format
	    string.push(significand[index++]);
	    significand_digits = significand_digits - 1;
	
	    if(significand_digits) {
	      string.push('.');
	    }
	
	    for(var i = 0; i < significand_digits; i++) {
	      string.push(significand[index++]);
	    }
	
	    // Exponent
	    string.push('E');
	    if(scientific_exponent > 0) {
	      string.push('+' + scientific_exponent);
	    } else {
	      string.push(scientific_exponent);
	    }
	  } else {
	    // Regular format with no decimal place
	    if(exponent >= 0) {
	      for(var i = 0; i < significand_digits; i++) {
	        string.push(significand[index++]);
	      }
	    } else {
	      var radix_position = significand_digits + exponent;
	
	      // non-zero digits before radix
	      if(radix_position > 0) {
	        for(var i = 0; i < radix_position; i++) {
	          string.push(significand[index++]);
	        }
	      } else {
	        string.push('0');
	      }
	
	      string.push('.');
	      // add leading zeros after radix
	      while(radix_position++ < 0) {
	        string.push('0');
	      }
	
	      for(var i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {
	        string.push(significand[index++]);
	      }
	    }
	  }
	
	  return string.join('');
	}
	
	Decimal128.prototype.toJSON = function() {
	  return { "$numberDecimal": this.toString() };
	}
	
	module.exports = Decimal128;
	module.exports.Decimal128 = Decimal128;


/***/ }),
/* 36 */
/***/ (function(module, exports) {

	/**
	 * A class representation of the BSON Double type.
	 *
	 * @class
	 * @param {number} value the number we want to represent as a double.
	 * @return {Double}
	 */
	function Double(value) {
	  if(!(this instanceof Double)) return new Double(value);
	
	  this._bsontype = 'Double';
	  this.value = value;
	}
	
	/**
	 * Access the number value.
	 *
	 * @method
	 * @return {number} returns the wrapped double number.
	 */
	Double.prototype.valueOf = function() {
	  return this.value;
	};
	
	/**
	 * @ignore
	 */
	Double.prototype.toJSON = function() {
	  return this.value;
	}
	
	module.exports = Double;
	module.exports.Double = Double;


/***/ }),
/* 37 */
/***/ (function(module, exports) {

	/**
	 * A class representation of the BSON MaxKey type.
	 *
	 * @class
	 * @return {MaxKey} A MaxKey instance
	 */
	function MaxKey() {
	  if(!(this instanceof MaxKey)) return new MaxKey();
	  
	  this._bsontype = 'MaxKey';  
	}
	
	module.exports = MaxKey;
	module.exports.MaxKey = MaxKey;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

	/**
	 * A class representation of the BSON MinKey type.
	 *
	 * @class
	 * @return {MinKey} A MinKey instance
	 */
	function MinKey() {
	  if(!(this instanceof MinKey)) return new MinKey();
	  
	  this._bsontype = 'MinKey';
	}
	
	module.exports = MinKey;
	module.exports.MinKey = MinKey;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

	/**
	 * Machine id.
	 *
	 * Create a random 3-byte value (i.e. unique for this
	 * process). Other drivers use a md5 of the machine id here, but
	 * that would mean an asyc call to gethostname, so we don't bother.
	 * @ignore
	 */
	var MACHINE_ID = parseInt(Math.random() * 0xFFFFFF, 10);
	
	// Regular expression that checks for hex value
	var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");
	var hasBufferType = false;
	
	// Check if buffer exists
	try {
	  if(Buffer && Buffer.from) hasBufferType = true;
	} catch(err) {};
	
	/**
	* Create a new ObjectID instance
	*
	* @class
	* @param {(string|number)} id Can be a 24 byte hex string, 12 byte binary string or a Number.
	* @property {number} generationTime The generation time of this ObjectId instance
	* @return {ObjectID} instance of ObjectID.
	*/
	var ObjectID = function ObjectID(id) {
	  // Duck-typing to support ObjectId from different npm packages
	  if(id instanceof ObjectID) return id;
	  if(!(this instanceof ObjectID)) return new ObjectID(id);
	
	  this._bsontype = 'ObjectID';
	
	  // The most common usecase (blank id, new objectId instance)
	  if(id == null || typeof id == 'number') {
	    // Generate a new id
	    this.id = this.generate(id);
	    // If we are caching the hex string
	    if(ObjectID.cacheHexString) this.__id = this.toString('hex');
	    // Return the object
	    return;
	  }
	
	  // Check if the passed in id is valid
	  var valid = ObjectID.isValid(id);
	
	  // Throw an error if it's not a valid setup
	  if(!valid && id != null){
	    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
	  } else if(valid && typeof id == 'string' && id.length == 24 && hasBufferType) {
	    return new ObjectID(new Buffer(id, 'hex'));
	  } else if(valid && typeof id == 'string' && id.length == 24) {
	    return ObjectID.createFromHexString(id);
	  } else if(id != null && id.length === 12) {
	    // assume 12 byte string
	    this.id = id;
	  } else if(id != null && id.toHexString) {
	    // Duck-typing to support ObjectId from different npm packages
	    return id;
	  } else {
	    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
	  }
	
	  if(ObjectID.cacheHexString) this.__id = this.toString('hex');
	};
	
	// Allow usage of ObjectId as well as ObjectID
	var ObjectId = ObjectID;
	
	// Precomputed hex table enables speedy hex string conversion
	var hexTable = [];
	for (var i = 0; i < 256; i++) {
	  hexTable[i] = (i <= 15 ? '0' : '') + i.toString(16);
	}
	
	/**
	* Return the ObjectID id as a 24 byte hex string representation
	*
	* @method
	* @return {string} return the 24 byte hex string representation.
	*/
	ObjectID.prototype.toHexString = function() {
	  if(ObjectID.cacheHexString && this.__id) return this.__id;
	
	  var hexString = '';
	  if(!this.id || !this.id.length) {
	    throw new Error('invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [' + JSON.stringify(this.id) + ']');
	  }
	
	  if(this.id instanceof _Buffer) {
	    hexString = convertToHex(this.id);
	    if(ObjectID.cacheHexString) this.__id = hexString;
	    return hexString;
	  }
	
	  for (var i = 0; i < this.id.length; i++) {
	    hexString += hexTable[this.id.charCodeAt(i)];
	  }
	
	  if(ObjectID.cacheHexString) this.__id = hexString;
	  return hexString;
	};
	
	/**
	* Update the ObjectID index used in generating new ObjectID's on the driver
	*
	* @method
	* @return {number} returns next index value.
	* @ignore
	*/
	ObjectID.prototype.get_inc = function() {
	  return ObjectID.index = (ObjectID.index + 1) % 0xFFFFFF;
	};
	
	/**
	* Update the ObjectID index used in generating new ObjectID's on the driver
	*
	* @method
	* @return {number} returns next index value.
	* @ignore
	*/
	ObjectID.prototype.getInc = function() {
	  return this.get_inc();
	};
	
	/**
	* Generate a 12 byte id buffer used in ObjectID's
	*
	* @method
	* @param {number} [time] optional parameter allowing to pass in a second based timestamp.
	* @return {Buffer} return the 12 byte id buffer string.
	*/
	ObjectID.prototype.generate = function(time) {
	  if ('number' != typeof time) {
	    time = ~~(Date.now()/1000);
	  }
	
	  // Use pid
	  var pid = (typeof process === 'undefined' ? Math.floor(Math.random() * 100000) : process.pid) % 0xFFFF;
	  var inc = this.get_inc();
	  // Buffer used
	  var buffer = new Buffer(12);
	  // Encode time
	  buffer[3] = time & 0xff;
	  buffer[2] = (time >> 8) & 0xff;
	  buffer[1] = (time >> 16) & 0xff;
	  buffer[0] = (time >> 24) & 0xff;
	  // Encode machine
	  buffer[6] = MACHINE_ID & 0xff;
	  buffer[5] = (MACHINE_ID >> 8) & 0xff;
	  buffer[4] = (MACHINE_ID >> 16) & 0xff;
	  // Encode pid
	  buffer[8] = pid & 0xff;
	  buffer[7] = (pid >> 8) & 0xff;
	  // Encode index
	  buffer[11] = inc & 0xff;
	  buffer[10] = (inc >> 8) & 0xff;
	  buffer[9] = (inc >> 16) & 0xff;
	  // Return the buffer
	  return buffer;
	};
	
	/**
	* Converts the id into a 24 byte hex string for printing
	*
	* @param {String} format The Buffer toString format parameter.
	* @return {String} return the 24 byte hex string representation.
	* @ignore
	*/
	ObjectID.prototype.toString = function(format) {
	  // Is the id a buffer then use the buffer toString method to return the format
	  if(this.id && this.id.copy) {
	    return this.id.toString(typeof format === 'string' ? format : 'hex');
	  }
	
	  // if(this.buffer )
	  return this.toHexString();
	};
	
	/**
	* Converts to a string representation of this Id.
	*
	* @return {String} return the 24 byte hex string representation.
	* @ignore
	*/
	ObjectID.prototype.inspect = ObjectID.prototype.toString;
	
	/**
	* Converts to its JSON representation.
	*
	* @return {String} return the 24 byte hex string representation.
	* @ignore
	*/
	ObjectID.prototype.toJSON = function() {
	  return this.toHexString();
	};
	
	/**
	* Compares the equality of this ObjectID with `otherID`.
	*
	* @method
	* @param {object} otherID ObjectID instance to compare against.
	* @return {boolean} the result of comparing two ObjectID's
	*/
	ObjectID.prototype.equals = function equals (otherId) {
	  var id;
	
	  if(otherId instanceof ObjectID) {
	    return this.toString() == otherId.toString();
	  } else if(typeof otherId == 'string' && ObjectID.isValid(otherId) && otherId.length == 12 && this.id instanceof _Buffer) {
	    return otherId === this.id.toString('binary');
	  } else if(typeof otherId == 'string' && ObjectID.isValid(otherId) && otherId.length == 24) {
	    return otherId.toLowerCase() === this.toHexString();
	  } else if(typeof otherId == 'string' && ObjectID.isValid(otherId) && otherId.length == 12) {
	    return otherId === this.id;
	  } else if(otherId != null && (otherId instanceof ObjectID || otherId.toHexString)) {
	    return otherId.toHexString() === this.toHexString();
	  } else {
	    return false;
	  }
	}
	
	/**
	* Returns the generation date (accurate up to the second) that this ID was generated.
	*
	* @method
	* @return {date} the generation date
	*/
	ObjectID.prototype.getTimestamp = function() {
	  var timestamp = new Date();
	  var time = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
	  timestamp.setTime(Math.floor(time) * 1000);
	  return timestamp;
	}
	
	/**
	* @ignore
	*/
	ObjectID.index = ~~(Math.random() * 0xFFFFFF);
	
	/**
	* @ignore
	*/
	ObjectID.createPk = function createPk () {
	  return new ObjectID();
	};
	
	/**
	* Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.
	*
	* @method
	* @param {number} time an integer number representing a number of seconds.
	* @return {ObjectID} return the created ObjectID
	*/
	ObjectID.createFromTime = function createFromTime (time) {
	  var buffer = new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
	  // Encode time into first 4 bytes
	  buffer[3] = time & 0xff;
	  buffer[2] = (time >> 8) & 0xff;
	  buffer[1] = (time >> 16) & 0xff;
	  buffer[0] = (time >> 24) & 0xff;
	  // Return the new objectId
	  return new ObjectID(buffer);
	};
	
	// Lookup tables
	var encodeLookup = '0123456789abcdef'.split('')
	var decodeLookup = []
	var i = 0
	while (i < 10) decodeLookup[0x30 + i] = i++
	while (i < 16) decodeLookup[0x41 - 10 + i] = decodeLookup[0x61 - 10 + i] = i++
	
	var _Buffer = Buffer;
	var convertToHex = function(bytes) {
	  return bytes.toString('hex');
	}
	
	/**
	* Creates an ObjectID from a hex string representation of an ObjectID.
	*
	* @method
	* @param {string} hexString create a ObjectID from a passed in 24 byte hexstring.
	* @return {ObjectID} return the created ObjectID
	*/
	ObjectID.createFromHexString = function createFromHexString (string) {
	  // Throw an error if it's not a valid setup
	  if(typeof string === 'undefined' || string != null && string.length != 24) {
	    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
	  }
	
	  // Use Buffer.from method if available
	  if(hasBufferType) return new ObjectID(new Buffer(string, 'hex'));
	
	  // Calculate lengths
	  var array = new _Buffer(12);
	  var n = 0;
	  var i = 0;
	
	  while (i < 24) {
	    array[n++] = decodeLookup[string.charCodeAt(i++)] << 4 | decodeLookup[string.charCodeAt(i++)]
	  }
	
	  return new ObjectID(array);
	};
	
	/**
	* Checks if a value is a valid bson ObjectId
	*
	* @method
	* @return {boolean} return true if the value is a valid bson ObjectId, return false otherwise.
	*/
	ObjectID.isValid = function isValid(id) {
	  if(id == null) return false;
	
	  if(typeof id == 'number') {
	    return true;
	  }
	
	  if(typeof id == 'string') {
	    return id.length == 12 || (id.length == 24 && checkForHexRegExp.test(id));
	  }
	
	  if(id instanceof ObjectID) {
	    return true;
	  }
	
	  if(id instanceof _Buffer) {
	    return true;
	  }
	
	  // Duck-Typing detection of ObjectId like objects
	  if(id.toHexString) {
	    return id.id.length == 12 || (id.id.length == 24 && checkForHexRegExp.test(id.id));
	  }
	
	  return false;
	};
	
	/**
	* @ignore
	*/
	Object.defineProperty(ObjectID.prototype, "generationTime", {
	   enumerable: true
	 , get: function () {
	     return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
	   }
	 , set: function (value) {
	     // Encode time into first 4 bytes
	     this.id[3] = value & 0xff;
	     this.id[2] = (value >> 8) & 0xff;
	     this.id[1] = (value >> 16) & 0xff;
	     this.id[0] = (value >> 24) & 0xff;
	   }
	});
	
	/**
	 * Expose.
	 */
	module.exports = ObjectID;
	module.exports.ObjectID = ObjectID;
	module.exports.ObjectId = ObjectID;


/***/ }),
/* 40 */
/***/ (function(module, exports) {

	/**
	 * A class representation of the BSON RegExp type.
	 *
	 * @class
	 * @return {BSONRegExp} A MinKey instance
	 */
	function BSONRegExp(pattern, options) {
	  if(!(this instanceof BSONRegExp)) return new BSONRegExp();
	
	  // Execute
	  this._bsontype = 'BSONRegExp';
	  this.pattern = pattern || '';
	  this.options = options || '';
	
	  // Validate options
	  for(var i = 0; i < this.options.length; i++) {
	    if(!(this.options[i] == 'i'
	      || this.options[i] == 'm'
	      || this.options[i] == 'x'
	      || this.options[i] == 'l'
	      || this.options[i] == 's'
	      || this.options[i] == 'u'
	    )) {
	      throw new Error('the regular expression options [' + this.options[i] + "] is not supported");
	    }
	  }
	}
	
	module.exports = BSONRegExp;
	module.exports.BSONRegExp = BSONRegExp;


/***/ }),
/* 41 */
/***/ (function(module, exports) {

	/**
	 * A class representation of the BSON Symbol type.
	 *
	 * @class
	 * @deprecated
	 * @param {string} value the string representing the symbol.
	 * @return {Symbol}
	 */
	function Symbol(value) {
	  if(!(this instanceof Symbol)) return new Symbol(value);
	  this._bsontype = 'Symbol';
	  this.value = value;
	}
	
	/**
	 * Access the wrapped string value.
	 *
	 * @method
	 * @return {String} returns the wrapped string.
	 */
	Symbol.prototype.valueOf = function() {
	  return this.value;
	};
	
	/**
	 * @ignore
	 */
	Symbol.prototype.toString = function() {
	  return this.value;
	}
	
	/**
	 * @ignore
	 */
	Symbol.prototype.inspect = function() {
	  return this.value;
	}
	
	/**
	 * @ignore
	 */
	Symbol.prototype.toJSON = function() {
	  return this.value;
	}
	
	module.exports = Symbol;
	module.exports.Symbol = Symbol;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	// Licensed under the Apache License, Version 2.0 (the "License");
	// you may not use this file except in compliance with the License.
	// You may obtain a copy of the License at
	//
	//     http://www.apache.org/licenses/LICENSE-2.0
	//
	// Unless required by applicable law or agreed to in writing, software
	// distributed under the License is distributed on an "AS IS" BASIS,
	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	// See the License for the specific language governing permissions and
	// limitations under the License.
	//
	// Copyright 2009 Google Inc. All Rights Reserved
	
	/**
	 * This type is for INTERNAL use in MongoDB only and should not be used in applications.
	 * The appropriate corresponding type is the JavaScript Date type.
	 * 
	 * Defines a Timestamp class for representing a 64-bit two's-complement
	 * integer value, which faithfully simulates the behavior of a Java "Timestamp". This
	 * implementation is derived from TimestampLib in GWT.
	 *
	 * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
	 * values as *signed* integers.  See the from* functions below for more
	 * convenient ways of constructing Timestamps.
	 *
	 * The internal representation of a Timestamp is the two given signed, 32-bit values.
	 * We use 32-bit pieces because these are the size of integers on which
	 * Javascript performs bit-operations.  For operations like addition and
	 * multiplication, we split each number into 16-bit pieces, which can easily be
	 * multiplied within Javascript's floating-point representation without overflow
	 * or change in sign.
	 *
	 * In the algorithms below, we frequently reduce the negative case to the
	 * positive case by negating the input(s) and then post-processing the result.
	 * Note that we must ALWAYS check specially whether those values are MIN_VALUE
	 * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
	 * a positive number, it overflows back into a negative).  Not handling this
	 * case would often result in infinite recursion.
	 *
	 * @class
	 * @param {number} low  the low (signed) 32 bits of the Timestamp.
	 * @param {number} high the high (signed) 32 bits of the Timestamp.
	 */
	function Timestamp(low, high) {
	  if(!(this instanceof Timestamp)) return new Timestamp(low, high);
	  this._bsontype = 'Timestamp';
	  /**
	   * @type {number}
	   * @ignore
	   */
	  this.low_ = low | 0;  // force into 32 signed bits.
	
	  /**
	   * @type {number}
	   * @ignore
	   */
	  this.high_ = high | 0;  // force into 32 signed bits.
	};
	
	/**
	 * Return the int value.
	 *
	 * @return {number} the value, assuming it is a 32-bit integer.
	 */
	Timestamp.prototype.toInt = function() {
	  return this.low_;
	};
	
	/**
	 * Return the Number value.
	 *
	 * @method
	 * @return {number} the closest floating-point representation to this value.
	 */
	Timestamp.prototype.toNumber = function() {
	  return this.high_ * Timestamp.TWO_PWR_32_DBL_ +
	         this.getLowBitsUnsigned();
	};
	
	/**
	 * Return the JSON value.
	 *
	 * @method
	 * @return {string} the JSON representation.
	 */
	Timestamp.prototype.toJSON = function() {
	  return this.toString();
	}
	
	/**
	 * Return the String value.
	 *
	 * @method
	 * @param {number} [opt_radix] the radix in which the text should be written.
	 * @return {string} the textual representation of this value.
	 */
	Timestamp.prototype.toString = function(opt_radix) {
	  var radix = opt_radix || 10;
	  if (radix < 2 || 36 < radix) {
	    throw Error('radix out of range: ' + radix);
	  }
	
	  if (this.isZero()) {
	    return '0';
	  }
	
	  if (this.isNegative()) {
	    if (this.equals(Timestamp.MIN_VALUE)) {
	      // We need to change the Timestamp value before it can be negated, so we remove
	      // the bottom-most digit in this base and then recurse to do the rest.
	      var radixTimestamp = Timestamp.fromNumber(radix);
	      var div = this.div(radixTimestamp);
	      var rem = div.multiply(radixTimestamp).subtract(this);
	      return div.toString(radix) + rem.toInt().toString(radix);
	    } else {
	      return '-' + this.negate().toString(radix);
	    }
	  }
	
	  // Do several (6) digits each time through the loop, so as to
	  // minimize the calls to the very expensive emulated div.
	  var radixToPower = Timestamp.fromNumber(Math.pow(radix, 6));
	
	  var rem = this;
	  var result = '';
	  while (true) {
	    var remDiv = rem.div(radixToPower);
	    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
	    var digits = intval.toString(radix);
	
	    rem = remDiv;
	    if (rem.isZero()) {
	      return digits + result;
	    } else {
	      while (digits.length < 6) {
	        digits = '0' + digits;
	      }
	      result = '' + digits + result;
	    }
	  }
	};
	
	/**
	 * Return the high 32-bits value.
	 *
	 * @method
	 * @return {number} the high 32-bits as a signed value.
	 */
	Timestamp.prototype.getHighBits = function() {
	  return this.high_;
	};
	
	/**
	 * Return the low 32-bits value.
	 *
	 * @method
	 * @return {number} the low 32-bits as a signed value.
	 */
	Timestamp.prototype.getLowBits = function() {
	  return this.low_;
	};
	
	/**
	 * Return the low unsigned 32-bits value.
	 *
	 * @method
	 * @return {number} the low 32-bits as an unsigned value.
	 */
	Timestamp.prototype.getLowBitsUnsigned = function() {
	  return (this.low_ >= 0) ?
	      this.low_ : Timestamp.TWO_PWR_32_DBL_ + this.low_;
	};
	
	/**
	 * Returns the number of bits needed to represent the absolute value of this Timestamp.
	 *
	 * @method
	 * @return {number} Returns the number of bits needed to represent the absolute value of this Timestamp.
	 */
	Timestamp.prototype.getNumBitsAbs = function() {
	  if (this.isNegative()) {
	    if (this.equals(Timestamp.MIN_VALUE)) {
	      return 64;
	    } else {
	      return this.negate().getNumBitsAbs();
	    }
	  } else {
	    var val = this.high_ != 0 ? this.high_ : this.low_;
	    for (var bit = 31; bit > 0; bit--) {
	      if ((val & (1 << bit)) != 0) {
	        break;
	      }
	    }
	    return this.high_ != 0 ? bit + 33 : bit + 1;
	  }
	};
	
	/**
	 * Return whether this value is zero.
	 *
	 * @method
	 * @return {boolean} whether this value is zero.
	 */
	Timestamp.prototype.isZero = function() {
	  return this.high_ == 0 && this.low_ == 0;
	};
	
	/**
	 * Return whether this value is negative.
	 *
	 * @method
	 * @return {boolean} whether this value is negative.
	 */
	Timestamp.prototype.isNegative = function() {
	  return this.high_ < 0;
	};
	
	/**
	 * Return whether this value is odd.
	 *
	 * @method
	 * @return {boolean} whether this value is odd.
	 */
	Timestamp.prototype.isOdd = function() {
	  return (this.low_ & 1) == 1;
	};
	
	/**
	 * Return whether this Timestamp equals the other
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp equals the other
	 */
	Timestamp.prototype.equals = function(other) {
	  return (this.high_ == other.high_) && (this.low_ == other.low_);
	};
	
	/**
	 * Return whether this Timestamp does not equal the other.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp does not equal the other.
	 */
	Timestamp.prototype.notEquals = function(other) {
	  return (this.high_ != other.high_) || (this.low_ != other.low_);
	};
	
	/**
	 * Return whether this Timestamp is less than the other.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp is less than the other.
	 */
	Timestamp.prototype.lessThan = function(other) {
	  return this.compare(other) < 0;
	};
	
	/**
	 * Return whether this Timestamp is less than or equal to the other.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp is less than or equal to the other.
	 */
	Timestamp.prototype.lessThanOrEqual = function(other) {
	  return this.compare(other) <= 0;
	};
	
	/**
	 * Return whether this Timestamp is greater than the other.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp is greater than the other.
	 */
	Timestamp.prototype.greaterThan = function(other) {
	  return this.compare(other) > 0;
	};
	
	/**
	 * Return whether this Timestamp is greater than or equal to the other.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} whether this Timestamp is greater than or equal to the other.
	 */
	Timestamp.prototype.greaterThanOrEqual = function(other) {
	  return this.compare(other) >= 0;
	};
	
	/**
	 * Compares this Timestamp with the given one.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to compare against.
	 * @return {boolean} 0 if they are the same, 1 if the this is greater, and -1 if the given one is greater.
	 */
	Timestamp.prototype.compare = function(other) {
	  if (this.equals(other)) {
	    return 0;
	  }
	
	  var thisNeg = this.isNegative();
	  var otherNeg = other.isNegative();
	  if (thisNeg && !otherNeg) {
	    return -1;
	  }
	  if (!thisNeg && otherNeg) {
	    return 1;
	  }
	
	  // at this point, the signs are the same, so subtraction will not overflow
	  if (this.subtract(other).isNegative()) {
	    return -1;
	  } else {
	    return 1;
	  }
	};
	
	/**
	 * The negation of this value.
	 *
	 * @method
	 * @return {Timestamp} the negation of this value.
	 */
	Timestamp.prototype.negate = function() {
	  if (this.equals(Timestamp.MIN_VALUE)) {
	    return Timestamp.MIN_VALUE;
	  } else {
	    return this.not().add(Timestamp.ONE);
	  }
	};
	
	/**
	 * Returns the sum of this and the given Timestamp.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to add to this one.
	 * @return {Timestamp} the sum of this and the given Timestamp.
	 */
	Timestamp.prototype.add = function(other) {
	  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
	
	  var a48 = this.high_ >>> 16;
	  var a32 = this.high_ & 0xFFFF;
	  var a16 = this.low_ >>> 16;
	  var a00 = this.low_ & 0xFFFF;
	
	  var b48 = other.high_ >>> 16;
	  var b32 = other.high_ & 0xFFFF;
	  var b16 = other.low_ >>> 16;
	  var b00 = other.low_ & 0xFFFF;
	
	  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	  c00 += a00 + b00;
	  c16 += c00 >>> 16;
	  c00 &= 0xFFFF;
	  c16 += a16 + b16;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c32 += a32 + b32;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c48 += a48 + b48;
	  c48 &= 0xFFFF;
	  return Timestamp.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
	};
	
	/**
	 * Returns the difference of this and the given Timestamp.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to subtract from this.
	 * @return {Timestamp} the difference of this and the given Timestamp.
	 */
	Timestamp.prototype.subtract = function(other) {
	  return this.add(other.negate());
	};
	
	/**
	 * Returns the product of this and the given Timestamp.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp to multiply with this.
	 * @return {Timestamp} the product of this and the other.
	 */
	Timestamp.prototype.multiply = function(other) {
	  if (this.isZero()) {
	    return Timestamp.ZERO;
	  } else if (other.isZero()) {
	    return Timestamp.ZERO;
	  }
	
	  if (this.equals(Timestamp.MIN_VALUE)) {
	    return other.isOdd() ? Timestamp.MIN_VALUE : Timestamp.ZERO;
	  } else if (other.equals(Timestamp.MIN_VALUE)) {
	    return this.isOdd() ? Timestamp.MIN_VALUE : Timestamp.ZERO;
	  }
	
	  if (this.isNegative()) {
	    if (other.isNegative()) {
	      return this.negate().multiply(other.negate());
	    } else {
	      return this.negate().multiply(other).negate();
	    }
	  } else if (other.isNegative()) {
	    return this.multiply(other.negate()).negate();
	  }
	
	  // If both Timestamps are small, use float multiplication
	  if (this.lessThan(Timestamp.TWO_PWR_24_) &&
	      other.lessThan(Timestamp.TWO_PWR_24_)) {
	    return Timestamp.fromNumber(this.toNumber() * other.toNumber());
	  }
	
	  // Divide each Timestamp into 4 chunks of 16 bits, and then add up 4x4 products.
	  // We can skip products that would overflow.
	
	  var a48 = this.high_ >>> 16;
	  var a32 = this.high_ & 0xFFFF;
	  var a16 = this.low_ >>> 16;
	  var a00 = this.low_ & 0xFFFF;
	
	  var b48 = other.high_ >>> 16;
	  var b32 = other.high_ & 0xFFFF;
	  var b16 = other.low_ >>> 16;
	  var b00 = other.low_ & 0xFFFF;
	
	  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
	  c00 += a00 * b00;
	  c16 += c00 >>> 16;
	  c00 &= 0xFFFF;
	  c16 += a16 * b00;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c16 += a00 * b16;
	  c32 += c16 >>> 16;
	  c16 &= 0xFFFF;
	  c32 += a32 * b00;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c32 += a16 * b16;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c32 += a00 * b32;
	  c48 += c32 >>> 16;
	  c32 &= 0xFFFF;
	  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
	  c48 &= 0xFFFF;
	  return Timestamp.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
	};
	
	/**
	 * Returns this Timestamp divided by the given one.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp by which to divide.
	 * @return {Timestamp} this Timestamp divided by the given one.
	 */
	Timestamp.prototype.div = function(other) {
	  if (other.isZero()) {
	    throw Error('division by zero');
	  } else if (this.isZero()) {
	    return Timestamp.ZERO;
	  }
	
	  if (this.equals(Timestamp.MIN_VALUE)) {
	    if (other.equals(Timestamp.ONE) ||
	        other.equals(Timestamp.NEG_ONE)) {
	      return Timestamp.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
	    } else if (other.equals(Timestamp.MIN_VALUE)) {
	      return Timestamp.ONE;
	    } else {
	      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
	      var halfThis = this.shiftRight(1);
	      var approx = halfThis.div(other).shiftLeft(1);
	      if (approx.equals(Timestamp.ZERO)) {
	        return other.isNegative() ? Timestamp.ONE : Timestamp.NEG_ONE;
	      } else {
	        var rem = this.subtract(other.multiply(approx));
	        var result = approx.add(rem.div(other));
	        return result;
	      }
	    }
	  } else if (other.equals(Timestamp.MIN_VALUE)) {
	    return Timestamp.ZERO;
	  }
	
	  if (this.isNegative()) {
	    if (other.isNegative()) {
	      return this.negate().div(other.negate());
	    } else {
	      return this.negate().div(other).negate();
	    }
	  } else if (other.isNegative()) {
	    return this.div(other.negate()).negate();
	  }
	
	  // Repeat the following until the remainder is less than other:  find a
	  // floating-point that approximates remainder / other *from below*, add this
	  // into the result, and subtract it from the remainder.  It is critical that
	  // the approximate value is less than or equal to the real value so that the
	  // remainder never becomes negative.
	  var res = Timestamp.ZERO;
	  var rem = this;
	  while (rem.greaterThanOrEqual(other)) {
	    // Approximate the result of division. This may be a little greater or
	    // smaller than the actual value.
	    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));
	
	    // We will tweak the approximate result by changing it in the 48-th digit or
	    // the smallest non-fractional digit, whichever is larger.
	    var log2 = Math.ceil(Math.log(approx) / Math.LN2);
	    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);
	
	    // Decrease the approximation until it is smaller than the remainder.  Note
	    // that if it is too large, the product overflows and is negative.
	    var approxRes = Timestamp.fromNumber(approx);
	    var approxRem = approxRes.multiply(other);
	    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
	      approx -= delta;
	      approxRes = Timestamp.fromNumber(approx);
	      approxRem = approxRes.multiply(other);
	    }
	
	    // We know the answer can't be zero... and actually, zero would cause
	    // infinite recursion since we would make no progress.
	    if (approxRes.isZero()) {
	      approxRes = Timestamp.ONE;
	    }
	
	    res = res.add(approxRes);
	    rem = rem.subtract(approxRem);
	  }
	  return res;
	};
	
	/**
	 * Returns this Timestamp modulo the given one.
	 *
	 * @method
	 * @param {Timestamp} other Timestamp by which to mod.
	 * @return {Timestamp} this Timestamp modulo the given one.
	 */
	Timestamp.prototype.modulo = function(other) {
	  return this.subtract(this.div(other).multiply(other));
	};
	
	/**
	 * The bitwise-NOT of this value.
	 *
	 * @method
	 * @return {Timestamp} the bitwise-NOT of this value.
	 */
	Timestamp.prototype.not = function() {
	  return Timestamp.fromBits(~this.low_, ~this.high_);
	};
	
	/**
	 * Returns the bitwise-AND of this Timestamp and the given one.
	 *
	 * @method
	 * @param {Timestamp} other the Timestamp with which to AND.
	 * @return {Timestamp} the bitwise-AND of this and the other.
	 */
	Timestamp.prototype.and = function(other) {
	  return Timestamp.fromBits(this.low_ & other.low_, this.high_ & other.high_);
	};
	
	/**
	 * Returns the bitwise-OR of this Timestamp and the given one.
	 *
	 * @method
	 * @param {Timestamp} other the Timestamp with which to OR.
	 * @return {Timestamp} the bitwise-OR of this and the other.
	 */
	Timestamp.prototype.or = function(other) {
	  return Timestamp.fromBits(this.low_ | other.low_, this.high_ | other.high_);
	};
	
	/**
	 * Returns the bitwise-XOR of this Timestamp and the given one.
	 *
	 * @method
	 * @param {Timestamp} other the Timestamp with which to XOR.
	 * @return {Timestamp} the bitwise-XOR of this and the other.
	 */
	Timestamp.prototype.xor = function(other) {
	  return Timestamp.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
	};
	
	/**
	 * Returns this Timestamp with bits shifted to the left by the given amount.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Timestamp} this shifted to the left by the given amount.
	 */
	Timestamp.prototype.shiftLeft = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var low = this.low_;
	    if (numBits < 32) {
	      var high = this.high_;
	      return Timestamp.fromBits(
	                 low << numBits,
	                 (high << numBits) | (low >>> (32 - numBits)));
	    } else {
	      return Timestamp.fromBits(0, low << (numBits - 32));
	    }
	  }
	};
	
	/**
	 * Returns this Timestamp with bits shifted to the right by the given amount.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Timestamp} this shifted to the right by the given amount.
	 */
	Timestamp.prototype.shiftRight = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var high = this.high_;
	    if (numBits < 32) {
	      var low = this.low_;
	      return Timestamp.fromBits(
	                 (low >>> numBits) | (high << (32 - numBits)),
	                 high >> numBits);
	    } else {
	      return Timestamp.fromBits(
	                 high >> (numBits - 32),
	                 high >= 0 ? 0 : -1);
	    }
	  }
	};
	
	/**
	 * Returns this Timestamp with bits shifted to the right by the given amount, with the new top bits matching the current sign bit.
	 *
	 * @method
	 * @param {number} numBits the number of bits by which to shift.
	 * @return {Timestamp} this shifted to the right by the given amount, with zeros placed into the new leading bits.
	 */
	Timestamp.prototype.shiftRightUnsigned = function(numBits) {
	  numBits &= 63;
	  if (numBits == 0) {
	    return this;
	  } else {
	    var high = this.high_;
	    if (numBits < 32) {
	      var low = this.low_;
	      return Timestamp.fromBits(
	                 (low >>> numBits) | (high << (32 - numBits)),
	                 high >>> numBits);
	    } else if (numBits == 32) {
	      return Timestamp.fromBits(high, 0);
	    } else {
	      return Timestamp.fromBits(high >>> (numBits - 32), 0);
	    }
	  }
	};
	
	/**
	 * Returns a Timestamp representing the given (32-bit) integer value.
	 *
	 * @method
	 * @param {number} value the 32-bit integer in question.
	 * @return {Timestamp} the corresponding Timestamp value.
	 */
	Timestamp.fromInt = function(value) {
	  if (-128 <= value && value < 128) {
	    var cachedObj = Timestamp.INT_CACHE_[value];
	    if (cachedObj) {
	      return cachedObj;
	    }
	  }
	
	  var obj = new Timestamp(value | 0, value < 0 ? -1 : 0);
	  if (-128 <= value && value < 128) {
	    Timestamp.INT_CACHE_[value] = obj;
	  }
	  return obj;
	};
	
	/**
	 * Returns a Timestamp representing the given value, provided that it is a finite number. Otherwise, zero is returned.
	 *
	 * @method
	 * @param {number} value the number in question.
	 * @return {Timestamp} the corresponding Timestamp value.
	 */
	Timestamp.fromNumber = function(value) {
	  if (isNaN(value) || !isFinite(value)) {
	    return Timestamp.ZERO;
	  } else if (value <= -Timestamp.TWO_PWR_63_DBL_) {
	    return Timestamp.MIN_VALUE;
	  } else if (value + 1 >= Timestamp.TWO_PWR_63_DBL_) {
	    return Timestamp.MAX_VALUE;
	  } else if (value < 0) {
	    return Timestamp.fromNumber(-value).negate();
	  } else {
	    return new Timestamp(
	               (value % Timestamp.TWO_PWR_32_DBL_) | 0,
	               (value / Timestamp.TWO_PWR_32_DBL_) | 0);
	  }
	};
	
	/**
	 * Returns a Timestamp representing the 64-bit integer that comes by concatenating the given high and low bits. Each is assumed to use 32 bits.
	 *
	 * @method
	 * @param {number} lowBits the low 32-bits.
	 * @param {number} highBits the high 32-bits.
	 * @return {Timestamp} the corresponding Timestamp value.
	 */
	Timestamp.fromBits = function(lowBits, highBits) {
	  return new Timestamp(lowBits, highBits);
	};
	
	/**
	 * Returns a Timestamp representation of the given string, written using the given radix.
	 *
	 * @method
	 * @param {string} str the textual representation of the Timestamp.
	 * @param {number} opt_radix the radix in which the text is written.
	 * @return {Timestamp} the corresponding Timestamp value.
	 */
	Timestamp.fromString = function(str, opt_radix) {
	  if (str.length == 0) {
	    throw Error('number format error: empty string');
	  }
	
	  var radix = opt_radix || 10;
	  if (radix < 2 || 36 < radix) {
	    throw Error('radix out of range: ' + radix);
	  }
	
	  if (str.charAt(0) == '-') {
	    return Timestamp.fromString(str.substring(1), radix).negate();
	  } else if (str.indexOf('-') >= 0) {
	    throw Error('number format error: interior "-" character: ' + str);
	  }
	
	  // Do several (8) digits each time through the loop, so as to
	  // minimize the calls to the very expensive emulated div.
	  var radixToPower = Timestamp.fromNumber(Math.pow(radix, 8));
	
	  var result = Timestamp.ZERO;
	  for (var i = 0; i < str.length; i += 8) {
	    var size = Math.min(8, str.length - i);
	    var value = parseInt(str.substring(i, i + size), radix);
	    if (size < 8) {
	      var power = Timestamp.fromNumber(Math.pow(radix, size));
	      result = result.multiply(power).add(Timestamp.fromNumber(value));
	    } else {
	      result = result.multiply(radixToPower);
	      result = result.add(Timestamp.fromNumber(value));
	    }
	  }
	  return result;
	};
	
	// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
	// from* methods on which they depend.
	
	
	/**
	 * A cache of the Timestamp representations of small integer values.
	 * @type {Object}
	 * @ignore
	 */
	Timestamp.INT_CACHE_ = {};
	
	// NOTE: the compiler should inline these constant values below and then remove
	// these variables, so there should be no runtime penalty for these.
	
	/**
	 * Number used repeated below in calculations.  This must appear before the
	 * first call to any from* function below.
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_16_DBL_ = 1 << 16;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_24_DBL_ = 1 << 24;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_32_DBL_ = Timestamp.TWO_PWR_16_DBL_ * Timestamp.TWO_PWR_16_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_31_DBL_ = Timestamp.TWO_PWR_32_DBL_ / 2;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_48_DBL_ = Timestamp.TWO_PWR_32_DBL_ * Timestamp.TWO_PWR_16_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_64_DBL_ = Timestamp.TWO_PWR_32_DBL_ * Timestamp.TWO_PWR_32_DBL_;
	
	/**
	 * @type {number}
	 * @ignore
	 */
	Timestamp.TWO_PWR_63_DBL_ = Timestamp.TWO_PWR_64_DBL_ / 2;
	
	/** @type {Timestamp} */
	Timestamp.ZERO = Timestamp.fromInt(0);
	
	/** @type {Timestamp} */
	Timestamp.ONE = Timestamp.fromInt(1);
	
	/** @type {Timestamp} */
	Timestamp.NEG_ONE = Timestamp.fromInt(-1);
	
	/** @type {Timestamp} */
	Timestamp.MAX_VALUE =
	    Timestamp.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);
	
	/** @type {Timestamp} */
	Timestamp.MIN_VALUE = Timestamp.fromBits(0, 0x80000000 | 0);
	
	/**
	 * @type {Timestamp}
	 * @ignore
	 */
	Timestamp.TWO_PWR_24_ = Timestamp.fromInt(1 << 24);
	
	/**
	 * Expose.
	 */
	module.exports = Timestamp;
	module.exports.Timestamp = Timestamp;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

	"use strict";
	
	var needSlaveOk = ['primaryPreferred', 'secondary', 'secondaryPreferred', 'nearest'];
	
	/**
	 * @fileOverview The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is
	 * used to construct connections.
	 *
	 * @example
	 * var ReplSet = require('mongodb-core').ReplSet
	 *   , ReadPreference = require('mongodb-core').ReadPreference
	 *   , assert = require('assert');
	 *
	 * var server = new ReplSet([{host: 'localhost', port: 30000}], {setName: 'rs'});
	 * // Wait for the connection event
	 * server.on('connect', function(server) {
	 *   var cursor = server.cursor('db.test'
	 *     , {find: 'db.test', query: {}}
	 *     , {readPreference: new ReadPreference('secondary')});
	 *   cursor.next(function(err, doc) {
	 *     server.destroy();
	 *   });
	 * });
	 *
	 * // Start connecting
	 * server.connect();
	 */
	
	/**
	 * Creates a new Pool instance
	 * @class
	 * @param {string} preference A string describing the preference (primary|primaryPreferred|secondary|secondaryPreferred|nearest)
	 * @param {array} tags The tags object
	 * @param {object} [options] Additional read preference options
	 * @param {number} [options.maxStalenessSeconds] Max Secondary Read Stalleness in Seconds, Minimum value is 90 seconds.
	 * @property {string} preference The preference string (primary|primaryPreferred|secondary|secondaryPreferred|nearest)
	 * @property {array} tags The tags object
	 * @property {object} options Additional read preference options
	 * @property {number} maxStalenessSeconds MaxStalenessSeconds value for the read preference
	 * @return {ReadPreference}
	 */
	var ReadPreference = function(preference, tags, options) {
	  this.preference = preference;
	  this.tags = tags;
	  this.options = options;
	
	  // Add the maxStalenessSeconds value to the read Preference
	  if(this.options && this.options.maxStalenessSeconds != null) {
	    this.options = options;
	    this.maxStalenessSeconds = this.options.maxStalenessSeconds >= 0
	      ? this.options.maxStalenessSeconds : null;
	  } else if(tags && typeof tags == 'object') {
	    this.options = tags, tags = null;
	  }
	}
	
	/**
	 * This needs slaveOk bit set
	 * @method
	 * @return {boolean}
	 */
	ReadPreference.prototype.slaveOk = function() {
	  return needSlaveOk.indexOf(this.preference) != -1;
	}
	
	/**
	 * Are the two read preference equal
	 * @method
	 * @return {boolean}
	 */
	ReadPreference.prototype.equals = function(readPreference) {
	  return readPreference.preference == this.preference;
	}
	
	/**
	 * Return JSON representation
	 * @method
	 * @return {Object}
	 */
	ReadPreference.prototype.toJSON = function() {
	  var readPreference = {mode: this.preference};
	  if(Array.isArray(this.tags)) readPreference.tags = this.tags;
	  if(this.maxStalenessSeconds) readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
	  return readPreference;
	}
	
	/**
	 * Primary read preference
	 * @method
	 * @return {ReadPreference}
	 */
	ReadPreference.primary = new ReadPreference('primary');
	/**
	 * Primary Preferred read preference
	 * @method
	 * @return {ReadPreference}
	 */
	ReadPreference.primaryPreferred = new ReadPreference('primaryPreferred');
	/**
	 * Secondary read preference
	 * @method
	 * @return {ReadPreference}
	 */
	ReadPreference.secondary = new ReadPreference('secondary');
	/**
	 * Secondary Preferred read preference
	 * @method
	 * @return {ReadPreference}
	 */
	ReadPreference.secondaryPreferred = new ReadPreference('secondaryPreferred');
	/**
	 * Nearest read preference
	 * @method
	 * @return {ReadPreference}
	 */
	ReadPreference.nearest = new ReadPreference('nearest');
	
	module.exports = ReadPreference;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(5);
	var util = __webpack_require__(1);
	
	/**
	 * Casting Error constructor.
	 *
	 * @param {String} type
	 * @param {String} value
	 * @inherits MongooseError
	 * @api private
	 */
	
	function CastError(type, value, path, reason) {
	  var stringValue = util.inspect(value);
	  stringValue = stringValue.replace(/^'/, '"').replace(/'$/, '"');
	  if (stringValue.charAt(0) !== '"') {
	    stringValue = '"' + stringValue + '"';
	  }
	  MongooseError.call(this, 'Cast to ' + type + ' failed for value ' +
	    stringValue + ' at path "' + path + '"');
	  this.name = 'CastError';
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	  this.stringValue = stringValue;
	  this.kind = type;
	  this.value = value;
	  this.path = path;
	  this.reason = reason;
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	CastError.prototype = Object.create(MongooseError.prototype);
	CastError.prototype.constructor = MongooseError;
	
	/*!
	 * ignore
	 */
	
	CastError.prototype.setModel = function(model) {
	  this.model = model;
	  this.message = 'Cast to ' + this.kind + ' failed for value ' +
	    this.stringValue + ' at path "' + this.path + '"' + ' for model "' +
	    model.modelName + '"';
	};
	
	/*!
	 * exports
	 */
	
	module.exports = CastError;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var readPref = __webpack_require__(29).ReadPreference;
	var EventEmitter = __webpack_require__(6).EventEmitter;
	var VirtualType = __webpack_require__(103);
	var utils = __webpack_require__(4);
	var MongooseTypes;
	var Kareem = __webpack_require__(169);
	var each = __webpack_require__(108);
	var SchemaType = __webpack_require__(12);
	var mpath = __webpack_require__(67);
	
	var IS_KAREEM_HOOK = {
	  count: true,
	  find: true,
	  findOne: true,
	  findOneAndUpdate: true,
	  findOneAndRemove: true,
	  insertMany: true,
	  replaceOne: true,
	  update: true,
	  updateMany: true,
	  updateOne: true
	};
	
	/**
	 * Schema constructor.
	 *
	 * ####Example:
	 *
	 *     var child = new Schema({ name: String });
	 *     var schema = new Schema({ name: String, age: Number, children: [child] });
	 *     var Tree = mongoose.model('Tree', schema);
	 *
	 *     // setting schema options
	 *     new Schema({ name: String }, { _id: false, autoIndex: false })
	 *
	 * ####Options:
	 *
	 * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)
	 * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true
	 * - [capped](/docs/guide.html#capped): bool - defaults to false
	 * - [collection](/docs/guide.html#collection): string - no default
	 * - [emitIndexErrors](/docs/guide.html#emitIndexErrors): bool - defaults to false.
	 * - [id](/docs/guide.html#id): bool - defaults to true
	 * - [_id](/docs/guide.html#_id): bool - defaults to true
	 * - `minimize`: bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true
	 * - [read](/docs/guide.html#read): string
	 * - [safe](/docs/guide.html#safe): bool - defaults to true.
	 * - [shardKey](/docs/guide.html#shardKey): bool - defaults to `null`
	 * - [strict](/docs/guide.html#strict): bool - defaults to true
	 * - [toJSON](/docs/guide.html#toJSON) - object - no default
	 * - [toObject](/docs/guide.html#toObject) - object - no default
	 * - [typeKey](/docs/guide.html#typeKey) - string - defaults to 'type'
	 * - [useNestedStrict](/docs/guide.html#useNestedStrict) - boolean - defaults to false
	 * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`
	 * - [versionKey](/docs/guide.html#versionKey): string - defaults to "__v"
	 * - [collation](/docs/guide.html#collation): object - defaults to null (which means use no collation)
	 *
	 * ####Note:
	 *
	 * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._
	 *
	 * @param {Object} definition
	 * @param {Object} [options]
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `init`: Emitted after the schema is compiled into a `Model`.
	 * @api public
	 */
	
	function Schema(obj, options) {
	  if (!(this instanceof Schema)) {
	    return new Schema(obj, options);
	  }
	
	  this.obj = obj;
	  this.paths = {};
	  this.aliases = {};
	  this.subpaths = {};
	  this.virtuals = {};
	  this.singleNestedPaths = {};
	  this.nested = {};
	  this.inherits = {};
	  this.callQueue = [];
	  this._indexes = [];
	  this.methods = {};
	  this.statics = {};
	  this.tree = {};
	  this.query = {};
	  this.childSchemas = [];
	  this.plugins = [];
	
	  this.s = {
	    hooks: new Kareem(),
	    kareemHooks: IS_KAREEM_HOOK
	  };
	
	  this.options = this.defaultOptions(options);
	
	  // build paths
	  if (obj) {
	    this.add(obj);
	  }
	
	  // check if _id's value is a subdocument (gh-2276)
	  var _idSubDoc = obj && obj._id && utils.isObject(obj._id);
	
	  // ensure the documents get an auto _id unless disabled
	  var auto_id = !this.paths['_id'] &&
	      (!this.options.noId && this.options._id) && !_idSubDoc;
	
	  if (auto_id) {
	    var _obj = {_id: {auto: true}};
	    _obj._id[this.options.typeKey] = Schema.ObjectId;
	    this.add(_obj);
	  }
	
	  for (var i = 0; i < this._defaultMiddleware.length; ++i) {
	    var m = this._defaultMiddleware[i];
	    this[m.kind](m.hook, !!m.isAsync, m.fn);
	  }
	
	  if (this.options.timestamps) {
	    this.setupTimestamp(this.options.timestamps);
	  }
	
	  // Assign virtual properties based on alias option
	  aliasFields(this);
	}
	
	/*!
	 * Create virtual properties with alias field
	 */
	function aliasFields(schema) {
	  for (var path in schema.paths) {
	    if (!schema.paths[path].options) continue;
	
	    var prop = schema.paths[path].path;
	    var alias = schema.paths[path].options.alias;
	
	    if (alias) {
	      if ('string' === typeof alias && alias.length > 0) {
	        if (schema.aliases[alias])
	          throw new Error('Duplicate alias, alias ' + alias + ' is used more than once');
	        else
	          schema.aliases[alias] = prop;
	
	        schema
	          .virtual(alias)
	          .get((function(p) {
	            return function() {
	              return this.get(p);
	            };
	          })(prop))
	          .set((function(p) {
	            return function(v) {
	              return this.set(p, v);
	            };
	          })(prop));
	      } else {
	        throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);
	      }
	    }
	  }
	}
	
	/*!
	 * Inherit from EventEmitter.
	 */
	Schema.prototype = Object.create(EventEmitter.prototype);
	Schema.prototype.constructor = Schema;
	Schema.prototype.instanceOfSchema = true;
	
	/**
	 * Default middleware attached to a schema. Cannot be changed.
	 *
	 * This field is used to make sure discriminators don't get multiple copies of
	 * built-in middleware. Declared as a constant because changing this at runtime
	 * may lead to instability with Model.prototype.discriminator().
	 *
	 * @api private
	 * @property _defaultMiddleware
	 */
	Object.defineProperty(Schema.prototype, '_defaultMiddleware', {
	  configurable: false,
	  enumerable: false,
	  writable: false,
	  value: [
	    {
	      kind: 'pre',
	      hook: 'remove',
	      isAsync: true,
	      fn: function(next, done) {
	        if (this.ownerDocument) {
	          done();
	          next();
	          return;
	        }
	
	        var subdocs = this.$__getAllSubdocs();
	
	        if (!subdocs.length) {
	          done();
	          next();
	          return;
	        }
	
	        each(subdocs, function(subdoc, cb) {
	          subdoc.remove({ noop: true }, function(err) {
	            cb(err);
	          });
	        }, function(error) {
	          if (error) {
	            done(error);
	            return;
	          }
	          next();
	          done();
	        });
	      }
	    }
	  ]
	});
	
	
	/**
	 * The original object passed to the schema constructor
	 *
	 * ####Example:
	 *
	 *     var schema = new Schema({ a: String }).add({ b: String });
	 *     schema.obj; // { a: String }
	 *
	 * @api public
	 * @property obj
	 */
	
	Schema.prototype.obj;
	
	/**
	 * Schema as flat paths
	 *
	 * ####Example:
	 *     {
	 *         '_id'        : SchemaType,
	 *       , 'nested.key' : SchemaType,
	 *     }
	 *
	 * @api private
	 * @property paths
	 */
	
	Schema.prototype.paths;
	
	/**
	 * Schema as a tree
	 *
	 * ####Example:
	 *     {
	 *         '_id'     : ObjectId
	 *       , 'nested'  : {
	 *             'key' : String
	 *         }
	 *     }
	 *
	 * @api private
	 * @property tree
	 */
	
	Schema.prototype.tree;
	
	/**
	 * Returns a deep copy of the schema
	 *
	 * @return {Schema} the cloned schema
	 * @api public
	 */
	
	Schema.prototype.clone = function() {
	  var s = new Schema(this.paths, this.options);
	  // Clone the call queue
	  s.callQueue = this.callQueue.map(function(f) { return f; });
	  s.methods = utils.clone(this.methods);
	  s.statics = utils.clone(this.statics);
	  s.plugins = Array.prototype.slice.call(this.plugins);
	  s._indexes = utils.clone(this._indexes);
	  s.s.hooks = this.s.hooks.clone();
	  return s;
	};
	
	/**
	 * Returns default options for this schema, merged with `options`.
	 *
	 * @param {Object} options
	 * @return {Object}
	 * @api private
	 */
	
	Schema.prototype.defaultOptions = function(options) {
	  if (options && options.safe === false) {
	    options.safe = {w: 0};
	  }
	
	  if (options && options.safe && options.safe.w === 0) {
	    // if you turn off safe writes, then versioning goes off as well
	    options.versionKey = false;
	  }
	
	  options = utils.options({
	    strict: true,
	    bufferCommands: true,
	    capped: false, // { size, max, autoIndexId }
	    versionKey: '__v',
	    discriminatorKey: '__t',
	    minimize: true,
	    autoIndex: null,
	    shardKey: null,
	    read: null,
	    validateBeforeSave: true,
	    // the following are only applied at construction time
	    noId: false, // deprecated, use { _id: false }
	    _id: true,
	    noVirtualId: false, // deprecated, use { id: false }
	    id: true,
	    typeKey: 'type',
	    retainKeyOrder: false
	  }, options);
	
	  if (options.read) {
	    options.read = readPref(options.read);
	  }
	
	  return options;
	};
	
	/**
	 * Adds key path / schema type pairs to this schema.
	 *
	 * ####Example:
	 *
	 *     var ToySchema = new Schema;
	 *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });
	 *
	 * @param {Object} obj
	 * @param {String} prefix
	 * @api public
	 */
	
	Schema.prototype.add = function add(obj, prefix) {
	  prefix = prefix || '';
	  var keys = Object.keys(obj);
	
	  for (var i = 0; i < keys.length; ++i) {
	    var key = keys[i];
	
	    if (obj[key] == null) {
	      throw new TypeError('Invalid value for schema path `' + prefix + key + '`');
	    }
	
	    if (Array.isArray(obj[key]) && obj[key].length === 1 && obj[key][0] == null) {
	      throw new TypeError('Invalid value for schema Array path `' + prefix + key + '`');
	    }
	
	    if (utils.isObject(obj[key]) &&
	        (!obj[key].constructor || utils.getFunctionName(obj[key].constructor) === 'Object') &&
	        (!obj[key][this.options.typeKey] || (this.options.typeKey === 'type' && obj[key].type.type))) {
	      if (Object.keys(obj[key]).length) {
	        // nested object { last: { name: String }}
	        this.nested[prefix + key] = true;
	        this.add(obj[key], prefix + key + '.');
	      } else {
	        if (prefix) {
	          this.nested[prefix.substr(0, prefix.length - 1)] = true;
	        }
	        this.path(prefix + key, obj[key]); // mixed type
	      }
	    } else {
	      if (prefix) {
	        this.nested[prefix.substr(0, prefix.length - 1)] = true;
	      }
	      this.path(prefix + key, obj[key]);
	    }
	  }
	};
	
	/**
	 * Reserved document keys.
	 *
	 * Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.
	 *
	 *      on, emit, _events, db, get, set, init, isNew, errors, schema, options, modelName, collection, _pres, _posts, toObject
	 *
	 * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.
	 *
	 *      var schema = new Schema(..);
	 *      schema.methods.init = function () {} // potentially breaking
	 */
	
	Schema.reserved = Object.create(null);
	var reserved = Schema.reserved;
	// Core object
	reserved['prototype'] =
	// EventEmitter
	reserved.emit =
	reserved.on =
	reserved.once =
	reserved.listeners =
	reserved.removeListener =
	// document properties and functions
	reserved.collection =
	reserved.db =
	reserved.errors =
	reserved.init =
	reserved.isModified =
	reserved.isNew =
	reserved.get =
	reserved.modelName =
	reserved.save =
	reserved.schema =
	reserved.set =
	reserved.toObject =
	reserved.validate =
	reserved.remove =
	// hooks.js
	reserved._pres = reserved._posts = 1;
	
	/*!
	 * Document keys to print warnings for
	 */
	
	var warnings = {};
	warnings.increment = '`increment` should not be used as a schema path name ' +
	    'unless you have disabled versioning.';
	
	/**
	 * Gets/sets schema paths.
	 *
	 * Sets a path (if arity 2)
	 * Gets a path (if arity 1)
	 *
	 * ####Example
	 *
	 *     schema.path('name') // returns a SchemaType
	 *     schema.path('name', Number) // changes the schemaType of `name` to Number
	 *
	 * @param {String} path
	 * @param {Object} constructor
	 * @api public
	 */
	
	Schema.prototype.path = function(path, obj) {
	  if (obj === undefined) {
	    if (this.paths[path]) {
	      return this.paths[path];
	    }
	    if (this.subpaths[path]) {
	      return this.subpaths[path];
	    }
	    if (this.singleNestedPaths[path]) {
	      return this.singleNestedPaths[path];
	    }
	
	    // subpaths?
	    return /\.\d+\.?.*$/.test(path)
	        ? getPositionalPath(this, path)
	        : undefined;
	  }
	
	  // some path names conflict with document methods
	  if (reserved[path]) {
	    throw new Error('`' + path + '` may not be used as a schema pathname');
	  }
	
	  if (warnings[path]) {
	    console.log('WARN: ' + warnings[path]);
	  }
	
	  // update the tree
	  var subpaths = path.split(/\./),
	      last = subpaths.pop(),
	      branch = this.tree;
	
	  subpaths.forEach(function(sub, i) {
	    if (!branch[sub]) {
	      branch[sub] = {};
	    }
	    if (typeof branch[sub] !== 'object') {
	      var msg = 'Cannot set nested path `' + path + '`. '
	          + 'Parent path `'
	          + subpaths.slice(0, i).concat([sub]).join('.')
	          + '` already set to type ' + branch[sub].name
	          + '.';
	      throw new Error(msg);
	    }
	    branch = branch[sub];
	  });
	
	  branch[last] = utils.clone(obj);
	
	  this.paths[path] = Schema.interpretAsType(path, obj, this.options);
	
	  if (this.paths[path].$isSingleNested) {
	    for (var key in this.paths[path].schema.paths) {
	      this.singleNestedPaths[path + '.' + key] =
	          this.paths[path].schema.paths[key];
	    }
	    for (key in this.paths[path].schema.singleNestedPaths) {
	      this.singleNestedPaths[path + '.' + key] =
	          this.paths[path].schema.singleNestedPaths[key];
	    }
	
	    this.childSchemas.push({
	      schema: this.paths[path].schema,
	      model: this.paths[path].caster
	    });
	  } else if (this.paths[path].$isMongooseDocumentArray) {
	    this.childSchemas.push({
	      schema: this.paths[path].schema,
	      model: this.paths[path].casterConstructor
	    });
	  }
	  return this;
	};
	
	/**
	 * Converts type arguments into Mongoose Types.
	 *
	 * @param {String} path
	 * @param {Object} obj constructor
	 * @api private
	 */
	
	Schema.interpretAsType = function(path, obj, options) {
	  if (obj instanceof SchemaType) {
	    return obj;
	  }
	
	  if (obj.constructor) {
	    var constructorName = utils.getFunctionName(obj.constructor);
	    if (constructorName !== 'Object') {
	      var oldObj = obj;
	      obj = {};
	      obj[options.typeKey] = oldObj;
	    }
	  }
	
	  // Get the type making sure to allow keys named "type"
	  // and default to mixed if not specified.
	  // { type: { type: String, default: 'freshcut' } }
	  var type = obj[options.typeKey] && (options.typeKey !== 'type' || !obj.type.type)
	      ? obj[options.typeKey]
	      : {};
	
	  if (utils.getFunctionName(type.constructor) === 'Object' || type === 'mixed') {
	    return new MongooseTypes.Mixed(path, obj);
	  }
	
	  if (Array.isArray(type) || Array === type || type === 'array') {
	    // if it was specified through { type } look for `cast`
	    var cast = (Array === type || type === 'array')
	        ? obj.cast
	        : type[0];
	
	    if (cast && cast.instanceOfSchema) {
	      return new MongooseTypes.DocumentArray(path, cast, obj);
	    }
	    if (cast &&
	        cast[options.typeKey] &&
	        cast[options.typeKey].instanceOfSchema) {
	      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj);
	    }
	
	    if (Array.isArray(cast)) {
	      return new MongooseTypes.Array(path, Schema.interpretAsType(path, cast, options), obj);
	    }
	
	    if (typeof cast === 'string') {
	      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];
	    } else if (cast && (!cast[options.typeKey] || (options.typeKey === 'type' && cast.type.type))
	        && utils.getFunctionName(cast.constructor) === 'Object') {
	      if (Object.keys(cast).length) {
	        // The `minimize` and `typeKey` options propagate to child schemas
	        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.
	        // See gh-3560
	        var childSchemaOptions = {minimize: options.minimize};
	        if (options.typeKey) {
	          childSchemaOptions.typeKey = options.typeKey;
	        }
	        //propagate 'strict' option to child schema
	        if (options.hasOwnProperty('strict')) {
	          childSchemaOptions.strict = options.strict;
	        }
	        //propagate 'runSettersOnQuery' option to child schema
	        if (options.hasOwnProperty('runSettersOnQuery')) {
	          childSchemaOptions.runSettersOnQuery = options.runSettersOnQuery;
	        }
	        var childSchema = new Schema(cast, childSchemaOptions);
	        childSchema.$implicitlyCreated = true;
	        return new MongooseTypes.DocumentArray(path, childSchema, obj);
	      } else {
	        // Special case: empty object becomes mixed
	        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);
	      }
	    }
	
	    if (cast) {
	      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)
	          ? cast[options.typeKey]
	          : cast;
	
	      name = typeof type === 'string'
	          ? type
	          : type.schemaName || utils.getFunctionName(type);
	
	      if (!(name in MongooseTypes)) {
	        throw new TypeError('Undefined type `' + name + '` at array `' + path +
	          '`');
	      }
	    }
	
	    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);
	  }
	
	  if (type && type.instanceOfSchema) {
	    return new MongooseTypes.Embedded(type, path, obj);
	  }
	
	  var name;
	  if (Buffer.isBuffer(type)) {
	    name = 'Buffer';
	  } else {
	    name = typeof type === 'string'
	        ? type
	      // If not string, `type` is a function. Outside of IE, function.name
	      // gives you the function name. In IE, you need to compute it
	        : type.schemaName || utils.getFunctionName(type);
	  }
	
	  if (name) {
	    name = name.charAt(0).toUpperCase() + name.substring(1);
	  }
	
	  if (undefined == MongooseTypes[name]) {
	    throw new TypeError('Undefined type `' + name + '` at `' + path +
	        '`\n  Did you try nesting Schemas? ' +
	        'You can only nest using refs or arrays.');
	  }
	
	  obj = utils.clone(obj, { retainKeyOrder: true });
	  if (!('runSettersOnQuery' in obj)) {
	    obj.runSettersOnQuery = options.runSettersOnQuery;
	  }
	  return new MongooseTypes[name](path, obj);
	};
	
	/**
	 * Iterates the schemas paths similar to Array#forEach.
	 *
	 * The callback is passed the pathname and schemaType as arguments on each iteration.
	 *
	 * @param {Function} fn callback function
	 * @return {Schema} this
	 * @api public
	 */
	
	Schema.prototype.eachPath = function(fn) {
	  var keys = Object.keys(this.paths),
	      len = keys.length;
	
	  for (var i = 0; i < len; ++i) {
	    fn(keys[i], this.paths[keys[i]]);
	  }
	
	  return this;
	};
	
	/**
	 * Returns an Array of path strings that are required by this schema.
	 *
	 * @api public
	 * @param {Boolean} invalidate refresh the cache
	 * @return {Array}
	 */
	
	Schema.prototype.requiredPaths = function requiredPaths(invalidate) {
	  if (this._requiredpaths && !invalidate) {
	    return this._requiredpaths;
	  }
	
	  var paths = Object.keys(this.paths),
	      i = paths.length,
	      ret = [];
	
	  while (i--) {
	    var path = paths[i];
	    if (this.paths[path].isRequired) {
	      ret.push(path);
	    }
	  }
	  this._requiredpaths = ret;
	  return this._requiredpaths;
	};
	
	/**
	 * Returns indexes from fields and schema-level indexes (cached).
	 *
	 * @api private
	 * @return {Array}
	 */
	
	Schema.prototype.indexedPaths = function indexedPaths() {
	  if (this._indexedpaths) {
	    return this._indexedpaths;
	  }
	  this._indexedpaths = this.indexes();
	  return this._indexedpaths;
	};
	
	/**
	 * Returns the pathType of `path` for this schema.
	 *
	 * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.
	 *
	 * @param {String} path
	 * @return {String}
	 * @api public
	 */
	
	Schema.prototype.pathType = function(path) {
	  if (path in this.paths) {
	    return 'real';
	  }
	  if (path in this.virtuals) {
	    return 'virtual';
	  }
	  if (path in this.nested) {
	    return 'nested';
	  }
	  if (path in this.subpaths) {
	    return 'real';
	  }
	  if (path in this.singleNestedPaths) {
	    return 'real';
	  }
	
	  if (/\.\d+\.|\.\d+$/.test(path)) {
	    return getPositionalPathType(this, path);
	  }
	  return 'adhocOrUndefined';
	};
	
	/**
	 * Returns true iff this path is a child of a mixed schema.
	 *
	 * @param {String} path
	 * @return {Boolean}
	 * @api private
	 */
	
	Schema.prototype.hasMixedParent = function(path) {
	  var subpaths = path.split(/\./g);
	  path = '';
	  for (var i = 0; i < subpaths.length; ++i) {
	    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];
	    if (path in this.paths &&
	        this.paths[path] instanceof MongooseTypes.Mixed) {
	      return true;
	    }
	  }
	
	  return false;
	};
	
	/**
	 * Setup updatedAt and createdAt timestamps to documents if enabled
	 *
	 * @param {Boolean|Object} timestamps timestamps options
	 * @api private
	 */
	Schema.prototype.setupTimestamp = function(timestamps) {
	  if (timestamps) {
	    var paths = ['createdAt', 'updatedAt'].map(handleTimestampOption.bind(null, timestamps));
	    var createdAt = paths[0];
	    var updatedAt = paths[1];
	    var schemaAdditions = paths.reduce(function(cur, path) {
	      if (path != null) {
	        var parts = path.split('.');
	        if (this.pathType(path) === 'adhocOrUndefined') {
	          for (var i = 0; i < parts.length; ++i) {
	            cur[parts[i]] = (i < parts.length - 1 ?
	            cur[parts[i]] || {} :
	              Date);
	          }
	        }
	      }
	      return cur;
	    }.bind(this), {});
	
	    this.add(schemaAdditions);
	
	    this.pre('save', function(next) {
	      var defaultTimestamp = new Date();
	      var auto_id = this._id && this._id.auto;
	
	      if (createdAt != null && !this.get(createdAt) && this.isSelected(createdAt)) {
	        this.set(createdAt, auto_id ? this._id.getTimestamp() : defaultTimestamp);
	      }
	
	      if (updatedAt != null && (this.isNew || this.isModified())) {
	        var ts = defaultTimestamp;
	        if (this.isNew) {
	          if (createdAt != null) {
	            ts = this.get(createdAt);
	          } else if (auto_id) {
	            ts = this._id.getTimestamp();
	          }
	        }
	        this.set(updatedAt, ts);
	      }
	
	      next();
	    });
	
	    var genUpdates = function(currentUpdate, overwrite) {
	      var now = new Date();
	      var updates = {};
	      var _updates = updates;
	      if (overwrite) {
	        if (currentUpdate && currentUpdate.$set) {
	          currentUpdate = currentUpdate.$set;
	          updates.$set = {};
	          _updates = updates.$set;
	        }
	        if (updatedAt != null && !currentUpdate[updatedAt]) {
	          _updates[updatedAt] = now;
	        }
	        if (createdAt != null && !currentUpdate[createdAt]) {
	          _updates[createdAt] = now;
	        }
	        return updates;
	      }
	      updates = { $set: {} };
	      currentUpdate = currentUpdate || {};
	
	      if (updatedAt != null &&
	          (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {
	        updates.$set[updatedAt] = now;
	      }
	
	      if (createdAt != null) {
	        if (currentUpdate[createdAt]) {
	          delete currentUpdate[createdAt];
	        }
	        if (currentUpdate.$set && currentUpdate.$set[createdAt]) {
	          delete currentUpdate.$set[createdAt];
	        }
	
	        updates.$setOnInsert = {};
	        updates.$setOnInsert[createdAt] = now;
	      }
	
	      return updates;
	    };
	
	    this.methods.initializeTimestamps = function() {
	      if (!this.get(createdAt)) {
	        this.set(createdAt, new Date());
	      }
	      if (!this.get(updatedAt)) {
	        this.set(updatedAt, new Date());
	      }
	      return this;
	    };
	
	    this.pre('findOneAndUpdate', function(next) {
	      var overwrite = this.options.overwrite;
	      this.findOneAndUpdate({}, genUpdates(this.getUpdate(), overwrite), {
	        overwrite: overwrite
	      });
	      applyTimestampsToChildren(this);
	      next();
	    });
	
	    this.pre('update', function(next) {
	      var overwrite = this.options.overwrite;
	      this.update({}, genUpdates(this.getUpdate(), overwrite), {
	        overwrite: overwrite
	      });
	      applyTimestampsToChildren(this);
	      next();
	    });
	  }
	};
	
	/*!
	 * ignore
	 */
	
	function handleTimestampOption(arg, prop) {
	  if (typeof arg === 'boolean') {
	    return prop;
	  }
	  if (typeof arg[prop] === 'boolean') {
	    return arg[prop] ? prop : null;
	  }
	  if (!(prop in arg)) {
	    return prop;
	  }
	  return arg[prop];
	}
	
	/*!
	 * ignore
	 */
	
	function applyTimestampsToChildren(query) {
	  var now = new Date();
	  var update = query.getUpdate();
	  var keys = Object.keys(update);
	  var key;
	  var schema = query.model.schema;
	  var len;
	  var createdAt;
	  var updatedAt;
	  var timestamps;
	  var path;
	
	  var hasDollarKey = keys.length && keys[0].charAt(0) === '$';
	
	  if (hasDollarKey) {
	    if (update.$push) {
	      for (key in update.$push) {
	        var $path = schema.path(key);
	        if (update.$push[key] &&
	            $path &&
	            $path.$isMongooseDocumentArray &&
	            $path.schema.options.timestamps) {
	          timestamps = $path.schema.options.timestamps;
	          createdAt = handleTimestampOption(timestamps, 'createdAt');
	          updatedAt = handleTimestampOption(timestamps, 'updatedAt');
	          if (update.$push[key].$each) {
	            update.$push[key].$each.forEach(function(subdoc) {
	              if (updatedAt != null) {
	                subdoc[updatedAt] = now;
	              }
	              if (createdAt != null) {
	                subdoc[createdAt] = now;
	              }
	            });
	          } else {
	            if (updatedAt != null) {
	              update.$push[key][updatedAt] = now;
	            }
	            if (createdAt != null) {
	              update.$push[key][createdAt] = now;
	            }
	          }
	        }
	      }
	    }
	    if (update.$set) {
	      for (key in update.$set) {
	        path = schema.path(key);
	        if (!path) {
	          continue;
	        }
	        if (Array.isArray(update.$set[key]) && path.$isMongooseDocumentArray) {
	          len = update.$set[key].length;
	          timestamps = schema.path(key).schema.options.timestamps;
	          if (timestamps) {
	            createdAt = handleTimestampOption(timestamps, 'createdAt');
	            updatedAt = handleTimestampOption(timestamps, 'updatedAt');
	            for (var i = 0; i < len; ++i) {
	              if (updatedAt != null) {
	                update.$set[key][i][updatedAt] = now;
	              }
	              if (createdAt != null) {
	                update.$set[key][i][createdAt] = now;
	              }
	            }
	          }
	        } else if (update.$set[key] && path.$isSingleNested) {
	          timestamps = schema.path(key).schema.options.timestamps;
	          if (timestamps) {
	            createdAt = handleTimestampOption(timestamps, 'createdAt');
	            updatedAt = handleTimestampOption(timestamps, 'updatedAt');
	            if (updatedAt != null) {
	              update.$set[key][updatedAt] = now;
	            }
	            if (createdAt != null) {
	              update.$set[key][createdAt] = now;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	/*!
	 * ignore
	 */
	
	function getPositionalPathType(self, path) {
	  var subpaths = path.split(/\.(\d+)\.|\.(\d+)$/).filter(Boolean);
	  if (subpaths.length < 2) {
	    return self.paths[subpaths[0]];
	  }
	
	  var val = self.path(subpaths[0]);
	  var isNested = false;
	  if (!val) {
	    return val;
	  }
	
	  var last = subpaths.length - 1,
	      subpath,
	      i = 1;
	
	  for (; i < subpaths.length; ++i) {
	    isNested = false;
	    subpath = subpaths[i];
	
	    if (i === last && val && !/\D/.test(subpath)) {
	      if (val.$isMongooseDocumentArray) {
	        var oldVal = val;
	        val = new SchemaType(subpath);
	        val.cast = function(value, doc, init) {
	          return oldVal.cast(value, doc, init)[0];
	        };
	        val.caster = oldVal.caster;
	        val.schema = oldVal.schema;
	      } else if (val instanceof MongooseTypes.Array) {
	        // StringSchema, NumberSchema, etc
	        val = val.caster;
	      } else {
	        val = undefined;
	      }
	      break;
	    }
	
	    // ignore if its just a position segment: path.0.subpath
	    if (!/\D/.test(subpath)) {
	      continue;
	    }
	
	    if (!(val && val.schema)) {
	      val = undefined;
	      break;
	    }
	
	    var type = val.schema.pathType(subpath);
	    isNested = (type === 'nested');
	    val = val.schema.path(subpath);
	  }
	
	  self.subpaths[path] = val;
	  if (val) {
	    return 'real';
	  }
	  if (isNested) {
	    return 'nested';
	  }
	  return 'adhocOrUndefined';
	}
	
	
	/*!
	 * ignore
	 */
	
	function getPositionalPath(self, path) {
	  getPositionalPathType(self, path);
	  return self.subpaths[path];
	}
	
	/**
	 * Adds a method call to the queue.
	 *
	 * @param {String} name name of the document method to call later
	 * @param {Array} args arguments to pass to the method
	 * @api public
	 */
	
	Schema.prototype.queue = function(name, args) {
	  this.callQueue.push([name, args]);
	  return this;
	};
	
	/**
	 * Defines a pre hook for the document.
	 *
	 * ####Example
	 *
	 *     var toySchema = new Schema(..);
	 *
	 *     toySchema.pre('save', function (next) {
	 *       if (!this.created) this.created = new Date;
	 *       next();
	 *     })
	 *
	 *     toySchema.pre('validate', function (next) {
	 *       if (this.name !== 'Woody') this.name = 'Woody';
	 *       next();
	 *     })
	 *
	 * @param {String} method
	 * @param {Function} callback
	 * @see hooks.js https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3
	 * @api public
	 */
	
	Schema.prototype.pre = function() {
	  var name = arguments[0];
	  if (IS_KAREEM_HOOK[name]) {
	    this.s.hooks.pre.apply(this.s.hooks, arguments);
	    return this;
	  }
	  return this.queue('pre', arguments);
	};
	
	/**
	 * Defines a post hook for the document
	 *
	 *     var schema = new Schema(..);
	 *     schema.post('save', function (doc) {
	 *       console.log('this fired after a document was saved');
	 *     });
	 *
	 *     schema.post('find', function(docs) {
	 *       console.log('this fired after you run a find query');
	 *     });
	 *
	 *     var Model = mongoose.model('Model', schema);
	 *
	 *     var m = new Model(..);
	 *     m.save(function(err) {
	 *       console.log('this fires after the `post` hook');
	 *     });
	 *
	 *     m.find(function(err, docs) {
	 *       console.log('this fires after the post find hook');
	 *     });
	 *
	 * @param {String} method name of the method to hook
	 * @param {Function} fn callback
	 * @see middleware http://mongoosejs.com/docs/middleware.html
	 * @see hooks.js https://www.npmjs.com/package/hooks-fixed
	 * @see kareem http://npmjs.org/package/kareem
	 * @api public
	 */
	
	Schema.prototype.post = function(method, fn) {
	  if (IS_KAREEM_HOOK[method]) {
	    this.s.hooks.post.apply(this.s.hooks, arguments);
	    return this;
	  }
	  // assuming that all callbacks with arity < 2 are synchronous post hooks
	  if (fn.length < 2) {
	    return this.queue('on', [arguments[0], function(doc) {
	      return fn.call(doc, doc);
	    }]);
	  }
	
	  if (fn.length === 3) {
	    this.s.hooks.post(method + ':error', fn);
	    return this;
	  }
	
	  return this.queue('post', [arguments[0], function(next) {
	    // wrap original function so that the callback goes last,
	    // for compatibility with old code that is using synchronous post hooks
	    var _this = this;
	    var args = Array.prototype.slice.call(arguments, 1);
	    fn.call(this, this, function(err) {
	      return next.apply(_this, [err].concat(args));
	    });
	  }]);
	};
	
	/**
	 * Registers a plugin for this schema.
	 *
	 * @param {Function} plugin callback
	 * @param {Object} [opts]
	 * @see plugins
	 * @api public
	 */
	
	Schema.prototype.plugin = function(fn, opts) {
	  if (typeof fn !== 'function') {
	    throw new Error('First param to `schema.plugin()` must be a function, ' +
	      'got "' + (typeof fn) + '"');
	  }
	
	  if (opts &&
	      opts.deduplicate) {
	    for (var i = 0; i < this.plugins.length; ++i) {
	      if (this.plugins[i].fn === fn) {
	        return this;
	      }
	    }
	  }
	  this.plugins.push({ fn: fn, opts: opts });
	
	  fn(this, opts);
	  return this;
	};
	
	/**
	 * Adds an instance method to documents constructed from Models compiled from this schema.
	 *
	 * ####Example
	 *
	 *     var schema = kittySchema = new Schema(..);
	 *
	 *     schema.method('meow', function () {
	 *       console.log('meeeeeoooooooooooow');
	 *     })
	 *
	 *     var Kitty = mongoose.model('Kitty', schema);
	 *
	 *     var fizz = new Kitty;
	 *     fizz.meow(); // meeeeeooooooooooooow
	 *
	 * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.
	 *
	 *     schema.method({
	 *         purr: function () {}
	 *       , scratch: function () {}
	 *     });
	 *
	 *     // later
	 *     fizz.purr();
	 *     fizz.scratch();
	 *
	 * @param {String|Object} method name
	 * @param {Function} [fn]
	 * @api public
	 */
	
	Schema.prototype.method = function(name, fn) {
	  if (typeof name !== 'string') {
	    for (var i in name) {
	      this.methods[i] = name[i];
	    }
	  } else {
	    this.methods[name] = fn;
	  }
	  return this;
	};
	
	/**
	 * Adds static "class" methods to Models compiled from this schema.
	 *
	 * ####Example
	 *
	 *     var schema = new Schema(..);
	 *     schema.static('findByName', function (name, callback) {
	 *       return this.find({ name: name }, callback);
	 *     });
	 *
	 *     var Drink = mongoose.model('Drink', schema);
	 *     Drink.findByName('sanpellegrino', function (err, drinks) {
	 *       //
	 *     });
	 *
	 * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.
	 *
	 * @param {String|Object} name
	 * @param {Function} [fn]
	 * @api public
	 */
	
	Schema.prototype.static = function(name, fn) {
	  if (typeof name !== 'string') {
	    for (var i in name) {
	      this.statics[i] = name[i];
	    }
	  } else {
	    this.statics[name] = fn;
	  }
	  return this;
	};
	
	/**
	 * Defines an index (most likely compound) for this schema.
	 *
	 * ####Example
	 *
	 *     schema.index({ first: 1, last: -1 })
	 *
	 * @param {Object} fields
	 * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#createIndex)
	 * @param {String} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.
	 * @api public
	 */
	
	Schema.prototype.index = function(fields, options) {
	  options || (options = {});
	
	  if (options.expires) {
	    utils.expires(options);
	  }
	
	  this._indexes.push([fields, options]);
	  return this;
	};
	
	/**
	 * Sets/gets a schema option.
	 *
	 * ####Example
	 *
	 *     schema.set('strict'); // 'true' by default
	 *     schema.set('strict', false); // Sets 'strict' to false
	 *     schema.set('strict'); // 'false'
	 *
	 * @param {String} key option name
	 * @param {Object} [value] if not passed, the current option value is returned
	 * @see Schema ./
	 * @api public
	 */
	
	Schema.prototype.set = function(key, value, _tags) {
	  if (arguments.length === 1) {
	    return this.options[key];
	  }
	
	  switch (key) {
	    case 'read':
	      this.options[key] = readPref(value, _tags);
	      break;
	    case 'safe':
	      this.options[key] = value === false
	          ? {w: 0}
	          : value;
	      break;
	    case 'timestamps':
	      this.setupTimestamp(value);
	      this.options[key] = value;
	      break;
	    default:
	      this.options[key] = value;
	  }
	
	  return this;
	};
	
	/**
	 * Gets a schema option.
	 *
	 * @param {String} key option name
	 * @api public
	 */
	
	Schema.prototype.get = function(key) {
	  return this.options[key];
	};
	
	/**
	 * The allowed index types
	 *
	 * @static indexTypes
	 * @receiver Schema
	 * @api public
	 */
	
	var indexTypes = '2d 2dsphere hashed text'.split(' ');
	
	Object.defineProperty(Schema, 'indexTypes', {
	  get: function() {
	    return indexTypes;
	  },
	  set: function() {
	    throw new Error('Cannot overwrite Schema.indexTypes');
	  }
	});
	
	/**
	 * Compiles indexes from fields and schema-level indexes
	 *
	 * @api public
	 */
	
	Schema.prototype.indexes = function() {
	  'use strict';
	
	  var indexes = [];
	  var schemaStack = [];
	
	  var collectIndexes = function(schema, prefix) {
	    // Ignore infinitely nested schemas, if we've already seen this schema
	    // along this path there must be a cycle
	    if (schemaStack.indexOf(schema) !== -1) {
	      return;
	    }
	    schemaStack.push(schema);
	
	    prefix = prefix || '';
	    var key, path, index, field, isObject, options, type;
	    var keys = Object.keys(schema.paths);
	
	    for (var i = 0; i < keys.length; ++i) {
	      key = keys[i];
	      path = schema.paths[key];
	
	      if ((path instanceof MongooseTypes.DocumentArray) || path.$isSingleNested) {
	        collectIndexes(path.schema, prefix + key + '.');
	      } else {
	        index = path._index || (path.caster && path.caster._index);
	
	        if (index !== false && index !== null && index !== undefined) {
	          field = {};
	          isObject = utils.isObject(index);
	          options = isObject ? index : {};
	          type = typeof index === 'string' ? index :
	              isObject ? index.type :
	                  false;
	
	          if (type && ~Schema.indexTypes.indexOf(type)) {
	            field[prefix + key] = type;
	          } else if (options.text) {
	            field[prefix + key] = 'text';
	            delete options.text;
	          } else {
	            field[prefix + key] = 1;
	          }
	
	          delete options.type;
	          if (!('background' in options)) {
	            options.background = true;
	          }
	
	          indexes.push([field, options]);
	        }
	      }
	    }
	
	    schemaStack.pop();
	
	    if (prefix) {
	      fixSubIndexPaths(schema, prefix);
	    } else {
	      schema._indexes.forEach(function(index) {
	        if (!('background' in index[1])) {
	          index[1].background = true;
	        }
	      });
	      indexes = indexes.concat(schema._indexes);
	    }
	  };
	
	  collectIndexes(this);
	  return indexes;
	
	  /*!
	   * Checks for indexes added to subdocs using Schema.index().
	   * These indexes need their paths prefixed properly.
	   *
	   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]
	   */
	
	  function fixSubIndexPaths(schema, prefix) {
	    var subindexes = schema._indexes,
	        len = subindexes.length,
	        indexObj,
	        newindex,
	        klen,
	        keys,
	        key,
	        i = 0,
	        j;
	
	    for (i = 0; i < len; ++i) {
	      indexObj = subindexes[i][0];
	      keys = Object.keys(indexObj);
	      klen = keys.length;
	      newindex = {};
	
	      // use forward iteration, order matters
	      for (j = 0; j < klen; ++j) {
	        key = keys[j];
	        newindex[prefix + key] = indexObj[key];
	      }
	
	      indexes.push([newindex, subindexes[i][1]]);
	    }
	  }
	};
	
	/**
	 * Creates a virtual type with the given name.
	 *
	 * @param {String} name
	 * @param {Object} [options]
	 * @return {VirtualType}
	 */
	
	Schema.prototype.virtual = function(name, options) {
	  if (options && options.ref) {
	    if (!options.localField) {
	      throw new Error('Reference virtuals require `localField` option');
	    }
	
	    if (!options.foreignField) {
	      throw new Error('Reference virtuals require `foreignField` option');
	    }
	
	    this.pre('init', function(next, obj) {
	      if (mpath.has(name, obj)) {
	        var _v = mpath.get(name, obj);
	        if (!this.$$populatedVirtuals) {
	          this.$$populatedVirtuals = {};
	        }
	
	        if (options.justOne) {
	          this.$$populatedVirtuals[name] = Array.isArray(_v) ?
	            _v[0] :
	            _v;
	        } else {
	          this.$$populatedVirtuals[name] = Array.isArray(_v) ?
	            _v :
	            _v == null ? [] : [_v];
	        }
	
	        mpath.unset(name, obj);
	      }
	      if (this.ownerDocument) {
	        next();
	        return this;
	      } else {
	        next();
	      }
	    });
	
	    var virtual = this.virtual(name);
	    virtual.options = options;
	    return virtual.
	      get(function() {
	        if (!this.$$populatedVirtuals) {
	          this.$$populatedVirtuals = {};
	        }
	        if (name in this.$$populatedVirtuals) {
	          return this.$$populatedVirtuals[name];
	        }
	        return null;
	      }).
	      set(function(_v) {
	        if (!this.$$populatedVirtuals) {
	          this.$$populatedVirtuals = {};
	        }
	
	        if (options.justOne) {
	          this.$$populatedVirtuals[name] = Array.isArray(_v) ?
	            _v[0] :
	            _v;
	
	          if (typeof this.$$populatedVirtuals[name] !== 'object') {
	            this.$$populatedVirtuals[name] = null;
	          }
	        } else {
	          this.$$populatedVirtuals[name] = Array.isArray(_v) ?
	            _v :
	            _v == null ? [] : [_v];
	
	          this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) {
	            return doc && typeof doc === 'object';
	          });
	        }
	      });
	  }
	
	  var virtuals = this.virtuals;
	  var parts = name.split('.');
	
	  if (this.pathType(name) === 'real') {
	    throw new Error('Virtual path "' + name + '"' +
	      ' conflicts with a real path in the schema');
	  }
	
	  virtuals[name] = parts.reduce(function(mem, part, i) {
	    mem[part] || (mem[part] = (i === parts.length - 1)
	        ? new VirtualType(options, name)
	        : {});
	    return mem[part];
	  }, this.tree);
	
	  return virtuals[name];
	};
	
	/*!
	 * ignore
	 */
	
	Schema.prototype._getVirtual = function(name) {
	  return _getVirtual(this, name);
	};
	
	/*!
	 * ignore
	 */
	
	function _getVirtual(schema, name) {
	  if (schema.virtuals[name]) {
	    return schema.virtuals[name];
	  }
	  var parts = name.split('.');
	  var cur = '';
	  var nestedSchemaPath = '';
	  for (var i = 0; i < parts.length; ++i) {
	    cur += (cur.length > 0 ? '.' : '') + parts[i];
	    if (schema.virtuals[cur]) {
	      if (i === parts.length - 1) {
	        schema.virtuals[cur].$nestedSchemaPath = nestedSchemaPath;
	        return schema.virtuals[cur];
	      }
	      continue;
	    } else if (schema.paths[cur] && schema.paths[cur].schema) {
	      schema = schema.paths[cur].schema;
	      nestedSchemaPath += (nestedSchemaPath.length > 0 ? '.' : '') + cur;
	      cur = '';
	    } else {
	      return null;
	    }
	  }
	}
	
	/**
	 * Returns the virtual type with the given `name`.
	 *
	 * @param {String} name
	 * @return {VirtualType}
	 */
	
	Schema.prototype.virtualpath = function(name) {
	  return this.virtuals[name];
	};
	
	/**
	 * Removes the given `path` (or [`paths`]).
	 *
	 * @param {String|Array} path
	 *
	 * @api public
	 */
	Schema.prototype.remove = function(path) {
	  if (typeof path === 'string') {
	    path = [path];
	  }
	  if (Array.isArray(path)) {
	    path.forEach(function(name) {
	      if (this.path(name)) {
	        delete this.paths[name];
	
	        var pieces = name.split('.');
	        var last = pieces.pop();
	        var branch = this.tree;
	        for (var i = 0; i < pieces.length; ++i) {
	          branch = branch[pieces[i]];
	        }
	        delete branch[last];
	      }
	    }, this);
	  }
	};
	
	/**
	 * Loads an ES6 class into a schema. Maps setters + getters, static methods, and instance methods to schema virtuals, statics, and methods.
	 *
	 * @param {Function} model
	 */
	Schema.prototype.loadClass = function(model, virtualsOnly) {
	  if (model === Object.prototype ||
	      model === Function.prototype ||
	      model.prototype.hasOwnProperty('$isMongooseModelPrototype')) {
	    return this;
	  }
	
	  this.loadClass(Object.getPrototypeOf(model));
	
	  // Add static methods
	  if (!virtualsOnly) {
	    Object.getOwnPropertyNames(model).forEach(function(name) {
	      if (name.match(/^(length|name|prototype)$/)) {
	        return;
	      }
	      var method = Object.getOwnPropertyDescriptor(model, name);
	      if (typeof method.value === 'function') {
	        this.static(name, method.value);
	      }
	    }, this);
	  }
	
	  // Add methods and virtuals
	  Object.getOwnPropertyNames(model.prototype).forEach(function(name) {
	    if (name.match(/^(constructor)$/)) {
	      return;
	    }
	    var method = Object.getOwnPropertyDescriptor(model.prototype, name);
	    if (!virtualsOnly) {
	      if (typeof method.value === 'function') {
	        this.method(name, method.value);
	      }
	    }
	    if (typeof method.get === 'function') {
	      this.virtual(name).get(method.get);
	    }
	    if (typeof method.set === 'function') {
	      this.virtual(name).set(method.set);
	    }
	  }, this);
	
	  return this;
	};
	
	/*!
	 * ignore
	 */
	
	Schema.prototype._getSchema = function(path) {
	  var _this = this;
	  var pathschema = _this.path(path);
	  var resultPath = [];
	
	  if (pathschema) {
	    pathschema.$fullPath = path;
	    return pathschema;
	  }
	
	  function search(parts, schema) {
	    var p = parts.length + 1;
	    var foundschema;
	    var trypath;
	
	    while (p--) {
	      trypath = parts.slice(0, p).join('.');
	      foundschema = schema.path(trypath);
	      if (foundschema) {
	        resultPath.push(trypath);
	
	        if (foundschema.caster) {
	          // array of Mixed?
	          if (foundschema.caster instanceof MongooseTypes.Mixed) {
	            foundschema.caster.$fullPath = resultPath.join('.');
	            return foundschema.caster;
	          }
	
	          // Now that we found the array, we need to check if there
	          // are remaining document paths to look up for casting.
	          // Also we need to handle array.$.path since schema.path
	          // doesn't work for that.
	          // If there is no foundschema.schema we are dealing with
	          // a path like array.$
	          if (p !== parts.length && foundschema.schema) {
	            var ret;
	            if (parts[p] === '$') {
	              if (p + 1 === parts.length) {
	                // comments.$
	                return foundschema;
	              }
	              // comments.$.comments.$.title
	              ret = search(parts.slice(p + 1), foundschema.schema);
	              if (ret) {
	                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||
	                  !foundschema.schema.$isSingleNested;
	              }
	              return ret;
	            }
	            // this is the last path of the selector
	            ret = search(parts.slice(p), foundschema.schema);
	            if (ret) {
	              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||
	                !foundschema.schema.$isSingleNested;
	            }
	            return ret;
	          }
	        }
	
	        foundschema.$fullPath = resultPath.join('.');
	
	        return foundschema;
	      }
	    }
	  }
	
	  // look for arrays
	  var parts = path.split('.');
	  for (var i = 0; i < parts.length; ++i) {
	    if (parts[i] === '$') {
	      // Re: gh-5628, because `schema.path()` doesn't take $ into account.
	      parts[i] = '0';
	    }
	  }
	  return search(parts, _this);
	};
	
	/*!
	 * ignore
	 */
	
	Schema.prototype._getPathType = function(path) {
	  var _this = this;
	  var pathschema = _this.path(path);
	
	  if (pathschema) {
	    return 'real';
	  }
	
	  function search(parts, schema) {
	    var p = parts.length + 1,
	        foundschema,
	        trypath;
	
	    while (p--) {
	      trypath = parts.slice(0, p).join('.');
	      foundschema = schema.path(trypath);
	      if (foundschema) {
	        if (foundschema.caster) {
	          // array of Mixed?
	          if (foundschema.caster instanceof MongooseTypes.Mixed) {
	            return { schema: foundschema, pathType: 'mixed' };
	          }
	
	          // Now that we found the array, we need to check if there
	          // are remaining document paths to look up for casting.
	          // Also we need to handle array.$.path since schema.path
	          // doesn't work for that.
	          // If there is no foundschema.schema we are dealing with
	          // a path like array.$
	          if (p !== parts.length && foundschema.schema) {
	            if (parts[p] === '$') {
	              if (p === parts.length - 1) {
	                return { schema: foundschema, pathType: 'nested' };
	              }
	              // comments.$.comments.$.title
	              return search(parts.slice(p + 1), foundschema.schema);
	            }
	            // this is the last path of the selector
	            return search(parts.slice(p), foundschema.schema);
	          }
	          return {
	            schema: foundschema,
	            pathType: foundschema.$isSingleNested ? 'nested' : 'array'
	          };
	        }
	        return { schema: foundschema, pathType: 'real' };
	      } else if (p === parts.length && schema.nested[trypath]) {
	        return { schema: schema, pathType: 'nested' };
	      }
	    }
	    return { schema: foundschema || schema, pathType: 'undefined' };
	  }
	
	  // look for arrays
	  return search(path.split('.'), _this);
	};
	
	
	/*!
	 * Module exports.
	 */
	
	module.exports = exports = Schema;
	
	// require down here because of reference issues
	
	/**
	 * The various built-in Mongoose Schema Types.
	 *
	 * ####Example:
	 *
	 *     var mongoose = require('mongoose');
	 *     var ObjectId = mongoose.Schema.Types.ObjectId;
	 *
	 * ####Types:
	 *
	 * - [String](#schema-string-js)
	 * - [Number](#schema-number-js)
	 * - [Boolean](#schema-boolean-js) | Bool
	 * - [Array](#schema-array-js)
	 * - [Buffer](#schema-buffer-js)
	 * - [Date](#schema-date-js)
	 * - [ObjectId](#schema-objectid-js) | Oid
	 * - [Mixed](#schema-mixed-js)
	 *
	 * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.
	 *
	 *     var Mixed = mongoose.Schema.Types.Mixed;
	 *     new mongoose.Schema({ _user: Mixed })
	 *
	 * @api public
	 */
	
	Schema.Types = MongooseTypes = __webpack_require__(139);
	
	/*!
	 * ignore
	 */
	
	exports.ObjectId = MongooseTypes.ObjectId;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseArray = __webpack_require__(101),
	    ObjectId = __webpack_require__(24),
	    ObjectIdSchema = __webpack_require__(97),
	    utils = __webpack_require__(4),
	    Document = __webpack_require__(8);
	
	/**
	 * DocumentArray constructor
	 *
	 * @param {Array} values
	 * @param {String} path the path to this array
	 * @param {Document} doc parent document
	 * @api private
	 * @return {MongooseDocumentArray}
	 * @inherits MongooseArray
	 * @see http://bit.ly/f6CnZU
	 */
	
	function MongooseDocumentArray(values, path, doc) {
	  var arr = [].concat(values);
	  arr._path = path;
	
	  var props = {
	    isMongooseArray: true,
	    isMongooseDocumentArray: true,
	    validators: [],
	    _atomics: {},
	    _schema: void 0,
	    _handlers: void 0
	  };
	
	  // Values always have to be passed to the constructor to initialize, since
	  // otherwise MongooseArray#push will mark the array as modified to the parent.
	  var keysMA = Object.keys(MongooseArray.mixin);
	  var numKeys = keysMA.length;
	  for (var j = 0; j < numKeys; ++j) {
	    arr[keysMA[j]] = MongooseArray.mixin[keysMA[j]];
	  }
	
	  var keysMDA = Object.keys(MongooseDocumentArray.mixin);
	  numKeys = keysMDA.length;
	  for (var i = 0; i < numKeys; ++i) {
	    arr[keysMDA[i]] = MongooseDocumentArray.mixin[keysMDA[i]];
	  }
	
	  var keysP = Object.keys(props);
	  numKeys = keysP.length;
	  for (var k = 0; k < numKeys; ++k) {
	    arr[keysP[k]] = props[keysP[k]];
	  }
	
	  // Because doc comes from the context of another function, doc === global
	  // can happen if there was a null somewhere up the chain (see #3020 && #3034)
	  // RB Jun 17, 2015 updated to check for presence of expected paths instead
	  // to make more proof against unusual node environments
	  if (doc && doc instanceof Document) {
	    arr._parent = doc;
	    arr._schema = doc.schema.path(path);
	    arr._handlers = {
	      isNew: arr.notify('isNew'),
	      save: arr.notify('save')
	    };
	
	    doc.on('save', arr._handlers.save);
	    doc.on('isNew', arr._handlers.isNew);
	  }
	
	  return arr;
	}
	
	/*!
	 * Inherits from MongooseArray
	 */
	// MongooseDocumentArray.mixin = Object.create( MongooseArray.mixin );
	MongooseDocumentArray.mixin = {
	  /*!
	   * ignore
	   */
	  toBSON: function() {
	    return this.toObject({
	      transform: false,
	      virtuals: false,
	      _skipDepopulateTopLevel: true,
	      depopulate: true,
	      flattenDecimals: false
	    });
	  },
	
	  /**
	   * Overrides MongooseArray#cast
	   *
	   * @method _cast
	   * @api private
	   * @receiver MongooseDocumentArray
	   */
	
	  _cast: function(value, index) {
	    var Constructor = this._schema.casterConstructor;
	    if (value instanceof Constructor ||
	        // Hack re: #5001, see #5005
	        (value && value.constructor && value.constructor.baseCasterConstructor === Constructor)) {
	      if (!(value.__parent && value.__parentArray)) {
	        // value may have been created using array.create()
	        value.__parent = this._parent;
	        value.__parentArray = this;
	      }
	      value.__index = index;
	      return value;
	    }
	
	    if (value === undefined || value === null) {
	      return null;
	    }
	
	    // handle cast('string') or cast(ObjectId) etc.
	    // only objects are permitted so we can safely assume that
	    // non-objects are to be interpreted as _id
	    if (Buffer.isBuffer(value) ||
	        value instanceof ObjectId || !utils.isObject(value)) {
	      value = {_id: value};
	    }
	
	    if (value &&
	        Constructor.discriminators &&
	        Constructor.schema.options.discriminatorKey &&
	        typeof value[Constructor.schema.options.discriminatorKey] === 'string' &&
	        Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]) {
	      Constructor = Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]];
	    }
	
	    return new Constructor(value, this, undefined, undefined, index);
	  },
	
	  /**
	   * Searches array items for the first document with a matching _id.
	   *
	   * ####Example:
	   *
	   *     var embeddedDoc = m.array.id(some_id);
	   *
	   * @return {EmbeddedDocument|null} the subdocument or null if not found.
	   * @param {ObjectId|String|Number|Buffer} id
	   * @TODO cast to the _id based on schema for proper comparison
	   * @method id
	   * @api public
	   * @receiver MongooseDocumentArray
	   */
	
	  id: function(id) {
	    var casted,
	        sid,
	        _id;
	
	    try {
	      var casted_ = ObjectIdSchema.prototype.cast.call({}, id);
	      if (casted_) {
	        casted = String(casted_);
	      }
	    } catch (e) {
	      casted = null;
	    }
	
	    for (var i = 0, l = this.length; i < l; i++) {
	      if (!this[i]) {
	        continue;
	      }
	      _id = this[i].get('_id');
	
	      if (_id === null || typeof _id === 'undefined') {
	        continue;
	      } else if (_id instanceof Document) {
	        sid || (sid = String(id));
	        if (sid == _id._id) {
	          return this[i];
	        }
	      } else if (!(id instanceof ObjectId) && !(_id instanceof ObjectId)) {
	        if (utils.deepEqual(id, _id)) {
	          return this[i];
	        }
	      } else if (casted == _id) {
	        return this[i];
	      }
	    }
	
	    return null;
	  },
	
	  /**
	   * Returns a native js Array of plain js objects
	   *
	   * ####NOTE:
	   *
	   * _Each sub-document is converted to a plain object by calling its `#toObject` method._
	   *
	   * @param {Object} [options] optional options to pass to each documents `toObject` method call during conversion
	   * @return {Array}
	   * @method toObject
	   * @api public
	   * @receiver MongooseDocumentArray
	   */
	
	  toObject: function(options) {
	    return this.map(function(doc) {
	      return doc && doc.toObject(options) || null;
	    });
	  },
	
	  /**
	   * Helper for console.log
	   *
	   * @method inspect
	   * @api public
	   * @receiver MongooseDocumentArray
	   */
	
	  inspect: function() {
	    return Array.prototype.slice.call(this);
	  },
	
	  /**
	   * Creates a subdocument casted to this schema.
	   *
	   * This is the same subdocument constructor used for casting.
	   *
	   * @param {Object} obj the value to cast to this arrays SubDocument schema
	   * @method create
	   * @api public
	   * @receiver MongooseDocumentArray
	   */
	
	  create: function(obj) {
	    var Constructor = this._schema.casterConstructor;
	    if (obj &&
	        Constructor.discriminators &&
	        Constructor.schema.options.discriminatorKey &&
	        typeof obj[Constructor.schema.options.discriminatorKey] === 'string' &&
	        Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]) {
	      Constructor = Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]];
	    }
	
	    return new Constructor(obj);
	  },
	
	  /**
	   * Creates a fn that notifies all child docs of `event`.
	   *
	   * @param {String} event
	   * @return {Function}
	   * @method notify
	   * @api private
	   * @receiver MongooseDocumentArray
	   */
	
	  notify: function notify(event) {
	    var _this = this;
	    return function notify(val) {
	      var i = _this.length;
	      while (i--) {
	        if (!_this[i]) {
	          continue;
	        }
	        switch (event) {
	          // only swap for save event for now, we may change this to all event types later
	          case 'save':
	            val = _this[i];
	            break;
	          default:
	            // NO-OP
	            break;
	        }
	        _this[i].emit(event, val);
	      }
	    };
	  }
	
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = MongooseDocumentArray;


/***/ }),
/* 47 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 48 */
/***/ (function(module, exports) {

	module.exports = require("crypto");

/***/ }),
/* 49 */
/***/ (function(module, exports) {

	module.exports = require("os");

/***/ }),
/* 50 */
/***/ (function(module, exports) {

	var Int32 = function(value) {
	  if(!(this instanceof Int32)) return new Int32(value);
	
	  this._bsontype = 'Int32';
	  this.value = value;
	}
	
	/**
	 * Access the number value.
	 *
	 * @method
	 * @return {number} returns the wrapped int32 number.
	 */
	Int32.prototype.valueOf = function() {
	  return this.value;
	};
	
	/**
	 * @ignore
	 */
	Int32.prototype.toJSON = function() {
	  return this.value;
	}
	
	module.exports = Int32;
	module.exports.Int32 = Int32;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(189),
	    isLength = __webpack_require__(118);
	
	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}
	
	module.exports = isArrayLike;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var f = __webpack_require__(1).format
	  , require_optional = __webpack_require__(20)
	  , Query = __webpack_require__(9).Query
	  , MongoError = __webpack_require__(7);
	
	var AuthSession = function(db, username, password, options) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	  this.options = options;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	// Kerberos class
	var Kerberos = null;
	var MongoAuthProcess = null;
	
	// Try to grab the Kerberos class
	try {
	  Kerberos = require_optional('kerberos').Kerberos;
	  // Authentication process for Mongo
	  MongoAuthProcess = require_optional('kerberos').processes.MongoAuthProcess;
	} catch(err) {  
	}
	
	/**
	 * Creates a new GSSAPI authentication mechanism
	 * @class
	 * @return {GSSAPI} A cursor instance
	 */
	var GSSAPI = function(bson) {
	  this.bson = bson;
	  this.authStore = [];
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	GSSAPI.prototype.auth = function(server, connections, db, username, password, options, callback) {
	  var self = this;
	  // We don't have the Kerberos library
	  if(Kerberos == null) return callback(new Error("Kerberos library is not installed"));
	  var gssapiServiceName = options['gssapiServiceName'] || 'mongodb';
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var errorObject = null;
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {
	    // Execute MongoCR
	    var execute = function(connection) {
	      // Start Auth process for a connection
	      GSSAPIInitialize(self, db, username, password, db, gssapiServiceName, server, connection, options, function(err, r) {
	        // Adjust count
	        count = count - 1;
	
	        // If we have an error
	        if(err) {
	          errorObject = err;
	        } else if(r.result['$err']) {
	          errorObject = r.result;
	        } else if(r.result['errmsg']) {
	          errorObject = r.result;
	        } else {
	          numberOfValidConnections = numberOfValidConnections + 1;
	        }
	
	        // We have authenticated all connections
	        if(count == 0 && numberOfValidConnections > 0) {
	          // Store the auth details
	          addAuthSession(self.authStore, new AuthSession(db, username, password, options));
	          // Return correct authentication
	          callback(null, true);
	        } else if(count == 0) {
	          if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
	          callback(errorObject, false);
	        }
	      });
	    }
	
	    var _execute = function(_connection) {
	      process.nextTick(function() {
	        execute(_connection);
	      });
	    }
	
	    _execute(connections.shift());
	  }
	}
	
	//
	// Initialize step
	var GSSAPIInitialize = function(self, db, username, password, authdb, gssapiServiceName, server, connection, options, callback) {
	  // Create authenticator
	  var mongo_auth_process = new MongoAuthProcess(connection.host, connection.port, gssapiServiceName, options);
	
	  // Perform initialization
	  mongo_auth_process.init(username, password, function(err) {
	    if(err) return callback(err, false);
	
	    // Perform the first step
	    mongo_auth_process.transition('', function(err, payload) {
	      if(err) return callback(err, false);
	
	      // Call the next db step
	      MongoDBGSSAPIFirstStep(self, mongo_auth_process, payload, db, username, password, authdb, server, connection, callback);
	    });
	  });
	}
	
	//
	// Perform first step against mongodb
	var MongoDBGSSAPIFirstStep = function(self, mongo_auth_process, payload, db, username, password, authdb, server, connection, callback) {
	  // Build the sasl start command
	  var command = {
	      saslStart: 1
	    , mechanism: 'GSSAPI'
	    , payload: payload
	    , autoAuthorize: 1
	  };
	
	  // Write the commmand on the connection
	  server(connection, new Query(self.bson, "$external.$cmd", command, {
	    numberToSkip: 0, numberToReturn: 1
	  }), function(err, r) {
	    if(err) return callback(err, false);
	    var doc = r.result;
	    // Execute mongodb transition
	    mongo_auth_process.transition(r.result.payload, function(err, payload) {
	      if(err) return callback(err, false);
	
	      // MongoDB API Second Step
	      MongoDBGSSAPISecondStep(self, mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback);
	    });
	  });
	}
	
	//
	// Perform first step against mongodb
	var MongoDBGSSAPISecondStep = function(self, mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback) {
	  // Build Authentication command to send to MongoDB
	  var command = {
	      saslContinue: 1
	    , conversationId: doc.conversationId
	    , payload: payload
	  };
	
	  // Execute the command
	  // Write the commmand on the connection
	  server(connection, new Query(self.bson, "$external.$cmd", command, {
	    numberToSkip: 0, numberToReturn: 1
	  }), function(err, r) {
	    if(err) return callback(err, false);
	    var doc = r.result;
	    // Call next transition for kerberos
	    mongo_auth_process.transition(doc.payload, function(err, payload) {
	      if(err) return callback(err, false);
	
	      // Call the last and third step
	      MongoDBGSSAPIThirdStep(self, mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback);
	    });
	  });
	}
	
	var MongoDBGSSAPIThirdStep = function(self, mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback) {
	  // Build final command
	  var command = {
	      saslContinue: 1
	    , conversationId: doc.conversationId
	    , payload: payload
	  };
	
	  // Execute the command
	  server(connection, new Query(self.bson, "$external.$cmd", command, {
	    numberToSkip: 0, numberToReturn: 1
	  }), function(err, r) {
	    if(err) return callback(err, false);
	    mongo_auth_process.transition(null, function(err) {
	      if(err) return callback(err, null);
	      callback(null, r);
	    });
	  });
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Remove authStore credentials
	 * @method
	 * @param {string} db Name of database we are removing authStore details about
	 * @return {object}
	 */
	GSSAPI.prototype.logout = function(dbName) {
	  this.authStore = this.authStore.filter(function(x) {
	    return x.db != dbName;
	  });
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	GSSAPI.prototype.reauthenticate = function(server, connections, callback) {
	  var authStore = this.authStore.slice(0);
	  var count = authStore.length;
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < authStore.length; i++) {
	    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, authStore[i].options, function(err) {
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(err, null);
	      }
	    });
	  }
	}
	
	/**
	 * This is a result from a authentication strategy
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {boolean} result The result of the authentication process
	 */
	
	module.exports = GSSAPI;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var f = __webpack_require__(1).format
	  , crypto = __webpack_require__(48)
	  , Query = __webpack_require__(9).Query
	  , MongoError = __webpack_require__(7);
	
	var AuthSession = function(db, username, password) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	/**
	 * Creates a new MongoCR authentication mechanism
	 * @class
	 * @return {MongoCR} A cursor instance
	 */
	var MongoCR = function(bson) {
	  this.bson = bson;
	  this.authStore = [];
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	MongoCR.prototype.auth = function(server, connections, db, username, password, callback) {
	  var self = this;
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var errorObject = null;
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {
	    // Execute MongoCR
	    var executeMongoCR = function(connection) {
	      // Write the commmand on the connection
	      server(connection, new Query(self.bson, f("%s.$cmd", db), {
	        getnonce:1
	      }, {
	        numberToSkip: 0, numberToReturn: 1
	      }), function(err, r) {
	        var nonce = null;
	        var key = null;
	
	        // Adjust the number of connections left
	        // Get nonce
	        if(err == null) {
	          nonce = r.result.nonce;
	          // Use node md5 generator
	          var md5 = crypto.createHash('md5');
	          // Generate keys used for authentication
	          md5.update(username + ":mongo:" + password, 'utf8');
	          var hash_password = md5.digest('hex');
	          // Final key
	          md5 = crypto.createHash('md5');
	          md5.update(nonce + username + hash_password, 'utf8');
	          key = md5.digest('hex');
	        }
	
	        // Execute command
	        // Write the commmand on the connection
	        server(connection, new Query(self.bson, f("%s.$cmd", db), {
	          authenticate: 1, user: username, nonce: nonce, key:key
	        }, {
	          numberToSkip: 0, numberToReturn: 1
	        }), function(err, r) {
	          count = count - 1;
	
	          // If we have an error
	          if(err) {
	            errorObject = err;
	          } else if(r.result['$err']) {
	            errorObject = r.result;
	          } else if(r.result['errmsg']) {
	            errorObject = r.result;
	          } else {
	            numberOfValidConnections = numberOfValidConnections + 1;
	          }
	
	          // We have authenticated all connections
	          if(count == 0 && numberOfValidConnections > 0) {
	            // Store the auth details
	            addAuthSession(self.authStore, new AuthSession(db, username, password));
	            // Return correct authentication
	            callback(null, true);
	          } else if(count == 0) {
	            if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
	            callback(errorObject, false);
	          }
	        });
	      });
	    }
	
	    var _execute = function(_connection) {
	      process.nextTick(function() {
	        executeMongoCR(_connection);
	      });
	    }
	
	    _execute(connections.shift());
	  }
	}
	
	/**
	 * Remove authStore credentials
	 * @method
	 * @param {string} db Name of database we are removing authStore details about
	 * @return {object}
	 */
	MongoCR.prototype.logout = function(dbName) {
	  this.authStore = this.authStore.filter(function(x) {
	    return x.db != dbName;
	  });
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	MongoCR.prototype.reauthenticate = function(server, connections, callback) {
	  var authStore = this.authStore.slice(0);
	  var count = authStore.length;
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < authStore.length; i++) {
	    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function(err) {
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(err, null);
	      }
	    });
	  }
	}
	
	/**
	 * This is a result from a authentication strategy
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {boolean} result The result of the authentication process
	 */
	
	module.exports = MongoCR;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var BSON = __webpack_require__(25);
	
	var f = __webpack_require__(1).format
	  , Binary = BSON.Binary
	  , retrieveBSON = __webpack_require__(11).retrieveBSON
	  , Query = __webpack_require__(9).Query
	  , MongoError = __webpack_require__(7);
	
	var BSON = retrieveBSON();
	
	var AuthSession = function(db, username, password) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	/**
	 * Creates a new Plain authentication mechanism
	 * @class
	 * @return {Plain} A cursor instance
	 */
	var Plain = function(bson) {
	  this.bson = bson;
	  this.authStore = [];
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	Plain.prototype.auth = function(server, connections, db, username, password, callback) {
	  var self = this;
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var errorObject = null;
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {
	    // Execute MongoCR
	    var execute = function(connection) {
	      // Create payload
	      var payload = new Binary(f("\x00%s\x00%s", username, password));
	
	      // Let's start the sasl process
	      var command = {
	          saslStart: 1
	        , mechanism: 'PLAIN'
	        , payload: payload
	        , autoAuthorize: 1
	      };
	
	      // Let's start the process
	      server(connection, new Query(self.bson, "$external.$cmd", command, {
	        numberToSkip: 0, numberToReturn: 1
	      }), function(err, r) {
	        // Adjust count
	        count = count - 1;
	
	        // If we have an error
	        if(err) {
	          errorObject = err;
	        } else if(r.result['$err']) {
	          errorObject = r.result;
	        } else if(r.result['errmsg']) {
	          errorObject = r.result;
	        } else {
	          numberOfValidConnections = numberOfValidConnections + 1;
	        }
	
	        // We have authenticated all connections
	        if(count == 0 && numberOfValidConnections > 0) {
	          // Store the auth details
	          addAuthSession(self.authStore, new AuthSession(db, username, password));
	          // Return correct authentication
	          callback(null, true);
	        } else if(count == 0) {
	          if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
	          callback(errorObject, false);
	        }
	      });
	    }
	
	    var _execute = function(_connection) {
	      process.nextTick(function() {
	        execute(_connection);
	      });
	    }
	
	    _execute(connections.shift());
	  }
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Remove authStore credentials
	 * @method
	 * @param {string} db Name of database we are removing authStore details about
	 * @return {object}
	 */
	Plain.prototype.logout = function(dbName) {
	  this.authStore = this.authStore.filter(function(x) {
	    return x.db != dbName;
	  });
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	Plain.prototype.reauthenticate = function(server, connections, callback) {
	  var authStore = this.authStore.slice(0);
	  var count = authStore.length;
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < authStore.length; i++) {
	    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function(err) {
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(err, null);
	      }
	    });
	  }
	}
	
	/**
	 * This is a result from a authentication strategy
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {boolean} result The result of the authentication process
	 */
	
	module.exports = Plain;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var f = __webpack_require__(1).format
	  , crypto = __webpack_require__(48)
	  , retrieveBSON = __webpack_require__(11).retrieveBSON
	  , Query = __webpack_require__(9).Query
	  , MongoError = __webpack_require__(7);
	
	var BSON = retrieveBSON(),
	  Binary = BSON.Binary;
	
	var AuthSession = function(db, username, password) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	var id = 0;
	
	/**
	 * Creates a new ScramSHA1 authentication mechanism
	 * @class
	 * @return {ScramSHA1} A cursor instance
	 */
	var ScramSHA1 = function(bson) {
	  this.bson = bson;
	  this.authStore = [];
	  this.id = id++;
	}
	
	var parsePayload = function(payload) {
	  var dict = {};
	  var parts = payload.split(',');
	
	  for(var i = 0; i < parts.length; i++) {
	    var valueParts = parts[i].split('=');
	    dict[valueParts[0]] = valueParts[1];
	  }
	
	  return dict;
	}
	
	var passwordDigest = function(username, password) {
	  if(typeof username != 'string') throw new MongoError("username must be a string");
	  if(typeof password != 'string') throw new MongoError("password must be a string");
	  if(password.length == 0) throw new MongoError("password cannot be empty");
	  // Use node md5 generator
	  var md5 = crypto.createHash('md5');
	  // Generate keys used for authentication
	  md5.update(username + ":mongo:" + password, 'utf8');
	  return md5.digest('hex');
	}
	
	// XOR two buffers
	var xor = function(a, b) {
	  if (!Buffer.isBuffer(a)) a = new Buffer(a)
	  if (!Buffer.isBuffer(b)) b = new Buffer(b)
	  var res = []
	  if (a.length > b.length) {
	    for (var i = 0; i < b.length; i++) {
	      res.push(a[i] ^ b[i])
	    }
	  } else {
	    for (i = 0; i < a.length; i++) {
	      res.push(a[i] ^ b[i])
	    }
	  }
	  return new Buffer(res);
	}
	
	// hiCache stores previous salt creations so it's not regenerated per-pool member
	var _hiCache = {};
	
	var hi = function(data, salt, iterations) {
	  var key = [data, salt.toString("base64"), iterations].join("_");
	  // check if we've already generated this salt
	  if (_hiCache[key] !== undefined) { return _hiCache[key] }
	  
	  // generate the salt and store it in the cache for the next worker
	  var data = crypto.pbkdf2Sync(data, salt, iterations, 20, "sha1");
	  _hiCache[key] = data;
	  
	  return data;
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	ScramSHA1.prototype.auth = function(server, connections, db, username, password, callback) {
	  var self = this;
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var errorObject = null;
	
	  // Execute MongoCR
	  var executeScram = function(connection) {
	    // Clean up the user
	    username = username.replace('=', "=3D").replace(',', '=2C');
	
	    // Create a random nonce
	    var nonce = crypto.randomBytes(24).toString('base64');
	    // var nonce = 'MsQUY9iw0T9fx2MUEz6LZPwGuhVvWAhc'
	    var firstBare = f("n=%s,r=%s", username, nonce);
	
	    // Build command structure
	    var cmd = {
	        saslStart: 1
	      , mechanism: 'SCRAM-SHA-1'
	      , payload: new Binary(f("n,,%s", firstBare))
	      , autoAuthorize: 1
	    }
	
	    // Handle the error
	    var handleError = function(err, r) {
	      if(err) {
	        numberOfValidConnections = numberOfValidConnections - 1;
	        errorObject = err; return false;
	      } else if(r.result['$err']) {
	        errorObject = r.result; return false;
	      } else if(r.result['errmsg']) {
	        errorObject = r.result; return false;
	      } else {
	        numberOfValidConnections = numberOfValidConnections + 1;
	      }
	
	      return true
	    }
	
	    // Finish up
	    var finish = function(_count, _numberOfValidConnections) {
	      if(_count == 0 && _numberOfValidConnections > 0) {
	        // Store the auth details
	        addAuthSession(self.authStore, new AuthSession(db, username, password));
	        // Return correct authentication
	        return callback(null, true);
	      } else if(_count == 0) {
	        if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using scram"));
	        return callback(errorObject, false);
	      }
	    }
	
	    var handleEnd = function(_err, _r) {
	      // Handle any error
	      handleError(_err, _r)
	      // Adjust the number of connections
	      count = count - 1;
	      // Execute the finish
	      finish(count, numberOfValidConnections);
	    }
	
	    // Write the commmand on the connection
	    server(connection, new Query(self.bson, f("%s.$cmd", db), cmd, {
	      numberToSkip: 0, numberToReturn: 1
	    }), function(err, r) {
	      // Do we have an error, handle it
	      if(handleError(err, r) == false) {
	        count = count - 1;
	
	        if(count == 0 && numberOfValidConnections > 0) {
	          // Store the auth details
	          addAuthSession(self.authStore, new AuthSession(db, username, password));
	          // Return correct authentication
	          return callback(null, true);
	        } else if(count == 0) {
	          if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using scram"));
	          return callback(errorObject, false);
	        }
	
	        return;
	      }
	
	      // Get the dictionary
	      var dict = parsePayload(r.result.payload.value())
	
	      // Unpack dictionary
	      var iterations = parseInt(dict.i, 10);
	      var salt = dict.s;
	      var rnonce = dict.r;
	
	      // Set up start of proof
	      var withoutProof = f("c=biws,r=%s", rnonce);
	      var passwordDig = passwordDigest(username, password);
	      var saltedPassword = hi(passwordDig
	          , new Buffer(salt, 'base64')
	          , iterations);
	
	      // Create the client key
	      var hmac = crypto.createHmac('sha1', saltedPassword);
	      hmac.update(new Buffer("Client Key"));
	      var clientKey = new Buffer(hmac.digest('base64'), 'base64');
	
	      // Create the stored key
	      var hash = crypto.createHash('sha1');
	      hash.update(clientKey);
	      var storedKey = new Buffer(hash.digest('base64'), 'base64');
	
	      // Create the authentication message
	      var authMsg = [firstBare, r.result.payload.value().toString('base64'), withoutProof].join(',');
	
	      // Create client signature
	      hmac = crypto.createHmac('sha1', storedKey);
	      hmac.update(new Buffer(authMsg));
	      var clientSig = new Buffer(hmac.digest('base64'), 'base64');
	
	      // Create client proof
	      var clientProof = f("p=%s", new Buffer(xor(clientKey, clientSig)).toString('base64'));
	
	      // Create client final
	      var clientFinal = [withoutProof, clientProof].join(',');
	      
	      //
	      // Create continue message
	      var cmd = {
	          saslContinue: 1
	        , conversationId: r.result.conversationId
	        , payload: new Binary(new Buffer(clientFinal))
	      }
	
	      //
	      // Execute sasl continue
	      // Write the commmand on the connection
	      server(connection, new Query(self.bson, f("%s.$cmd", db), cmd, {
	        numberToSkip: 0, numberToReturn: 1
	      }), function(err, r) {
	        if(r && r.result.done == false) {
	          var cmd = {
	              saslContinue: 1
	            , conversationId: r.result.conversationId
	            , payload: new Buffer(0)
	          }
	
	          // Write the commmand on the connection
	          server(connection, new Query(self.bson, f("%s.$cmd", db), cmd, {
	            numberToSkip: 0, numberToReturn: 1
	          }), function(err, r) {
	            handleEnd(err, r);
	          });
	        } else {
	          handleEnd(err, r);
	        }
	      });
	    });
	  }
	
	  var _execute = function(_connection) {
	    process.nextTick(function() {
	      executeScram(_connection);
	    });
	  }
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {
	    _execute(connections.shift());
	  }
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Remove authStore credentials
	 * @method
	 * @param {string} db Name of database we are removing authStore details about
	 * @return {object}
	 */
	ScramSHA1.prototype.logout = function(dbName) {
	  this.authStore = this.authStore.filter(function(x) {
	    return x.db != dbName;
	  });
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	ScramSHA1.prototype.reauthenticate = function(server, connections, callback) {
	  var authStore = this.authStore.slice(0);
	  var count = authStore.length;
	  // No connections
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < authStore.length; i++) {
	    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function(err) {
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(err, null);
	      }
	    });
	  }
	}
	
	
	module.exports = ScramSHA1;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var f = __webpack_require__(1).format
	  , Query = __webpack_require__(9).Query
	  , MongoError = __webpack_require__(7);
	
	var AuthSession = function(db, username, password) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	/**
	 * Creates a new X509 authentication mechanism
	 * @class
	 * @return {X509} A cursor instance
	 */
	var X509 = function(bson) {
	  this.bson = bson;
	  this.authStore = [];
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	X509.prototype.auth = function(server, connections, db, username, password, callback) {
	  var self = this;
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var errorObject = null;
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {
	    // Execute MongoCR
	    var execute = function(connection) {
	      // Let's start the sasl process
	      var command = {
	          authenticate: 1
	        , mechanism: 'MONGODB-X509'
	      };
	
	      // Add username if specified
	      if(username) {
	        command.user = username;
	      }
	
	      // Let's start the process
	      server(connection, new Query(self.bson, "$external.$cmd", command, {
	        numberToSkip: 0, numberToReturn: 1
	      }), function(err, r) {
	        // Adjust count
	        count = count - 1;
	
	        // If we have an error
	        if(err) {
	          errorObject = err;
	        } else if(r.result['$err']) {
	          errorObject = r.result;
	        } else if(r.result['errmsg']) {
	          errorObject = r.result;
	        } else {
	          numberOfValidConnections = numberOfValidConnections + 1;
	        }
	
	        // We have authenticated all connections
	        if(count == 0 && numberOfValidConnections > 0) {
	          // Store the auth details
	          addAuthSession(self.authStore, new AuthSession(db, username, password));
	          // Return correct authentication
	          callback(null, true);
	        } else if(count == 0) {
	          if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
	          callback(errorObject, false);
	        }
	      });
	    }
	
	    var _execute = function(_connection) {
	      process.nextTick(function() {
	        execute(_connection);
	      });
	    }
	
	    _execute(connections.shift());
	  }
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Remove authStore credentials
	 * @method
	 * @param {string} db Name of database we are removing authStore details about
	 * @return {object}
	 */
	X509.prototype.logout = function(dbName) {
	  this.authStore = this.authStore.filter(function(x) {
	    return x.db != dbName;
	  });
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	X509.prototype.reauthenticate = function(server, connections, callback) {
	  var authStore = this.authStore.slice(0);
	  var count = authStore.length;
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < authStore.length; i++) {
	    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, function(err) {
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(err, null);
	      }
	    });
	  }
	}
	
	/**
	 * This is a result from a authentication strategy
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {boolean} result The result of the authentication process
	 */
	
	module.exports = X509;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var Logger = __webpack_require__(19)
	  , retrieveBSON = __webpack_require__(11).retrieveBSON
	  , MongoError = __webpack_require__(7)
	  , f = __webpack_require__(1).format;
	
	var BSON = retrieveBSON(),
	  Long = BSON.Long;
	
	/**
	 * This is a cursor results callback
	 *
	 * @callback resultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {object} document
	 */
	
	/**
	 * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB
	 * allowing for iteration over the results returned from the underlying query.
	 *
	 * **CURSORS Cannot directly be instantiated**
	 * @example
	 * var Server = require('mongodb-core').Server
	 *   , ReadPreference = require('mongodb-core').ReadPreference
	 *   , assert = require('assert');
	 *
	 * var server = new Server({host: 'localhost', port: 27017});
	 * // Wait for the connection event
	 * server.on('connect', function(server) {
	 *   assert.equal(null, err);
	 *
	 *   // Execute the write
	 *   var cursor = _server.cursor('integration_tests.inserts_example4', {
	 *       find: 'integration_tests.example4'
	 *     , query: {a:1}
	 *   }, {
	 *     readPreference: new ReadPreference('secondary');
	 *   });
	 *
	 *   // Get the first document
	 *   cursor.next(function(err, doc) {
	 *     assert.equal(null, err);
	 *     server.destroy();
	 *   });
	 * });
	 *
	 * // Start connecting
	 * server.connect();
	 */
	
	/**
	 * Creates a new Cursor, not to be used directly
	 * @class
	 * @param {object} bson An instance of the BSON parser
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {{object}|Long} cmd The selector (can be a command or a cursorId)
	 * @param {object} [options=null] Optional settings.
	 * @param {object} [options.batchSize=1000] Batchsize for the operation
	 * @param {array} [options.documents=[]] Initial documents list for cursor
	 * @param {object} [options.transforms=null] Transform methods for the cursor results
	 * @param {function} [options.transforms.query] Transform the value returned from the initial query
	 * @param {function} [options.transforms.doc] Transform each document returned from Cursor.prototype.next
	 * @param {object} topology The server topology instance.
	 * @param {object} topologyOptions The server topology options.
	 * @return {Cursor} A cursor instance
	 * @property {number} cursorBatchSize The current cursorBatchSize for the cursor
	 * @property {number} cursorLimit The current cursorLimit for the cursor
	 * @property {number} cursorSkip The current cursorSkip for the cursor
	 */
	var Cursor = function(bson, ns, cmd, options, topology, topologyOptions) {
	  options = options || {};
	
	  // Cursor pool
	  this.pool = null;
	  // Cursor server
	  this.server = null;
	
	  // Do we have a not connected handler
	  this.disconnectHandler = options.disconnectHandler;
	
	  // Set local values
	  this.bson = bson;
	  this.ns = ns;
	  this.cmd = cmd;
	  this.options = options;
	  this.topology = topology;
	
	  // All internal state
	  this.cursorState = {
	      cursorId: null
	    , cmd: cmd
	    , documents: options.documents || []
	    , cursorIndex: 0
	    , dead: false
	    , killed: false
	    , init: false
	    , notified: false
	    , limit: options.limit || cmd.limit || 0
	    , skip: options.skip || cmd.skip || 0
	    , batchSize: options.batchSize || cmd.batchSize || 1000
	    , currentLimit: 0
	    // Result field name if not a cursor (contains the array of results)
	    , transforms: options.transforms
	  }
	
	  // Add promoteLong to cursor state
	  if(typeof topologyOptions.promoteLongs == 'boolean') {
	    this.cursorState.promoteLongs = topologyOptions.promoteLongs;
	  } else if(typeof options.promoteLongs == 'boolean') {
	    this.cursorState.promoteLongs = options.promoteLongs;
	  }
	
	  // Add promoteValues to cursor state
	  if(typeof topologyOptions.promoteValues == 'boolean') {
	    this.cursorState.promoteValues = topologyOptions.promoteValues;
	  } else if(typeof options.promoteValues == 'boolean') {
	    this.cursorState.promoteValues = options.promoteValues;
	  }
	
	  // Add promoteBuffers to cursor state
	  if(typeof topologyOptions.promoteBuffers == 'boolean') {
	    this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;
	  } else if(typeof options.promoteBuffers == 'boolean') {
	    this.cursorState.promoteBuffers = options.promoteBuffers;
	  }
	
	  // Logger
	  this.logger = Logger('Cursor', topologyOptions);
	
	  //
	  // Did we pass in a cursor id
	  if(typeof cmd == 'number') {
	    this.cursorState.cursorId = Long.fromNumber(cmd);
	    this.cursorState.lastCursorId = this.cursorState.cursorId;
	  } else if(cmd instanceof Long) {
	    this.cursorState.cursorId = cmd;
	    this.cursorState.lastCursorId = cmd;
	  }
	}
	
	Cursor.prototype.setCursorBatchSize = function(value) {
	  this.cursorState.batchSize = value;
	}
	
	Cursor.prototype.cursorBatchSize = function() {
	  return this.cursorState.batchSize;
	}
	
	Cursor.prototype.setCursorLimit = function(value) {
	  this.cursorState.limit = value;
	}
	
	Cursor.prototype.cursorLimit = function() {
	  return this.cursorState.limit;
	}
	
	Cursor.prototype.setCursorSkip = function(value) {
	  this.cursorState.skip = value;
	}
	
	Cursor.prototype.cursorSkip = function() {
	  return this.cursorState.skip;
	}
	
	//
	// Handle callback (including any exceptions thrown)
	var handleCallback = function(callback, err, result) {
	  try {
	    callback(err, result);
	  } catch(err) {
	    process.nextTick(function() {
	      throw err;
	    });
	  }
	}
	
	// Internal methods
	Cursor.prototype._find = function(callback) {
	  var self = this;
	
	  if(self.logger.isDebug()) {
	    self.logger.debug(f('issue initial query [%s] with flags [%s]'
	      , JSON.stringify(self.cmd)
	      , JSON.stringify(self.query)));
	  }
	
	  var queryCallback = function(err, r) {
	    if(err) return callback(err);
	
	    // Get the raw message
	    var result = r.message;
	
	    // Query failure bit set
	    if(result.queryFailure) {
	      return callback(MongoError.create(result.documents[0]), null);
	    }
	
	    // Check if we have a command cursor
	    if(Array.isArray(result.documents) && result.documents.length == 1
	      && (!self.cmd.find || (self.cmd.find && self.cmd.virtual == false))
	      && (result.documents[0].cursor != 'string'
	        || result.documents[0]['$err']
	        || result.documents[0]['errmsg']
	        || Array.isArray(result.documents[0].result))
	      ) {
	
	      // We have a an error document return the error
	      if(result.documents[0]['$err']
	        || result.documents[0]['errmsg']) {
	        return callback(MongoError.create(result.documents[0]), null);
	      }
	
	      // We have a cursor document
	      if(result.documents[0].cursor != null
	        && typeof result.documents[0].cursor != 'string') {
	          var id = result.documents[0].cursor.id;
	          // If we have a namespace change set the new namespace for getmores
	          if(result.documents[0].cursor.ns) {
	            self.ns = result.documents[0].cursor.ns;
	          }
	          // Promote id to long if needed
	          self.cursorState.cursorId = typeof id == 'number' ? Long.fromNumber(id) : id;
	          self.cursorState.lastCursorId = self.cursorState.cursorId;
	          // If we have a firstBatch set it
	          if(Array.isArray(result.documents[0].cursor.firstBatch)) {
	            self.cursorState.documents = result.documents[0].cursor.firstBatch;//.reverse();
	          }
	
	          // Return after processing command cursor
	          return callback(null, null);
	      }
	
	      if(Array.isArray(result.documents[0].result)) {
	        self.cursorState.documents = result.documents[0].result;
	        self.cursorState.cursorId = Long.ZERO;
	        return callback(null, null);
	      }
	    }
	
	    // Otherwise fall back to regular find path
	    self.cursorState.cursorId = result.cursorId;
	    self.cursorState.documents = result.documents;
	    self.cursorState.lastCursorId = result.cursorId;
	
	    // Transform the results with passed in transformation method if provided
	    if(self.cursorState.transforms && typeof self.cursorState.transforms.query == 'function') {
	      self.cursorState.documents = self.cursorState.transforms.query(result);
	    }
	
	    // Return callback
	    callback(null, null);
	  }
	
	  // Options passed to the pool
	  var queryOptions = {};
	
	  // If we have a raw query decorate the function
	  if(self.options.raw || self.cmd.raw) {
	    // queryCallback.raw = self.options.raw || self.cmd.raw;
	    queryOptions.raw = self.options.raw || self.cmd.raw;
	  }
	
	  // Do we have documentsReturnedIn set on the query
	  if(typeof self.query.documentsReturnedIn == 'string') {
	    // queryCallback.documentsReturnedIn = self.query.documentsReturnedIn;
	    queryOptions.documentsReturnedIn = self.query.documentsReturnedIn;
	  }
	
	  // Add promote Long value if defined
	  if(typeof self.cursorState.promoteLongs == 'boolean') {
	    queryOptions.promoteLongs = self.cursorState.promoteLongs;
	  }
	
	  // Add promote values if defined
	  if(typeof self.cursorState.promoteValues == 'boolean') {
	    queryOptions.promoteValues = self.cursorState.promoteValues;
	  }
	
	  // Add promote values if defined
	  if(typeof self.cursorState.promoteBuffers == 'boolean') {
	    queryOptions.promoteBuffers = self.cursorState.promoteBuffers;
	  }
	  // Write the initial command out
	  self.server.s.pool.write(self.query, queryOptions, queryCallback);
	}
	
	Cursor.prototype._getmore = function(callback) {
	  if(this.logger.isDebug()) this.logger.debug(f('schedule getMore call for query [%s]', JSON.stringify(this.query)))
	  // Determine if it's a raw query
	  var raw = this.options.raw || this.cmd.raw;
	
	  // Set the current batchSize
	  var batchSize = this.cursorState.batchSize;
	  if(this.cursorState.limit > 0
	    && ((this.cursorState.currentLimit + batchSize) > this.cursorState.limit)) {
	    batchSize = this.cursorState.limit - this.cursorState.currentLimit;
	  }
	
	  // Default pool
	  var pool = this.server.s.pool;
	
	  // We have a wire protocol handler
	  this.server.wireProtocolHandler.getMore(this.bson, this.ns, this.cursorState, batchSize, raw, pool, this.options, callback);
	}
	
	Cursor.prototype._killcursor = function(callback) {
	  // Set cursor to dead
	  this.cursorState.dead = true;
	  this.cursorState.killed = true;
	  // Remove documents
	  this.cursorState.documents = [];
	
	  // If no cursor id just return
	  if(this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init == false) {
	    if(callback) callback(null, null);
	    return;
	  }
	
	  // Default pool
	  var pool = this.server.s.pool;
	  // Execute command
	  this.server.wireProtocolHandler.killCursor(this.bson, this.ns, this.cursorState.cursorId, pool, callback);
	}
	
	/**
	 * Clone the cursor
	 * @method
	 * @return {Cursor}
	 */
	Cursor.prototype.clone = function() {
	  return this.topology.cursor(this.ns, this.cmd, this.options);
	}
	
	/**
	 * Checks if the cursor is dead
	 * @method
	 * @return {boolean} A boolean signifying if the cursor is dead or not
	 */
	Cursor.prototype.isDead = function() {
	  return this.cursorState.dead == true;
	}
	
	/**
	 * Checks if the cursor was killed by the application
	 * @method
	 * @return {boolean} A boolean signifying if the cursor was killed by the application
	 */
	Cursor.prototype.isKilled = function() {
	  return this.cursorState.killed == true;
	}
	
	/**
	 * Checks if the cursor notified it's caller about it's death
	 * @method
	 * @return {boolean} A boolean signifying if the cursor notified the callback
	 */
	Cursor.prototype.isNotified = function() {
	  return this.cursorState.notified == true;
	}
	
	/**
	 * Returns current buffered documents length
	 * @method
	 * @return {number} The number of items in the buffered documents
	 */
	Cursor.prototype.bufferedCount = function() {
	  return this.cursorState.documents.length - this.cursorState.cursorIndex;
	}
	
	/**
	 * Returns current buffered documents
	 * @method
	 * @return {Array} An array of buffered documents
	 */
	Cursor.prototype.readBufferedDocuments = function(number) {
	  var unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;
	  var length = number < unreadDocumentsLength ? number : unreadDocumentsLength;
	  var elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length);
	
	  // Transform the doc with passed in transformation method if provided
	  if(this.cursorState.transforms && typeof this.cursorState.transforms.doc == 'function') {
	    // Transform all the elements
	    for(var i = 0; i < elements.length; i++) {
	      elements[i] = this.cursorState.transforms.doc(elements[i]);
	    }
	  }
	
	  // Ensure we do not return any more documents than the limit imposed
	  // Just return the number of elements up to the limit
	  if(this.cursorState.limit > 0 && (this.cursorState.currentLimit + elements.length) > this.cursorState.limit) {
	    elements = elements.slice(0, (this.cursorState.limit - this.cursorState.currentLimit));
	    this.kill();
	  }
	
	  // Adjust current limit
	  this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;
	  this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;
	
	  // Return elements
	  return elements;
	}
	
	/**
	 * Kill the cursor
	 * @method
	 * @param {resultCallback} callback A callback function
	 */
	Cursor.prototype.kill = function(callback) {
	  this._killcursor(callback);
	}
	
	/**
	 * Resets the cursor
	 * @method
	 * @return {null}
	 */
	Cursor.prototype.rewind = function() {
	  if(this.cursorState.init) {
	    if(!this.cursorState.dead) {
	      this.kill();
	    }
	
	    this.cursorState.currentLimit = 0;
	    this.cursorState.init = false;
	    this.cursorState.dead = false;
	    this.cursorState.killed = false;
	    this.cursorState.notified = false;
	    this.cursorState.documents = [];
	    this.cursorState.cursorId = null;
	    this.cursorState.cursorIndex = 0;
	  }
	}
	
	/**
	 * Validate if the pool is dead and return error
	 */
	var isConnectionDead = function(self, callback) {
	  if(self.pool
	    && self.pool.isDestroyed()) {
	    self.cursorState.notified = true;
	    self.cursorState.killed = true;
	    self.cursorState.documents = [];
	    self.cursorState.cursorIndex = 0;
	    callback(MongoError.create(f('connection to host %s:%s was destroyed', self.pool.host, self.pool.port)))
	    return true;
	  }
	
	  return false;
	}
	
	/**
	 * Validate if the cursor is dead but was not explicitly killed by user
	 */
	var isCursorDeadButNotkilled = function(self, callback) {
	  // Cursor is dead but not marked killed, return null
	  if(self.cursorState.dead && !self.cursorState.killed) {
	    self.cursorState.notified = true;
	    self.cursorState.killed = true;
	    self.cursorState.documents = [];
	    self.cursorState.cursorIndex = 0;
	    handleCallback(callback, null, null);
	    return true;
	  }
	
	  return false;
	}
	
	/**
	 * Validate if the cursor is dead and was killed by user
	 */
	var isCursorDeadAndKilled = function(self, callback) {
	  if(self.cursorState.dead && self.cursorState.killed) {
	    handleCallback(callback, MongoError.create('cursor is dead'));
	    return true;
	  }
	
	  return false;
	}
	
	/**
	 * Validate if the cursor was killed by the user
	 */
	var isCursorKilled = function(self, callback) {
	  if(self.cursorState.killed) {
	    self.cursorState.notified = true;
	    self.cursorState.documents = [];
	    self.cursorState.cursorIndex = 0;
	    handleCallback(callback, null, null);
	    return true;
	  }
	
	  return false;
	}
	
	/**
	 * Mark cursor as being dead and notified
	 */
	var setCursorDeadAndNotified = function(self, callback) {
	  self.cursorState.dead = true;
	  self.cursorState.notified = true;
	  self.cursorState.documents = [];
	  self.cursorState.cursorIndex = 0;
	  handleCallback(callback, null, null);
	}
	
	/**
	 * Mark cursor as being notified
	 */
	var setCursorNotified = function(self, callback) {
	  self.cursorState.notified = true;
	  self.cursorState.documents = [];
	  self.cursorState.cursorIndex = 0;
	  handleCallback(callback, null, null);
	}
	
	var nextFunction = function(self, callback) {
	  // We have notified about it
	  if(self.cursorState.notified) {
	    return callback(new Error('cursor is exhausted'));
	  }
	
	  // Cursor is killed return null
	  if(isCursorKilled(self, callback)) return;
	
	  // Cursor is dead but not marked killed, return null
	  if(isCursorDeadButNotkilled(self, callback)) return;
	
	  // We have a dead and killed cursor, attempting to call next should error
	  if(isCursorDeadAndKilled(self, callback)) return;
	
	  // We have just started the cursor
	  if(!self.cursorState.init) {
	    // Topology is not connected, save the call in the provided store to be
	    // Executed at some point when the handler deems it's reconnected
	    if(!self.topology.isConnected(self.options) && self.disconnectHandler != null) {
	      if (self.topology.isDestroyed()) {
	        // Topology was destroyed, so don't try to wait for it to reconnect
	        return callback(new MongoError('Topology was destroyed'));
	      }
	      return self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);
	    }
	
	    try {
	      self.server = self.topology.getServer(self.options);
	    } catch(err) {
	      // Handle the error and add object to next method call
	      if(self.disconnectHandler != null) {
	        return self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);
	      }
	
	      // Otherwise return the error
	      return callback(err);
	    }
	
	    // Set as init
	    self.cursorState.init = true;
	
	    // Server does not support server
	    if(self.cmd
	      && self.cmd.collation
	      && self.server.ismaster.maxWireVersion < 5) {
	      return callback(new MongoError(f('server %s does not support collation', self.server.name)));
	    }
	
	    try {
	      self.query = self.server.wireProtocolHandler.command(self.bson, self.ns, self.cmd, self.cursorState, self.topology, self.options);
	    } catch(err) {
	      return callback(err);
	    }
	  }
	
	  // If we don't have a cursorId execute the first query
	  if(self.cursorState.cursorId == null) {
	    // Check if pool is dead and return if not possible to
	    // execute the query against the db
	    if(isConnectionDead(self, callback)) return;
	
	    // Check if topology is destroyed
	    if(self.topology.isDestroyed()) return callback(new MongoError('connection destroyed, not possible to instantiate cursor'));
	
	    // query, cmd, options, cursorState, callback
	    self._find(function(err) {
	      if(err) return handleCallback(callback, err, null);
	
	      if(self.cursorState.documents.length == 0
	        && self.cursorState.cursorId && self.cursorState.cursorId.isZero()
	        && !self.cmd.tailable && !self.cmd.awaitData) {
	        return setCursorNotified(self, callback);
	      }
	
	      nextFunction(self, callback);
	    });
	  } else if(self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
	    // Ensure we kill the cursor on the server
	    self.kill();
	    // Set cursor in dead and notified state
	    return setCursorDeadAndNotified(self, callback);
	  } else if(self.cursorState.cursorIndex == self.cursorState.documents.length
	      && !Long.ZERO.equals(self.cursorState.cursorId)) {
	      // Ensure an empty cursor state
	      self.cursorState.documents = [];
	      self.cursorState.cursorIndex = 0;
	
	      // Check if topology is destroyed
	      if(self.topology.isDestroyed()) return callback(new MongoError('connection destroyed, not possible to instantiate cursor'));
	
	      // Check if connection is dead and return if not possible to
	      // execute a getmore on this connection
	      if(isConnectionDead(self, callback)) return;
	
	      // Execute the next get more
	      self._getmore(function(err, doc, connection) {
	        if(err) return handleCallback(callback, err);
	
	        // Save the returned connection to ensure all getMore's fire over the same connection
	        self.connection = connection;
	
	        // Tailable cursor getMore result, notify owner about it
	        // No attempt is made here to retry, this is left to the user of the
	        // core module to handle to keep core simple
	        if(self.cursorState.documents.length == 0
	          && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) {
	          // No more documents in the tailed cursor
	          return handleCallback(callback, MongoError.create({
	              message: 'No more documents in tailed cursor'
	            , tailable: self.cmd.tailable
	            , awaitData: self.cmd.awaitData
	          }));
	        } else if(self.cursorState.documents.length == 0
	          && self.cmd.tailable && !Long.ZERO.equals(self.cursorState.cursorId)) {
	          return nextFunction(self, callback);
	        }
	
	        if(self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
	          return setCursorDeadAndNotified(self, callback);
	        }
	
	        nextFunction(self, callback);
	      });
	  } else if(self.cursorState.documents.length == self.cursorState.cursorIndex
	    && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) {
	      return handleCallback(callback, MongoError.create({
	          message: 'No more documents in tailed cursor'
	        , tailable: self.cmd.tailable
	        , awaitData: self.cmd.awaitData
	      }));
	  } else if(self.cursorState.documents.length == self.cursorState.cursorIndex
	      && Long.ZERO.equals(self.cursorState.cursorId)) {
	      setCursorDeadAndNotified(self, callback);
	  } else {
	    if(self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {
	      // Ensure we kill the cursor on the server
	      self.kill();
	      // Set cursor in dead and notified state
	      return setCursorDeadAndNotified(self, callback);
	    }
	
	    // Increment the current cursor limit
	    self.cursorState.currentLimit += 1;
	
	    // Get the document
	    var doc = self.cursorState.documents[self.cursorState.cursorIndex++];
	
	    // Doc overflow
	    if(!doc || doc.$err) {
	      // Ensure we kill the cursor on the server
	      self.kill();
	      // Set cursor in dead and notified state
	      return setCursorDeadAndNotified(self, function() {
	        handleCallback(callback, new MongoError(doc ? doc.$err : undefined));
	      });
	    }
	
	    // Transform the doc with passed in transformation method if provided
	    if(self.cursorState.transforms && typeof self.cursorState.transforms.doc == 'function') {
	      doc = self.cursorState.transforms.doc(doc);
	    }
	
	    // Return the document
	    handleCallback(callback, null, doc);
	  }
	}
	
	/**
	 * Retrieve the next document from the cursor
	 * @method
	 * @param {resultCallback} callback A callback function
	 */
	Cursor.prototype.next = function(callback) {
	  nextFunction(this, callback);
	}
	
	module.exports = Cursor;


/***/ }),
/* 58 */
/***/ (function(module, exports) {

	/**
	 * Copy the values of all enumerable own properties from one or more
	 * source objects to a target object. It will return the target object.
	 */
	var assign = Object.assign ? Object.assign : function assign(target) {
	  if (target === undefined || target === null) {
	    throw new TypeError('Cannot convert first argument to object');
	  }
	
	  var to = Object(target);
	  for (var i = 1; i < arguments.length; i++) {
	    var nextSource = arguments[i];
	    if (nextSource === undefined || nextSource === null) {
	      continue;
	    }
	
	    var keysArray = Object.keys(Object(nextSource));
	    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
	      var nextKey = keysArray[nextIndex];
	      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
	      if (desc !== undefined && desc.enumerable) {
	        to[nextKey] = nextSource[nextKey];
	      }
	    }
	  }
	
	  return to;
	}
	
	module.exports = {
	  assign: assign
	};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var checkCollectionName = __webpack_require__(2).checkCollectionName
	  , ObjectID = __webpack_require__(3).BSON.ObjectID
	  , Long = __webpack_require__(3).BSON.Long
	  , Code = __webpack_require__(3).BSON.Code
	  , f = __webpack_require__(1).format
	  , AggregationCursor = __webpack_require__(27)
	  , MongoError = __webpack_require__(3).MongoError
	  , shallowClone = __webpack_require__(2).shallowClone
	  , isObject = __webpack_require__(2).isObject
	  , toError = __webpack_require__(2).toError
	  , normalizeHintField = __webpack_require__(2).normalizeHintField
	  , handleCallback = __webpack_require__(2).handleCallback
	  , decorateCommand = __webpack_require__(2).decorateCommand
	  , formattedOrderClause = __webpack_require__(2).formattedOrderClause
	  , ReadPreference = __webpack_require__(16)
	  , CoreReadPreference = __webpack_require__(3).ReadPreference
	  , CommandCursor = __webpack_require__(23)
	  , Define = __webpack_require__(13)
	  , Cursor = __webpack_require__(17)
	  , unordered = __webpack_require__(81)
	  , ordered = __webpack_require__(80)
	  , assign = __webpack_require__(2).assign
	  , mergeOptions = __webpack_require__(2).mergeOptions;
	
	/**
	 * @fileOverview The **Collection** class is an internal class that embodies a MongoDB collection
	 * allowing for insert/update/remove/find and other command operation on that MongoDB collection.
	 *
	 * **COLLECTION Cannot directly be instantiated**
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Create a collection we want to drop later
	 *   var col = db.collection('createIndexExample1');
	 *   // Show that duplicate records got dropped
	 *   col.find({}).toArray(function(err, items) {
	 *     test.equal(null, err);
	 *     test.equal(4, items.length);
	 *     db.close();
	 *   });
	 * });
	 */
	
	var mergeKeys = ['readPreference', 'ignoreUndefined'];
	
	/**
	 * Create a new Collection instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @property {string} collectionName Get the collection name.
	 * @property {string} namespace Get the full collection namespace.
	 * @property {object} writeConcern The current write concern values.
	 * @property {object} readConcern The current read concern values.
	 * @property {object} hint Get current index hint for collection.
	 * @return {Collection} a Collection instance.
	 */
	var Collection = function(db, topology, dbName, name, pkFactory, options) {
	  checkCollectionName(name);
	
	  // Unpack variables
	  var internalHint = null;
	  var slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;
	  var serializeFunctions = options == null || options.serializeFunctions == null ? db.s.options.serializeFunctions : options.serializeFunctions;
	  var raw = options == null || options.raw == null ? db.s.options.raw : options.raw;
	  var promoteLongs = options == null || options.promoteLongs == null ? db.s.options.promoteLongs : options.promoteLongs;
	  var promoteValues = options == null || options.promoteValues == null ? db.s.options.promoteValues : options.promoteValues;
	  var promoteBuffers = options == null || options.promoteBuffers == null ? db.s.options.promoteBuffers : options.promoteBuffers;
	  var readPreference = null;
	  var collectionHint = null;
	  var namespace = f("%s.%s", dbName, name);
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(10).Promise;
	  }
	
	  // Assign the right collection level readPreference
	  if(options && options.readPreference) {
	    readPreference = options.readPreference;
	  } else if(db.options.readPreference) {
	    readPreference = db.options.readPreference;
	  }
	
	  // Set custom primary key factory if provided
	  pkFactory = pkFactory == null
	    ? ObjectID
	    : pkFactory;
	
	  // Internal state
	  this.s = {
	    // Set custom primary key factory if provided
	      pkFactory: pkFactory
	    // Db
	    , db: db
	    // Topology
	    , topology: topology
	    // dbName
	    , dbName: dbName
	    // Options
	    , options: options
	    // Namespace
	    , namespace: namespace
	    // Read preference
	    , readPreference: readPreference
	    // SlaveOK
	    , slaveOk: slaveOk
	    // Serialize functions
	    , serializeFunctions: serializeFunctions
	    // Raw
	    , raw: raw
	    // promoteLongs
	    , promoteLongs: promoteLongs
	    // promoteValues
	    , promoteValues: promoteValues
	    // promoteBuffers
	    , promoteBuffers: promoteBuffers
	    // internalHint
	    , internalHint: internalHint
	    // collectionHint
	    , collectionHint: collectionHint
	    // Name
	    , name: name
	    // Promise library
	    , promiseLibrary: promiseLibrary
	    // Read Concern
	    , readConcern: options.readConcern
	  }
	}
	
	var define = Collection.define = new Define('Collection', Collection, false);
	
	Object.defineProperty(Collection.prototype, 'collectionName', {
	  enumerable: true, get: function() { return this.s.name; }
	});
	
	Object.defineProperty(Collection.prototype, 'namespace', {
	  enumerable: true, get: function() { return this.s.namespace; }
	});
	
	Object.defineProperty(Collection.prototype, 'readConcern', {
	  enumerable: true, get: function() { return this.s.readConcern || {level: 'local'}; }
	});
	
	Object.defineProperty(Collection.prototype, 'writeConcern', {
	  enumerable:true,
	  get: function() {
	    var ops = {};
	    if(this.s.options.w != null) ops.w = this.s.options.w;
	    if(this.s.options.j != null) ops.j = this.s.options.j;
	    if(this.s.options.fsync != null) ops.fsync = this.s.options.fsync;
	    if(this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;
	    return ops;
	  }
	});
	
	/**
	 * @ignore
	 */
	Object.defineProperty(Collection.prototype, "hint", {
	    enumerable: true
	  , get: function () { return this.s.collectionHint; }
	  , set: function (v) { this.s.collectionHint = normalizeHintField(v); }
	});
	
	/**
	 * Creates a cursor for a query that can be used to iterate over results from MongoDB
	 * @method
	 * @param {object} query The cursor query object.
	 * @throws {MongoError}
	 * @return {Cursor}
	 */
	Collection.prototype.find = function() {
	  var options
	    , args = Array.prototype.slice.call(arguments, 0)
	    , has_callback = typeof args[args.length - 1] === 'function'
	    , has_weird_callback = typeof args[0] === 'function'
	    , callback = has_callback ? args.pop() : (has_weird_callback ? args.shift() : null)
	    , len = args.length
	    , selector = len >= 1 ? args[0] : {}
	    , fields = len >= 2 ? args[1] : undefined;
	
	  if(len === 1 && has_weird_callback) {
	    // backwards compat for callback?, options case
	    selector = {};
	    options = args[0];
	  }
	
	  if(len === 2 && fields !== undefined && !Array.isArray(fields)) {
	    var fieldKeys = Object.keys(fields);
	    var is_option = false;
	
	    for(var i = 0; i < fieldKeys.length; i++) {
	      if(testForFields[fieldKeys[i]] != null) {
	        is_option = true;
	        break;
	      }
	    }
	
	    if(is_option) {
	      options = fields;
	      fields = undefined;
	    } else {
	      options = {};
	    }
	  } else if(len === 2 && Array.isArray(fields) && !Array.isArray(fields[0])) {
	    var newFields = {};
	    // Rewrite the array
	    for(i = 0; i < fields.length; i++) {
	      newFields[fields[i]] = 1;
	    }
	    // Set the fields
	    fields = newFields;
	  }
	
	  if(3 === len) {
	    options = args[2];
	  }
	
	  // Ensure selector is not null
	  selector = selector == null ? {} : selector;
	  // Validate correctness off the selector
	  var object = selector;
	  if(Buffer.isBuffer(object)) {
	    var object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
	    if(object_size != object.length)  {
	      var error = new Error("query selector raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
	      error.name = 'MongoError';
	      throw error;
	    }
	  }
	
	  // Validate correctness of the field selector
	  object = fields;
	  if(Buffer.isBuffer(object)) {
	    object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;
	    if(object_size != object.length)  {
	      error = new Error("query fields raw message size does not match message header size [" + object.length + "] != [" + object_size + "]");
	      error.name = 'MongoError';
	      throw error;
	    }
	  }
	
	  // Check special case where we are using an objectId
	  if(selector != null && selector._bsontype == 'ObjectID') {
	    selector = {_id:selector};
	  }
	
	  // If it's a serialized fields field we need to just let it through
	  // user be warned it better be good
	  if(options && options.fields && !(Buffer.isBuffer(options.fields))) {
	    fields = {};
	
	    if(Array.isArray(options.fields)) {
	      if(!options.fields.length) {
	        fields['_id'] = 1;
	      } else {
	        var l = options.fields.length;
	
	        for (i = 0; i < l; i++) {
	          fields[options.fields[i]] = 1;
	        }
	      }
	    } else {
	      fields = options.fields;
	    }
	  }
	
	  if (!options) options = {};
	
	  var newOptions = {};
	
	  // Make a shallow copy of the collection options
	  for(var key in this.s.options) {
	    if(mergeKeys.indexOf(key) != -1) {
	      newOptions[key] = this.s.options[key];
	    }
	  }
	
	  // Make a shallow copy of options
	  for (var key in options) {
	    newOptions[key] = options[key];
	  }
	
	  // Unpack options
	  newOptions.skip = len > 3 ? args[2] : options.skip ? options.skip : 0;
	  newOptions.limit = len > 3 ? args[3] : options.limit ? options.limit : 0;
	  newOptions.raw = options.raw != null && typeof options.raw === 'boolean' ? options.raw : this.s.raw;
	  newOptions.hint = options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;
	  newOptions.timeout = len == 5 ? args[4] : typeof options.timeout === 'undefined' ? undefined : options.timeout;
	  // // If we have overridden slaveOk otherwise use the default db setting
	  newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk;
	
	  // Add read preference if needed
	  newOptions = getReadPreference(this, newOptions, this.s.db, this);
	
	  // Set slave ok to true if read preference different from primary
	  if(newOptions.readPreference != null
	    && (newOptions.readPreference != 'primary' || newOptions.readPreference.mode != 'primary')) {
	    newOptions.slaveOk = true;
	  }
	
	  // Ensure the query is an object
	  if(selector != null && typeof selector != 'object') {
	    throw MongoError.create({message: "query selector must be an object", driver:true });
	  }
	
	  // Build the find command
	  var findCommand = {
	      find: this.s.namespace
	    , limit: newOptions.limit
	    , skip: newOptions.skip
	    , query: selector
	  }
	
	  // Ensure we use the right await data option
	  if(typeof newOptions.awaitdata == 'boolean')  {
	    newOptions.awaitData = newOptions.awaitdata
	  }
	
	  // Translate to new command option noCursorTimeout
	  if(typeof newOptions.timeout == 'boolean') newOptions.noCursorTimeout = newOptions.timeout;
	
	  // Merge in options to command
	  for(var name in newOptions) {
	    if(newOptions[name] != null) findCommand[name] = newOptions[name];
	  }
	
	  // Format the fields
	  var formatFields = function(fields) {
	    var object = {};
	    if(Array.isArray(fields)) {
	      for(var i = 0; i < fields.length; i++) {
	        if(Array.isArray(fields[i])) {
	          object[fields[i][0]] = fields[i][1];
	        } else {
	          object[fields[i][0]] = 1;
	        }
	      }
	    } else {
	      object = fields;
	    }
	
	    return object;
	  }
	
	  // Special treatment for the fields selector
	  if(fields) findCommand.fields = formatFields(fields);
	
	  // Add db object to the new options
	  newOptions.db = this.s.db;
	
	  // Add the promise library
	  newOptions.promiseLibrary = this.s.promiseLibrary;
	
	  // Set raw if available at collection level
	  if(newOptions.raw == null && typeof this.s.raw == 'boolean') newOptions.raw = this.s.raw;
	  // Set promoteLongs if available at collection level
	  if(newOptions.promoteLongs == null && typeof this.s.promoteLongs == 'boolean') newOptions.promoteLongs = this.s.promoteLongs;
	  if(newOptions.promoteValues == null && typeof this.s.promoteValues == 'boolean') newOptions.promoteValues = this.s.promoteValues;
	  if(newOptions.promoteBuffers == null && typeof this.s.promoteBuffers == 'boolean') newOptions.promoteBuffers = this.s.promoteBuffers;
	
	  // Sort options
	  if(findCommand.sort) {
	    findCommand.sort = formattedOrderClause(findCommand.sort);
	  }
	
	  // Set the readConcern
	  if(this.s.readConcern) {
	    findCommand.readConcern = this.s.readConcern;
	  }
	
	  // Decorate find command with collation options
	  decorateWithCollation(findCommand, this, options);
	
	  // Create the cursor
	  if(typeof callback == 'function') return handleCallback(callback, null, this.s.topology.cursor(this.s.namespace, findCommand, newOptions));
	  return this.s.topology.cursor(this.s.namespace, findCommand, newOptions);
	}
	
	define.classMethod('find', {callback: false, promise:false, returns: [Cursor]});
	
	/**
	 * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,
	 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
	 * can be overridden by setting the **forceServerObjectId** flag.
	 *
	 * @method
	 * @param {object} doc Document to insert.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {Collection~insertOneWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.insertOne = function(doc, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	  if(Array.isArray(doc) && typeof callback == 'function') {
	    return callback(MongoError.create({message: 'doc parameter must be an object', driver:true }));
	  } else if(Array.isArray(doc)) {
	    return new this.s.promiseLibrary(function(resolve, reject) {
	      reject(MongoError.create({message: 'doc parameter must be an object', driver:true }));
	    });
	  }
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return insertOne(self, doc, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    insertOne(self, doc, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var insertOne = function(self, doc, options, callback) {
	  insertDocuments(self, [doc], options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    // Workaround for pre 2.6 servers
	    if(r == null) return callback(null, {result: {ok:1}});
	    // Add values to top level to ensure crud spec compatibility
	    r.insertedCount = r.result.n;
	    r.insertedId = doc._id;
	    if(callback) callback(null, r);
	  });
	}
	
	var mapInserManyResults = function(docs, r) {
	  var ids = r.getInsertedIds();
	  var keys = Object.keys(ids);
	  var finalIds = new Array(keys.length);
	
	  for(var i = 0; i < keys.length; i++) {
	    if(ids[keys[i]]._id) {
	      finalIds[ids[keys[i]].index] = ids[keys[i]]._id;
	    }
	  }
	
	  var finalResult = {
	    result: {ok: 1, n: r.insertedCount},
	    ops: docs,
	    insertedCount: r.insertedCount,
	    insertedIds: finalIds
	  };
	
	  if(r.getLastOp()) {
	    finalResult.result.opTime = r.getLastOp();
	  }
	
	  return finalResult;
	}
	
	define.classMethod('insertOne', {callback: true, promise:true});
	
	/**
	 * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
	 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
	 * can be overridden by setting the **forceServerObjectId** flag.
	 *
	 * @method
	 * @param {object[]} docs Documents to insert.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {boolean} [options.ordered=true] If true, when an insert fails, don't execute the remaining writes. If false, continue with remaining inserts when one fails.
	 * @param {Collection~insertWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.insertMany = function(docs, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options ? shallowClone(options) : {ordered:true};
	  if(!Array.isArray(docs) && typeof callback == 'function') {
	    return callback(MongoError.create({message: 'docs parameter must be an array of documents', driver:true }));
	  } else if(!Array.isArray(docs)) {
	    return new this.s.promiseLibrary(function(resolve, reject) {
	      reject(MongoError.create({message: 'docs parameter must be an array of documents', driver:true }));
	    });
	  }
	
	  // Get the write concern options
	  if(typeof options.checkKeys != 'boolean') {
	    options.checkKeys = true;
	  }
	
	  // If keep going set unordered
	  options['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;
	
	  // Set up the force server object id
	  var forceServerObjectId = typeof options.forceServerObjectId == 'boolean'
	    ? options.forceServerObjectId : self.s.db.options.forceServerObjectId;
	
	  // Do we want to force the server to assign the _id key
	  if(forceServerObjectId !== true) {
	    // Add _id if not specified
	    for(var i = 0; i < docs.length; i++) {
	      if(docs[i]._id == null) docs[i]._id = self.s.pkFactory.createPk();
	    }
	  }
	
	  // Generate the bulk write operations
	  var operations = [{
	    insertMany: docs
	  }];
	
	  // Execute using callback
	  if(typeof callback == 'function') return bulkWrite(self, operations, options, function(err, r) {
	    if(err) return callback(err, r);
	    callback(null, mapInserManyResults(docs, r));
	  });
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    bulkWrite(self, operations, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(mapInserManyResults(docs, r));
	    });
	  });
	}
	
	define.classMethod('insertMany', {callback: true, promise:true});
	
	/**
	 * @typedef {Object} Collection~BulkWriteOpResult
	 * @property {number} insertedCount Number of documents inserted.
	 * @property {number} matchedCount Number of documents matched for update.
	 * @property {number} modifiedCount Number of documents modified.
	 * @property {number} deletedCount Number of documents deleted.
	 * @property {number} upsertedCount Number of documents upserted.
	 * @property {object} insertedIds Inserted document generated Id's, hash key is the index of the originating operation
	 * @property {object} upsertedIds Upserted document generated Id's, hash key is the index of the originating operation
	 * @property {object} result The command result object.
	 */
	
	/**
	 * The callback format for inserts
	 * @callback Collection~bulkWriteOpCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection~BulkWriteOpResult} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Perform a bulkWrite operation without a fluent API
	 *
	 * Legal operation types are
	 *
	 *  { insertOne: { document: { a: 1 } } }
	 *
	 *  { updateOne: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }
	 *
	 *  { updateMany: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }
	 *
	 *  { deleteOne: { filter: {c:1} } }
	 *
	 *  { deleteMany: { filter: {c:1} } }
	 *
	 *  { replaceOne: { filter: {c:3}, replacement: {c:4}, upsert:true}}
	 *
	 * If documents passed in do not contain the **_id** field,
	 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
	 * can be overridden by setting the **forceServerObjectId** flag.
	 *
	 * @method
	 * @param {object[]} operations Bulk operations to perform.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.ordered=true] Execute write operation in ordered or unordered fashion.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {Collection~bulkWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.bulkWrite = function(operations, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {ordered:true};
	
	  if(!Array.isArray(operations)) {
	    throw MongoError.create({message: "operations must be an array of documents", driver:true });
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return bulkWrite(self, operations, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    bulkWrite(self, operations, options, function(err, r) {
	      if(err && r == null) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var bulkWrite = function(self, operations, options, callback) {
	  // Add ignoreUndfined
	  if(self.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = self.s.options.ignoreUndefined;
	  }
	
	  // Create the bulk operation
	  var bulk = options.ordered == true || options.ordered == null ? self.initializeOrderedBulkOp(options) : self.initializeUnorderedBulkOp(options);
	
	  // Do we have a collation
	  var collation = false;
	
	  // for each op go through and add to the bulk
	  try {
	    for(var i = 0; i < operations.length; i++) {
	      // Get the operation type
	      var key = Object.keys(operations[i])[0];
	      // Check if we have a collation
	      if(operations[i][key].collation) {
	        collation = true;
	      }
	
	      // Pass to the raw bulk
	      bulk.raw(operations[i]);
	    }
	  } catch(err) {
	    return callback(err, null);
	  }
	
	  // Final options for write concern
	  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
	  var writeCon = finalOptions.writeConcern ? finalOptions.writeConcern : {};
	  var capabilities = self.s.topology.capabilities();
	
	  // Did the user pass in a collation, check if our write server supports it
	  if(collation && capabilities && !capabilities.commandsTakeCollation) {
	    return callback(new MongoError(f('server/primary/mongos does not support collation')));
	  }
	
	  // Execute the bulk
	  bulk.execute(writeCon, function(err, r) {
	    // We have connection level error
	    if(!r && err) return callback(err, null);
	    // We have single error
	    if(r && r.hasWriteErrors() && r.getWriteErrorCount() == 1) {
	      return callback(toError(r.getWriteErrorAt(0)), r);
	    }
	
	    r.insertedCount = r.nInserted;
	    r.matchedCount = r.nMatched;
	    r.modifiedCount = r.nModified || 0;
	    r.deletedCount = r.nRemoved;
	    r.upsertedCount = r.getUpsertedIds().length;
	    r.upsertedIds = {};
	    r.insertedIds = {};
	
	    // Update the n
	    r.n = r.insertedCount;
	
	    // Inserted documents
	    var inserted = r.getInsertedIds();
	    // Map inserted ids
	    for(var i = 0; i < inserted.length; i++) {
	      r.insertedIds[inserted[i].index] = inserted[i]._id;
	    }
	
	    // Upserted documents
	    var upserted = r.getUpsertedIds();
	    // Map upserted ids
	    for(i = 0; i < upserted.length; i++) {
	      r.upsertedIds[upserted[i].index] = upserted[i]._id;
	    }
	
	    // Check if we have write errors
	    if(r.hasWriteErrors()) {
	      // Get all the errors
	      var errors = r.getWriteErrors();
	      // Return the MongoError object
	      return callback(toError({
	        message: 'write operation failed', code: errors[0].code, writeErrors: errors
	      }), r);
	    }
	
	    // Check if we have a writeConcern error
	    if(r.getWriteConcernError()) {
	      // Return the MongoError object
	      return callback(toError(r.getWriteConcernError()), r);
	    }
	
	    // Return the results
	    callback(null, r);
	  });
	}
	
	var insertDocuments = function(self, docs, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	  // Ensure we are operating on an array op docs
	  docs = Array.isArray(docs) ? docs : [docs];
	
	  // Get the write concern options
	  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
	  if(typeof finalOptions.checkKeys != 'boolean') finalOptions.checkKeys = true;
	
	  // If keep going set unordered
	  if(finalOptions.keepGoing == true) finalOptions.ordered = false;
	  finalOptions['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;
	
	  // Set up the force server object id
	  var forceServerObjectId = typeof options.forceServerObjectId == 'boolean'
	    ? options.forceServerObjectId : self.s.db.options.forceServerObjectId;
	
	  // Add _id if not specified
	  if(forceServerObjectId !== true){
	    for(var i = 0; i < docs.length; i++) {
	      if(docs[i]._id === void 0) docs[i]._id = self.s.pkFactory.createPk();
	    }
	  }
	
	  // File inserts
	  self.s.topology.insert(self.s.namespace, docs, finalOptions, function(err, result) {
	    if(callback == null) return;
	    if(err) return handleCallback(callback, err);
	    if(result == null) return handleCallback(callback, null, null);
	    if(result.result.code) return handleCallback(callback, toError(result.result));
	    if(result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0]));
	    // Add docs to the list
	    result.ops = docs;
	    // Return the results
	    handleCallback(callback, null, result);
	  });
	}
	
	define.classMethod('bulkWrite', {callback: true, promise:true});
	
	/**
	 * @typedef {Object} Collection~WriteOpResult
	 * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
	 * @property {object} connection The connection object used for the operation.
	 * @property {object} result The command result object.
	 */
	
	/**
	 * The callback format for inserts
	 * @callback Collection~writeOpCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection~WriteOpResult} result The result object if the command was executed successfully.
	 */
	
	/**
	 * @typedef {Object} Collection~insertWriteOpResult
	 * @property {Number} insertedCount The total amount of documents inserted.
	 * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
	 * @property {ObjectId[]} insertedIds All the generated _id's for the inserted documents.
	 * @property {object} connection The connection object used for the operation.
	 * @property {object} result The raw command result object returned from MongoDB (content might vary by server version).
	 * @property {Number} result.ok Is 1 if the command executed correctly.
	 * @property {Number} result.n The total count of documents inserted.
	 */
	
	/**
	 * @typedef {Object} Collection~insertOneWriteOpResult
	 * @property {Number} insertedCount The total amount of documents inserted.
	 * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany
	 * @property {ObjectId} insertedId The driver generated ObjectId for the insert operation.
	 * @property {object} connection The connection object used for the operation.
	 * @property {object} result The raw command result object returned from MongoDB (content might vary by server version).
	 * @property {Number} result.ok Is 1 if the command executed correctly.
	 * @property {Number} result.n The total count of documents inserted.
	 */
	
	/**
	 * The callback format for inserts
	 * @callback Collection~insertWriteOpCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection~insertWriteOpResult} result The result object if the command was executed successfully.
	 */
	
	/**
	 * The callback format for inserts
	 * @callback Collection~insertOneWriteOpCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection~insertOneWriteOpResult} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,
	 * one will be added to each of the documents missing it by the driver, mutating the document. This behavior
	 * can be overridden by setting the **forceServerObjectId** flag.
	 *
	 * @method
	 * @param {(object|object[])} docs Documents to insert.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {Collection~insertWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use insertOne, insertMany or bulkWrite
	 */
	Collection.prototype.insert = function(docs, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {ordered:false};
	  docs = !Array.isArray(docs) ? [docs] : docs;
	
	  if(options.keepGoing == true) {
	    options.ordered = false;
	  }
	
	  return this.insertMany(docs, options, callback);
	}
	
	define.classMethod('insert', {callback: true, promise:true});
	
	/**
	 * @typedef {Object} Collection~updateWriteOpResult
	 * @property {Object} result The raw result returned from MongoDB, field will vary depending on server version.
	 * @property {Number} result.ok Is 1 if the command executed correctly.
	 * @property {Number} result.n The total count of documents scanned.
	 * @property {Number} result.nModified The total count of documents modified.
	 * @property {Object} connection The connection object used for the operation.
	 * @property {Number} matchedCount The number of documents that matched the filter.
	 * @property {Number} modifiedCount The number of documents that were modified.
	 * @property {Number} upsertedCount The number of documents upserted.
	 * @property {Object} upsertedId The upserted id.
	 * @property {ObjectId} upsertedId._id The upserted _id returned from the server.
	 */
	
	/**
	 * The callback format for inserts
	 * @callback Collection~updateWriteOpCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection~updateWriteOpResult} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Update a single document on MongoDB
	 * @method
	 * @param {object} filter The Filter used to select the document to update
	 * @param {object} update The update operations to be applied to the document
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.upsert=false] Update operation is an upsert.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {Collection~updateWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.updateOne = function(filter, update, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = shallowClone(options)
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return updateOne(self, filter, update, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    updateOne(self, filter, update, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var updateOne = function(self, filter, update, options, callback) {
	  // Set single document update
	  options.multi = false;
	  // Execute update
	  updateDocuments(self, filter, update, options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    if(r == null) return callback(null, {result: {ok:1}});
	    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
	    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
	    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
	    r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
	    if(callback) callback(null, r);
	  });
	}
	
	define.classMethod('updateOne', {callback: true, promise:true});
	
	/**
	 * Replace a document on MongoDB
	 * @method
	 * @param {object} filter The Filter used to select the document to update
	 * @param {object} doc The Document that replaces the matching document
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.upsert=false] Update operation is an upsert.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {Collection~updateWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.replaceOne = function(filter, doc, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = shallowClone(options)
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return replaceOne(self, filter, doc, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    replaceOne(self, filter, doc, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var replaceOne = function(self, filter, doc, options, callback) {
	  // Set single document update
	  options.multi = false;
	
	  // Execute update
	  updateDocuments(self, filter, doc, options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    if(r == null) return callback(null, {result: {ok:1}});
	
	    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
	    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
	    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
	    r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
	    r.ops = [doc];
	    if(callback) callback(null, r);
	  });
	}
	
	define.classMethod('replaceOne', {callback: true, promise:true});
	
	/**
	 * Update multiple documents on MongoDB
	 * @method
	 * @param {object} filter The Filter used to select the document to update
	 * @param {object} update The update operations to be applied to the document
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.upsert=false] Update operation is an upsert.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~updateWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.updateMany = function(filter, update, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = shallowClone(options)
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return updateMany(self, filter, update, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    updateMany(self, filter, update, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var updateMany = function(self, filter, update, options, callback) {
	  // Set single document update
	  options.multi = true;
	  // Execute update
	  updateDocuments(self, filter, update, options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    if(r == null) return callback(null, {result: {ok:1}});
	    r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;
	    r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] : null;
	    r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;
	    r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;
	    if(callback) callback(null, r);
	  });
	}
	
	define.classMethod('updateMany', {callback: true, promise:true});
	
	var updateDocuments = function(self, selector, document, options, callback) {
	  if('function' === typeof options) callback = options, options = null;
	  if(options == null) options = {};
	  if(!('function' === typeof callback)) callback = null;
	
	  // If we are not providing a selector or document throw
	  if(selector == null || typeof selector != 'object') return callback(toError("selector must be a valid JavaScript object"));
	  if(document == null || typeof document != 'object') return callback(toError("document must be a valid JavaScript object"));
	
	  // Get the write concern options
	  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
	
	  // Do we return the actual result document
	  // Either use override on the function, or go back to default on either the collection
	  // level or db
	  finalOptions['serializeFunctions'] = options['serializeFunctions'] || self.s.serializeFunctions;
	
	  // Execute the operation
	  var op = {q: selector, u: document};
	  op.upsert = typeof options.upsert == 'boolean' ? options.upsert : false;
	  op.multi = typeof options.multi == 'boolean' ? options.multi : false;
	
	  // Have we specified collation
	  decorateWithCollation(finalOptions, self, options);
	
	  // Update options
	  self.s.topology.update(self.s.namespace, [op], finalOptions, function(err, result) {
	    if(callback == null) return;
	    if(err) return handleCallback(callback, err, null);
	    if(result == null) return handleCallback(callback, null, null);
	    if(result.result.code) return handleCallback(callback, toError(result.result));
	    if(result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0]));
	    // Return the results
	    handleCallback(callback, null, result);
	  });
	}
	
	/**
	 * Updates documents.
	 * @method
	 * @param {object} selector The selector for the update operation.
	 * @param {object} document The update document.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.upsert=false] Update operation is an upsert.
	 * @param {boolean} [options.multi=false] Update one/all documents with operation.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {object} [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
	 * @param {Collection~writeOpCallback} [callback] The command result callback
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated use updateOne, updateMany or bulkWrite
	 */
	Collection.prototype.update = function(selector, document, options, callback) {
	  var self = this;
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return updateDocuments(self, selector, document, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    updateDocuments(self, selector, document, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('update', {callback: true, promise:true});
	
	/**
	 * @typedef {Object} Collection~deleteWriteOpResult
	 * @property {Object} result The raw result returned from MongoDB, field will vary depending on server version.
	 * @property {Number} result.ok Is 1 if the command executed correctly.
	 * @property {Number} result.n The total count of documents deleted.
	 * @property {Object} connection The connection object used for the operation.
	 * @property {Number} deletedCount The number of documents deleted.
	 */
	
	/**
	 * The callback format for inserts
	 * @callback Collection~deleteWriteOpCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection~deleteWriteOpResult} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Delete a document on MongoDB
	 * @method
	 * @param {object} filter The Filter used to select the document to remove
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~deleteWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.deleteOne = function(filter, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = shallowClone(options);
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return deleteOne(self, filter, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    deleteOne(self, filter, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var deleteOne = function(self, filter, options, callback) {
	  options.single = true;
	  removeDocuments(self, filter, options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    if(r == null) return callback(null, {result: {ok:1}});
	    r.deletedCount = r.result.n;
	    if(callback) callback(null, r);
	  });
	}
	
	define.classMethod('deleteOne', {callback: true, promise:true});
	
	Collection.prototype.removeOne = Collection.prototype.deleteOne;
	
	define.classMethod('removeOne', {callback: true, promise:true});
	
	/**
	 * Delete multiple documents on MongoDB
	 * @method
	 * @param {object} filter The Filter used to select the documents to remove
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~deleteWriteOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.deleteMany = function(filter, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = shallowClone(options);
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return deleteMany(self, filter, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    deleteMany(self, filter, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var deleteMany = function(self, filter, options, callback) {
	  options.single = false;
	
	  removeDocuments(self, filter, options, function(err, r) {
	    if(callback == null) return;
	    if(err && callback) return callback(err);
	    if(r == null) return callback(null, {result: {ok:1}});
	    r.deletedCount = r.result.n;
	    if(callback) callback(null, r);
	  });
	}
	
	var removeDocuments = function(self, selector, options, callback) {
	  if(typeof options == 'function') {
	    callback = options, options = {};
	  } else if (typeof selector === 'function') {
	    callback = selector;
	    options = {};
	    selector = {};
	  }
	
	  // Create an empty options object if the provided one is null
	  options = options || {};
	
	  // Get the write concern options
	  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
	
	  // If selector is null set empty
	  if(selector == null) selector = {};
	
	  // Build the op
	  var op = {q: selector, limit: 0};
	  if(options.single) op.limit = 1;
	
	  // Have we specified collation
	  decorateWithCollation(finalOptions, self, options);
	
	  // Execute the remove
	  self.s.topology.remove(self.s.namespace, [op], finalOptions, function(err, result) {
	    if(callback == null) return;
	    if(err) return handleCallback(callback, err, null);
	    if(result == null) return handleCallback(callback, null, null);
	    if(result.result.code) return handleCallback(callback, toError(result.result));
	    if(result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0]));
	    // Return the results
	    handleCallback(callback, null, result);
	  });
	}
	
	define.classMethod('deleteMany', {callback: true, promise:true});
	
	Collection.prototype.removeMany = Collection.prototype.deleteMany;
	
	define.classMethod('removeMany', {callback: true, promise:true});
	
	/**
	 * Remove documents.
	 * @method
	 * @param {object} selector The selector for the update operation.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.single=false] Removes the first document found.
	 * @param {Collection~writeOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated use deleteOne, deleteMany or bulkWrite
	 */
	Collection.prototype.remove = function(selector, options, callback) {
	  var self = this;
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return removeDocuments(self, selector, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    removeDocuments(self, selector, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('remove', {callback: true, promise:true});
	
	/**
	 * Save a document. Simple full document replacement function. Not recommended for efficiency, use atomic
	 * operators and update instead for more efficient operations.
	 * @method
	 * @param {object} doc Document to save
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~writeOpCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated use insertOne, insertMany, updateOne or updateMany
	 */
	Collection.prototype.save = function(doc, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Add ignoreUndfined
	  if(this.s.options.ignoreUndefined) {
	    options = shallowClone(options);
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return save(self, doc, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    save(self, doc, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var save = function(self, doc, options, callback) {
	  // Get the write concern options
	  var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
	  // Establish if we need to perform an insert or update
	  if(doc._id != null) {
	    finalOptions.upsert = true;
	    return updateDocuments(self, {_id: doc._id}, doc, finalOptions, callback);
	  }
	
	  // Insert the document
	  insertDocuments(self, [doc], options, function(err, r) {
	    if(callback == null) return;
	    if(doc == null) return handleCallback(callback, null, null);
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, null, r);
	  });
	}
	
	define.classMethod('save', {callback: true, promise:true});
	
	/**
	 * The callback format for results
	 * @callback Collection~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Fetches the first document that matches the query
	 * @method
	 * @param {object} query Query for find Operation
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.limit=0] Sets the limit of documents returned in the query.
	 * @param {(array|object)} [options.sort=null] Set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.
	 * @param {object} [options.fields=null] The fields to return in the query. Object of fields to include or exclude (not both), {'a':1}
	 * @param {number} [options.skip=0] Set to skip N documents ahead in your query (useful for pagination).
	 * @param {Object} [options.hint=null] Tell the query to use specific indexes in the query. Object of indexes to use, {'_id':1}
	 * @param {boolean} [options.explain=false] Explain the query instead of returning the data.
	 * @param {boolean} [options.snapshot=false] Snapshot query.
	 * @param {boolean} [options.timeout=false] Specify if the cursor can timeout.
	 * @param {boolean} [options.tailable=false] Specify if the cursor is tailable.
	 * @param {number} [options.batchSize=0] Set the batchSize for the getMoreCommand when iterating over the query results.
	 * @param {boolean} [options.returnKey=false] Only return the index key.
	 * @param {number} [options.maxScan=null] Limit the number of items to scan.
	 * @param {number} [options.min=null] Set index bounds.
	 * @param {number} [options.max=null] Set index bounds.
	 * @param {boolean} [options.showDiskLoc=false] Show disk location of results.
	 * @param {string} [options.comment=null] You can put a $comment field on a query to make looking in the profiler logs simpler.
	 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
	 * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
	 * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
	 * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {boolean} [options.partial=false] Specify if the cursor should return partial results when querying against a sharded system
	 * @param {number} [options.maxTimeMS=null] Number of miliseconds to wait before aborting the query.
	 * @param {object} [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.findOne = function() {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  var callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	
	  // Execute using callback
	  if(typeof callback == 'function') return findOne(self, args, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    findOne(self, args, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var findOne = function(self, args, callback) {
	  var cursor = self.find.apply(self, args).limit(-1).batchSize(1);
	  // Return the item
	  cursor.next(function(err, item) {
	    if(err != null) return handleCallback(callback, toError(err), null);
	    handleCallback(callback, null, item);
	  });
	}
	
	define.classMethod('findOne', {callback: true, promise:true});
	
	/**
	 * The callback format for the collection method, must be used if strict is specified
	 * @callback Collection~collectionResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection} collection The collection instance.
	 */
	
	/**
	 * Rename the collection.
	 *
	 * @method
	 * @param {string} newName New name of of the collection.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.dropTarget=false] Drop the target name collection if it previously exists.
	 * @param {Collection~collectionResultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.rename = function(newName, opt, callback) {
	  var self = this;
	  if(typeof opt == 'function') callback = opt, opt = {};
	  opt = assign({}, opt, {readPreference: ReadPreference.PRIMARY});
	
	  // Execute using callback
	  if(typeof callback == 'function') return rename(self, newName, opt, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    rename(self, newName, opt, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var rename = function(self, newName, opt, callback) {
	  // Check the collection name
	  checkCollectionName(newName);
	  // Build the command
	  var renameCollection = f("%s.%s", self.s.dbName, self.s.name);
	  var toCollection =  f("%s.%s", self.s.dbName, newName);
	  var dropTarget = typeof opt.dropTarget == 'boolean' ? opt.dropTarget : false;
	  var cmd = {'renameCollection':renameCollection, 'to':toCollection, 'dropTarget':dropTarget};
	
	  // Decorate command with writeConcern if supported
	  decorateWithWriteConcern(cmd, self, opt);
	
	  // Execute against admin
	  self.s.db.admin().command(cmd, opt, function(err, doc) {
	    if(err) return handleCallback(callback, err, null);
	    // We have an error
	    if(doc.errmsg) return handleCallback(callback, toError(doc), null);
	    try {
	      return handleCallback(callback, null, new Collection(self.s.db, self.s.topology, self.s.dbName, newName, self.s.pkFactory, self.s.options));
	    } catch(err) {
	      return handleCallback(callback, toError(err), null);
	    }
	  });
	}
	
	define.classMethod('rename', {callback: true, promise:true});
	
	/**
	 * Drop the collection from the database, removing it permanently. New accesses will create a new collection.
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {Collection~resultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.drop = function(options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return self.s.db.dropCollection(self.s.name, options, callback);
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.dropCollection(self.s.name, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('drop', {callback: true, promise:true});
	
	/**
	 * Returns the options of the collection.
	 *
	 * @method
	 * @param {Collection~resultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.options = function(callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return options(self, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    options(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var options = function(self, callback) {
	  self.s.db.listCollections({name: self.s.name}).toArray(function(err, collections) {
	    if(err) return handleCallback(callback, err);
	    if(collections.length == 0) {
	      return handleCallback(callback, MongoError.create({message: f("collection %s not found", self.s.namespace), driver:true }));
	    }
	
	    handleCallback(callback, err, collections[0].options || null);
	  });
	}
	
	define.classMethod('options', {callback: true, promise:true});
	
	/**
	 * Returns if the collection is a capped collection
	 *
	 * @method
	 * @param {Collection~resultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.isCapped = function(callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return isCapped(self, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    isCapped(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var isCapped = function(self, callback) {
	  self.options(function(err, document) {
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, null, document && document.capped);
	  });
	}
	
	define.classMethod('isCapped', {callback: true, promise:true});
	
	/**
	 * Creates an index on the db and collection collection.
	 * @method
	 * @param {(string|object)} fieldOrSpec Defines the index.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.unique=false] Creates an unique index.
	 * @param {boolean} [options.sparse=false] Creates a sparse index.
	 * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.
	 * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
	 * @param {number} [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
	 * @param {number} [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
	 * @param {number} [options.v=null] Specify the format version of the indexes.
	 * @param {number} [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
	 * @param {string} [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
	 * @param {object} [options.partialFilterExpression=null] Creates a partial index based on the given filter object (MongoDB 3.2 or higher)
	 * @param {object} [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.createIndex = function(fieldOrSpec, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() || {} : {};
	  options = typeof callback === 'function' ? options : callback;
	  options = options == null ? {} : options;
	
	  // Execute using callback
	  if(typeof callback == 'function') return createIndex(self, fieldOrSpec, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    createIndex(self, fieldOrSpec, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var createIndex = function(self, fieldOrSpec, options, callback) {
	  self.s.db.createIndex(self.s.name, fieldOrSpec, options, callback);
	}
	
	define.classMethod('createIndex', {callback: true, promise:true});
	
	/**
	 * Creates multiple indexes in the collection, this method is only supported for
	 * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported
	 * error. Index specifications are defined at http://docs.mongodb.org/manual/reference/command/createIndexes/.
	 * @method
	 * @param {array} indexSpecs An array of index specifications to be created
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.createIndexes = function(indexSpecs, callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return createIndexes(self, indexSpecs, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    createIndexes(self, indexSpecs, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var createIndexes = function(self, indexSpecs, callback) {
	  var capabilities = self.s.topology.capabilities();
	
	  // Ensure we generate the correct name if the parameter is not set
	  for(var i = 0; i < indexSpecs.length; i++) {
	    if(indexSpecs[i].name == null) {
	      var keys = [];
	
	      // Did the user pass in a collation, check if our write server supports it
	      if(indexSpecs[i].collation && capabilities && !capabilities.commandsTakeCollation) {
	        return callback(new MongoError(f('server/primary/mongos does not support collation')));
	      }
	
	      for(var name in indexSpecs[i].key) {
	        keys.push(f('%s_%s', name, indexSpecs[i].key[name]));
	      }
	
	      // Set the name
	      indexSpecs[i].name = keys.join('_');
	    }
	  }
	
	  // Execute the index
	  self.s.db.command({
	    createIndexes: self.s.name, indexes: indexSpecs
	  }, { readPreference: ReadPreference.PRIMARY }, callback);
	}
	
	define.classMethod('createIndexes', {callback: true, promise:true});
	
	/**
	 * Drops an index from this collection.
	 * @method
	 * @param {string} indexName Name of the index to drop.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.dropIndex = function(indexName, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() || {} : {};
	  // Run only against primary
	  options.readPreference = ReadPreference.PRIMARY;
	
	  // Execute using callback
	  if(typeof callback == 'function') return dropIndex(self, indexName, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    dropIndex(self, indexName, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var dropIndex = function(self, indexName, options, callback) {
	  // Delete index command
	  var cmd = {'dropIndexes':self.s.name, 'index':indexName};
	
	  // Decorate command with writeConcern if supported
	  decorateWithWriteConcern(cmd, self, options);
	
	  // Execute command
	  self.s.db.command(cmd, options, function(err, result) {
	    if(typeof callback != 'function') return;
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, null, result);
	  });
	}
	
	define.classMethod('dropIndex', {callback: true, promise:true});
	
	/**
	 * Drops all indexes from this collection.
	 * @method
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.dropIndexes = function(options, callback) {
	  var self = this;
	
	  // Do we have options
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return dropIndexes(self, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    dropIndexes(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var dropIndexes = function(self, options, callback) {
	  self.dropIndex('*', options, function(err) {
	    if(err) return handleCallback(callback, err, false);
	    handleCallback(callback, null, true);
	  });
	}
	
	define.classMethod('dropIndexes', {callback: true, promise:true});
	
	/**
	 * Drops all indexes from this collection.
	 * @method
	 * @deprecated use dropIndexes
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {Promise} returns Promise if no [callback] passed
	 */
	Collection.prototype.dropAllIndexes = Collection.prototype.dropIndexes;
	
	define.classMethod('dropAllIndexes', {callback: true, promise:true});
	
	/**
	 * Reindex all indexes on the collection
	 * Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.
	 * @method
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.reIndex = function(options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return reIndex(self, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    reIndex(self, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var reIndex = function(self, options, callback) {
	  // Reindex
	  var cmd = {'reIndex':self.s.name};
	
	  // Execute the command
	  self.s.db.command(cmd, options, function(err, result) {
	    if(callback == null) return;
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, null, result.ok ? true : false);
	  });
	}
	
	define.classMethod('reIndex', {callback: true, promise:true});
	
	/**
	 * Get the list of all indexes information for the collection.
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.batchSize=null] The batchSize for the returned command cursor or if pre 2.8 the systems batch collection
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @return {CommandCursor}
	 */
	Collection.prototype.listIndexes = function(options) {
	  options = options || {};
	  // Clone the options
	  options = shallowClone(options);
	  // Determine the read preference in the options.
	  options = getReadPreference(this, options, this.s.db, this);
	  // Set the CommandCursor constructor
	  options.cursorFactory = CommandCursor;
	  // Set the promiseLibrary
	  options.promiseLibrary = this.s.promiseLibrary;
	
	  if(!this.s.topology.capabilities()) {
	    throw new MongoError('cannot connect to server');
	  }
	
	  // We have a list collections command
	  if(this.s.topology.capabilities().hasListIndexesCommand) {
	    // Cursor options
	    var cursor = options.batchSize ? {batchSize: options.batchSize} : {}
	    // Build the command
	    var command = { listIndexes: this.s.name, cursor: cursor };
	    // Execute the cursor
	    cursor = this.s.topology.cursor(f('%s.$cmd', this.s.dbName), command, options);
	    // Do we have a readPreference, apply it
	    if(options.readPreference) cursor.setReadPreference(options.readPreference);
	    // Return the cursor
	    return cursor;
	  }
	
	  // Get the namespace
	  var ns = f('%s.system.indexes', this.s.dbName);
	  // Get the query
	  cursor = this.s.topology.cursor(ns, {find: ns, query: {ns: this.s.namespace}}, options);
	  // Do we have a readPreference, apply it
	  if(options.readPreference) cursor.setReadPreference(options.readPreference);
	  // Set the passed in batch size if one was provided
	  if(options.batchSize) cursor = cursor.batchSize(options.batchSize);
	  // Return the cursor
	  return cursor;
	};
	
	define.classMethod('listIndexes', {callback: false, promise:false, returns: [CommandCursor]});
	
	/**
	 * Ensures that an index exists, if it does not it creates it
	 * @method
	 * @deprecated use createIndexes instead
	 * @param {(string|object)} fieldOrSpec Defines the index.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.unique=false] Creates an unique index.
	 * @param {boolean} [options.sparse=false] Creates a sparse index.
	 * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.
	 * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
	 * @param {number} [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
	 * @param {number} [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
	 * @param {number} [options.v=null] Specify the format version of the indexes.
	 * @param {number} [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
	 * @param {number} [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
	 * @param {object} [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.ensureIndex = function(fieldOrSpec, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return ensureIndex(self, fieldOrSpec, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    ensureIndex(self, fieldOrSpec, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var ensureIndex = function(self, fieldOrSpec, options, callback) {
	  self.s.db.ensureIndex(self.s.name, fieldOrSpec, options, callback);
	}
	
	define.classMethod('ensureIndex', {callback: true, promise:true});
	
	/**
	 * Checks if one or more indexes exist on the collection, fails on first non-existing index
	 * @method
	 * @param {(string|array)} indexes One or more index names to check.
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.indexExists = function(indexes, callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return indexExists(self, indexes, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    indexExists(self, indexes, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var indexExists = function(self, indexes, callback) {
	  self.indexInformation(function(err, indexInformation) {
	    // If we have an error return
	    if(err != null) return handleCallback(callback, err, null);
	    // Let's check for the index names
	    if(!Array.isArray(indexes)) return handleCallback(callback, null, indexInformation[indexes] != null);
	    // Check in list of indexes
	    for(var i = 0; i < indexes.length; i++) {
	      if(indexInformation[indexes[i]] == null) {
	        return handleCallback(callback, null, false);
	      }
	    }
	
	    // All keys found return true
	    return handleCallback(callback, null, true);
	  });
	}
	
	define.classMethod('indexExists', {callback: true, promise:true});
	
	/**
	 * Retrieves this collections index info.
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.full=false] Returns the full raw index information.
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.indexInformation = function(options, callback) {
	  var self = this;
	  // Unpack calls
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() || {} : {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return indexInformation(self, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    indexInformation(self, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var indexInformation = function(self, options, callback) {
	  self.s.db.indexInformation(self.s.name, options, callback);
	}
	
	define.classMethod('indexInformation', {callback: true, promise:true});
	
	/**
	 * The callback format for results
	 * @callback Collection~countCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {number} result The count of documents that matched the query.
	 */
	
	/**
	 * Count number of matching documents in the db to a query.
	 * @method
	 * @param {object} query The query for the count.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.limit=null] The limit of documents to count.
	 * @param {boolean} [options.skip=null] The number of documents to skip for the count.
	 * @param {string} [options.hint=null] An index name hint for the query.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.maxTimeMS=null] Number of miliseconds to wait before aborting the query.
	 * @param {Collection~countCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.count = function(query, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  var queryOption = args.length ? args.shift() || {} : {};
	  var optionsOption = args.length ? args.shift() || {} : {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return count(self, queryOption, optionsOption, callback);
	
	  // Check if query is empty
	  query = query || {};
	  options = options || {};
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    count(self, query, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var count = function(self, query, options, callback) {
	  var skip = options.skip;
	  var limit = options.limit;
	  var hint = options.hint;
	  var maxTimeMS = options.maxTimeMS;
	
	  // Final query
	  var cmd = {
	    'count': self.s.name, 'query': query
	  };
	
	  // Add limit, skip and maxTimeMS if defined
	  if(typeof skip == 'number') cmd.skip = skip;
	  if(typeof limit == 'number') cmd.limit = limit;
	  if(typeof maxTimeMS == 'number') cmd.maxTimeMS = maxTimeMS;
	  if(hint) cmd.hint = hint;
	
	  options = shallowClone(options);
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(self, options, self.s.db, self);
	
	  // Do we have a readConcern specified
	  if(self.s.readConcern) {
	    cmd.readConcern = self.s.readConcern;
	  }
	
	  // Have we specified collation
	  decorateWithCollation(cmd, self, options);
	
	  // Execute command
	  self.s.db.command(cmd, options, function(err, result) {
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, null, result.n);
	  });
	}
	
	define.classMethod('count', {callback: true, promise:true});
	
	/**
	 * The distinct command returns returns a list of distinct values for the given key across a collection.
	 * @method
	 * @param {string} key Field of the document to find distinct values for.
	 * @param {object} query The query for filtering the set of documents to which we apply the distinct filter.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.maxTimeMS=null] Number of miliseconds to wait before aborting the query.
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.distinct = function(key, query, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  var queryOption = args.length ? args.shift() || {} : {};
	  var optionsOption = args.length ? args.shift() || {} : {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return distinct(self, key, queryOption, optionsOption, callback);
	
	  // Ensure the query and options are set
	  query = query || {};
	  options = options || {};
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    distinct(self, key, query, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var distinct = function(self, key, query, options, callback) {
	  // maxTimeMS option
	  var maxTimeMS = options.maxTimeMS;
	
	  // Distinct command
	  var cmd = {
	    'distinct': self.s.name, 'key': key, 'query': query
	  };
	
	  options = shallowClone(options);
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(self, options, self.s.db, self);
	
	  // Add maxTimeMS if defined
	  if(typeof maxTimeMS == 'number')
	    cmd.maxTimeMS = maxTimeMS;
	
	  // Do we have a readConcern specified
	  if(self.s.readConcern) {
	    cmd.readConcern = self.s.readConcern;
	  }
	
	  // Have we specified collation
	  decorateWithCollation(cmd, self, options);
	
	  // Execute the command
	  self.s.db.command(cmd, options, function(err, result) {
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, null, result.values);
	  });
	}
	
	define.classMethod('distinct', {callback: true, promise:true});
	
	/**
	 * Retrieve all the indexes on the collection.
	 * @method
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.indexes = function(callback) {
	  var self = this;
	  // Execute using callback
	  if(typeof callback == 'function') return indexes(self, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    indexes(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var indexes = function(self, callback) {
	  self.s.db.indexInformation(self.s.name, {full:true}, callback);
	}
	
	define.classMethod('indexes', {callback: true, promise:true});
	
	/**
	 * Get all the collection statistics.
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.scale=null] Divide the returned sizes by scale value.
	 * @param {Collection~resultCallback} [callback] The collection result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.stats = function(options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  // Fetch all commands
	  options = args.length ? args.shift() || {} : {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return stats(self, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    stats(self, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var stats = function(self, options, callback) {
	  // Build command object
	  var commandObject = {
	    collStats:self.s.name
	  }
	
	  // Check if we have the scale value
	  if(options['scale'] != null) commandObject['scale'] = options['scale'];
	
	  options = shallowClone(options);
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(self, options, self.s.db, self);
	
	  // Execute the command
	  self.s.db.command(commandObject, options, callback);
	}
	
	define.classMethod('stats', {callback: true, promise:true});
	
	/**
	 * @typedef {Object} Collection~findAndModifyWriteOpResult
	 * @property {object} value Document returned from findAndModify command.
	 * @property {object} lastErrorObject The raw lastErrorObject returned from the command.
	 * @property {Number} ok Is 1 if the command executed correctly.
	 */
	
	/**
	 * The callback format for inserts
	 * @callback Collection~findAndModifyCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection~findAndModifyWriteOpResult} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Find a document and delete it in one atomic operation, requires a write lock for the duration of the operation.
	 *
	 * @method
	 * @param {object} filter Document selection filter.
	 * @param {object} [options=null] Optional settings.
	 * @param {object} [options.projection=null] Limits the fields to return for all matching documents.
	 * @param {object} [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
	 * @param {number} [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
	 * @param {Collection~findAndModifyCallback} [callback] The collection result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.findOneAndDelete = function(filter, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Basic validation
	  if(filter == null || typeof filter != 'object') throw toError('filter parameter must be an object');
	
	  // Execute using callback
	  if(typeof callback == 'function') return findOneAndDelete(self, filter, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    options = options || {};
	
	    findOneAndDelete(self, filter, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var findOneAndDelete = function(self, filter, options, callback) {
	  // Final options
	  var finalOptions = shallowClone(options);
	  finalOptions['fields'] = options.projection;
	  finalOptions['remove'] = true;
	  // Execute find and Modify
	  self.findAndModify(
	      filter
	    , options.sort
	    , null
	    , finalOptions
	    , callback
	  );
	}
	
	define.classMethod('findOneAndDelete', {callback: true, promise:true});
	
	/**
	 * Find a document and replace it in one atomic operation, requires a write lock for the duration of the operation.
	 *
	 * @method
	 * @param {object} filter Document selection filter.
	 * @param {object} replacement Document replacing the matching document.
	 * @param {object} [options=null] Optional settings.
	 * @param {object} [options.projection=null] Limits the fields to return for all matching documents.
	 * @param {object} [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
	 * @param {number} [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
	 * @param {boolean} [options.upsert=false] Upsert the document if it does not exist.
	 * @param {boolean} [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.
	 * @param {Collection~findAndModifyCallback} [callback] The collection result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.findOneAndReplace = function(filter, replacement, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Basic validation
	  if(filter == null || typeof filter != 'object') throw toError('filter parameter must be an object');
	  if(replacement == null || typeof replacement != 'object') throw toError('replacement parameter must be an object');
	
	  // Execute using callback
	  if(typeof callback == 'function') return findOneAndReplace(self, filter, replacement, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    options = options || {};
	
	    findOneAndReplace(self, filter, replacement, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var findOneAndReplace = function(self, filter, replacement, options, callback) {
	  // Final options
	  var finalOptions = shallowClone(options);
	  finalOptions['fields'] = options.projection;
	  finalOptions['update'] = true;
	  finalOptions['new'] = typeof options.returnOriginal == 'boolean' ? !options.returnOriginal : false;
	  finalOptions['upsert'] = typeof options.upsert == 'boolean' ? options.upsert : false;
	
	  // Execute findAndModify
	  self.findAndModify(
	      filter
	    , options.sort
	    , replacement
	    , finalOptions
	    , callback
	  );
	}
	
	define.classMethod('findOneAndReplace', {callback: true, promise:true});
	
	/**
	 * Find a document and update it in one atomic operation, requires a write lock for the duration of the operation.
	 *
	 * @method
	 * @param {object} filter Document selection filter.
	 * @param {object} update Update operations to be performed on the document
	 * @param {object} [options=null] Optional settings.
	 * @param {object} [options.projection=null] Limits the fields to return for all matching documents.
	 * @param {object} [options.sort=null] Determines which document the operation modifies if the query selects multiple documents.
	 * @param {number} [options.maxTimeMS=null] The maximum amount of time to allow the query to run.
	 * @param {boolean} [options.upsert=false] Upsert the document if it does not exist.
	 * @param {boolean} [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.
	 * @param {Collection~findAndModifyCallback} [callback] The collection result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.findOneAndUpdate = function(filter, update, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Basic validation
	  if(filter == null || typeof filter != 'object') throw toError('filter parameter must be an object');
	  if(update == null || typeof update != 'object') throw toError('update parameter must be an object');
	
	  // Execute using callback
	  if(typeof callback == 'function') return findOneAndUpdate(self, filter, update, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    options = options || {};
	
	    findOneAndUpdate(self, filter, update, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var findOneAndUpdate = function(self, filter, update, options, callback) {
	  // Final options
	  var finalOptions = shallowClone(options);
	  finalOptions['fields'] = options.projection;
	  finalOptions['update'] = true;
	  finalOptions['new'] = typeof options.returnOriginal == 'boolean' ? !options.returnOriginal : false;
	  finalOptions['upsert'] = typeof options.upsert == 'boolean' ? options.upsert : false;
	
	  // Execute findAndModify
	  self.findAndModify(
	      filter
	    , options.sort
	    , update
	    , finalOptions
	    , callback
	  );
	}
	
	define.classMethod('findOneAndUpdate', {callback: true, promise:true});
	
	/**
	 * Find and update a document.
	 * @method
	 * @param {object} query Query object to locate the object to modify.
	 * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
	 * @param {object} doc The fields/vals to be updated.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.remove=false] Set to true to remove the object before returning.
	 * @param {boolean} [options.upsert=false] Perform an upsert operation.
	 * @param {boolean} [options.new=false] Set to true if you want to return the modified object rather than the original. Ignored for remove.
	 * @param {object} [options.fields=null] Object containing the field projection for the result returned from the operation.
	 * @param {Collection~findAndModifyCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead
	 */
	Collection.prototype.findAndModify = function(query, sort, doc, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  sort = args.length ? args.shift() || [] : [];
	  doc = args.length ? args.shift() : null;
	  options = args.length ? args.shift() || {} : {};
	
	  // Clone options
	  options = shallowClone(options);
	  // Force read preference primary
	  options.readPreference = ReadPreference.PRIMARY;
	
	  // Execute using callback
	  if(typeof callback == 'function') return findAndModify(self, query, sort, doc, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    options = options || {};
	
	    findAndModify(self, query, sort, doc, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var findAndModify = function(self, query, sort, doc, options, callback) {
	  // Create findAndModify command object
	  var queryObject = {
	     'findandmodify': self.s.name
	   , 'query': query
	  };
	
	  sort = formattedOrderClause(sort);
	  if(sort) {
	    queryObject.sort = sort;
	  }
	
	  queryObject.new = options.new ? true : false;
	  queryObject.remove = options.remove ? true : false;
	  queryObject.upsert = options.upsert ? true : false;
	
	  if(options.fields) {
	    queryObject.fields = options.fields;
	  }
	
	  if(doc && !options.remove) {
	    queryObject.update = doc;
	  }
	
	  if(options.maxTimeMS)
	    queryObject.maxTimeMS = options.maxTimeMS;
	
	  // Either use override on the function, or go back to default on either the collection
	  // level or db
	  if(options['serializeFunctions'] != null) {
	    options['serializeFunctions'] = options['serializeFunctions'];
	  } else {
	    options['serializeFunctions'] = self.s.serializeFunctions;
	  }
	
	  // No check on the documents
	  options.checkKeys = false;
	
	  // Get the write concern settings
	  var finalOptions = writeConcern(options, self.s.db, self, options);
	
	  // Decorate the findAndModify command with the write Concern
	  if(finalOptions.writeConcern) {
	    queryObject.writeConcern = finalOptions.writeConcern;
	  }
	
	  // Have we specified bypassDocumentValidation
	  if(typeof finalOptions.bypassDocumentValidation == 'boolean') {
	    queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;
	  }
	
	  // Have we specified collation
	  decorateWithCollation(queryObject, self, options);
	
	  // Execute the command
	  self.s.db.command(queryObject
	    , options, function(err, result) {
	      if(err) return handleCallback(callback, err, null);
	      return handleCallback(callback, null, result);
	  });
	}
	
	define.classMethod('findAndModify', {callback: true, promise:true});
	
	/**
	 * Find and remove a document.
	 * @method
	 * @param {object} query Query object to locate the object to modify.
	 * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated use findOneAndDelete instead
	 */
	Collection.prototype.findAndRemove = function(query, sort, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  sort = args.length ? args.shift() || [] : [];
	  options = args.length ? args.shift() || {} : {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return findAndRemove(self, query, sort, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    findAndRemove(self, query, sort, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var findAndRemove = function(self, query, sort, options, callback) {
	  // Add the remove option
	  options['remove'] = true;
	  // Execute the callback
	  self.findAndModify(query, sort, null, options, callback);
	}
	
	define.classMethod('findAndRemove', {callback: true, promise:true});
	
	function decorateWithWriteConcern(command, self, options) {
	  // Do we support collation 3.4 and higher
	  var capabilities = self.s.topology.capabilities();
	  // Do we support write concerns 3.4 and higher
	  if(capabilities && capabilities.commandsTakeWriteConcern) {
	    // Get the write concern settings
	    var finalOptions = writeConcern(shallowClone(options), self.s.db, self, options);
	    // Add the write concern to the command
	    if(finalOptions.writeConcern) {
	      command.writeConcern = finalOptions.writeConcern;
	    }
	  }
	}
	
	function decorateWithCollation(command, self, options) {
	  // Do we support collation 3.4 and higher
	  var capabilities = self.s.topology.capabilities();
	  // Do we support write concerns 3.4 and higher
	  if(capabilities && capabilities.commandsTakeCollation) {
	    if(options.collation && typeof options.collation == 'object') {
	      command.collation = options.collation;
	    }
	  }
	}
	
	/**
	 * Execute an aggregation framework pipeline against the collection, needs MongoDB >= 2.2
	 * @method
	 * @param {object} pipeline Array containing all the aggregation framework commands for the execution.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.cursor=null] Return the query as cursor, on 2.6 > it returns as a real cursor on pre 2.6 it returns as an emulated cursor.
	 * @param {number} [options.cursor.batchSize=null] The batchSize for the cursor
	 * @param {boolean} [options.explain=false] Explain returns the aggregation execution plan (requires mongodb 2.6 >).
	 * @param {boolean} [options.allowDiskUse=false] allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 >).
	 * @param {number} [options.maxTimeMS=null] maxTimeMS specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
	 * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
	 * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
	 * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
	 * @param {object} [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
	 * @param {Collection~resultCallback} callback The command result callback
	 * @return {(null|AggregationCursor)}
	 */
	Collection.prototype.aggregate = function(pipeline, options, callback) {
	  var self = this;
	
	  if(Array.isArray(pipeline)) {
	    // Set up callback if one is provided
	    if(typeof options == 'function') {
	      callback = options;
	      options = {};
	    }
	
	    // If we have no options or callback we are doing
	    // a cursor based aggregation
	    if(options == null && callback == null) {
	      options = {};
	    }
	  } else {
	    // Aggregation pipeline passed as arguments on the method
	    var args = Array.prototype.slice.call(arguments, 0);
	    // Get the callback
	    callback = args.pop();
	    // Get the possible options object
	    var opts = args[args.length - 1];
	    // If it contains any of the admissible options pop it of the args
	    options = opts && (opts.readPreference
	      || opts.explain || opts.cursor || opts.out
	      || opts.maxTimeMS || opts.allowDiskUse) ? args.pop() : {};
	      // Left over arguments is the pipeline
	    pipeline = args;
	  }
	
	  // Ignore readConcern option
	  var ignoreReadConcern = false;
	
	  // Build the command
	  var command = { aggregate : this.s.name, pipeline : pipeline};
	
	  // If out was specified
	  if(typeof options.out == 'string') {
	    pipeline.push({$out: options.out});
	    // Ignore read concern
	    ignoreReadConcern = true;
	  } else if(pipeline.length > 0 && pipeline[pipeline.length - 1]['$out']) {
	    ignoreReadConcern = true;
	  }
	
	  // Decorate command with writeConcern if out has been specified
	  if(pipeline.length > 0 && pipeline[pipeline.length - 1]['$out']) {
	    decorateWithWriteConcern(command, self, options);
	  }
	
	  // Have we specified collation
	  decorateWithCollation(command, self, options);
	
	  // If we have bypassDocumentValidation set
	  if(typeof options.bypassDocumentValidation == 'boolean') {
	    command.bypassDocumentValidation = options.bypassDocumentValidation;
	  }
	
	  // Do we have a readConcern specified
	  if(!ignoreReadConcern && this.s.readConcern) {
	    command.readConcern = this.s.readConcern;
	  }
	
	  // If we have allowDiskUse defined
	  if(options.allowDiskUse) command.allowDiskUse = options.allowDiskUse;
	  if(typeof options.maxTimeMS == 'number') command.maxTimeMS = options.maxTimeMS;
	
	  options = shallowClone(options);
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(this, options, this.s.db, this);
	
	  // If explain has been specified add it
	  if(options.explain) command.explain = options.explain;
	
	  // Validate that cursor options is valid
	  if(options.cursor != null && typeof options.cursor != 'object') {
	    throw toError('cursor options must be an object');
	  }
	
	  // promiseLibrary
	  options.promiseLibrary = this.s.promiseLibrary;
	
	  // Set the AggregationCursor constructor
	  options.cursorFactory = AggregationCursor;
	  if(typeof callback != 'function') {
	    if(!this.s.topology.capabilities()) {
	      throw new MongoError('cannot connect to server');
	    }
	
	    if(this.s.topology.capabilities().hasAggregationCursor) {
	      options.cursor = options.cursor || { batchSize : 1000 };
	      command.cursor = options.cursor;
	    }
	
	    // Allow disk usage command
	    if(typeof options.allowDiskUse == 'boolean') command.allowDiskUse = options.allowDiskUse;
	    if(typeof options.maxTimeMS == 'number') command.maxTimeMS = options.maxTimeMS;
	
	    // Execute the cursor
	    return this.s.topology.cursor(this.s.namespace, command, options);
	  }
	
	  // We do not allow cursor
	  if(options.cursor) {
	    return this.s.topology.cursor(this.s.namespace, command, options);
	  }
	
	  // Execute the command
	  this.s.db.command(command, options, function(err, result) {
	    if(err) {
	      handleCallback(callback, err);
	    } else if(result['err'] || result['errmsg']) {
	      handleCallback(callback, toError(result));
	    } else if(typeof result == 'object' && result['serverPipeline']) {
	      handleCallback(callback, null, result['serverPipeline']);
	    } else if(typeof result == 'object' && result['stages']) {
	      handleCallback(callback, null, result['stages']);
	    } else {
	      handleCallback(callback, null, result.result);
	    }
	  });
	}
	
	define.classMethod('aggregate', {callback: true, promise:false});
	
	/**
	 * The callback format for results
	 * @callback Collection~parallelCollectionScanCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Cursor[]} cursors A list of cursors returned allowing for parallel reading of collection.
	 */
	
	/**
	 * Return N number of parallel cursors for a collection allowing parallel reading of entire collection. There are
	 * no ordering guarantees for returned results.
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.batchSize=null] Set the batchSize for the getMoreCommand when iterating over the query results.
	 * @param {number} [options.numCursors=1] The maximum number of parallel command cursors to return (the number of returned cursors will be in the range 1:numCursors)
	 * @param {boolean} [options.raw=false] Return all BSON documents as Raw Buffer documents.
	 * @param {Collection~parallelCollectionScanCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.parallelCollectionScan = function(options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {numCursors: 1};
	  // Set number of cursors to 1
	  options.numCursors = options.numCursors || 1;
	  options.batchSize = options.batchSize || 1000;
	
	  options = shallowClone(options);
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(this, options, this.s.db, this);
	
	  // Add a promiseLibrary
	  options.promiseLibrary = this.s.promiseLibrary;
	
	  // Execute using callback
	  if(typeof callback == 'function') return parallelCollectionScan(self, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    parallelCollectionScan(self, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var parallelCollectionScan = function(self, options, callback) {
	  // Create command object
	  var commandObject = {
	      parallelCollectionScan: self.s.name
	    , numCursors: options.numCursors
	  }
	
	  // Do we have a readConcern specified
	  if(self.s.readConcern) {
	    commandObject.readConcern = self.s.readConcern;
	  }
	
	  // Store the raw value
	  var raw = options.raw;
	  delete options['raw'];
	
	  // Execute the command
	  self.s.db.command(commandObject, options, function(err, result) {
	    if(err) return handleCallback(callback, err, null);
	    if(result == null) return handleCallback(callback, new Error("no result returned for parallelCollectionScan"), null);
	
	    var cursors = [];
	    // Add the raw back to the option
	    if(raw) options.raw = raw;
	    // Create command cursors for each item
	    for(var i = 0; i < result.cursors.length; i++) {
	      var rawId = result.cursors[i].cursor.id
	      // Convert cursorId to Long if needed
	      var cursorId = typeof rawId == 'number' ? Long.fromNumber(rawId) : rawId;
	      // Add a command cursor
	      cursors.push(self.s.topology.cursor(self.s.namespace, cursorId, options));
	    }
	
	    handleCallback(callback, null, cursors);
	  });
	}
	
	define.classMethod('parallelCollectionScan', {callback: true, promise:true});
	
	/**
	 * Execute the geoNear command to search for items in the collection
	 *
	 * @method
	 * @param {number} x Point to search on the x axis, ensure the indexes are ordered in the same order.
	 * @param {number} y Point to search on the y axis, ensure the indexes are ordered in the same order.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.num=null] Max number of results to return.
	 * @param {number} [options.minDistance=null] Include results starting at minDistance from a point (2.6 or higher)
	 * @param {number} [options.maxDistance=null] Include results up to maxDistance from the point.
	 * @param {number} [options.distanceMultiplier=null] Include a value to multiply the distances with allowing for range conversions.
	 * @param {object} [options.query=null] Filter the results by a query.
	 * @param {boolean} [options.spherical=false] Perform query using a spherical model.
	 * @param {boolean} [options.uniqueDocs=false] The closest location in a document to the center of the search region will always be returned MongoDB > 2.X.
	 * @param {boolean} [options.includeLocs=false] Include the location data fields in the top level of the results MongoDB > 2.X.
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.geoNear = function(x, y, options, callback) {
	  var self = this;
	  var point = typeof(x) == 'object' && x
	    , args = Array.prototype.slice.call(arguments, point?1:2);
	
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  // Fetch all commands
	  options = args.length ? args.shift() || {} : {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return geoNear(self, x, y, point, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    geoNear(self, x, y, point, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var geoNear = function(self, x, y, point, options, callback) {
	  // Build command object
	  var commandObject = {
	    geoNear:self.s.name,
	    near: point || [x, y]
	  }
	
	  options = shallowClone(options);
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(self, options, self.s.db, self);
	
	  // Exclude readPreference and existing options to prevent user from
	  // shooting themselves in the foot
	  var exclude = {
	    readPreference: true,
	    geoNear: true,
	    near: true
	  };
	
	  // Filter out any excluded objects
	  commandObject = decorateCommand(commandObject, options, exclude);
	
	  // Do we have a readConcern specified
	  if(self.s.readConcern) {
	    commandObject.readConcern = self.s.readConcern;
	  }
	
	  // Have we specified collation
	  decorateWithCollation(commandObject, self, options);
	
	  // Execute the command
	  self.s.db.command(commandObject, options, function (err, res) {
	    if(err) return handleCallback(callback, err);
	    if(res.err || res.errmsg) return handleCallback(callback, toError(res));
	    // should we only be returning res.results here? Not sure if the user
	    // should see the other return information
	    handleCallback(callback, null, res);
	  });
	}
	
	define.classMethod('geoNear', {callback: true, promise:true});
	
	/**
	 * Execute a geo search using a geo haystack index on a collection.
	 *
	 * @method
	 * @param {number} x Point to search on the x axis, ensure the indexes are ordered in the same order.
	 * @param {number} y Point to search on the y axis, ensure the indexes are ordered in the same order.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.maxDistance=null] Include results up to maxDistance from the point.
	 * @param {object} [options.search=null] Filter the results by a query.
	 * @param {number} [options.limit=false] Max number of results to return.
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.geoHaystackSearch = function(x, y, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  // Fetch all commands
	  options = args.length ? args.shift() || {} : {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return geoHaystackSearch(self, x, y, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    geoHaystackSearch(self, x, y, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var geoHaystackSearch = function(self, x, y, options, callback) {
	  // Build command object
	  var commandObject = {
	    geoSearch: self.s.name,
	    near: [x, y]
	  }
	
	  // Remove read preference from hash if it exists
	  commandObject = decorateCommand(commandObject, options, {readPreference: true});
	
	  options = shallowClone(options);
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(self, options, self.s.db, self);
	
	  // Do we have a readConcern specified
	  if(self.s.readConcern) {
	    commandObject.readConcern = self.s.readConcern;
	  }
	
	  // Execute the command
	  self.s.db.command(commandObject, options, function (err, res) {
	    if(err) return handleCallback(callback, err);
	    if(res.err || res.errmsg) handleCallback(callback, toError(res));
	    // should we only be returning res.results here? Not sure if the user
	    // should see the other return information
	    handleCallback(callback, null, res);
	  });
	}
	
	define.classMethod('geoHaystackSearch', {callback: true, promise:true});
	
	/**
	 * Group function helper
	 * @ignore
	 */
	// var groupFunction = function () {
	//   var c = db[ns].find(condition);
	//   var map = new Map();
	//   var reduce_function = reduce;
	//
	//   while (c.hasNext()) {
	//     var obj = c.next();
	//     var key = {};
	//
	//     for (var i = 0, len = keys.length; i < len; ++i) {
	//       var k = keys[i];
	//       key[k] = obj[k];
	//     }
	//
	//     var aggObj = map.get(key);
	//
	//     if (aggObj == null) {
	//       var newObj = Object.extend({}, key);
	//       aggObj = Object.extend(newObj, initial);
	//       map.put(key, aggObj);
	//     }
	//
	//     reduce_function(obj, aggObj);
	//   }
	//
	//   return { "result": map.values() };
	// }.toString();
	var groupFunction = 'function () {\nvar c = db[ns].find(condition);\nvar map = new Map();\nvar reduce_function = reduce;\n\nwhile (c.hasNext()) {\nvar obj = c.next();\nvar key = {};\n\nfor (var i = 0, len = keys.length; i < len; ++i) {\nvar k = keys[i];\nkey[k] = obj[k];\n}\n\nvar aggObj = map.get(key);\n\nif (aggObj == null) {\nvar newObj = Object.extend({}, key);\naggObj = Object.extend(newObj, initial);\nmap.put(key, aggObj);\n}\n\nreduce_function(obj, aggObj);\n}\n\nreturn { "result": map.values() };\n}';
	
	/**
	 * Run a group command across a collection
	 *
	 * @method
	 * @param {(object|array|function|code)} keys An object, array or function expressing the keys to group by.
	 * @param {object} condition An optional condition that must be true for a row to be considered.
	 * @param {object} initial Initial value of the aggregation counter object.
	 * @param {(function|Code)} reduce The reduce function aggregates (reduces) the objects iterated
	 * @param {(function|Code)} finalize An optional function to be run on each item in the result set just before the item is returned.
	 * @param {boolean} command Specify if you wish to run using the internal group command or using eval, default is true.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated MongoDB 3.6 or higher will no longer support the group command. We recommend rewriting using the aggregation framework.
	 */
	Collection.prototype.group = function(keys, condition, initial, reduce, finalize, command, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 3);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  // Fetch all commands
	  reduce = args.length ? args.shift() : null;
	  finalize = args.length ? args.shift() : null;
	  command = args.length ? args.shift() : null;
	  options = args.length ? args.shift() || {} : {};
	
	  // Make sure we are backward compatible
	  if(!(typeof finalize == 'function')) {
	    command = finalize;
	    finalize = null;
	  }
	
	  if (!Array.isArray(keys) && keys instanceof Object && typeof(keys) !== 'function' && !(keys._bsontype == 'Code')) {
	    keys = Object.keys(keys);
	  }
	
	  if(typeof reduce === 'function') {
	    reduce = reduce.toString();
	  }
	
	  if(typeof finalize === 'function') {
	    finalize = finalize.toString();
	  }
	
	  // Set up the command as default
	  command = command == null ? true : command;
	
	  // Execute using callback
	  if(typeof callback == 'function') return group(self, keys, condition, initial, reduce, finalize, command, options, callback);
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    group(self, keys, condition, initial, reduce, finalize, command, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	var group = function(self, keys, condition, initial, reduce, finalize, command, options, callback) {
	  // Execute using the command
	  if(command) {
	    var reduceFunction = reduce && reduce._bsontype == 'Code'
	        ? reduce
	        : new Code(reduce);
	
	    var selector = {
	      group: {
	          'ns': self.s.name
	        , '$reduce': reduceFunction
	        , 'cond': condition
	        , 'initial': initial
	        , 'out': "inline"
	      }
	    };
	
	    // if finalize is defined
	    if(finalize != null) selector.group['finalize'] = finalize;
	    // Set up group selector
	    if ('function' === typeof keys || (keys && keys._bsontype == 'Code')) {
	      selector.group.$keyf = keys && keys._bsontype == 'Code'
	        ? keys
	        : new Code(keys);
	    } else {
	      var hash = {};
	      keys.forEach(function (key) {
	        hash[key] = 1;
	      });
	      selector.group.key = hash;
	    }
	
	    options = shallowClone(options);
	    // Ensure we have the right read preference inheritance
	    options = getReadPreference(self, options, self.s.db, self);
	
	    // Do we have a readConcern specified
	    if(self.s.readConcern) {
	      selector.readConcern = self.s.readConcern;
	    }
	
	    // Have we specified collation
	    decorateWithCollation(selector, self, options);
	
	    // Execute command
	    self.s.db.command(selector, options, function(err, result) {
	      if(err) return handleCallback(callback, err, null);
	      handleCallback(callback, null, result.retval);
	    });
	  } else {
	    // Create execution scope
	    var scope = reduce != null && reduce._bsontype == 'Code'
	      ? reduce.scope
	      : {};
	
	    scope.ns = self.s.name;
	    scope.keys = keys;
	    scope.condition = condition;
	    scope.initial = initial;
	
	    // Pass in the function text to execute within mongodb.
	    var groupfn = groupFunction.replace(/ reduce;/, reduce.toString() + ';');
	
	    self.s.db.eval(new Code(groupfn, scope), function (err, results) {
	      if (err) return handleCallback(callback, err, null);
	      handleCallback(callback, null, results.result || results);
	    });
	  }
	}
	
	define.classMethod('group', {callback: true, promise:true});
	
	/**
	 * Functions that are passed as scope args must
	 * be converted to Code instances.
	 * @ignore
	 */
	function processScope (scope) {
	  if(!isObject(scope) || scope._bsontype == 'ObjectID') {
	    return scope;
	  }
	
	  var keys = Object.keys(scope);
	  var i = keys.length;
	  var key;
	  var new_scope = {};
	
	  while (i--) {
	    key = keys[i];
	    if ('function' == typeof scope[key]) {
	      new_scope[key] = new Code(String(scope[key]));
	    } else {
	      new_scope[key] = processScope(scope[key]);
	    }
	  }
	
	  return new_scope;
	}
	
	/**
	 * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.
	 *
	 * @method
	 * @param {(function|string)} map The mapping function.
	 * @param {(function|string)} reduce The reduce function.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.out=null] Sets the output target for the map reduce job. *{inline:1} | {replace:'collectionName'} | {merge:'collectionName'} | {reduce:'collectionName'}*
	 * @param {object} [options.query=null] Query filter object.
	 * @param {object} [options.sort=null] Sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces.
	 * @param {number} [options.limit=null] Number of objects to return from collection.
	 * @param {boolean} [options.keeptemp=false] Keep temporary data.
	 * @param {(function|string)} [options.finalize=null] Finalize function.
	 * @param {object} [options.scope=null] Can pass in variables that can be access from map/reduce/finalize.
	 * @param {boolean} [options.jsMode=false] It is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X.
	 * @param {boolean} [options.verbose=false] Provide statistics on job execution time.
	 * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.
	 * @param {Collection~resultCallback} [callback] The command result callback
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	Collection.prototype.mapReduce = function(map, reduce, options, callback) {
	  var self = this;
	  if('function' === typeof options) callback = options, options = {};
	  // Out must allways be defined (make sure we don't break weirdly on pre 1.8+ servers)
	  if(null == options.out) {
	    throw new Error("the out option parameter must be defined, see mongodb docs for possible values");
	  }
	
	  if('function' === typeof map) {
	    map = map.toString();
	  }
	
	  if('function' === typeof reduce) {
	    reduce = reduce.toString();
	  }
	
	  if('function' === typeof options.finalize) {
	    options.finalize = options.finalize.toString();
	  }
	
	  // Execute using callback
	  if(typeof callback == 'function') return mapReduce(self, map, reduce, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    mapReduce(self, map, reduce, options, function(err, r, r1) {
	      if(err) return reject(err);
	      if(!r1) return resolve(r);
	      resolve({results: r, stats: r1});
	    });
	  });
	}
	
	var mapReduce = function(self, map, reduce, options, callback) {
	  var mapCommandHash = {
	      mapreduce: self.s.name
	    , map: map
	    , reduce: reduce
	  };
	
	  // Exclusion list
	  var exclusionList = ['readPreference'];
	
	  // Add any other options passed in
	  for(var n in options) {
	    if('scope' == n) {
	      mapCommandHash[n] = processScope(options[n]);
	    } else {
	      // Only include if not in exclusion list
	      if(exclusionList.indexOf(n) == -1) {
	        mapCommandHash[n] = options[n];
	      }
	    }
	  }
	
	  options = shallowClone(options);
	
	  // Ensure we have the right read preference inheritance
	  options = getReadPreference(self, options, self.s.db, self);
	
	  // If we have a read preference and inline is not set as output fail hard
	  if((options.readPreference != false && options.readPreference != 'primary')
	    && options['out'] && (options['out'].inline != 1 && options['out'] != 'inline')) {
	      // Force readPreference to primary
	      options.readPreference = 'primary';
	      // Decorate command with writeConcern if supported
	      decorateWithWriteConcern(mapCommandHash, self, options);
	  } else if(self.s.readConcern) {
	    mapCommandHash.readConcern = self.s.readConcern;
	  }
	
	  // Is bypassDocumentValidation specified
	  if(typeof options.bypassDocumentValidation == 'boolean') {
	    mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;
	  }
	
	  // Have we specified collation
	  decorateWithCollation(mapCommandHash, self, options);
	
	  // Execute command
	  self.s.db.command(mapCommandHash, {readPreference:options.readPreference}, function (err, result) {
	    if(err) return handleCallback(callback, err);
	    // Check if we have an error
	    if(1 != result.ok || result.err || result.errmsg) {
	      return handleCallback(callback, toError(result));
	    }
	
	    // Create statistics value
	    var stats = {};
	    if(result.timeMillis) stats['processtime'] = result.timeMillis;
	    if(result.counts) stats['counts'] = result.counts;
	    if(result.timing) stats['timing'] = result.timing;
	
	    // invoked with inline?
	    if(result.results) {
	      // If we wish for no verbosity
	      if(options['verbose'] == null || !options['verbose']) {
	        return handleCallback(callback, null, result.results);
	      }
	
	      return handleCallback(callback, null, result.results, stats);
	    }
	
	    // The returned collection
	    var collection = null;
	
	    // If we have an object it's a different db
	    if(result.result != null && typeof result.result == 'object') {
	      var doc = result.result;
	      collection = self.s.db.db(doc.db).collection(doc.collection);
	    } else {
	      // Create a collection object that wraps the result collection
	      collection = self.s.db.collection(result.result)
	    }
	
	    // If we wish for no verbosity
	    if(options['verbose'] == null || !options['verbose']) {
	      return handleCallback(callback, err, collection);
	    }
	
	    // Return stats as third set of values
	    handleCallback(callback, err, collection, stats);
	  });
	}
	
	define.classMethod('mapReduce', {callback: true, promise:true});
	
	/**
	 * Initiate a Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @return {UnorderedBulkOperation}
	 */
	Collection.prototype.initializeUnorderedBulkOp = function(options) {
	  options = options || {};
	  options.promiseLibrary = this.s.promiseLibrary;
	  return unordered(this.s.topology, this, options);
	}
	
	define.classMethod('initializeUnorderedBulkOp', {callback: false, promise:false, returns: [ordered.UnorderedBulkOperation]});
	
	/**
	 * Initiate an In order bulk write operation, operations will be serially executed in the order they are added, creating a new operation for each switch in types.
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {OrderedBulkOperation} callback The command result callback
	 * @return {null}
	 */
	Collection.prototype.initializeOrderedBulkOp = function(options) {
	  options = options || {};
	  options.promiseLibrary = this.s.promiseLibrary;
	  return ordered(this.s.topology, this, options);
	}
	
	define.classMethod('initializeOrderedBulkOp', {callback: false, promise:false, returns: [ordered.OrderedBulkOperation]});
	
	// Get write concern
	var writeConcern = function(target, db, col, options) {
	  if(options.w != null || options.j != null || options.fsync != null) {
	    var opts = {};
	    if(options.w != null) opts.w = options.w;
	    if(options.wtimeout != null) opts.wtimeout = options.wtimeout;
	    if(options.j != null) opts.j = options.j;
	    if(options.fsync != null) opts.fsync = options.fsync;
	    target.writeConcern = opts;
	  } else if(col.writeConcern.w != null || col.writeConcern.j != null || col.writeConcern.fsync != null) {
	    target.writeConcern = col.writeConcern;
	  } else if(db.writeConcern.w != null || db.writeConcern.j != null || db.writeConcern.fsync != null) {
	    target.writeConcern = db.writeConcern;
	  }
	
	  return target
	}
	
	// Figure out the read preference
	var getReadPreference = function(self, options, db) {
	  var r = null
	  if(options.readPreference) {
	    r = options.readPreference
	  } else if(self.s.readPreference) {
	    r = self.s.readPreference
	  } else if(db.s.readPreference) {
	    r = db.s.readPreference;
	  }
	
	  if(r instanceof ReadPreference) {
	    options.readPreference = new CoreReadPreference(r.mode, r.tags, {maxStalenessSeconds: r.maxStalenessSeconds});
	  } else if(typeof r == 'string') {
	    options.readPreference = new CoreReadPreference(r);
	  } else if(r && !(r instanceof ReadPreference) && typeof r == 'object') {
	    var mode = r.mode || r.preference;
	    if (mode && typeof mode == 'string') {
	      options.readPreference = new CoreReadPreference(mode, r.tags, {maxStalenessSeconds: r.maxStalenessSeconds});
	    }
	  }
	
	  return options;
	}
	
	var testForFields = {
	    limit: 1, sort: 1, fields:1, skip: 1, hint: 1, explain: 1, snapshot: 1, timeout: 1, tailable: 1, tailableRetryInterval: 1
	  , numberOfRetries: 1, awaitdata: 1, awaitData: 1, exhaust: 1, batchSize: 1, returnKey: 1, maxScan: 1, min: 1, max: 1, showDiskLoc: 1
	  , comment: 1, raw: 1, readPreference: 1, partial: 1, read: 1, dbName: 1, oplogReplay: 1, connection: 1, maxTimeMS: 1, transforms: 1
	  , collation: 1
	}
	
	module.exports = Collection;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var EventEmitter = __webpack_require__(6).EventEmitter
	  , inherits = __webpack_require__(1).inherits
	  , CServer = __webpack_require__(3).Server
	  , Cursor = __webpack_require__(17)
	  , AggregationCursor = __webpack_require__(27)
	  , CommandCursor = __webpack_require__(23)
	  , f = __webpack_require__(1).format
	  , ServerCapabilities = __webpack_require__(28).ServerCapabilities
	  , Store = __webpack_require__(28).Store
	  , Define = __webpack_require__(13)
	  , MongoError = __webpack_require__(3).MongoError
	  , MAX_JS_INT = __webpack_require__(2).MAX_JS_INT
	  , translateOptions = __webpack_require__(2).translateOptions
	  , filterOptions = __webpack_require__(2).filterOptions
	  , mergeOptions = __webpack_require__(2).mergeOptions
	  , getReadPreference = __webpack_require__(2).getReadPreference
	  , os = __webpack_require__(49);
	
	// Get package.json variable
	var driverVersion = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../package.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).version;
	var nodejsversion = f('Node.js %s, %s', process.version, os.endianness());
	var type = os.type();
	var name = process.platform;
	var architecture = process.arch;
	var release = os.release();
	
	/**
	 * @fileOverview The **Server** class is a class that represents a single server topology and is
	 * used to construct connections.
	 *
	 * **Server Should not be used, use MongoClient.connect**
	 * @example
	 * var Db = require('mongodb').Db,
	 *   Server = require('mongodb').Server,
	 *   test = require('assert');
	 * // Connect using single Server
	 * var db = new Db('test', new Server('localhost', 27017););
	 * db.open(function(err, db) {
	 *   // Get an additional db
	 *   db.close();
	 * });
	 */
	
	 // Allowed parameters
	 var legalOptionNames = ['ha', 'haInterval', 'acceptableLatencyMS'
	   , 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate'
	   , 'sslCA', 'sslCRL', 'sslCert', 'sslKey', 'sslPass', 'socketOptions', 'bufferMaxEntries'
	   , 'store', 'auto_reconnect', 'autoReconnect', 'emitError'
	   , 'keepAlive', 'noDelay', 'connectTimeoutMS', 'socketTimeoutMS', 'family'
	   , 'loggerLevel', 'logger', 'reconnectTries', 'reconnectInterval', 'monitoring'
	   , 'appname', 'domainsEnabled'
	   , 'servername', 'promoteLongs', 'promoteValues', 'promoteBuffers'];
	
	/**
	 * Creates a new Server instance
	 * @class
	 * @deprecated
	 * @param {string} host The host for the server, can be either an IP4, IP6 or domain socket style host.
	 * @param {number} [port] The server port if IP4.
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.
	 * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)
	 * @param {object} [options.sslValidate=true] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {array} [options.sslCA=null] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {array} [options.sslCRL=null] Array of revocation certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslCert=null] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslKey=null] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslPass=null] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.
	 * @param {object} [options.socketOptions=null] Socket options
	 * @param {boolean} [options.socketOptions.autoReconnect=true] Reconnect on error.
	 * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option.
	 * @param {number} [options.socketOptions.keepAlive=0] TCP KeepAlive on the socket with a X ms delay before start.
	 * @param {number} [options.socketOptions.connectTimeoutMS=0] TCP Connection timeout setting
	 * @param {number} [options.socketOptions.socketTimeoutMS=0] TCP Socket timeout setting
	 * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times
	 * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries
	 * @param {number} [options.monitoring=true] Triggers the server instance to call ismaster
	 * @param {number} [options.haInterval=10000] The interval of calling ismaster when monitoring is enabled.
	 * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
	 * @fires Server#connect
	 * @fires Server#close
	 * @fires Server#error
	 * @fires Server#timeout
	 * @fires Server#parseError
	 * @fires Server#reconnect
	 * @property {string} parserType the parser type used (c++ or js).
	 * @return {Server} a Server instance.
	 */
	var Server = function(host, port, options) {
	  options = options || {};
	  if(!(this instanceof Server)) return new Server(host, port, options);
	  EventEmitter.call(this);
	  var self = this;
	
	  // Filter the options
	  options = filterOptions(options, legalOptionNames);
	
	  // Stored options
	  var storeOptions = {
	      force: false
	    , bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : MAX_JS_INT
	  }
	
	  // Shared global store
	  var store = options.store || new Store(self, storeOptions);
	
	  // Detect if we have a socket connection
	  if(host.indexOf('\/') != -1) {
	    if(port != null && typeof port == 'object') {
	      options = port;
	      port = null;
	    }
	  } else if(port == null) {
	    throw MongoError.create({message: 'port must be specified', driver:true});
	  }
	
	  // Get the reconnect option
	  var reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;
	  reconnect = typeof options.autoReconnect == 'boolean' ? options.autoReconnect : reconnect;
	
	  // Clone options
	  var clonedOptions = mergeOptions({}, {
	    host: host, port: port, disconnectHandler: store,
	    cursorFactory: Cursor,
	    reconnect: reconnect,
	    emitError: typeof options.emitError == 'boolean' ? options.emitError : true,
	    size: typeof options.poolSize == 'number' ? options.poolSize : 5
	  });
	
	  // Translate any SSL options and other connectivity options
	  clonedOptions = translateOptions(clonedOptions, options);
	
	  // Socket options
	  var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0
	    ? options.socketOptions : options;
	
	  // Translate all the options to the mongodb-core ones
	  clonedOptions = translateOptions(clonedOptions, socketOptions);
	  if(typeof clonedOptions.keepAlive == 'number') {
	    clonedOptions.keepAliveInitialDelay = clonedOptions.keepAlive;
	    clonedOptions.keepAlive = clonedOptions.keepAlive > 0;
	  }
	
	  // Build default client information
	  this.clientInfo = {
	    driver: {
	      name: "nodejs",
	      version: driverVersion
	    },
	    os: {
	      type: type,
	      name: name,
	      architecture: architecture,
	      version: release
	    },
	    platform: nodejsversion
	  }
	
	  // Build default client information
	  clonedOptions.clientInfo = this.clientInfo;
	  // Do we have an application specific string
	  if(options.appname) {
	    clonedOptions.clientInfo.application = { name: options.appname };
	  }
	
	  // Create an instance of a server instance from mongodb-core
	  var server = new CServer(clonedOptions);
	
	  // Define the internal properties
	  this.s = {
	    // Create an instance of a server instance from mongodb-core
	      server: server
	    // Server capabilities
	    , sCapabilities: null
	    // Cloned options
	    , clonedOptions: clonedOptions
	    // Reconnect
	    , reconnect: clonedOptions.reconnect
	    // Emit error
	    , emitError: clonedOptions.emitError
	    // Pool size
	    , poolSize: clonedOptions.size
	    // Store Options
	    , storeOptions: storeOptions
	    // Store
	    , store: store
	    // Host
	    , host: host
	    // Port
	    , port: port
	    // Options
	    , options: options
	  }
	}
	
	inherits(Server, EventEmitter);
	
	var define = Server.define = new Define('Server', Server, false);
	
	// BSON property
	Object.defineProperty(Server.prototype, 'bson', {
	  enumerable: true, get: function() {
	    return this.s.server.s.bson;
	  }
	});
	
	// Last ismaster
	Object.defineProperty(Server.prototype, 'isMasterDoc', {
	  enumerable:true, get: function() {
	    return this.s.server.lastIsMaster();
	  }
	});
	
	Object.defineProperty(Server.prototype, 'parserType', {
	  enumerable:true, get: function() {
	    return this.s.server.parserType;
	  }
	});
	
	// Last ismaster
	Object.defineProperty(Server.prototype, 'poolSize', {
	  enumerable:true, get: function() { return this.s.server.connections().length; }
	});
	
	Object.defineProperty(Server.prototype, 'autoReconnect', {
	  enumerable:true, get: function() { return this.s.reconnect; }
	});
	
	Object.defineProperty(Server.prototype, 'host', {
	  enumerable:true, get: function() { return this.s.host; }
	});
	
	Object.defineProperty(Server.prototype, 'port', {
	  enumerable:true, get: function() { return this.s.port; }
	});
	
	// Connect
	Server.prototype.connect = function(db, _options, callback) {
	  var self = this;
	  if('function' === typeof _options) callback = _options, _options = {};
	  if(_options == null) _options = {};
	  if(!('function' === typeof callback)) callback = null;
	  self.s.options = _options;
	
	  // Update bufferMaxEntries
	  self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries;
	
	  // Error handler
	  var connectErrorHandler = function() {
	    return function(err) {
	      // Remove all event handlers
	      var events = ['timeout', 'error', 'close'];
	      events.forEach(function(e) {
	        self.s.server.removeListener(e, connectHandlers[e]);
	      });
	
	      self.s.server.removeListener('connect', connectErrorHandler);
	
	      // Try to callback
	      try {
	        callback(err);
	      } catch(err) {
	        process.nextTick(function() { throw err; })
	      }
	    }
	  }
	
	  // Actual handler
	  var errorHandler = function(event) {
	    return function(err) {
	      if(event != 'error') {
	        self.emit(event, err);
	      }
	    }
	  }
	
	  // Error handler
	  var reconnectHandler = function() {
	    self.emit('reconnect', self);
	    self.s.store.execute();
	  }
	
	  // Reconnect failed
	  var reconnectFailedHandler = function(err) {
	    self.emit('reconnectFailed', err);
	    self.s.store.flush(err);
	  }
	
	  // Destroy called on topology, perform cleanup
	  var destroyHandler = function() {
	    self.s.store.flush();
	  }
	
	  // relay the event
	  var relay = function(event) {
	    return function(t, server) {
	      self.emit(event, t, server);
	    }
	  }
	
	  // Connect handler
	  var connectHandler = function() {
	    // Clear out all the current handlers left over
	    ["timeout", "error", "close", 'destroy'].forEach(function(e) {
	      self.s.server.removeAllListeners(e);
	    });
	
	    // Set up listeners
	    self.s.server.on('timeout', errorHandler('timeout'));
	    self.s.server.once('error', errorHandler('error'));
	    self.s.server.on('close', errorHandler('close'));
	    // Only called on destroy
	    self.s.server.on('destroy', destroyHandler);
	
	    // Emit open event
	    self.emit('open', null, self);
	
	    // Return correctly
	    try {
	      callback(null, self);
	    } catch(err) {
	      console.log(err.stack)
	      process.nextTick(function() { throw err; })
	    }
	  }
	
	  // Set up listeners
	  var connectHandlers = {
	    timeout: connectErrorHandler('timeout'),
	    error: connectErrorHandler('error'),
	    close: connectErrorHandler('close')
	  };
	
	  // Clear out all the current handlers left over
	  ["timeout", "error", "close", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	    'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening',
	    'topologyClosed', 'topologyDescriptionChanged'].forEach(function(e) {
	    self.s.server.removeAllListeners(e);
	  });
	
	  // Add the event handlers
	  self.s.server.once('timeout', connectHandlers.timeout);
	  self.s.server.once('error', connectHandlers.error);
	  self.s.server.once('close', connectHandlers.close);
	  self.s.server.once('connect', connectHandler);
	  // Reconnect server
	  self.s.server.on('reconnect', reconnectHandler);
	  self.s.server.on('reconnectFailed', reconnectFailedHandler);
	
	  // Set up SDAM listeners
	  self.s.server.on('serverDescriptionChanged', relay('serverDescriptionChanged'));
	  self.s.server.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));
	  self.s.server.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));
	  self.s.server.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));
	  self.s.server.on('serverOpening', relay('serverOpening'));
	  self.s.server.on('serverClosed', relay('serverClosed'));
	  self.s.server.on('topologyOpening', relay('topologyOpening'));
	  self.s.server.on('topologyClosed', relay('topologyClosed'));
	  self.s.server.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));
	  self.s.server.on('attemptReconnect', relay('attemptReconnect'));
	  self.s.server.on('monitoring', relay('monitoring'));
	
	  // Start connection
	  self.s.server.connect(_options);
	}
	
	// Server capabilities
	Server.prototype.capabilities = function() {
	  if(this.s.sCapabilities) return this.s.sCapabilities;
	  if(this.s.server.lastIsMaster() == null) return null;
	  this.s.sCapabilities = new ServerCapabilities(this.s.server.lastIsMaster());
	  return this.s.sCapabilities;
	}
	
	define.classMethod('capabilities', {callback: false, promise:false, returns: [ServerCapabilities]});
	
	// Command
	Server.prototype.command = function(ns, cmd, options, callback) {
	  this.s.server.command(ns, cmd, getReadPreference(options), callback);
	}
	
	define.classMethod('command', {callback: true, promise:false});
	
	// Insert
	Server.prototype.insert = function(ns, ops, options, callback) {
	  this.s.server.insert(ns, ops, options, callback);
	}
	
	define.classMethod('insert', {callback: true, promise:false});
	
	// Update
	Server.prototype.update = function(ns, ops, options, callback) {
	  this.s.server.update(ns, ops, options, callback);
	}
	
	define.classMethod('update', {callback: true, promise:false});
	
	// Remove
	Server.prototype.remove = function(ns, ops, options, callback) {
	  this.s.server.remove(ns, ops, options, callback);
	}
	
	define.classMethod('remove', {callback: true, promise:false});
	
	// IsConnected
	Server.prototype.isConnected = function() {
	  return this.s.server.isConnected();
	}
	
	Server.prototype.isDestroyed = function() {
	  return this.s.server.isDestroyed();
	}
	
	define.classMethod('isConnected', {callback: false, promise:false, returns: [Boolean]});
	
	// Insert
	Server.prototype.cursor = function(ns, cmd, options) {
	  options.disconnectHandler = this.s.store;
	  return this.s.server.cursor(ns, cmd, options);
	}
	
	define.classMethod('cursor', {callback: false, promise:false, returns: [Cursor, AggregationCursor, CommandCursor]});
	
	Server.prototype.lastIsMaster = function() {
	  return this.s.server.lastIsMaster();
	}
	
	/**
	 * Unref all sockets
	 * @method
	 */
	Server.prototype.unref = function() {
	  this.s.server.unref();
	}
	
	Server.prototype.close = function(forceClosed) {
	  this.s.server.destroy();
	  // We need to wash out all stored processes
	  if(forceClosed == true) {
	    this.s.storeOptions.force = forceClosed;
	    this.s.store.flush();
	  }
	}
	
	define.classMethod('close', {callback: false, promise:false});
	
	Server.prototype.auth = function() {
	  var args = Array.prototype.slice.call(arguments, 0);
	  this.s.server.auth.apply(this.s.server, args);
	}
	
	define.classMethod('auth', {callback: true, promise:false});
	
	Server.prototype.logout = function() {
	  var args = Array.prototype.slice.call(arguments, 0);
	  this.s.server.logout.apply(this.s.server, args);
	}
	
	define.classMethod('logout', {callback: true, promise:false});
	
	/**
	 * All raw connections
	 * @method
	 * @return {array}
	 */
	Server.prototype.connections = function() {
	  return this.s.server.connections();
	}
	
	define.classMethod('connections', {callback: false, promise:false, returns:[Array]});
	
	/**
	 * Server connect event
	 *
	 * @event Server#connect
	 * @type {object}
	 */
	
	/**
	 * Server close event
	 *
	 * @event Server#close
	 * @type {object}
	 */
	
	/**
	 * Server reconnect event
	 *
	 * @event Server#reconnect
	 * @type {object}
	 */
	
	/**
	 * Server error event
	 *
	 * @event Server#error
	 * @type {MongoError}
	 */
	
	/**
	 * Server timeout event
	 *
	 * @event Server#timeout
	 * @type {object}
	 */
	
	/**
	 * Server parseError event
	 *
	 * @event Server#parseError
	 * @type {object}
	 */
	
	module.exports = Server;


/***/ }),
/* 61 */
/***/ (function(module, exports) {

	
	/*!
	 * Connection states
	 */
	
	var STATES = module.exports = exports = Object.create(null);
	
	var disconnected = 'disconnected';
	var connected = 'connected';
	var connecting = 'connecting';
	var disconnecting = 'disconnecting';
	var unauthorized = 'unauthorized';
	var uninitialized = 'uninitialized';
	
	STATES[0] = disconnected;
	STATES[1] = connected;
	STATES[2] = connecting;
	STATES[3] = disconnecting;
	STATES[4] = unauthorized;
	STATES[99] = uninitialized;
	
	STATES[disconnected] = 0;
	STATES[connected] = 1;
	STATES[connecting] = 2;
	STATES[disconnecting] = 3;
	STATES[unauthorized] = 4;
	STATES[uninitialized] = 99;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module exports.
	 */
	
	exports.Binary = __webpack_require__(85);
	exports.ObjectId = __webpack_require__(86);
	exports.ReadPreference = __webpack_require__(84);


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies
	 */
	
	var utils = __webpack_require__(4);
	
	/*!
	 * Prepare a set of path options for query population.
	 *
	 * @param {Query} query
	 * @param {Object} options
	 * @return {Array}
	 */
	
	exports.preparePopulationOptions = function preparePopulationOptions(query, options) {
	  var pop = utils.object.vals(query.options.populate);
	
	  // lean options should trickle through all queries
	  if (options.lean) pop.forEach(makeLean);
	
	  return pop;
	};
	
	/*!
	 * Prepare a set of path options for query population. This is the MongooseQuery
	 * version
	 *
	 * @param {Query} query
	 * @param {Object} options
	 * @return {Array}
	 */
	
	exports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {
	  var pop = utils.object.vals(query._mongooseOptions.populate);
	
	  // lean options should trickle through all queries
	  if (options.lean) pop.forEach(makeLean);
	
	  return pop;
	};
	
	/*!
	 * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,
	 * it returns an instance of the given model.
	 *
	 * @param {Model}  model
	 * @param {Object} doc
	 * @param {Object} fields
	 *
	 * @return {Model}
	 */
	exports.createModel = function createModel(model, doc, fields, userProvidedFields) {
	  var discriminatorMapping = model.schema
	    ? model.schema.discriminatorMapping
	    : null;
	
	  var key = discriminatorMapping && discriminatorMapping.isRoot
	    ? discriminatorMapping.key
	    : null;
	
	  if (key && doc[key] && model.discriminators && model.discriminators[doc[key]]) {
	    var discriminator = model.discriminators[doc[key]];
	    var _fields = utils.clone(userProvidedFields);
	    exports.applyPaths(_fields, discriminator.schema);
	    return new model.discriminators[doc[key]](undefined, _fields, true);
	  }
	
	  return new model(undefined, fields, true);
	};
	
	/*!
	 * ignore
	 */
	
	exports.applyPaths = function applyPaths(fields, schema) {
	  // determine if query is selecting or excluding fields
	
	  var exclude;
	  var keys;
	  var ki;
	  var field;
	
	  if (fields) {
	    keys = Object.keys(fields);
	    ki = keys.length;
	
	    while (ki--) {
	      if (keys[ki][0] === '+') {
	        continue;
	      }
	      field = fields[keys[ki]];
	      if (typeof field === 'object' && field && field.$slice) {
	        continue;
	      }
	      exclude = field === 0;
	      break;
	    }
	  }
	
	  // if selecting, apply default schematype select:true fields
	  // if excluding, apply schematype select:false fields
	
	  var selected = [];
	  var excluded = [];
	  var stack = [];
	
	  var analyzePath = function(path, type) {
	    if (typeof type.selected !== 'boolean') return;
	
	    var plusPath = '+' + path;
	    if (fields && plusPath in fields) {
	      // forced inclusion
	      delete fields[plusPath];
	
	      // if there are other fields being included, add this one
	      // if no other included fields, leave this out (implied inclusion)
	      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {
	        fields[path] = 1;
	      }
	
	      return;
	    }
	
	    // check for parent exclusions
	    var root = path.split('.')[0];
	    if (~excluded.indexOf(root)) return;
	
	    (type.selected ? selected : excluded).push(path);
	  };
	
	  var analyzeSchema = function(schema, prefix) {
	    prefix || (prefix = '');
	
	    // avoid recursion
	    if (stack.indexOf(schema) !== -1) {
	      return;
	    }
	    stack.push(schema);
	
	    schema.eachPath(function(path, type) {
	      if (prefix) path = prefix + '.' + path;
	
	      analyzePath(path, type);
	
	      // array of subdocs?
	      if (type.schema) {
	        analyzeSchema(type.schema, path);
	      }
	    });
	
	    stack.pop();
	  };
	
	  analyzeSchema(schema);
	
	  var i;
	  switch (exclude) {
	    case true:
	      for (i = 0; i < excluded.length; ++i) {
	        fields[excluded[i]] = 0;
	      }
	      break;
	    case false:
	      if (schema &&
	          schema.paths['_id'] &&
	          schema.paths['_id'].options &&
	          schema.paths['_id'].options.select === false) {
	        fields._id = 0;
	      }
	      for (i = 0; i < selected.length; ++i) {
	        fields[selected[i]] = 1;
	      }
	      break;
	    case undefined:
	      // user didn't specify fields, implies returning all fields.
	      // only need to apply excluded fields
	      for (i = 0; i < excluded.length; ++i) {
	        fields[excluded[i]] = 0;
	      }
	      break;
	  }
	};
	
	/*!
	 * Set each path query option to lean
	 *
	 * @param {Object} option
	 */
	
	function makeLean(option) {
	  option.options || (option.options = {});
	  option.options.lean = true;
	}


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var SchemaType = __webpack_require__(12);
	var utils = __webpack_require__(4);
	
	/**
	 * Mixed SchemaType constructor.
	 *
	 * @param {String} path
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function Mixed(path, options) {
	  if (options && options.default) {
	    var def = options.default;
	    if (Array.isArray(def) && def.length === 0) {
	      // make sure empty array defaults are handled
	      options.default = Array;
	    } else if (!options.shared && utils.isObject(def) && Object.keys(def).length === 0) {
	      // prevent odd "shared" objects between documents
	      options.default = function() {
	        return {};
	      };
	    }
	  }
	
	  SchemaType.call(this, path, options, 'Mixed');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	Mixed.schemaName = 'Mixed';
	
	/*!
	 * Inherits from SchemaType.
	 */
	Mixed.prototype = Object.create(SchemaType.prototype);
	Mixed.prototype.constructor = Mixed;
	
	/**
	 * Casts `val` for Mixed.
	 *
	 * _this is a no-op_
	 *
	 * @param {Object} value to cast
	 * @api private
	 */
	
	Mixed.prototype.cast = function(val) {
	  return val;
	};
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $cond
	 * @param {any} [val]
	 * @api private
	 */
	
	Mixed.prototype.castForQuery = function($cond, val) {
	  if (arguments.length === 2) {
	    return val;
	  }
	  return $cond;
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = Mixed;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/*!
	 * Module requirements.
	 */
	
	var Types = {
	  Number: __webpack_require__(96)
	};
	
	/*!
	 * @ignore
	 */
	
	exports.castToNumber = castToNumber;
	exports.castArraysOfNumbers = castArraysOfNumbers;
	
	/*!
	 * @ignore
	 */
	
	function castToNumber(val) {
	  return Types.Number.prototype.cast.call(this, val);
	}
	
	function castArraysOfNumbers(arr, self) {
	  arr.forEach(function(v, i) {
	    if (Array.isArray(v)) {
	      castArraysOfNumbers(v, self);
	    } else {
	      arr[i] = castToNumber.call(self, v);
	    }
	  });
	}


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/*!
	 * Module dependencies.
	 */
	
	var ObjectId = __webpack_require__(24);
	var utils = __webpack_require__(4);
	
	exports.flatten = flatten;
	exports.modifiedPaths = modifiedPaths;
	
	/*!
	 * ignore
	 */
	
	function flatten(update, path, options) {
	  var keys;
	  if (update && utils.isMongooseObject(update) && !Buffer.isBuffer(update)) {
	    keys = Object.keys(update.toObject({ transform: false, virtuals: false }));
	  } else {
	    keys = Object.keys(update || {});
	  }
	
	  var numKeys = keys.length;
	  var result = {};
	  path = path ? path + '.' : '';
	
	  for (var i = 0; i < numKeys; ++i) {
	    var key = keys[i];
	    var val = update[key];
	    result[path + key] = val;
	    if (shouldFlatten(val)) {
	      if (options && options.skipArrays && Array.isArray(val)) {
	        continue;
	      }
	      var flat = flatten(val, path + key, options);
	      for (var k in flat) {
	        result[k] = flat[k];
	      }
	      if (Array.isArray(val)) {
	        result[path + key] = val;
	      }
	    }
	  }
	
	  return result;
	}
	
	/*!
	 * ignore
	 */
	
	function modifiedPaths(update, path, result) {
	  var keys = Object.keys(update || {});
	  var numKeys = keys.length;
	  result = result || {};
	  path = path ? path + '.' : '';
	
	  for (var i = 0; i < numKeys; ++i) {
	    var key = keys[i];
	    var val = update[key];
	
	    result[path + key] = true;
	    if (utils.isMongooseObject(val) && !Buffer.isBuffer(val)) {
	      val = val.toObject({ transform: false, virtuals: false });
	    }
	    if (shouldFlatten(val)) {
	      modifiedPaths(val, path + key, result);
	    }
	  }
	
	  return result;
	}
	
	/*!
	 * ignore
	 */
	
	function shouldFlatten(val) {
	  return val &&
	    typeof val === 'object' &&
	    !(val instanceof Date) &&
	    !(val instanceof ObjectId) &&
	    (!Array.isArray(val) || val.length > 0) &&
	    !(val instanceof Buffer);
	}


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = exports = __webpack_require__(244);


/***/ }),
/* 68 */
/***/ (function(module, exports) {

	'use strict';
	
	/**
	 * methods a collection must implement
	 */
	
	var methods = [
	    'find'
	  , 'findOne'
	  , 'update'
	  , 'updateMany',
	  , 'updateOne'
	  , 'replaceOne'
	  , 'remove'
	  , 'count'
	  , 'distinct'
	  , 'findAndModify'
	  , 'aggregate'
	  , 'findStream'
	  , 'deleteOne'
	  , 'deleteMany'
	];
	
	/**
	 * Collection base class from which implementations inherit
	 */
	
	function Collection () {}
	
	for (var i = 0, len = methods.length; i < len; ++i) {
	  var method = methods[i];
	  Collection.prototype[method] = notImplemented(method);
	}
	
	module.exports = exports = Collection;
	Collection.methods = methods;
	
	/**
	 * creates a function which throws an implementation error
	 */
	
	function notImplemented (method) {
	  return function () {
	    throw new Error('collection.' + method + ' not implemented');
	  }
	}


/***/ }),
/* 69 */
/***/ (function(module, exports) {

	module.exports = require("path");

/***/ }),
/* 70 */
/***/ (function(module, exports) {

	module.exports = require("readable-stream");

/***/ }),
/* 71 */
/***/ (function(module, exports) {

	"use strict"
	
	// We have an ES6 Map available, return the native instance
	if(typeof global.Map !== 'undefined') {
	  module.exports = global.Map;
	  module.exports.Map = global.Map;
	} else {
	  // We will return a polyfill
	  var Map = function(array) {
	    this._keys = [];
	    this._values = {};
	
	    for(var i = 0; i < array.length; i++) {
	      if(array[i] == null) continue;  // skip null and undefined
	      var entry = array[i];
	      var key = entry[0];
	      var value = entry[1];
	      // Add the key to the list of keys in order
	      this._keys.push(key);
	      // Add the key and value to the values dictionary with a point
	      // to the location in the ordered keys list
	      this._values[key] = {v: value, i: this._keys.length - 1};
	    }
	  }
	
	  Map.prototype.clear = function() {
	    this._keys = [];
	    this._values = {};
	  }
	
	  Map.prototype.delete = function(key) {
	    var value = this._values[key];
	    if(value == null) return false;
	    // Delete entry
	    delete this._values[key];
	    // Remove the key from the ordered keys list
	    this._keys.splice(value.i, 1);
	    return true;
	  }
	
	  Map.prototype.entries = function() {
	    var self = this;
	    var index = 0;
	
	    return {
	      next: function() {
	        var key = self._keys[index++];
	        return {
	          value: key !== undefined ? [key, self._values[key].v] : undefined,
	          done: key !== undefined ? false : true
	        }
	      }
	    };
	  }
	
	  Map.prototype.forEach = function(callback, self) {
	    self = self || this;
	
	    for(var i = 0; i < this._keys.length; i++) {
	      var key = this._keys[i];
	      // Call the forEach callback
	      callback.call(self, this._values[key].v, key, self);
	    }
	  }
	
	  Map.prototype.get = function(key) {
	    return this._values[key] ? this._values[key].v : undefined;
	  }
	
	  Map.prototype.has = function(key) {
	    return this._values[key] != null;
	  }
	
	  Map.prototype.keys = function(key) {
	    var self = this;
	    var index = 0;
	
	    return {
	      next: function() {
	        var key = self._keys[index++];
	        return {
	          value: key !== undefined ? key : undefined,
	          done: key !== undefined ? false : true
	        }
	      }
	    };
	  }
	
	  Map.prototype.set = function(key, value) {
	    if(this._values[key]) {
	      this._values[key].v = value;
	      return this;
	    }
	
	    // Add the key to the list of keys in order
	    this._keys.push(key);
	    // Add the key and value to the values dictionary with a point
	    // to the location in the ordered keys list
	    this._values[key] = {v: value, i: this._keys.length - 1};
	    return this;
	  }
	
	  Map.prototype.values = function(key, value) {
	    var self = this;
	    var index = 0;
	
	    return {
	      next: function() {
	        var key = self._keys[index++];
	        return {
	          value: key !== undefined ? self._values[key].v : undefined,
	          done: key !== undefined ? false : true
	        }
	      }
	    };
	  }
	
	  // Last ismaster
	  Object.defineProperty(Map.prototype, 'size', {
	    enumerable:true,
	    get: function() { return this._keys.length; }
	  });
	
	  module.exports = Map;
	  module.exports.Map = Map;
	}

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(115),
	    getRawTag = __webpack_require__(177),
	    objectToString = __webpack_require__(182);
	
	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';
	
	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}
	
	module.exports = baseGetTag;


/***/ }),
/* 73 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}
	
	module.exports = isObjectLike;


/***/ }),
/* 74 */
/***/ (function(module, exports) {

	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}
	
	module.exports = noop;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var f = __webpack_require__(1).format
	  , require_optional = __webpack_require__(20)
	  , Query = __webpack_require__(9).Query
	  , MongoError = __webpack_require__(7);
	
	var AuthSession = function(db, username, password, options) {
	  this.db = db;
	  this.username = username;
	  this.password = password;
	  this.options = options;
	}
	
	AuthSession.prototype.equal = function(session) {
	  return session.db == this.db
	    && session.username == this.username
	    && session.password == this.password;
	}
	
	// Kerberos class
	var Kerberos = null;
	var MongoAuthProcess = null;
	
	// Try to grab the Kerberos class
	try {
	  Kerberos = require_optional('kerberos').Kerberos
	  // Authentication process for Mongo
	  MongoAuthProcess = require_optional('kerberos').processes.MongoAuthProcess
	} catch(err) {}
	
	/**
	 * Creates a new SSPI authentication mechanism
	 * @class
	 * @return {SSPI} A cursor instance
	 */
	var SSPI = function(bson) {
	  this.bson = bson;
	  this.authStore = [];
	}
	
	/**
	 * Authenticate
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {string} db Name of the database
	 * @param {string} username Username
	 * @param {string} password Password
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	SSPI.prototype.auth = function(server, connections, db, username, password, options, callback) {
	  var self = this;
	  // We don't have the Kerberos library
	  if(Kerberos == null) return callback(new Error("Kerberos library is not installed"));
	  var gssapiServiceName = options['gssapiServiceName'] || 'mongodb';
	  // Total connections
	  var count = connections.length;
	  if(count == 0) return callback(null, null);
	
	  // Valid connections
	  var numberOfValidConnections = 0;
	  var errorObject = null;
	
	  // For each connection we need to authenticate
	  while(connections.length > 0) {
	    // Execute MongoCR
	    var execute = function(connection) {
	      // Start Auth process for a connection
	      SSIPAuthenticate(self, username, password, gssapiServiceName, server, connection, options, function(err, r) {
	        // Adjust count
	        count = count - 1;
	
	        // If we have an error
	        if(err) {
	          errorObject = err;
	        } else if(r && typeof r == 'object' && r.result['$err']) {
	          errorObject = r.result;
	        } else if(r && typeof r == 'object' && r.result['errmsg']) {
	          errorObject = r.result;
	        } else {
	          numberOfValidConnections = numberOfValidConnections + 1;
	        }
	
	        // We have authenticated all connections
	        if(count == 0 && numberOfValidConnections > 0) {
	          // Store the auth details
	          addAuthSession(self.authStore, new AuthSession(db, username, password, options));
	          // Return correct authentication
	          callback(null, true);
	        } else if(count == 0) {
	          if(errorObject == null) errorObject = new MongoError(f("failed to authenticate using mongocr"));
	          callback(errorObject, false);
	        }
	      });
	    }
	
	    var _execute = function(_connection) {
	      process.nextTick(function() {
	        execute(_connection);
	      });
	    }
	
	    _execute(connections.shift());
	  }
	}
	
	var SSIPAuthenticate = function(self, username, password, gssapiServiceName, server, connection, options, callback) {
	  // Build Authentication command to send to MongoDB
	  var command = {
	      saslStart: 1
	    , mechanism: 'GSSAPI'
	    , payload: ''
	    , autoAuthorize: 1
	  };
	
	  // Create authenticator
	  var mongo_auth_process = new MongoAuthProcess(connection.host, connection.port, gssapiServiceName, options);
	
	  // Execute first sasl step
	  server(connection, new Query(self.bson, "$external.$cmd", command, {
	    numberToSkip: 0, numberToReturn: 1
	  }), function(err, r) {
	    if(err) return callback(err, false);
	    var doc = r.result;
	
	    mongo_auth_process.init(username, password, function(err) {
	      if(err) return callback(err);
	
	      mongo_auth_process.transition(doc.payload, function(err, payload) {
	        if(err) return callback(err);
	
	        // Perform the next step against mongod
	        var command = {
	            saslContinue: 1
	          , conversationId: doc.conversationId
	          , payload: payload
	        };
	
	        // Execute the command
	        server(connection, new Query(self.bson, "$external.$cmd", command, {
	          numberToSkip: 0, numberToReturn: 1
	        }), function(err, r) {
	          if(err) return callback(err, false);
	          var doc = r.result;
	
	          mongo_auth_process.transition(doc.payload, function(err, payload) {
	            if(err) return callback(err);
	
	            // Perform the next step against mongod
	            var command = {
	                saslContinue: 1
	              , conversationId: doc.conversationId
	              , payload: payload
	            };
	
	            // Execute the command
	            server(connection, new Query(self.bson, "$external.$cmd", command, {
	              numberToSkip: 0, numberToReturn: 1
	            }), function(err, r) {
	              if(err) return callback(err, false);
	              var doc = r.result;
	
	              mongo_auth_process.transition(doc.payload, function(err, payload) {
	                // Perform the next step against mongod
	                var command = {
	                    saslContinue: 1
	                  , conversationId: doc.conversationId
	                  , payload: payload
	                };
	
	                // Execute the command
	                server(connection, new Query(self.bson, "$external.$cmd", command, {
	                  numberToSkip: 0, numberToReturn: 1
	                }), function(err, r) {
	                  if(err) return callback(err, false);
	                  var doc = r.result;
	
	                  if(doc.done) return callback(null, true);
	                  callback(new Error("Authentication failed"), false);
	                });
	              });
	            });
	          });
	        });
	      });
	    });
	  });
	}
	
	// Add to store only if it does not exist
	var addAuthSession = function(authStore, session) {
	  var found = false;
	
	  for(var i = 0; i < authStore.length; i++) {
	    if(authStore[i].equal(session)) {
	      found = true;
	      break;
	    }
	  }
	
	  if(!found) authStore.push(session);
	}
	
	/**
	 * Remove authStore credentials
	 * @method
	 * @param {string} db Name of database we are removing authStore details about
	 * @return {object}
	 */
	SSPI.prototype.logout = function(dbName) {
	  this.authStore = this.authStore.filter(function(x) {
	    return x.db != dbName;
	  });
	}
	
	/**
	 * Re authenticate pool
	 * @method
	 * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on
	 * @param {[]Connections} connections Connections to authenticate using this authenticator
	 * @param {authResultCallback} callback The callback to return the result from the authentication
	 * @return {object}
	 */
	SSPI.prototype.reauthenticate = function(server, connections, callback) {
	  var authStore = this.authStore.slice(0);
	  var count = authStore.length;
	  if(count == 0) return callback(null, null);
	  // Iterate over all the auth details stored
	  for(var i = 0; i < authStore.length; i++) {
	    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, authStore[i].options, function(err) {
	      count = count - 1;
	      // Done re-authenticating
	      if(count == 0) {
	        callback(err, null);
	      }
	    });
	  }
	}
	
	/**
	 * This is a result from a authentication strategy
	 *
	 * @callback authResultCallback
	 * @param {error} error An error object. Set to null if no error present
	 * @param {boolean} result The result of the authentication process
	 */
	
	module.exports = SSPI;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict"
	
	var inherits = __webpack_require__(1).inherits,
	  f = __webpack_require__(1).format,
	  EventEmitter = __webpack_require__(6).EventEmitter,
	  ReadPreference = __webpack_require__(43),
	  Logger = __webpack_require__(19),
	  debugOptions = __webpack_require__(11).debugOptions,
	  retrieveBSON = __webpack_require__(11).retrieveBSON,
	  Pool = __webpack_require__(194),
	  Query = __webpack_require__(9).Query,
	  MongoError = __webpack_require__(7),
	  PreTwoSixWireProtocolSupport = __webpack_require__(198),
	  TwoSixWireProtocolSupport = __webpack_require__(199),
	  ThreeTwoWireProtocolSupport = __webpack_require__(200),
	  BasicCursor = __webpack_require__(57),
	  sdam = __webpack_require__(15),
	  assign = __webpack_require__(58).assign,
	  createClientInfo = __webpack_require__(15).createClientInfo;
	
	// Used for filtering out fields for loggin
	var debugFields = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host'
	  , 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'checkServerIdentity'
	  , 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'crl', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs', 'promoteValues'
	  , 'promoteBuffers', 'servername'];
	
	// Server instance id
	var id = 0;
	var serverAccounting = false;
	var servers = {};
	var BSON = retrieveBSON();
	
	/**
	 * Creates a new Server instance
	 * @class
	 * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection
	 * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times
	 * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries
	 * @param {number} [options.monitoring=true] Enable the server state monitoring (calling ismaster at monitoringInterval)
	 * @param {number} [options.monitoringInterval=5000] The interval of calling ismaster when monitoring is enabled.
	 * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors
	 * @param {string} options.host The server host
	 * @param {number} options.port The server port
	 * @param {number} [options.size=5] Server connection pool size
	 * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled
	 * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled
	 * @param {boolean} [options.noDelay=true] TCP Connection no delay
	 * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting
	 * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting
	 * @param {boolean} [options.ssl=false] Use SSL for connection
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {Buffer} [options.ca] SSL Certificate store binary buffer
	 * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer
	 * @param {Buffer} [options.cert] SSL Certificate binary buffer
	 * @param {Buffer} [options.key] SSL Key file binary buffer
	 * @param {string} [options.passphrase] SSL Certificate pass phrase
	 * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates
	 * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.
	 * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
	 * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
	 * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
	 * @param {string} [options.appname=null] Application name, passed in on ismaster call and logged in mongod server logs. Maximum size 128 bytes.
	 * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
	 * @return {Server} A cursor instance
	 * @fires Server#connect
	 * @fires Server#close
	 * @fires Server#error
	 * @fires Server#timeout
	 * @fires Server#parseError
	 * @fires Server#reconnect
	 * @fires Server#reconnectFailed
	 * @fires Server#serverHeartbeatStarted
	 * @fires Server#serverHeartbeatSucceeded
	 * @fires Server#serverHeartbeatFailed
	 * @fires Server#topologyOpening
	 * @fires Server#topologyClosed
	 * @fires Server#topologyDescriptionChanged
	 * @property {string} type the topology type.
	 * @property {string} parserType the parser type used (c++ or js).
	 */
	var Server = function(options) {
	  options = options || {};
	
	  // Add event listener
	  EventEmitter.call(this);
	
	  // Server instance id
	  this.id = id++;
	
	  // Internal state
	  this.s = {
	    // Options
	    options: options,
	    // Logger
	    logger: Logger('Server', options),
	    // Factory overrides
	    Cursor: options.cursorFactory || BasicCursor,
	    // BSON instance
	    bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128,
	      BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey,
	      BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),
	    // Pool
	    pool: null,
	    // Disconnect handler
	    disconnectHandler: options.disconnectHandler,
	    // Monitor thread (keeps the connection alive)
	    monitoring: typeof options.monitoring == 'boolean' ? options.monitoring : true,
	    // Is the server in a topology
	    inTopology: typeof options.inTopology == 'boolean' ? options.inTopology : false,
	    // Monitoring timeout
	    monitoringInterval: typeof options.monitoringInterval == 'number'
	      ? options.monitoringInterval
	      : 5000,
	    // Topology id
	    topologyId: -1
	  }
	
	  // Curent ismaster
	  this.ismaster = null;
	  // Current ping time
	  this.lastIsMasterMS = -1;
	  // The monitoringProcessId
	  this.monitoringProcessId = null;
	  // Initial connection
	  this.initalConnect = true;
	  // Wire protocol handler, default to oldest known protocol handler
	  // this gets changed when the first ismaster is called.
	  this.wireProtocolHandler = new PreTwoSixWireProtocolSupport();
	  // Default type
	  this._type = 'server';
	  // Set the client info
	  this.clientInfo = createClientInfo(options);
	
	  // Max Stalleness values
	  // last time we updated the ismaster state
	  this.lastUpdateTime = 0;
	  // Last write time
	  this.lastWriteDate = 0;
	  // Stalleness
	  this.staleness = 0;
	}
	
	inherits(Server, EventEmitter);
	
	Object.defineProperty(Server.prototype, 'type', {
	  enumerable:true, get: function() { return this._type; }
	});
	
	Object.defineProperty(Server.prototype, 'parserType', {
	  enumerable:true, get: function() {
	    return BSON.native ? "c++" : "js";
	  }
	});
	
	Server.enableServerAccounting = function() {
	  serverAccounting = true;
	  servers = {};
	}
	
	Server.disableServerAccounting = function() {
	  serverAccounting = false;
	}
	
	Server.servers = function() {
	  return servers;
	}
	
	Object.defineProperty(Server.prototype, 'name', {
	  enumerable:true,
	  get: function() { return this.s.options.host + ":" + this.s.options.port; }
	});
	
	function configureWireProtocolHandler(self, ismaster) {
	  // 3.2 wire protocol handler
	  if(ismaster.maxWireVersion >= 4) {
	    return new ThreeTwoWireProtocolSupport(new TwoSixWireProtocolSupport());
	  }
	
	  // 2.6 wire protocol handler
	  if(ismaster.maxWireVersion >= 2) {
	    return new TwoSixWireProtocolSupport();
	  }
	
	  // 2.4 or earlier wire protocol handler
	  return new PreTwoSixWireProtocolSupport();
	}
	
	function disconnectHandler(self, type, ns, cmd, options, callback) {
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!self.s.pool.isConnected() && self.s.disconnectHandler != null && !options.monitoring) {
	    self.s.disconnectHandler.add(type, ns, cmd, options, callback);
	    return true;
	  }
	
	  // If we have no connection error
	  if(!self.s.pool.isConnected()) {
	    callback(MongoError.create(f("no connection available to server %s", self.name)));
	    return true;
	  }
	}
	
	function monitoringProcess(self) {
	  return function() {
	    // Pool was destroyed do not continue process
	    if(self.s.pool.isDestroyed()) return;
	    // Emit monitoring Process event
	    self.emit('monitoring', self);
	    // Perform ismaster call
	    // Query options
	    var queryOptions = { numberToSkip: 0, numberToReturn: -1, checkKeys: false, slaveOk: true };
	    // Create a query instance
	    var query = new Query(self.s.bson, 'admin.$cmd', {ismaster:true}, queryOptions);
	    // Get start time
	    var start = new Date().getTime();
	
	    // Execute the ismaster query
	    self.s.pool.write(query, {
	      socketTimeout: (typeof self.s.options.connectionTimeout !== 'number') ? 2000 : self.s.options.connectionTimeout,
	      monitoring: true,
	    }, function(err, result) {
	      // Set initial lastIsMasterMS
	      self.lastIsMasterMS = new Date().getTime() - start;
	      if(self.s.pool.isDestroyed()) return;
	      // Update the ismaster view if we have a result
	      if(result) {
	        self.ismaster = result.result;
	      }
	      // Re-schedule the monitoring process
	      self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);
	    });
	  }
	}
	
	var eventHandler = function(self, event) {
	  return function(err) {
	    // Log information of received information if in info mode
	    if(self.s.logger.isInfo()) {
	      var object = err instanceof MongoError ? JSON.stringify(err) : {}
	      self.s.logger.info(f('server %s fired event %s out with message %s'
	        , self.name, event, object));
	    }
	
	    // Handle connect event
	    if(event == 'connect') {
	      // Issue an ismaster command at connect
	      // Query options
	      var queryOptions = { numberToSkip: 0, numberToReturn: -1, checkKeys: false, slaveOk: true };
	      // Create a query instance
	      var query = new Query(self.s.bson, 'admin.$cmd', {ismaster:true, client: self.clientInfo}, queryOptions);
	      // Get start time
	      var start = new Date().getTime();
	      // Execute the ismaster query
	      self.s.pool.write(query, {
	        socketTimeout: self.s.options.connectionTimeout || 2000,
	      }, function(err, result) {
	        // Set initial lastIsMasterMS
	        self.lastIsMasterMS = new Date().getTime() - start;
	        if(err) {
	          self.destroy();
	          if(self.listeners('error').length > 0) self.emit('error', err);
	          return;
	        }
	
	        // Ensure no error emitted after initial connect when reconnecting
	        self.initalConnect = false;
	        // Save the ismaster
	        self.ismaster = result.result;
	
	        // It's a proxy change the type so
	        // the wireprotocol will send $readPreference
	        if(self.ismaster.msg == 'isdbgrid') {
	          self._type = 'mongos';
	        }
	        // Add the correct wire protocol handler
	        self.wireProtocolHandler = configureWireProtocolHandler(self, self.ismaster);
	        // Have we defined self monitoring
	        if(self.s.monitoring) {
	          self.monitoringProcessId = setTimeout(monitoringProcess(self), self.s.monitoringInterval);
	        }
	
	        // Emit server description changed if something listening
	        sdam.emitServerDescriptionChanged(self, {
	          address: self.name, arbiters: [], hosts: [], passives: [], type: sdam.getTopologyType(self)
	        });
	
	        if(!self.s.inTopology) {
	          // Emit topology description changed if something listening
	          sdam.emitTopologyDescriptionChanged(self, {
	            topologyType: 'Single', servers: [{address: self.name, arbiters: [], hosts: [], passives: [], type: sdam.getTopologyType(self)}]
	          });
	        }
	
	        // Log the ismaster if available
	        if(self.s.logger.isInfo()) {
	          self.s.logger.info(f('server %s connected with ismaster [%s]', self.name, JSON.stringify(self.ismaster)));
	        }
	
	        // Emit connect
	        self.emit('connect', self);
	      });
	    } else if(event == 'error' || event == 'parseError'
	      || event == 'close' || event == 'timeout' || event == 'reconnect'
	      || event == 'attemptReconnect' || 'reconnectFailed') {
	      // Remove server instance from accounting
	      if(serverAccounting && ['close', 'timeout', 'error', 'parseError', 'reconnectFailed'].indexOf(event) != -1) {
	        // Emit toplogy opening event if not in topology
	        if(!self.s.inTopology) {
	          self.emit('topologyOpening', { topologyId: self.id });
	        }
	
	        delete servers[self.id];
	      }
	
	      if (event === 'close') {
	        // Closing emits a server description changed event going to unknown.
	        sdam.emitServerDescriptionChanged(self, {
	          address: self.name, arbiters: [], hosts: [], passives: [], type: 'Unknown'
	        });
	      }
	
	      // Reconnect failed return error
	      if(event == 'reconnectFailed') {
	        self.emit('reconnectFailed', err);
	        // Emit error if any listeners
	        if(self.listeners('error').length > 0) {
	          self.emit('error', err);
	        }
	        // Terminate
	        return;
	      }
	
	      // On first connect fail
	      if(self.s.pool.state == 'disconnected' && self.initalConnect && ['close', 'timeout', 'error', 'parseError'].indexOf(event) != -1) {
	        self.initalConnect = false;
	        return self.emit('error', new MongoError(f('failed to connect to server [%s] on first connect [%s]', self.name, err)));
	      }
	
	      // Reconnect event, emit the server
	      if(event == 'reconnect') {
	        // Reconnecting emits a server description changed event going from unknown to the
	        // current server type.
	        sdam.emitServerDescriptionChanged(self, {
	          address: self.name, arbiters: [], hosts: [], passives: [], type: sdam.getTopologyType(self)
	        });
	        return self.emit(event, self);
	      }
	
	      // Emit the event
	      self.emit(event, err);
	    }
	  }
	}
	
	/**
	 * Initiate server connect
	 * @method
	 * @param {array} [options.auth=null] Array of auth options to apply on connect
	 */
	Server.prototype.connect = function(options) {
	  var self = this;
	  options = options || {};
	
	  // Set the connections
	  if(serverAccounting) servers[this.id] = this;
	
	  // Do not allow connect to be called on anything that's not disconnected
	  if(self.s.pool && !self.s.pool.isDisconnected() && !self.s.pool.isDestroyed()) {
	    throw MongoError.create(f('server instance in invalid state %s', self.s.pool.state));
	  }
	
	  // Create a pool
	  self.s.pool = new Pool(assign(self.s.options, options, {bson: this.s.bson}));
	
	  // Set up listeners
	  self.s.pool.on('close', eventHandler(self, 'close'));
	  self.s.pool.on('error', eventHandler(self, 'error'));
	  self.s.pool.on('timeout', eventHandler(self, 'timeout'));
	  self.s.pool.on('parseError', eventHandler(self, 'parseError'));
	  self.s.pool.on('connect', eventHandler(self, 'connect'));
	  self.s.pool.on('reconnect', eventHandler(self, 'reconnect'));
	  self.s.pool.on('reconnectFailed', eventHandler(self, 'reconnectFailed'));
	
	  // Emit toplogy opening event if not in topology
	  if(!self.s.inTopology) {
	    this.emit('topologyOpening', { topologyId: self.id });
	  }
	
	  // Emit opening server event
	  self.emit('serverOpening', {
	    topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.id,
	    address: self.name
	  });
	
	  // Connect with optional auth settings
	  if(options.auth) {
	    self.s.pool.connect.apply(self.s.pool, options.auth);
	  } else {
	    self.s.pool.connect();
	  }
	}
	
	/**
	 * Get the server description
	 * @method
	 * @return {object}
	*/
	Server.prototype.getDescription = function() {
	  var ismaster = this.ismaster || {};
	  var description = {
	    type: sdam.getTopologyType(this),
	    address: this.name,
	  };
	
	  // Add fields if available
	  if(ismaster.hosts) description.hosts = ismaster.hosts;
	  if(ismaster.arbiters) description.arbiters = ismaster.arbiters;
	  if(ismaster.passives) description.passives = ismaster.passives;
	  if(ismaster.setName) description.setName = ismaster.setName;
	  return description;
	}
	
	/**
	 * Returns the last known ismaster document for this server
	 * @method
	 * @return {object}
	 */
	Server.prototype.lastIsMaster = function() {
	  return this.ismaster;
	}
	
	/**
	 * Unref all connections belong to this server
	 * @method
	 */
	Server.prototype.unref = function() {
	  this.s.pool.unref();
	}
	
	/**
	 * Figure out if the server is connected
	 * @method
	 * @return {boolean}
	 */
	Server.prototype.isConnected = function() {
	  if(!this.s.pool) return false;
	  return this.s.pool.isConnected();
	}
	
	/**
	 * Figure out if the server instance was destroyed by calling destroy
	 * @method
	 * @return {boolean}
	 */
	Server.prototype.isDestroyed = function() {
	  if(!this.s.pool) return false;
	  return this.s.pool.isDestroyed();
	}
	
	function basicWriteValidations(self) {
	  if(!self.s.pool) return MongoError.create('server instance is not connected');
	  if(self.s.pool.isDestroyed()) return MongoError.create('server instance pool was destroyed');
	}
	
	function basicReadValidations(self, options) {
	  basicWriteValidations(self, options);
	
	  if(options.readPreference && !(options.readPreference instanceof ReadPreference)) {
	    throw new Error("readPreference must be an instance of ReadPreference");
	  }
	}
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {object} cmd The command hash
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.checkKeys=false] Specify if the bson parser should validate keys.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.
	 * @param {opResultCallback} callback A callback function
	 */
	Server.prototype.command = function(ns, cmd, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {}, options = options || {};
	  var result = basicReadValidations(self, options);
	  if(result) return callback(result);
	
	  // Clone the options
	  options = assign({}, options, { wireProtocolCommand: false });
	
	  // Debug log
	  if(self.s.logger.isDebug()) self.s.logger.debug(f('executing command [%s] against %s', JSON.stringify({
	    ns: ns, cmd: cmd, options: debugOptions(debugFields, options)
	  }), self.name));
	
	  // If we are not connected or have a disconnectHandler specified
	  if(disconnectHandler(self, 'command', ns, cmd, options, callback)) return;
	
	  // Check if we have collation support
	  if(this.ismaster && this.ismaster.maxWireVersion < 5 && cmd.collation) {
	    return callback(new MongoError(f('server %s does not support collation', this.name)));
	  }
	
	  // Query options
	  var queryOptions = {
	    numberToSkip: 0,
	    numberToReturn: -1,
	    checkKeys: typeof options.checkKeys == 'boolean' ? options.checkKeys: false,
	    serializeFunctions: typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false,
	    ignoreUndefined: typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false
	  };
	
	  // Are we executing against a specific topology
	  var topology = options.topology || {};
	  // Create the query object
	  var query = self.wireProtocolHandler.command(self.s.bson, ns, cmd, {}, topology, options);
	  // Set slave OK of the query
	  query.slaveOk = options.readPreference ? options.readPreference.slaveOk() : false;
	
	  // Write options
	  var writeOptions = {
	    raw: typeof options.raw == 'boolean' ? options.raw : false,
	    promoteLongs: typeof options.promoteLongs == 'boolean' ? options.promoteLongs : true,
	    promoteValues: typeof options.promoteValues == 'boolean' ? options.promoteValues : true,
	    promoteBuffers: typeof options.promoteBuffers == 'boolean' ? options.promoteBuffers : false,
	    command: true,
	    monitoring: typeof options.monitoring == 'boolean' ? options.monitoring : false,
	    fullResult: typeof options.fullResult == 'boolean' ? options.fullResult : false,
	    requestId: query.requestId,
	    socketTimeout: typeof options.socketTimeout == 'number' ? options.socketTimeout : null,
	  };
	
	  // Write the operation to the pool
	  self.s.pool.write(query, writeOptions, callback);
	}
	
	/**
	 * Insert one or more documents
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of documents to insert
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Server.prototype.insert = function(ns, ops, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {}, options = options || {};
	  var result = basicWriteValidations(self, options);
	  if(result) return callback(result);
	
	  // If we are not connected or have a disconnectHandler specified
	  if(disconnectHandler(self, 'insert', ns, ops, options, callback)) return;
	
	  // Setup the docs as an array
	  ops = Array.isArray(ops) ? ops : [ops];
	
	  // Execute write
	  return self.wireProtocolHandler.insert(self.s.pool, self.ismaster, ns, self.s.bson, ops, options, callback);
	}
	
	/**
	 * Perform one or more update operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of updates
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Server.prototype.update = function(ns, ops, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {}, options = options || {};
	  var result = basicWriteValidations(self, options);
	  if(result) return callback(result);
	
	  // If we are not connected or have a disconnectHandler specified
	  if(disconnectHandler(self, 'update', ns, ops, options, callback)) return;
	
	  // Check if we have collation support
	  if(this.ismaster && this.ismaster.maxWireVersion < 5 && options.collation) {
	    return callback(new MongoError(f('server %s does not support collation', this.name)));
	  }
	
	  // Setup the docs as an array
	  ops = Array.isArray(ops) ? ops : [ops];
	  // Execute write
	  return self.wireProtocolHandler.update(self.s.pool, self.ismaster, ns, self.s.bson, ops, options, callback);
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of removes
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Server.prototype.remove = function(ns, ops, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {}, options = options || {};
	  var result = basicWriteValidations(self, options);
	  if(result) return callback(result);
	
	  // If we are not connected or have a disconnectHandler specified
	  if(disconnectHandler(self, 'remove', ns, ops, options, callback)) return;
	
	  // Check if we have collation support
	  if(this.ismaster && this.ismaster.maxWireVersion < 5 && options.collation) {
	    return callback(new MongoError(f('server %s does not support collation', this.name)));
	  }
	
	  // Setup the docs as an array
	  ops = Array.isArray(ops) ? ops : [ops];
	  // Execute write
	  return self.wireProtocolHandler.remove(self.s.pool, self.ismaster, ns, self.s.bson, ops, options, callback);
	}
	
	/**
	 * Get a new cursor
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {{object}|{Long}} cmd Can be either a command returning a cursor or a cursorId
	 * @param {object} [options.batchSize=0] Batchsize for the operation
	 * @param {array} [options.documents=[]] Initial documents list for cursor
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Server.prototype.cursor = function(ns, cmd, cursorOptions) {
	  var s = this.s;
	  cursorOptions = cursorOptions || {};
	  // Set up final cursor type
	  var FinalCursor = cursorOptions.cursorFactory || s.Cursor;
	  // Return the cursor
	  return new FinalCursor(s.bson, ns, cmd, cursorOptions, this, s.options);
	}
	
	/**
	 * Logout from a database
	 * @method
	 * @param {string} db The db we are logging out from
	 * @param {authResultCallback} callback A callback function
	 */
	Server.prototype.logout = function(dbName, callback) {
	  this.s.pool.logout(dbName, callback);
	}
	
	/**
	 * Authenticate using a specified mechanism
	 * @method
	 * @param {string} mechanism The Auth mechanism we are invoking
	 * @param {string} db The db we are invoking the mechanism against
	 * @param {...object} param Parameters for the specific mechanism
	 * @param {authResultCallback} callback A callback function
	 */
	Server.prototype.auth = function(mechanism, db) {
	  var self = this;
	
	  // If we have the default mechanism we pick mechanism based on the wire
	  // protocol max version. If it's >= 3 then scram-sha1 otherwise mongodb-cr
	  if(mechanism == 'default' && self.ismaster && self.ismaster.maxWireVersion >= 3) {
	    mechanism = 'scram-sha-1';
	  } else if(mechanism == 'default') {
	    mechanism = 'mongocr';
	  }
	
	  // Slice all the arguments off
	  var args = Array.prototype.slice.call(arguments, 0);
	  // Set the mechanism
	  args[0] = mechanism;
	  // Get the callback
	  var callback = args[args.length - 1];
	
	  // If we are not connected or have a disconnectHandler specified
	  if(disconnectHandler(self, 'auth', db, args, {}, callback)) {
	    return;
	  }
	
	  // Do not authenticate if we are an arbiter
	  if(this.lastIsMaster() && this.lastIsMaster().arbiterOnly) {
	    return callback(null, true);
	  }
	
	  // Apply the arguments to the pool
	  self.s.pool.auth.apply(self.s.pool, args);
	}
	
	/**
	 * Compare two server instances
	 * @method
	 * @param {Server} server Server to compare equality against
	 * @return {boolean}
	 */
	Server.prototype.equals = function(server) {
	  if(typeof server == 'string') return this.name.toLowerCase() == server.toLowerCase();
	  if(server.name) return this.name.toLowerCase() == server.name.toLowerCase();
	  return false;
	}
	
	/**
	 * All raw connections
	 * @method
	 * @return {Connection[]}
	 */
	Server.prototype.connections = function() {
	  return this.s.pool.allConnections();
	}
	
	/**
	 * Get server
	 * @method
	 * @return {Server}
	 */
	Server.prototype.getServer = function() {
	  return this;
	}
	
	/**
	 * Get connection
	 * @method
	 * @return {Connection}
	 */
	Server.prototype.getConnection = function() {
	  return this.s.pool.get();
	}
	
	var listeners = ['close', 'error', 'timeout', 'parseError', 'connect'];
	
	/**
	 * Destroy the server connection
	 * @method
	 * @param {boolean} [options.emitClose=false] Emit close event on destroy
	 * @param {boolean} [options.emitDestroy=false] Emit destroy event on destroy
	 * @param {boolean} [options.force=false] Force destroy the pool
	 */
	Server.prototype.destroy = function(options) {
	  options = options || {};
	  var self = this;
	
	  // Set the connections
	  if(serverAccounting) delete servers[this.id];
	
	  // Destroy the monitoring process if any
	  if(this.monitoringProcessId) {
	    clearTimeout(this.monitoringProcessId);
	  }
	
	  // No pool, return
	  if(!self.s.pool) return;
	
	  // Emit close event
	  if(options.emitClose) {
	    self.emit('close', self);
	  }
	
	  // Emit destroy event
	  if(options.emitDestroy) {
	    self.emit('destroy', self);
	  }
	
	  // Remove all listeners
	  listeners.forEach(function(event) {
	    self.s.pool.removeAllListeners(event);
	  });
	
	  // Emit opening server event
	  if(self.listeners('serverClosed').length > 0) self.emit('serverClosed', {
	    topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.id, address: self.name
	  });
	
	  // Emit toplogy opening event if not in topology
	  if(self.listeners('topologyClosed').length > 0 && !self.s.inTopology) {
	    self.emit('topologyClosed', { topologyId: self.id });
	  }
	
	  if(self.s.logger.isDebug()) {
	    self.s.logger.debug(f('destroy called on server %s', self.name));
	  }
	
	  // Destroy the pool
	  this.s.pool.destroy(options.force);
	}
	
	/**
	 * A server connect event, used to verify that the connection is up and running
	 *
	 * @event Server#connect
	 * @type {Server}
	 */
	
	/**
	 * A server reconnect event, used to verify that the server topology has reconnected
	 *
	 * @event Server#reconnect
	 * @type {Server}
	 */
	
	/**
	 * A server opening SDAM monitoring event
	 *
	 * @event Server#serverOpening
	 * @type {object}
	 */
	
	/**
	 * A server closed SDAM monitoring event
	 *
	 * @event Server#serverClosed
	 * @type {object}
	 */
	
	/**
	 * A server description SDAM change monitoring event
	 *
	 * @event Server#serverDescriptionChanged
	 * @type {object}
	 */
	
	/**
	 * A topology open SDAM event
	 *
	 * @event Server#topologyOpening
	 * @type {object}
	 */
	
	/**
	 * A topology closed SDAM event
	 *
	 * @event Server#topologyClosed
	 * @type {object}
	 */
	
	/**
	 * A topology structure SDAM change event
	 *
	 * @event Server#topologyDescriptionChanged
	 * @type {object}
	 */
	
	/**
	 * Server reconnect failed
	 *
	 * @event Server#reconnectFailed
	 * @type {Error}
	 */
	
	/**
	 * Server connection pool closed
	 *
	 * @event Server#close
	 * @type {object}
	 */
	
	/**
	 * Server connection pool caused an error
	 *
	 * @event Server#error
	 * @type {Error}
	 */
	
	/**
	 * Server destroyed was called
	 *
	 * @event Server#destroy
	 * @type {Server}
	 */
	
	module.exports = Server;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var MongoError = __webpack_require__(7);
	
	// Wire command operation ids
	var OP_UPDATE = 2001;
	var OP_INSERT = 2002;
	var OP_DELETE = 2006;
	
	var Insert = function(requestId, ismaster, bson, ns, documents, options) {
	  // Basic options needed to be passed in
	  if(ns == null) throw new MongoError("ns must be specified for query");
	  if(!Array.isArray(documents) || documents.length == 0) throw new MongoError("documents array must contain at least one document to insert");
	
	  // Validate that we are not passing 0x00 in the collection name
	  if(!!~ns.indexOf("\x00")) {
	    throw new MongoError("namespace cannot contain a null character");
	  }
	
	  // Set internal
	  this.requestId = requestId;
	  this.bson = bson;
	  this.ns = ns;
	  this.documents = documents;
	  this.ismaster = ismaster;
	
	  // Ensure empty options
	  options = options || {};
	
	  // Unpack options
	  this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
	  this.ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
	  this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : true;
	  this.continueOnError = typeof options.continueOnError == 'boolean' ? options.continueOnError : false;
	  // Set flags
	  this.flags = this.continueOnError ? 1 : 0;
	}
	
	// To Binary
	Insert.prototype.toBin = function() {
	  // Contains all the buffers to be written
	  var buffers = [];
	
	  // Header buffer
	  var header = new Buffer(
	    4 * 4 // Header
	    + 4   // Flags
	    + Buffer.byteLength(this.ns) + 1 // namespace
	  );
	
	  // Add header to buffers
	  buffers.push(header);
	
	  // Total length of the message
	  var totalLength = header.length;
	
	  // Serialize all the documents
	  for(var i = 0; i < this.documents.length; i++) {
	    var buffer = this.bson.serialize(this.documents[i], {
	      checkKeys: this.checkKeys,
	      serializeFunctions: this.serializeFunctions,
	      ignoreUndefined: this.ignoreUndefined,
	    });
	
	    // Document is larger than maxBsonObjectSize, terminate serialization
	    if(buffer.length > this.ismaster.maxBsonObjectSize) {
	      throw new MongoError("Document exceeds maximum allowed bson size of " + this.ismaster.maxBsonObjectSize + " bytes");
	    }
	
	    // Add to total length of wire protocol message
	    totalLength = totalLength + buffer.length;
	    // Add to buffer
	    buffers.push(buffer);
	  }
	
	  // Command is larger than maxMessageSizeBytes terminate serialization
	  if(totalLength > this.ismaster.maxMessageSizeBytes) {
	    throw new MongoError("Command exceeds maximum message size of " + this.ismaster.maxMessageSizeBytes + " bytes");
	  }
	
	  // Add all the metadata
	  var index = 0;
	
	  // Write header length
	  header[index + 3] = (totalLength >> 24) & 0xff;
	  header[index + 2] = (totalLength >> 16) & 0xff;
	  header[index + 1] = (totalLength >> 8) & 0xff;
	  header[index] = (totalLength) & 0xff;
	  index = index + 4;
	
	  // Write header requestId
	  header[index + 3] = (this.requestId >> 24) & 0xff;
	  header[index + 2] = (this.requestId >> 16) & 0xff;
	  header[index + 1] = (this.requestId >> 8) & 0xff;
	  header[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // No flags
	  header[index + 3] = (0 >> 24) & 0xff;
	  header[index + 2] = (0 >> 16) & 0xff;
	  header[index + 1] = (0 >> 8) & 0xff;
	  header[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Operation
	  header[index + 3] = (OP_INSERT >> 24) & 0xff;
	  header[index + 2] = (OP_INSERT >> 16) & 0xff;
	  header[index + 1] = (OP_INSERT >> 8) & 0xff;
	  header[index] = (OP_INSERT) & 0xff;
	  index = index + 4;
	
	  // Flags
	  header[index + 3] = (this.flags >> 24) & 0xff;
	  header[index + 2] = (this.flags >> 16) & 0xff;
	  header[index + 1] = (this.flags >> 8) & 0xff;
	  header[index] = (this.flags) & 0xff;
	  index = index + 4;
	
	  // Write collection name
	  index = index + header.write(this.ns, index, 'utf8') + 1;
	  header[index - 1] = 0;
	
	  // Return the buffers
	  return buffers;
	}
	
	var Update = function(requestId, ismaster, bson, ns, update, options) {
	  // Basic options needed to be passed in
	  if(ns == null) throw new MongoError("ns must be specified for query");
	
	  // Ensure empty options
	  options = options || {};
	
	  // Set internal
	  this.requestId = requestId;
	  this.bson = bson;
	  this.ns = ns;
	  this.ismaster = ismaster;
	
	  // Unpack options
	  this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
	  this.ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
	  this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : false;
	
	  // Unpack the update document
	  this.upsert = typeof update[0].upsert == 'boolean' ? update[0].upsert : false;
	  this.multi = typeof update[0].multi == 'boolean' ? update[0].multi : false;
	  this.q = update[0].q;
	  this.u = update[0].u;
	
	  // Create flag value
	  this.flags = this.upsert ? 1 : 0;
	  this.flags = this.multi ? this.flags | 2 : this.flags;
	}
	
	// To Binary
	Update.prototype.toBin = function() {
	  // Contains all the buffers to be written
	  var buffers = [];
	
	  // Header buffer
	  var header = new Buffer(
	    4 * 4 // Header
	    + 4   // ZERO
	    + Buffer.byteLength(this.ns) + 1 // namespace
	    + 4   // Flags
	  );
	
	  // Add header to buffers
	  buffers.push(header);
	
	  // Total length of the message
	  var totalLength = header.length;
	
	  // Serialize the selector
	  var selector = this.bson.serialize(this.q, {
	    checkKeys: this.checkKeys,
	    serializeFunctions: this.serializeFunctions,
	    ignoreUndefined: this.ignoreUndefined,
	  });
	  buffers.push(selector);
	  totalLength = totalLength + selector.length;
	
	  // Serialize the update
	  var update = this.bson.serialize(this.u, {
	    checkKeys: this.checkKeys,
	    serializeFunctions: this.serializeFunctions,
	    ignoreUndefined: this.ignoreUndefined,
	  });
	  buffers.push(update);
	  totalLength = totalLength + update.length;
	
	  // Index in header buffer
	  var index = 0;
	
	  // Write header length
	  header[index + 3] = (totalLength >> 24) & 0xff;
	  header[index + 2] = (totalLength >> 16) & 0xff;
	  header[index + 1] = (totalLength >> 8) & 0xff;
	  header[index] = (totalLength) & 0xff;
	  index = index + 4;
	
	  // Write header requestId
	  header[index + 3] = (this.requestId >> 24) & 0xff;
	  header[index + 2] = (this.requestId >> 16) & 0xff;
	  header[index + 1] = (this.requestId >> 8) & 0xff;
	  header[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // No flags
	  header[index + 3] = (0 >> 24) & 0xff;
	  header[index + 2] = (0 >> 16) & 0xff;
	  header[index + 1] = (0 >> 8) & 0xff;
	  header[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Operation
	  header[index + 3] = (OP_UPDATE >> 24) & 0xff;
	  header[index + 2] = (OP_UPDATE >> 16) & 0xff;
	  header[index + 1] = (OP_UPDATE >> 8) & 0xff;
	  header[index] = (OP_UPDATE) & 0xff;
	  index = index + 4;
	
	  // Write ZERO
	  header[index + 3] = (0 >> 24) & 0xff;
	  header[index + 2] = (0 >> 16) & 0xff;
	  header[index + 1] = (0 >> 8) & 0xff;
	  header[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Write collection name
	  index = index + header.write(this.ns, index, 'utf8') + 1;
	  header[index - 1] = 0;
	
	  // Flags
	  header[index + 3] = (this.flags >> 24) & 0xff;
	  header[index + 2] = (this.flags >> 16) & 0xff;
	  header[index + 1] = (this.flags >> 8) & 0xff;
	  header[index] = (this.flags) & 0xff;
	  index = index + 4;
	
	  // Return the buffers
	  return buffers;
	}
	
	var Remove = function(requestId, ismaster, bson, ns, remove, options) {
	  // Basic options needed to be passed in
	  if(ns == null) throw new MongoError("ns must be specified for query");
	
	  // Ensure empty options
	  options = options || {};
	
	  // Set internal
	  this.requestId = requestId;
	  this.bson = bson;
	  this.ns = ns;
	  this.ismaster = ismaster;
	
	  // Unpack options
	  this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;
	  this.ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;
	  this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : false;
	
	  // Unpack the update document
	  this.limit = typeof remove[0].limit == 'number' ? remove[0].limit : 1;
	  this.q = remove[0].q;
	
	  // Create flag value
	  this.flags = this.limit == 1 ? 1 : 0;
	}
	
	// To Binary
	Remove.prototype.toBin = function() {
	  // Contains all the buffers to be written
	  var buffers = [];
	
	  // Header buffer
	  var header = new Buffer(
	    4 * 4 // Header
	    + 4   // ZERO
	    + Buffer.byteLength(this.ns) + 1 // namespace
	    + 4   // Flags
	  );
	
	  // Add header to buffers
	  buffers.push(header);
	
	  // Total length of the message
	  var totalLength = header.length;
	
	  // Serialize the selector
	  var selector = this.bson.serialize(this.q, {
	    checkKeys: this.checkKeys,
	    serializeFunctions: this.serializeFunctions,
	    ignoreUndefined: this.ignoreUndefined,
	  });
	  buffers.push(selector);
	  totalLength = totalLength + selector.length;
	
	  // Index in header buffer
	  var index = 0;
	
	  // Write header length
	  header[index + 3] = (totalLength >> 24) & 0xff;
	  header[index + 2] = (totalLength >> 16) & 0xff;
	  header[index + 1] = (totalLength >> 8) & 0xff;
	  header[index] = (totalLength) & 0xff;
	  index = index + 4;
	
	  // Write header requestId
	  header[index + 3] = (this.requestId >> 24) & 0xff;
	  header[index + 2] = (this.requestId >> 16) & 0xff;
	  header[index + 1] = (this.requestId >> 8) & 0xff;
	  header[index] = (this.requestId) & 0xff;
	  index = index + 4;
	
	  // No flags
	  header[index + 3] = (0 >> 24) & 0xff;
	  header[index + 2] = (0 >> 16) & 0xff;
	  header[index + 1] = (0 >> 8) & 0xff;
	  header[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Operation
	  header[index + 3] = (OP_DELETE >> 24) & 0xff;
	  header[index + 2] = (OP_DELETE >> 16) & 0xff;
	  header[index + 1] = (OP_DELETE >> 8) & 0xff;
	  header[index] = (OP_DELETE) & 0xff;
	  index = index + 4;
	
	  // Write ZERO
	  header[index + 3] = (0 >> 24) & 0xff;
	  header[index + 2] = (0 >> 16) & 0xff;
	  header[index + 1] = (0 >> 8) & 0xff;
	  header[index] = (0) & 0xff;
	  index = index + 4;
	
	  // Write collection name
	  index = index + header.write(this.ns, index, 'utf8') + 1;
	  header[index - 1] = 0;
	
	  // Write ZERO
	  header[index + 3] = (this.flags >> 24) & 0xff;
	  header[index + 2] = (this.flags >> 16) & 0xff;
	  header[index + 1] = (this.flags >> 8) & 0xff;
	  header[index] = (this.flags) & 0xff;
	  index = index + 4;
	
	  // Return the buffers
	  return buffers;
	}
	
	module.exports = {
	    Insert: Insert
	  , Update: Update
	  , Remove: Remove
	}


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict"
	
	var ReadPreference = __webpack_require__(43),
	  MongoError = __webpack_require__(7);
	
	var getReadPreference = function(cmd, options) {
	  // Default to command version of the readPreference
	  var readPreference = cmd.readPreference || new ReadPreference('primary');
	  // If we have an option readPreference override the command one
	  if(options.readPreference) {
	    readPreference = options.readPreference;
	  }
	
	  if(typeof readPreference == 'string') {
	    readPreference = new ReadPreference(readPreference);
	  }
	
	  if(!(readPreference instanceof ReadPreference)) {
	    throw new MongoError('readPreference must be a ReadPreference instance');
	  }
	
	  return readPreference;
	}
	
	module.exports = {
	  getReadPreference: getReadPreference
	}


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	var shallowClone = __webpack_require__(2).shallowClone
	  , handleCallback = __webpack_require__(2).handleCallback
	  , MongoError = __webpack_require__(3).MongoError;
	
	var authenticate = function(self, username, password, options, callback) {
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	
	  // the default db to authenticate against is 'self'
	  // if authententicate is called from a retry context, it may be another one, like admin
	  var authdb = options.dbName ? options.dbName : self.databaseName;
	  authdb = self.authSource ? self.authSource : authdb;
	  authdb = options.authdb ? options.authdb : authdb;
	  authdb = options.authSource ? options.authSource : authdb;
	
	  // Callback
	  var _callback = function(err, result) {
	    if(self.listeners('authenticated').length > 0) {
	      self.emit('authenticated', err, result);
	    }
	
	    // Return to caller
	    handleCallback(callback, err, result);
	  }
	
	  // authMechanism
	  var authMechanism = options.authMechanism || '';
	  authMechanism = authMechanism.toUpperCase();
	
	  // If classic auth delegate to auth command
	  if(authMechanism == 'MONGODB-CR') {
	    self.s.topology.auth('mongocr', authdb, username, password, function(err) {
	      if(err) return handleCallback(callback, err, false);
	      _callback(null, true);
	    });
	  } else if(authMechanism == 'PLAIN') {
	    self.s.topology.auth('plain', authdb, username, password, function(err) {
	      if(err) return handleCallback(callback, err, false);
	      _callback(null, true);
	    });
	  } else if(authMechanism == 'MONGODB-X509') {
	    self.s.topology.auth('x509', authdb, username, password, function(err) {
	      if(err) return handleCallback(callback, err, false);
	      _callback(null, true);
	    });
	  } else if(authMechanism == 'SCRAM-SHA-1') {
	    self.s.topology.auth('scram-sha-1', authdb, username, password, function(err) {
	      if(err) return handleCallback(callback, err, false);
	      _callback(null, true);
	    });
	  } else if(authMechanism == 'GSSAPI') {
	    if(process.platform == 'win32') {
	      self.s.topology.auth('sspi', authdb, username, password, options, function(err) {
	        if(err) return handleCallback(callback, err, false);
	        _callback(null, true);
	      });
	    } else {
	      self.s.topology.auth('gssapi', authdb, username, password, options, function(err) {
	        if(err) return handleCallback(callback, err, false);
	        _callback(null, true);
	      });
	    }
	  } else if(authMechanism == 'DEFAULT') {
	    self.s.topology.auth('default', authdb, username, password, function(err) {
	      if(err) return handleCallback(callback, err, false);
	      _callback(null, true);
	    });
	  } else {
	    handleCallback(callback, MongoError.create({message: f("authentication mechanism %s not supported", options.authMechanism), driver:true}));
	  }
	}
	
	module.exports = function(self, username, password, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  // Shallow copy the options
	  options = shallowClone(options);
	
	  // Set default mechanism
	  if(!options.authMechanism) {
	    options.authMechanism = 'DEFAULT';
	  } else if(options.authMechanism != 'GSSAPI'
	    && options.authMechanism != 'DEFAULT'
	    && options.authMechanism != 'MONGODB-CR'
	    && options.authMechanism != 'MONGODB-X509'
	    && options.authMechanism != 'SCRAM-SHA-1'
	    && options.authMechanism != 'PLAIN') {
	      return handleCallback(callback, MongoError.create({message: "only DEFAULT, GSSAPI, PLAIN, MONGODB-X509, SCRAM-SHA-1 or MONGODB-CR is supported by authMechanism", driver:true}));
	  }
	
	  // If we have a callback fallback
	  if(typeof callback == 'function') return authenticate(self, username, password, options, function(err, r) {
	    // Support failed auth method
	    if(err && err.message && err.message.indexOf('saslStart') != -1) err.code = 59;
	    // Reject error
	    if(err) return callback(err, r);
	    callback(null, r);
	  });
	
	  // Return a promise
	  return new self.s.promiseLibrary(function(resolve, reject) {
	    authenticate(self, username, password, options, function(err, r) {
	      // Support failed auth method
	      if(err && err.message && err.message.indexOf('saslStart') != -1) err.code = 59;
	      // Reject error
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var common = __webpack_require__(122)
		, utils = __webpack_require__(2)
	  , toError = __webpack_require__(2).toError
		, handleCallback = __webpack_require__(2).handleCallback
		, shallowClone = utils.shallowClone
	  , BulkWriteResult = common.BulkWriteResult
	  , ObjectID = __webpack_require__(3).BSON.ObjectID
	  , Define = __webpack_require__(13)
		, BSON = __webpack_require__(3).BSON
	  , Batch = common.Batch
	  , mergeBatchResults = common.mergeBatchResults;
	
	var bson = new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128,
		BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey,
		BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]);
	
	/**
	 * Create a FindOperatorsOrdered instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @return {FindOperatorsOrdered} a FindOperatorsOrdered instance.
	 */
	var FindOperatorsOrdered = function(self) {
	  this.s = self.s;
	}
	
	/**
	 * Add a single update document to the bulk operation
	 *
	 * @method
	 * @param {object} doc update operations
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	FindOperatorsOrdered.prototype.update = function(updateDocument) {
	  // Perform upsert
	  var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;
	
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , u: updateDocument
	    , multi: true
	    , upsert: upsert
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the update document to the list
	  return addToOperationsList(this, common.UPDATE, document);
	}
	
	/**
	 * Add a single update one document to the bulk operation
	 *
	 * @method
	 * @param {object} doc update operations
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	FindOperatorsOrdered.prototype.updateOne = function(updateDocument) {
	  // Perform upsert
	  var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;
	
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , u: updateDocument
	    , multi: false
	    , upsert: upsert
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the update document to the list
	  return addToOperationsList(this, common.UPDATE, document);
	}
	
	/**
	 * Add a replace one operation to the bulk operation
	 *
	 * @method
	 * @param {object} doc the new document to replace the existing one with
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	FindOperatorsOrdered.prototype.replaceOne = function(updateDocument) {
	  this.updateOne(updateDocument);
	}
	
	/**
	 * Upsert modifier for update bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {FindOperatorsOrdered}
	 */
	FindOperatorsOrdered.prototype.upsert = function() {
	  this.s.currentOp.upsert = true;
	  return this;
	}
	
	/**
	 * Add a remove one operation to the bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	FindOperatorsOrdered.prototype.deleteOne = function() {
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , limit: 1
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the remove document to the list
	  return addToOperationsList(this, common.REMOVE, document);
	}
	
	// Backward compatibility
	FindOperatorsOrdered.prototype.removeOne = FindOperatorsOrdered.prototype.deleteOne;
	
	/**
	 * Add a remove operation to the bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	FindOperatorsOrdered.prototype.delete = function() {
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , limit: 0
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the remove document to the list
	  return addToOperationsList(this, common.REMOVE, document);
	}
	
	// Backward compatibility
	FindOperatorsOrdered.prototype.remove = FindOperatorsOrdered.prototype.delete;
	
	// Add to internal list of documents
	var addToOperationsList = function(_self, docType, document) {
	  // Get the bsonSize
	  var bsonSize = bson.calculateObjectSize(document, {
			checkKeys: false,
		});
	
	  // Throw error if the doc is bigger than the max BSON size
	  if(bsonSize >= _self.s.maxBatchSizeBytes) {
			throw toError("document is larger than the maximum size " + _self.s.maxBatchSizeBytes);
		}
	
	  // Create a new batch object if we don't have a current one
	  if(_self.s.currentBatch == null) _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);
	
	  // Check if we need to create a new batch
	  if(((_self.s.currentBatchSize + 1) >= _self.s.maxWriteBatchSize)
	    || ((_self.s.currentBatchSizeBytes +  _self.s.currentBatchSizeBytes) >= _self.s.maxBatchSizeBytes)
	    || (_self.s.currentBatch.batchType != docType)) {
	    // Save the batch to the execution stack
	    _self.s.batches.push(_self.s.currentBatch);
	
	    // Create a new batch
	    _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);
	
	    // Reset the current size trackers
	    _self.s.currentBatchSize = 0;
	    _self.s.currentBatchSizeBytes = 0;
	  } else {
	    // Update current batch size
	    _self.s.currentBatchSize = _self.s.currentBatchSize + 1;
	    _self.s.currentBatchSizeBytes = _self.s.currentBatchSizeBytes + bsonSize;
	  }
	
	  if(docType == common.INSERT) {
	    _self.s.bulkResult.insertedIds.push({index: _self.s.currentIndex, _id: document._id});
	  }
	
	  // We have an array of documents
	  if(Array.isArray(document)) {
	    throw toError("operation passed in cannot be an Array");
	  } else {
	    _self.s.currentBatch.originalIndexes.push(_self.s.currentIndex);
	    _self.s.currentBatch.operations.push(document)
			_self.s.currentBatchSizeBytes = _self.s.currentBatchSizeBytes + bsonSize;
	    _self.s.currentIndex = _self.s.currentIndex + 1;
	  }
	
	  // Return self
	  return _self;
	}
	
	/**
	 * Create a new OrderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @property {number} length Get the number of operations in the bulk.
	 * @return {OrderedBulkOperation} a OrderedBulkOperation instance.
	 */
	function OrderedBulkOperation(topology, collection, options) {
		options = options == null ? {} : options;
		// TODO Bring from driver information in isMaster
		var executed = false;
	
		// Current item
		var currentOp = null;
	
		// Handle to the bson serializer, used to calculate running sizes
		var bson = topology.bson;
	
		// Namespace for the operation
	  var namespace = collection.collectionName;
	
	  // Set max byte size
		var maxBatchSizeBytes = topology.isMasterDoc && topology.isMasterDoc.maxBsonObjectSize
	    ? topology.isMasterDoc.maxBsonObjectSize : (1024*1025*16);
		var maxWriteBatchSize = topology.isMasterDoc && topology.isMasterDoc.maxWriteBatchSize
	    ? topology.isMasterDoc.maxWriteBatchSize : 1000;
	
	  // Get the write concern
	  var writeConcern = common.writeConcern(shallowClone(options), collection, options);
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(10).Promise;
	  }
	
	  // Final results
	  var bulkResult = {
	      ok: 1
	    , writeErrors: []
	    , writeConcernErrors: []
	    , insertedIds: []
	    , nInserted: 0
	    , nUpserted: 0
	    , nMatched: 0
	    , nModified: 0
	    , nRemoved: 0
	    , upserted: []
	  };
	
	  // Internal state
	  this.s = {
	    // Final result
	      bulkResult: bulkResult
	    // Current batch state
	    , currentBatch: null
	    , currentIndex: 0
	    , currentBatchSize: 0
	    , currentBatchSizeBytes: 0
	    , batches: []
	    // Write concern
	    , writeConcern: writeConcern
	    // Max batch size options
	    , maxBatchSizeBytes: maxBatchSizeBytes
	    , maxWriteBatchSize: maxWriteBatchSize
	    // Namespace
	    , namespace: namespace
	    // BSON
	    , bson: bson
	    // Topology
	    , topology: topology
	    // Options
	    , options: options
	    // Current operation
	    , currentOp: currentOp
	    // Executed
	    , executed: executed
	    // Collection
	    , collection: collection
	    // Promise Library
	    , promiseLibrary: promiseLibrary
			// Fundamental error
			, err: null
	    // Bypass validation
	    , bypassDocumentValidation: typeof options.bypassDocumentValidation == 'boolean' ? options.bypassDocumentValidation : false
	  }
	}
	
	var define = OrderedBulkOperation.define = new Define('OrderedBulkOperation', OrderedBulkOperation, false);
	
	OrderedBulkOperation.prototype.raw = function(op) {
	  var key = Object.keys(op)[0];
	
	  // Set up the force server object id
	  var forceServerObjectId = typeof this.s.options.forceServerObjectId == 'boolean'
	    ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId;
	
	  // Update operations
	  if((op.updateOne && op.updateOne.q)
	    || (op.updateMany && op.updateMany.q)
	    || (op.replaceOne && op.replaceOne.q)) {
	    op[key].multi = op.updateOne || op.replaceOne ? false : true;
	    return addToOperationsList(this, common.UPDATE, op[key]);
	  }
	
	  // Crud spec update format
	  if(op.updateOne || op.updateMany || op.replaceOne) {
	    var multi = op.updateOne || op.replaceOne ? false : true;
	    var operation = {q: op[key].filter, u: op[key].update || op[key].replacement, multi: multi}
	    operation.upsert = op[key].upsert ? true: false;
			if(op.collation) operation.collation = op.collation;
	    return addToOperationsList(this, common.UPDATE, operation);
	  }
	
	  // Remove operations
	  if(op.removeOne || op.removeMany || (op.deleteOne && op.deleteOne.q) || op.deleteMany && op.deleteMany.q) {
	    op[key].limit = op.removeOne ? 1 : 0;
	    return addToOperationsList(this, common.REMOVE, op[key]);
	  }
	
	  // Crud spec delete operations, less efficient
	  if(op.deleteOne || op.deleteMany) {
	    var limit = op.deleteOne ? 1 : 0;
	    operation = {q: op[key].filter, limit: limit}
			if(op.collation) operation.collation = op.collation;
	    return addToOperationsList(this, common.REMOVE, operation);
	  }
	
	  // Insert operations
	  if(op.insertOne && op.insertOne.document == null) {
	    if(forceServerObjectId !== true && op.insertOne._id == null) op.insertOne._id = new ObjectID();
	    return addToOperationsList(this, common.INSERT, op.insertOne);
	  } else if(op.insertOne && op.insertOne.document) {
	    if(forceServerObjectId !== true && op.insertOne.document._id == null) op.insertOne.document._id = new ObjectID();
	    return addToOperationsList(this, common.INSERT, op.insertOne.document);
	  }
	
	  if(op.insertMany) {
	    for(var i = 0; i < op.insertMany.length; i++) {
	      if(forceServerObjectId !== true && op.insertMany[i]._id == null) op.insertMany[i]._id = new ObjectID();
	      addToOperationsList(this, common.INSERT, op.insertMany[i]);
	    }
	
	    return;
	  }
	
	  // No valid type of operation
	  throw toError("bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany");
	}
	
	/**
	 * Add a single insert document to the bulk operation
	 *
	 * @param {object} doc the document to insert
	 * @throws {MongoError}
	 * @return {OrderedBulkOperation}
	 */
	OrderedBulkOperation.prototype.insert = function(document) {
	  if(this.s.collection.s.db.options.forceServerObjectId !== true && document._id == null) document._id = new ObjectID();
	  return addToOperationsList(this, common.INSERT, document);
	}
	
	/**
	 * Initiate a find operation for an update/updateOne/remove/removeOne/replaceOne
	 *
	 * @method
	 * @param {object} selector The selector for the bulk operation.
	 * @throws {MongoError}
	 * @return {FindOperatorsOrdered}
	 */
	OrderedBulkOperation.prototype.find = function(selector) {
	  if (!selector) {
	    throw toError("Bulk find operation must specify a selector");
	  }
	
	  // Save a current selector
	  this.s.currentOp = {
	    selector: selector
	  }
	
	  return new FindOperatorsOrdered(this);
	}
	
	Object.defineProperty(OrderedBulkOperation.prototype, 'length', {
	  enumerable: true,
	  get: function() {
	    return this.s.currentIndex;
	  }
	});
	
	//
	// Execute next write command in a chain
	var executeCommands = function(self, callback) {
	  if(self.s.batches.length == 0) {
	    return handleCallback(callback, null, new BulkWriteResult(self.s.bulkResult));
	  }
	
	  // Ordered execution of the command
	  var batch = self.s.batches.shift();
	
	  var resultHandler = function(err, result) {
			// Error is a driver related error not a bulk op error, terminate
			if(err && err.driver || err && err.message) {
				return handleCallback(callback, err);
			}
	
	    // If we have and error
	    if(err) err.ok = 0;
	    // Merge the results together
	    var mergeResult = mergeBatchResults(true, batch, self.s.bulkResult, err, result);
	    if(mergeResult != null) {
	      return handleCallback(callback, null, new BulkWriteResult(self.s.bulkResult));
	    }
	
	    // If we are ordered and have errors and they are
	    // not all replication errors terminate the operation
	    if(self.s.bulkResult.writeErrors.length > 0) {
	      return handleCallback(callback, toError(self.s.bulkResult.writeErrors[0]), new BulkWriteResult(self.s.bulkResult));
	    }
	
	    // Execute the next command in line
	    executeCommands(self, callback);
	  }
	
	  var finalOptions = {ordered: true}
	  if(self.s.writeConcern != null) {
	    finalOptions.writeConcern = self.s.writeConcern;
	  }
	
		// Set an operationIf if provided
		if(self.operationId) {
			resultHandler.operationId = self.operationId;
		}
	
		// Serialize functions
		if(self.s.options.serializeFunctions) {
			finalOptions.serializeFunctions = true
		}
	
	  // Serialize functions
	  if(self.s.options.ignoreUndefined) {
	    finalOptions.ignoreUndefined = true
	  }
	
	  // Is the bypassDocumentValidation options specific
	  if(self.s.bypassDocumentValidation == true) {
	    finalOptions.bypassDocumentValidation = true;
	  }
	
	  try {
	    if(batch.batchType == common.INSERT) {
	      self.s.topology.insert(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    } else if(batch.batchType == common.UPDATE) {
	      self.s.topology.update(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    } else if(batch.batchType == common.REMOVE) {
	      self.s.topology.remove(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    }
	  } catch(err) {
	    // Force top level error
	    err.ok = 0;
	    // Merge top level error and return
	    handleCallback(callback, null, mergeBatchResults(false, batch, self.s.bulkResult, err, null));
	  }
	}
	
	/**
	 * The callback format for results
	 * @callback OrderedBulkOperation~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {BulkWriteResult} result The bulk write result.
	 */
	
	/**
	 * Execute the ordered bulk operation
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.fsync=false] Specify a file sync write concern.
	 * @param {OrderedBulkOperation~resultCallback} [callback] The result callback
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	OrderedBulkOperation.prototype.execute = function(_writeConcern, callback) {
	  var self = this;
	  if (this.s.executed) {
	    var executedError = toError('batch cannot be re-executed');
	    return (typeof callback === 'function') ?
	      callback(executedError, null) : this.s.promiseLibrary.reject(executedError);
	  }
	
	  if (typeof _writeConcern === 'function') {
	    callback = _writeConcern;
	  } else if (_writeConcern && typeof _writeConcern === 'object') {
	    this.s.writeConcern = _writeConcern;
	  }
	
	  // If we have current batch
	  if (this.s.currentBatch) this.s.batches.push(this.s.currentBatch)
	
	  // If we have no operations in the bulk raise an error
	  if (this.s.batches.length == 0) {
	    var emptyBatchError = toError('Invalid Operation, no operations specified');
	    return (typeof callback === 'function') ?
	      callback(emptyBatchError, null) : this.s.promiseLibrary.reject(emptyBatchError);
	  }
	
	  // Execute using callback
	  if (typeof callback === 'function') {
	    return executeCommands(this, callback);
	  }
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    executeCommands(self, function(err, r) {
	      if (err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('execute', {callback: true, promise:false});
	
	/**
	 * Returns an unordered batch object
	 * @ignore
	 */
	var initializeOrderedBulkOp = function(topology, collection, options) {
		return new OrderedBulkOperation(topology, collection, options);
	}
	
	initializeOrderedBulkOp.OrderedBulkOperation = OrderedBulkOperation;
	module.exports = initializeOrderedBulkOp;
	module.exports.Bulk = OrderedBulkOperation;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var common = __webpack_require__(122)
		, utils = __webpack_require__(2)
	  , toError = __webpack_require__(2).toError
		, handleCallback = __webpack_require__(2).handleCallback
	  , shallowClone = utils.shallowClone
	  , BulkWriteResult = common.BulkWriteResult
	  , ObjectID = __webpack_require__(3).BSON.ObjectID
		, BSON = __webpack_require__(3).BSON
	  , Define = __webpack_require__(13)
	  , Batch = common.Batch
	  , mergeBatchResults = common.mergeBatchResults;
	
	var bson = new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128,
		BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey,
		BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]);
	
	/**
	 * Create a FindOperatorsUnordered instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @property {number} length Get the number of operations in the bulk.
	 * @return {FindOperatorsUnordered} a FindOperatorsUnordered instance.
	 */
	var FindOperatorsUnordered = function(self) {
	  this.s = self.s;
	}
	
	/**
	 * Add a single update document to the bulk operation
	 *
	 * @method
	 * @param {object} doc update operations
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.update = function(updateDocument) {
	  // Perform upsert
	  var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;
	
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , u: updateDocument
	    , multi: true
	    , upsert: upsert
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the update document to the list
	  return addToOperationsList(this, common.UPDATE, document);
	}
	
	/**
	 * Add a single update one document to the bulk operation
	 *
	 * @method
	 * @param {object} doc update operations
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.updateOne = function(updateDocument) {
	  // Perform upsert
	  var upsert = typeof this.s.currentOp.upsert == 'boolean' ? this.s.currentOp.upsert : false;
	
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , u: updateDocument
	    , multi: false
	    , upsert: upsert
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the update document to the list
	  return addToOperationsList(this, common.UPDATE, document);
	}
	
	/**
	 * Add a replace one operation to the bulk operation
	 *
	 * @method
	 * @param {object} doc the new document to replace the existing one with
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.replaceOne = function(updateDocument) {
	  this.updateOne(updateDocument);
	}
	
	/**
	 * Upsert modifier for update bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {FindOperatorsUnordered}
	 */
	FindOperatorsUnordered.prototype.upsert = function() {
	  this.s.currentOp.upsert = true;
	  return this;
	}
	
	/**
	 * Add a remove one operation to the bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.removeOne = function() {
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , limit: 1
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the remove document to the list
	  return addToOperationsList(this, common.REMOVE, document);
	}
	
	/**
	 * Add a remove operation to the bulk operation
	 *
	 * @method
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	FindOperatorsUnordered.prototype.remove = function() {
	  // Establish the update command
	  var document = {
	      q: this.s.currentOp.selector
	    , limit: 0
	  }
	
	  // Clear out current Op
	  this.s.currentOp = null;
	  // Add the remove document to the list
	  return addToOperationsList(this, common.REMOVE, document);
	}
	
	//
	// Add to the operations list
	//
	var addToOperationsList = function(_self, docType, document) {
	  // Get the bsonSize
	  var bsonSize = bson.calculateObjectSize(document, {
			checkKeys: false,
		});
	  // Throw error if the doc is bigger than the max BSON size
	  if(bsonSize >= _self.s.maxBatchSizeBytes) throw toError("document is larger than the maximum size " + _self.s.maxBatchSizeBytes);
	  // Holds the current batch
	  _self.s.currentBatch = null;
	  // Get the right type of batch
	  if(docType == common.INSERT) {
	    _self.s.currentBatch = _self.s.currentInsertBatch;
	  } else if(docType == common.UPDATE) {
	    _self.s.currentBatch = _self.s.currentUpdateBatch;
	  } else if(docType == common.REMOVE) {
	    _self.s.currentBatch = _self.s.currentRemoveBatch;
	  }
	
	  // Create a new batch object if we don't have a current one
	  if(_self.s.currentBatch == null) _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);
	
	  // Check if we need to create a new batch
	  if(((_self.s.currentBatch.size + 1) >= _self.s.maxWriteBatchSize)
	    || ((_self.s.currentBatch.sizeBytes + bsonSize) >= _self.s.maxBatchSizeBytes)
	    || (_self.s.currentBatch.batchType != docType)) {
	    // Save the batch to the execution stack
	    _self.s.batches.push(_self.s.currentBatch);
	
	    // Create a new batch
	    _self.s.currentBatch = new Batch(docType, _self.s.currentIndex);
	  }
	
	  // We have an array of documents
	  if(Array.isArray(document)) {
	    throw toError("operation passed in cannot be an Array");
	  } else {
	    _self.s.currentBatch.operations.push(document);
	    _self.s.currentBatch.originalIndexes.push(_self.s.currentIndex);
	    _self.s.currentIndex = _self.s.currentIndex + 1;
	  }
	
	  // Save back the current Batch to the right type
	  if(docType == common.INSERT) {
	    _self.s.currentInsertBatch = _self.s.currentBatch;
	    _self.s.bulkResult.insertedIds.push({index: _self.s.bulkResult.insertedIds.length, _id: document._id});
	  } else if(docType == common.UPDATE) {
	    _self.s.currentUpdateBatch = _self.s.currentBatch;
	  } else if(docType == common.REMOVE) {
	    _self.s.currentRemoveBatch = _self.s.currentBatch;
	  }
	
	  // Update current batch size
	  _self.s.currentBatch.size = _self.s.currentBatch.size + 1;
	  _self.s.currentBatch.sizeBytes = _self.s.currentBatch.sizeBytes + bsonSize;
	
	  // Return self
	  return _self;
	}
	
	/**
	 * Create a new UnorderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @property {number} length Get the number of operations in the bulk.
	 * @return {UnorderedBulkOperation} a UnorderedBulkOperation instance.
	 */
	var UnorderedBulkOperation = function(topology, collection, options) {
		options = options == null ? {} : options;
	
		// Get the namesspace for the write operations
	  var namespace = collection.collectionName;
	  // Used to mark operation as executed
	  var executed = false;
	
		// Current item
	  // var currentBatch = null;
		var currentOp = null;
	
		// Handle to the bson serializer, used to calculate running sizes
		var bson = topology.bson;
	
	  // Set max byte size
	  var maxBatchSizeBytes = topology.isMasterDoc && topology.isMasterDoc.maxBsonObjectSize
	    ? topology.isMasterDoc.maxBsonObjectSize : (1024*1025*16);
	  var maxWriteBatchSize = topology.isMasterDoc && topology.isMasterDoc.maxWriteBatchSize
	    ? topology.isMasterDoc.maxWriteBatchSize : 1000;
	
	  // Get the write concern
	  var writeConcern = common.writeConcern(shallowClone(options), collection, options);
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(10).Promise;
	  }
	
	  // Final results
	  var bulkResult = {
	      ok: 1
	    , writeErrors: []
	    , writeConcernErrors: []
	    , insertedIds: []
	    , nInserted: 0
	    , nUpserted: 0
	    , nMatched: 0
	    , nModified: 0
	    , nRemoved: 0
	    , upserted: []
	  };
	
	  // Internal state
	  this.s = {
	    // Final result
	      bulkResult: bulkResult
	    // Current batch state
	    , currentInsertBatch: null
	    , currentUpdateBatch: null
	    , currentRemoveBatch: null
	    , currentBatch: null
	    , currentIndex: 0
	    , batches: []
	    // Write concern
	    , writeConcern: writeConcern
	    // Max batch size options
	    , maxBatchSizeBytes: maxBatchSizeBytes
	    , maxWriteBatchSize: maxWriteBatchSize
	    // Namespace
	    , namespace: namespace
	    // BSON
	    , bson: bson
	    // Topology
	    , topology: topology
	    // Options
	    , options: options
	    // Current operation
	    , currentOp: currentOp
	    // Executed
	    , executed: executed
	    // Collection
	    , collection: collection
	    // Promise Library
	    , promiseLibrary: promiseLibrary
	    // Bypass validation
	    , bypassDocumentValidation: typeof options.bypassDocumentValidation == 'boolean' ? options.bypassDocumentValidation : false
	  }
	}
	
	var define = UnorderedBulkOperation.define = new Define('UnorderedBulkOperation', UnorderedBulkOperation, false);
	
	/**
	 * Add a single insert document to the bulk operation
	 *
	 * @param {object} doc the document to insert
	 * @throws {MongoError}
	 * @return {UnorderedBulkOperation}
	 */
	UnorderedBulkOperation.prototype.insert = function(document) {
	  if(this.s.collection.s.db.options.forceServerObjectId !== true && document._id == null) document._id = new ObjectID();
	  return addToOperationsList(this, common.INSERT, document);
	}
	
	/**
	 * Initiate a find operation for an update/updateOne/remove/removeOne/replaceOne
	 *
	 * @method
	 * @param {object} selector The selector for the bulk operation.
	 * @throws {MongoError}
	 * @return {FindOperatorsUnordered}
	 */
	UnorderedBulkOperation.prototype.find = function(selector) {
	  if (!selector) {
	    throw toError("Bulk find operation must specify a selector");
	  }
	
	  // Save a current selector
	  this.s.currentOp = {
	    selector: selector
	  }
	
	  return new FindOperatorsUnordered(this);
	}
	
	Object.defineProperty(UnorderedBulkOperation.prototype, 'length', {
	  enumerable: true,
	  get: function() {
	    return this.s.currentIndex;
	  }
	});
	
	UnorderedBulkOperation.prototype.raw = function(op) {
	  var key = Object.keys(op)[0];
	
	  // Set up the force server object id
	  var forceServerObjectId = typeof this.s.options.forceServerObjectId == 'boolean'
	    ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId;
	
	  // Update operations
	  if((op.updateOne && op.updateOne.q)
	    || (op.updateMany && op.updateMany.q)
	    || (op.replaceOne && op.replaceOne.q)) {
	    op[key].multi = op.updateOne || op.replaceOne ? false : true;
	    return addToOperationsList(this, common.UPDATE, op[key]);
	  }
	
	  // Crud spec update format
	  if(op.updateOne || op.updateMany || op.replaceOne) {
	    var multi = op.updateOne || op.replaceOne ? false : true;
	    var operation = {q: op[key].filter, u: op[key].update || op[key].replacement, multi: multi}
	    if(op[key].upsert) operation.upsert = true;
	    return addToOperationsList(this, common.UPDATE, operation);
	  }
	
	  // Remove operations
	  if(op.removeOne || op.removeMany || (op.deleteOne && op.deleteOne.q) || op.deleteMany && op.deleteMany.q) {
	    op[key].limit = op.removeOne ? 1 : 0;
	    return addToOperationsList(this, common.REMOVE, op[key]);
	  }
	
	  // Crud spec delete operations, less efficient
	  if(op.deleteOne || op.deleteMany) {
	    var limit = op.deleteOne ? 1 : 0;
	    operation = {q: op[key].filter, limit: limit}
	    return addToOperationsList(this, common.REMOVE, operation);
	  }
	
	  // Insert operations
	  if(op.insertOne && op.insertOne.document == null) {
	    if(forceServerObjectId !== true && op.insertOne._id == null) op.insertOne._id = new ObjectID();
	    return addToOperationsList(this, common.INSERT, op.insertOne);
	  } else if(op.insertOne && op.insertOne.document) {
	    if(forceServerObjectId !== true && op.insertOne.document._id == null) op.insertOne.document._id = new ObjectID();
	    return addToOperationsList(this, common.INSERT, op.insertOne.document);
	  }
	
	  if(op.insertMany) {
	    for(var i = 0; i < op.insertMany.length; i++) {
	      if(forceServerObjectId !== true && op.insertMany[i]._id == null) op.insertMany[i]._id = new ObjectID();
	      addToOperationsList(this, common.INSERT, op.insertMany[i]);
	    }
	
	    return;
	  }
	
	  // No valid type of operation
	  throw toError("bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany");
	}
	
	//
	// Execute the command
	var executeBatch = function(self, batch, callback) {
	  var finalOptions = {ordered: false}
	  if(self.s.writeConcern != null) {
	    finalOptions.writeConcern = self.s.writeConcern;
	  }
	
	  var resultHandler = function(err, result) {
			// Error is a driver related error not a bulk op error, terminate
			if(err && err.driver || err && err.message) {
				return handleCallback(callback, err);
			}
	
	    // If we have and error
	    if(err) err.ok = 0;
	    handleCallback(callback, null, mergeBatchResults(false, batch, self.s.bulkResult, err, result));
	  }
	
		// Set an operationIf if provided
		if(self.operationId) {
			resultHandler.operationId = self.operationId;
		}
	
		// Serialize functions
		if(self.s.options.serializeFunctions) {
			finalOptions.serializeFunctions = true
		}
	
	  // Is the bypassDocumentValidation options specific
	  if(self.s.bypassDocumentValidation == true) {
	    finalOptions.bypassDocumentValidation = true;
	  }
	
	  try {
	    if(batch.batchType == common.INSERT) {
	      self.s.topology.insert(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    } else if(batch.batchType == common.UPDATE) {
	      self.s.topology.update(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    } else if(batch.batchType == common.REMOVE) {
	      self.s.topology.remove(self.s.collection.namespace, batch.operations, finalOptions, resultHandler);
	    }
	  } catch(err) {
	    // Force top level error
	    err.ok = 0;
	    // Merge top level error and return
	    handleCallback(callback, null, mergeBatchResults(false, batch, self.s.bulkResult, err, null));
	  }
	}
	
	//
	// Execute all the commands
	var executeBatches = function(self, callback) {
	  var numberOfCommandsToExecute = self.s.batches.length;
	  // Execute over all the batches
	  for(var i = 0; i < self.s.batches.length; i++) {
	    executeBatch(self, self.s.batches[i], function(err) {
				// Driver layer error capture it
				if(err) error = err;
				// Count down the number of commands left to execute
	      numberOfCommandsToExecute = numberOfCommandsToExecute - 1;
	
	      // Execute
	      if(numberOfCommandsToExecute == 0) {
					// Driver level error
					if(error) return handleCallback(callback, error);
					// Treat write errors
	        var error = self.s.bulkResult.writeErrors.length > 0 ? toError(self.s.bulkResult.writeErrors[0]) : null;
	        handleCallback(callback, error, new BulkWriteResult(self.s.bulkResult));
	      }
	    });
	  }
	}
	
	/**
	 * The callback format for results
	 * @callback UnorderedBulkOperation~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {BulkWriteResult} result The bulk write result.
	 */
	
	/**
	 * Execute the ordered bulk operation
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.fsync=false] Specify a file sync write concern.
	 * @param {UnorderedBulkOperation~resultCallback} [callback] The result callback
	 * @throws {MongoError}
	 * @return {Promise} returns Promise if no callback passed
	 */
	UnorderedBulkOperation.prototype.execute = function(_writeConcern, callback) {
	  var self = this;
	  if (this.s.executed) {
	    var executedError = toError('batch cannot be re-executed');
	    return (typeof callback === 'function') ?
	      callback(executedError, null) : this.s.promiseLibrary.reject(executedError);
	  }
	
	  if (typeof _writeConcern === 'function') {
	    callback = _writeConcern;
	  } else if (_writeConcern && typeof _writeConcern === 'object') {
	    this.s.writeConcern = _writeConcern;
	  }
	
	  // If we have current batch
	  if (this.s.currentInsertBatch) this.s.batches.push(this.s.currentInsertBatch);
	  if (this.s.currentUpdateBatch) this.s.batches.push(this.s.currentUpdateBatch);
	  if (this.s.currentRemoveBatch) this.s.batches.push(this.s.currentRemoveBatch);
	
	  // If we have no operations in the bulk raise an error
	  if (this.s.batches.length == 0) {
	    var emptyBatchError = toError('Invalid Operation, no operations specified');
	    return (typeof callback === 'function') ?
	      callback(emptyBatchError, null) : this.s.promiseLibrary.reject(emptyBatchError);
	  }
	
	  // Execute using callback
	  if (typeof callback === 'function') return executeBatches(this, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    executeBatches(self, function(err, r) {
	      if (err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('execute', {callback: true, promise:false});
	
	/**
	 * Returns an unordered batch object
	 * @ignore
	 */
	var initializeUnorderedBulkOp = function(topology, collection, options) {
		return new UnorderedBulkOperation(topology, collection, options);
	}
	
	initializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;
	module.exports = initializeUnorderedBulkOp;
	module.exports.Bulk = UnorderedBulkOperation;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var EventEmitter = __webpack_require__(6).EventEmitter
	  , authenticate = __webpack_require__(79)
	  , inherits = __webpack_require__(1).inherits
	  , getSingleProperty = __webpack_require__(2).getSingleProperty
	  , shallowClone = __webpack_require__(2).shallowClone
	  , parseIndexOptions = __webpack_require__(2).parseIndexOptions
	  , debugOptions = __webpack_require__(2).debugOptions
	  , CommandCursor = __webpack_require__(23)
	  , handleCallback = __webpack_require__(2).handleCallback
	  , filterOptions = __webpack_require__(2).filterOptions
	  , toError = __webpack_require__(2).toError
	  , ReadPreference = __webpack_require__(16)
	  , f = __webpack_require__(1).format
	  , Admin = __webpack_require__(121)
	  , Code = __webpack_require__(3).BSON.Code
	  , CoreReadPreference = __webpack_require__(3).ReadPreference
	  , MongoError = __webpack_require__(3).MongoError
	  , ObjectID = __webpack_require__(3).ObjectID
	  , Define = __webpack_require__(13)
	  , Logger = __webpack_require__(3).Logger
	  , Collection = __webpack_require__(59)
	  , crypto = __webpack_require__(48)
	  , mergeOptionsAndWriteConcern = __webpack_require__(2).mergeOptionsAndWriteConcern
	  , assign = __webpack_require__(2).assign;
	
	var debugFields = ['authSource', 'w', 'wtimeout', 'j', 'native_parser', 'forceServerObjectId'
	  , 'serializeFunctions', 'raw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bufferMaxEntries', 'numberOfRetries', 'retryMiliSeconds'
	  , 'readPreference', 'pkFactory', 'parentDb', 'promiseLibrary', 'noListener'];
	
	// Filter out any write concern options
	var illegalCommandFields = ['w', 'wtimeout', 'j', 'fsync', 'autoIndexId'
	  , 'strict', 'serializeFunctions', 'pkFactory', 'raw', 'readPreference'];
	
	/**
	 * @fileOverview The **Db** class is a class that represents a MongoDB Database.
	 *
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Get an additional db
	 *   var testDb = db.db('test');
	 *   db.close();
	 * });
	 */
	
	// Allowed parameters
	var legalOptionNames = ['w', 'wtimeout', 'fsync', 'j', 'readPreference', 'readPreferenceTags', 'native_parser'
	  , 'forceServerObjectId', 'pkFactory', 'serializeFunctions', 'raw', 'bufferMaxEntries', 'authSource'
	  , 'ignoreUndefined', 'promoteLongs', 'promiseLibrary', 'readConcern', 'retryMiliSeconds', 'numberOfRetries'
	  , 'parentDb', 'noListener', 'loggerLevel', 'logger', 'promoteBuffers', 'promoteLongs', 'promoteValues'];
	
	/**
	 * Creates a new Db instance
	 * @class
	 * @param {string} databaseName The name of the database this instance represents.
	 * @param {(Server|ReplSet|Mongos)} topology The server topology for the database.
	 * @param {object} [options=null] Optional settings.
	 * @param {string} [options.authSource=null] If the database authentication is dependent on another databaseName.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
	 * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
	 * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
	 * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
	 * @param {number} [options.bufferMaxEntries=-1] Sets a cap on how many operations the driver will buffer up before giving up on getting a working connection, default is -1 which is unlimited.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
	 * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	 * @param {object} [options.readConcern=null] Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)
	 * @param {object} [options.readConcern.level='local'] Specify a read concern level for the collection operations, one of [local|majority]. (only MongoDB 3.2 or higher supported)
	 * @property {(Server|ReplSet|Mongos)} serverConfig Get the current db topology.
	 * @property {number} bufferMaxEntries Current bufferMaxEntries value for the database
	 * @property {string} databaseName The name of the database this instance represents.
	 * @property {object} options The options associated with the db instance.
	 * @property {boolean} native_parser The current value of the parameter native_parser.
	 * @property {boolean} slaveOk The current slaveOk value for the db instance.
	 * @property {object} writeConcern The current write concern values.
	 * @property {object} topology Access the topology object (single server, replicaset or mongos).
	 * @fires Db#close
	 * @fires Db#authenticated
	 * @fires Db#reconnect
	 * @fires Db#error
	 * @fires Db#timeout
	 * @fires Db#parseError
	 * @fires Db#fullsetup
	 * @return {Db} a Db instance.
	 */
	var Db = function(databaseName, topology, options) {
	  options = options || {};
	  if(!(this instanceof Db)) return new Db(databaseName, topology, options);
	  EventEmitter.call(this);
	  var self = this;
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(10).Promise;
	  }
	
	  // Filter the options
	  options = filterOptions(options, legalOptionNames);
	
	  // Ensure we put the promiseLib in the options
	  options.promiseLibrary = promiseLibrary;
	
	  // var self = this;  // Internal state of the db object
	  this.s = {
	    // Database name
	      databaseName: databaseName
	    // DbCache
	    , dbCache: {}
	    // Children db's
	    , children: []
	    // Topology
	    , topology: topology
	    // Options
	    , options: options
	    // Logger instance
	    , logger: Logger('Db', options)
	    // Get the bson parser
	    , bson: topology ? topology.bson : null
	    // Authsource if any
	    , authSource: options.authSource
	    // Unpack read preference
	    , readPreference: options.readPreference
	    // Set buffermaxEntries
	    , bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : -1
	    // Parent db (if chained)
	    , parentDb: options.parentDb || null
	    // Set up the primary key factory or fallback to ObjectID
	    , pkFactory: options.pkFactory || ObjectID
	    // Get native parser
	    , nativeParser: options.nativeParser || options.native_parser
	    // Promise library
	    , promiseLibrary: promiseLibrary
	    // No listener
	    , noListener: typeof options.noListener == 'boolean' ? options.noListener : false
	    // ReadConcern
	    , readConcern: options.readConcern
	  }
	
	  // Ensure we have a valid db name
	  validateDatabaseName(self.s.databaseName);
	
	  // Add a read Only property
	  getSingleProperty(this, 'serverConfig', self.s.topology);
	  getSingleProperty(this, 'bufferMaxEntries', self.s.bufferMaxEntries);
	  getSingleProperty(this, 'databaseName', self.s.databaseName);
	
	  // This is a child db, do not register any listeners
	  if(options.parentDb) return;
	  if(this.s.noListener) return;
	
	  // Add listeners
	  topology.on('error', createListener(self, 'error', self));
	  topology.on('timeout', createListener(self, 'timeout', self));
	  topology.on('close', createListener(self, 'close', self));
	  topology.on('parseError', createListener(self, 'parseError', self));
	  topology.once('open', createListener(self, 'open', self));
	  topology.once('fullsetup', createListener(self, 'fullsetup', self));
	  topology.once('all', createListener(self, 'all', self));
	  topology.on('reconnect', createListener(self, 'reconnect', self));
	}
	
	inherits(Db, EventEmitter);
	
	var define = Db.define = new Define('Db', Db, false);
	
	// Topology
	Object.defineProperty(Db.prototype, 'topology', {
	  enumerable:true,
	  get: function() { return this.s.topology; }
	});
	
	// Options
	Object.defineProperty(Db.prototype, 'options', {
	  enumerable:true,
	  get: function() { return this.s.options; }
	});
	
	// slaveOk specified
	Object.defineProperty(Db.prototype, 'slaveOk', {
	  enumerable:true,
	  get: function() {
	    if(this.s.options.readPreference != null
	      && (this.s.options.readPreference != 'primary' || this.s.options.readPreference.mode != 'primary')) {
	      return true;
	    }
	    return false;
	  }
	});
	
	// get the write Concern
	Object.defineProperty(Db.prototype, 'writeConcern', {
	  enumerable:true,
	  get: function() {
	    var ops = {};
	    if(this.s.options.w != null) ops.w = this.s.options.w;
	    if(this.s.options.j != null) ops.j = this.s.options.j;
	    if(this.s.options.fsync != null) ops.fsync = this.s.options.fsync;
	    if(this.s.options.wtimeout != null) ops.wtimeout = this.s.options.wtimeout;
	    return ops;
	  }
	});
	
	/**
	 * The callback format for the Db.open method
	 * @callback Db~openCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Db} db The Db instance if the open method was successful.
	 */
	
	// Internal method
	var open = function(self, callback) {
	  self.s.topology.connect(self, self.s.options, function(err) {
	    if(callback == null) return;
	    var internalCallback = callback;
	    callback == null;
	
	    if(err) {
	      self.close();
	      return internalCallback(err);
	    }
	
	    internalCallback(null, self);
	  });
	}
	
	/**
	 * Open the database
	 * @method
	 * @param {Db~openCallback} [callback] Callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.open = function(callback) {
	  var self = this;
	  // We provided a callback leg
	  if(typeof callback == 'function') return open(self, callback);
	  // Return promise
	  return new self.s.promiseLibrary(function(resolve, reject) {
	    open(self, function(err, db) {
	      if(err) return reject(err);
	      resolve(db);
	    })
	  });
	}
	
	define.classMethod('open', {callback: true, promise:true});
	
	/**
	 * Converts provided read preference to CoreReadPreference
	 * @param {(ReadPreference|string|object)} readPreference the user provided read preference
	 * @return {CoreReadPreference}
	 */
	var convertReadPreference = function(readPreference) {
	  if(readPreference && typeof readPreference == 'string') {
	    return new CoreReadPreference(readPreference);
	  } else if(readPreference instanceof ReadPreference) {
	    return new CoreReadPreference(readPreference.mode, readPreference.tags, {maxStalenessSeconds: readPreference.maxStalenessSeconds});
	  } else if(readPreference && typeof readPreference == 'object') {
	    var mode = readPreference.mode || readPreference.preference;
	    if (mode && typeof mode == 'string') {
	      readPreference = new CoreReadPreference(mode, readPreference.tags, {maxStalenessSeconds: readPreference.maxStalenessSeconds});
	    }
	  }
	  return readPreference;
	}
	
	/**
	 * The callback format for results
	 * @callback Db~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object} result The result object if the command was executed successfully.
	 */
	
	var executeCommand = function(self, command, options, callback) {
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	  // Get the db name we are executing against
	  var dbName = options.dbName || options.authdb || self.s.databaseName;
	
	  // If we have a readPreference set
	  if(options.readPreference == null && self.s.readPreference) {
	    options.readPreference = self.s.readPreference;
	  }
	
	  // Convert the readPreference if its not a write
	  if(options.readPreference) {
	    options.readPreference = convertReadPreference(options.readPreference);
	  } else {
	    options.readPreference = CoreReadPreference.primary;
	  }
	
	  // Debug information
	  if(self.s.logger.isDebug()) self.s.logger.debug(f('executing command %s against %s with options [%s]'
	    , JSON.stringify(command), f('%s.$cmd', dbName), JSON.stringify(debugOptions(debugFields, options))));
	
	  // Execute command
	  self.s.topology.command(f('%s.$cmd', dbName), command, options, function(err, result) {
	    if(err) return handleCallback(callback, err);
	    if(options.full) return handleCallback(callback, null, result);
	    handleCallback(callback, null, result.result);
	  });
	}
	
	/**
	 * Execute a command
	 * @method
	 * @param {object} command The command hash
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.command = function(command, options, callback) {
	  var self = this;
	  // Change the callback
	  if(typeof options == 'function') callback = options, options = {};
	  // Clone the options
	  options = shallowClone(options);
	
	  // Do we have a callback
	  if(typeof callback == 'function') return executeCommand(self, command, options, callback);
	  // Return a promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    executeCommand(self, command, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('command', {callback: true, promise:true});
	
	/**
	 * The callback format for results
	 * @callback Db~noResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {null} result Is not set to a value
	 */
	
	/**
	 * Close the db and its underlying connections
	 * @method
	 * @param {boolean} force Force close, emitting no events
	 * @param {Db~noResultCallback} [callback] The result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.close = function(force, callback) {
	  if(typeof force == 'function') callback = force, force = false;
	  this.s.topology.close(force);
	  var self = this;
	
	  // Fire close event if any listeners
	  if(this.listeners('close').length > 0) {
	    this.emit('close');
	
	    // If it's the top level db emit close on all children
	    if(this.parentDb == null) {
	      // Fire close on all children
	      for(var i = 0; i < this.s.children.length; i++) {
	        this.s.children[i].emit('close');
	      }
	    }
	
	    // Remove listeners after emit
	    self.removeAllListeners('close');
	  }
	
	  // Close parent db if set
	  if(this.s.parentDb) this.s.parentDb.close();
	  // Callback after next event loop tick
	  if(typeof callback == 'function') return process.nextTick(function() {
	    handleCallback(callback, null);
	  })
	
	  // Return dummy promise
	  return new this.s.promiseLibrary(function(resolve) {
	    resolve();
	  });
	}
	
	define.classMethod('close', {callback: true, promise:true});
	
	/**
	 * Return the Admin db instance
	 * @method
	 * @return {Admin} return the new Admin db instance
	 */
	Db.prototype.admin = function() {
	  return new Admin(this, this.s.topology, this.s.promiseLibrary);
	};
	
	define.classMethod('admin', {callback: false, promise:false, returns: [Admin]});
	
	/**
	 * The callback format for the collection method, must be used if strict is specified
	 * @callback Db~collectionResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection} collection The collection instance.
	 */
	
	var collectionKeys = ['pkFactory', 'readPreference'
	  , 'serializeFunctions', 'strict', 'readConcern', 'ignoreUndefined', 'promoteValues', 'promoteBuffers', 'promoteLongs'];
	
	/**
	 * Fetch a specific collection (containing the actual collection information). If the application does not use strict mode you can
	 * can use it without a callback in the following way: `var collection = db.collection('mycollection');`
	 *
	 * @method
	 * @param {string} name the collection name we wish to access.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
	 * @param {object} [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.strict=false] Returns an error if the collection does not exist
	 * @param {object} [options.readConcern=null] Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)
	 * @param {object} [options.readConcern.level='local'] Specify a read concern level for the collection operations, one of [local|majority]. (only MongoDB 3.2 or higher supported)
	 * @param {Db~collectionResultCallback} callback The collection result callback
	 * @return {Collection} return the new Collection instance if not in strict mode
	 */
	Db.prototype.collection = function(name, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	  options = shallowClone(options);
	  // Set the promise library
	  options.promiseLibrary = this.s.promiseLibrary;
	
	  // If we have not set a collection level readConcern set the db level one
	  options.readConcern = options.readConcern || this.s.readConcern;
	
	  // Do we have ignoreUndefined set
	  if(this.s.options.ignoreUndefined) {
	    options.ignoreUndefined = this.s.options.ignoreUndefined;
	  }
	
	  // Merge in all needed options and ensure correct writeConcern merging from db level
	  options = mergeOptionsAndWriteConcern(options, this.s.options, collectionKeys, true);
	
	  // Execute
	  if(options == null || !options.strict) {
	    try {
	      var collection = new Collection(this, this.s.topology, this.s.databaseName, name, this.s.pkFactory, options);
	      if(callback) callback(null, collection);
	      return collection;
	    } catch(err) {
	      // if(err instanceof MongoError && callback) return callback(err);
	      if(callback) return callback(err);
	      throw err;
	    }
	  }
	
	  // Strict mode
	  if(typeof callback != 'function') {
	    throw toError(f("A callback is required in strict mode. While getting collection %s.", name));
	  }
	
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) {
	    return callback(new MongoError('topology was destroyed'));
	  }
	
	  // Strict mode
	  this.listCollections({name:name}, options).toArray(function(err, collections) {
	    if(err != null) return handleCallback(callback, err, null);
	    if(collections.length == 0) return handleCallback(callback, toError(f("Collection %s does not exist. Currently in strict mode.", name)), null);
	
	    try {
	      return handleCallback(callback, null, new Collection(self, self.s.topology, self.s.databaseName, name, self.s.pkFactory, options));
	    } catch(err) {
	      return handleCallback(callback, err, null);
	    }
	  });
	}
	
	define.classMethod('collection', {callback: true, promise:false, returns: [Collection]});
	
	function decorateWithWriteConcern(command, self, options) {
	  // Do we support write concerns 3.4 and higher
	  if(self.s.topology.capabilities().commandsTakeWriteConcern) {
	    // Get the write concern settings
	    var finalOptions = writeConcern(shallowClone(options), self, options);
	    // Add the write concern to the command
	    if(finalOptions.writeConcern) {
	      command.writeConcern = finalOptions.writeConcern;
	    }
	  }
	}
	
	var createCollection = function(self, name, options, callback) {
	  // Get the write concern options
	  var finalOptions = writeConcern(shallowClone(options), self, options);
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	  // Check if we have the name
	  self.listCollections({name: name})
	    .setReadPreference(ReadPreference.PRIMARY)
	    .toArray(function(err, collections) {
	      if(err != null) return handleCallback(callback, err, null);
	      if(collections.length > 0 && finalOptions.strict) {
	        return handleCallback(callback, MongoError.create({message: f("Collection %s already exists. Currently in strict mode.", name), driver:true}), null);
	      } else if (collections.length > 0) {
	        try { return handleCallback(callback, null, new Collection(self, self.s.topology, self.s.databaseName, name, self.s.pkFactory, options)); }
	        catch(err) { return handleCallback(callback, err); }
	      }
	
	      // Create collection command
	      var cmd = {'create':name};
	
	      // Decorate command with writeConcern if supported
	      decorateWithWriteConcern(cmd, self, options);
	      // Add all optional parameters
	      for(var n in options) {
	        if(options[n] != null
	          && typeof options[n] != 'function' && illegalCommandFields.indexOf(n) == -1) {
	            cmd[n] = options[n];
	        }
	      }
	
	      // Force a primary read Preference
	      finalOptions.readPreference = ReadPreference.PRIMARY;
	
	      // Execute command
	      self.command(cmd, finalOptions, function(err) {
	        if(err) return handleCallback(callback, err);
	        handleCallback(callback, null, new Collection(self, self.s.topology, self.s.databaseName, name, self.s.pkFactory, options));
	      });
	  });
	}
	
	/**
	 * Create a new collection on a server with the specified options. Use this to create capped collections.
	 * More information about command options available at https://docs.mongodb.com/manual/reference/command/create/
	 *
	 * @method
	 * @param {string} name the collection name we wish to access.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
	 * @param {object} [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {boolean} [options.strict=false] Returns an error if the collection does not exist
	 * @param {boolean} [options.capped=false] Create a capped collection.
	 * @param {boolean} [options.autoIndexId=true] Create an index on the _id field of the document, True by default on MongoDB 2.2 or higher off for version < 2.2.
	 * @param {number} [options.size=null] The size of the capped collection in bytes.
	 * @param {number} [options.max=null] The maximum number of documents in the capped collection.
	 * @param {number} [options.flags=null] Optional. Available for the MMAPv1 storage engine only to set the usePowerOf2Sizes and the noPadding flag.
	 * @param {object} [options.storageEngine=null] Allows users to specify configuration to the storage engine on a per-collection basis when creating a collection on MongoDB 3.0 or higher.
	 * @param {object} [options.validator=null] Allows users to specify validation rules or expressions for the collection. For more information, see Document Validation on MongoDB 3.2 or higher.
	 * @param {string} [options.validationLevel=null] Determines how strictly MongoDB applies the validation rules to existing documents during an update on MongoDB 3.2 or higher.
	 * @param {string} [options.validationAction=null] Determines whether to error on invalid documents or just warn about the violations but allow invalid documents to be inserted on MongoDB 3.2 or higher.
	 * @param {object} [options.indexOptionDefaults=null] Allows users to specify a default configuration for indexes when creating a collection on MongoDB 3.2 or higher.
	 * @param {string} [options.viewOn=null] The name of the source collection or view from which to create the view. The name is not the full namespace of the collection or view; i.e. does not include the database name and implies the same database as the view to create on MongoDB 3.4 or higher.
	 * @param {array} [options.pipeline=null] An array that consists of the aggregation pipeline stage. create creates the view by applying the specified pipeline to the viewOn collection or view on MongoDB 3.4 or higher.
	 * @param {object} [options.collation=null] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
	 * @param {Db~collectionResultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.createCollection = function(name, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  name = args.length ? args.shift() : null;
	  options = args.length ? args.shift() || {} : {};
	
	  // Do we have a promisesLibrary
	  options.promiseLibrary = options.promiseLibrary || this.s.promiseLibrary;
	
	  // Check if the callback is in fact a string
	  if(typeof callback == 'string') name = callback;
	
	  // Execute the fallback callback
	  if(typeof callback == 'function') return createCollection(self, name, options, callback);
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    createCollection(self, name, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('createCollection', {callback: true, promise:true});
	
	/**
	 * Get all the db statistics.
	 *
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.scale=null] Divide the returned sizes by scale value.
	 * @param {Db~resultCallback} [callback] The collection result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.stats = function(options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	  // Build command object
	  var commandObject = { dbStats:true };
	  // Check if we have the scale value
	  if(options['scale'] != null) commandObject['scale'] = options['scale'];
	
	  // If we have a readPreference set
	  if(options.readPreference == null && this.s.readPreference) {
	    options.readPreference = this.s.readPreference;
	  }
	
	  // Execute the command
	  return this.command(commandObject, options, callback);
	}
	
	define.classMethod('stats', {callback: true, promise:true});
	
	// Transformation methods for cursor results
	var listCollectionsTranforms = function(databaseName) {
	  var matching = f('%s.', databaseName);
	
	  return {
	    doc: function(doc) {
	      var index = doc.name.indexOf(matching);
	      // Remove database name if available
	      if(doc.name && index == 0) {
	        doc.name = doc.name.substr(index + matching.length);
	      }
	
	      return doc;
	    }
	  }
	}
	
	/**
	 * Get the list of all collection information for the specified db.
	 *
	 * @method
	 * @param {object} filter Query to filter collections by
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.batchSize=null] The batchSize for the returned command cursor or if pre 2.8 the systems batch collection
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @return {CommandCursor}
	 */
	Db.prototype.listCollections = function(filter, options) {
	  filter = filter || {};
	  options = options || {};
	
	  // Shallow clone the object
	  options = shallowClone(options);
	  // Set the promise library
	  options.promiseLibrary = this.s.promiseLibrary;
	
	  // Ensure valid readPreference
	  if(options.readPreference) {
	    options.readPreference = convertReadPreference(options.readPreference);
	  }
	
	  // We have a list collections command
	  if(this.serverConfig.capabilities().hasListCollectionsCommand) {
	    // Cursor options
	    var cursor = options.batchSize ? {batchSize: options.batchSize} : {}
	    // Build the command
	    var command = { listCollections : true, filter: filter, cursor: cursor };
	    // Set the AggregationCursor constructor
	    options.cursorFactory = CommandCursor;
	    // Create the cursor
	    cursor = this.s.topology.cursor(f('%s.$cmd', this.s.databaseName), command, options);
	    // Do we have a readPreference, apply it
	    if(options.readPreference) {
	      cursor.setReadPreference(options.readPreference);
	    }
	    // Return the cursor
	    return cursor;
	  }
	
	  // We cannot use the listCollectionsCommand
	  if(!this.serverConfig.capabilities().hasListCollectionsCommand) {
	    // If we have legacy mode and have not provided a full db name filter it
	    if(typeof filter.name == 'string' && !(new RegExp('^' + this.databaseName + '\\.').test(filter.name))) {
	      filter = shallowClone(filter);
	      filter.name = f('%s.%s', this.s.databaseName, filter.name);
	    }
	  }
	
	  // No filter, filter by current database
	  if(filter == null) {
	    filter.name = f('/%s/', this.s.databaseName);
	  }
	
	  // Rewrite the filter to use $and to filter out indexes
	  if(filter.name) {
	    filter = {$and: [{name: filter.name}, {name:/^((?!\$).)*$/}]};
	  } else {
	    filter = {name:/^((?!\$).)*$/};
	  }
	
	  // Return options
	  var _options = {transforms: listCollectionsTranforms(this.s.databaseName)}
	  // Get the cursor
	  cursor = this.collection(Db.SYSTEM_NAMESPACE_COLLECTION).find(filter, _options);
	  // Do we have a readPreference, apply it
	  if(options.readPreference) cursor.setReadPreference(options.readPreference);
	  // Set the passed in batch size if one was provided
	  if(options.batchSize) cursor = cursor.batchSize(options.batchSize);
	  // We have a fallback mode using legacy systems collections
	  return cursor;
	};
	
	define.classMethod('listCollections', {callback: false, promise:false, returns: [CommandCursor]});
	
	var evaluate = function(self, code, parameters, options, callback) {
	  var finalCode = code;
	  var finalParameters = [];
	
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	
	  // If not a code object translate to one
	  if(!(finalCode && finalCode._bsontype == 'Code')) finalCode = new Code(finalCode);
	  // Ensure the parameters are correct
	  if(parameters != null && !Array.isArray(parameters) && typeof parameters !== 'function') {
	    finalParameters = [parameters];
	  } else if(parameters != null && Array.isArray(parameters) && typeof parameters !== 'function') {
	    finalParameters = parameters;
	  }
	
	  // Create execution selector
	  var cmd = {'$eval':finalCode, 'args':finalParameters};
	  // Check if the nolock parameter is passed in
	  if(options['nolock']) {
	    cmd['nolock'] = options['nolock'];
	  }
	
	  // Set primary read preference
	  options.readPreference = new CoreReadPreference(ReadPreference.PRIMARY);
	
	  // Execute the command
	  self.command(cmd, options, function(err, result) {
	    if(err) return handleCallback(callback, err, null);
	    if(result && result.ok == 1) return handleCallback(callback, null, result.retval);
	    if(result) return handleCallback(callback, MongoError.create({message: f("eval failed: %s", result.errmsg), driver:true}), null);
	    handleCallback(callback, err, result);
	  });
	}
	
	/**
	 * Evaluate JavaScript on the server
	 *
	 * @method
	 * @param {Code} code JavaScript to execute on server.
	 * @param {(object|array)} parameters The parameters for the call.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.nolock=false] Tell MongoDB not to block on the evaulation of the javascript.
	 * @param {Db~resultCallback} [callback] The results callback
	 * @deprecated Eval is deprecated on MongoDB 3.2 and forward
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.eval = function(code, parameters, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  parameters = args.length ? args.shift() : parameters;
	  options = args.length ? args.shift() || {} : {};
	
	  // Check if the callback is in fact a string
	  if(typeof callback == 'function') return evaluate(self, code, parameters, options, callback);
	  // Execute the command
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    evaluate(self, code, parameters, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	define.classMethod('eval', {callback: true, promise:true});
	
	/**
	 * Rename a collection.
	 *
	 * @method
	 * @param {string} fromCollection Name of current collection to rename.
	 * @param {string} toCollection New name of of the collection.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.dropTarget=false] Drop the target name collection if it previously exists.
	 * @param {Db~collectionResultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.renameCollection = function(fromCollection, toCollection, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	  // Add return new collection
	  options.new_collection = true;
	
	  // Check if the callback is in fact a string
	  if(typeof callback == 'function') {
	    return this.collection(fromCollection).rename(toCollection, options, callback);
	  }
	
	  // Return a promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.collection(fromCollection).rename(toCollection, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	define.classMethod('renameCollection', {callback: true, promise:true});
	
	/**
	 * Drop a collection from the database, removing it permanently. New accesses will create a new collection.
	 *
	 * @method
	 * @param {string} name Name of collection to drop
	 * @param {Db~resultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.dropCollection = function(name, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Command to execute
	  var cmd = {'drop':name}
	
	  // Decorate with write concern
	  decorateWithWriteConcern(cmd, self, options);
	
	  // options
	  options = assign({}, this.s.options, {readPreference: ReadPreference.PRIMARY});
	
	  // Check if the callback is in fact a string
	  if(typeof callback == 'function') return this.command(cmd, options, function(err, result) {
	    // Did the user destroy the topology
	    if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	    if(err) return handleCallback(callback, err);
	    if(result.ok) return handleCallback(callback, null, true);
	    handleCallback(callback, null, false);
	  });
	
	  // Clone the options
	  options = shallowClone(self.s.options);
	  // Set readPreference PRIMARY
	  options.readPreference = ReadPreference.PRIMARY;
	
	  // Execute the command
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    // Execute command
	    self.command(cmd, options, function(err, result) {
	      // Did the user destroy the topology
	      if(self.serverConfig && self.serverConfig.isDestroyed()) return reject(new MongoError('topology was destroyed'));
	      if(err) return reject(err);
	      if(result.ok) return resolve(true);
	      resolve(false);
	    });
	  });
	};
	
	define.classMethod('dropCollection', {callback: true, promise:true});
	
	/**
	 * Drop a database, removing it permanently from the server.
	 *
	 * @method
	 * @param {Db~resultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.dropDatabase = function(options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	  // Drop database command
	  var cmd = {'dropDatabase':1};
	
	  // Decorate with write concern
	  decorateWithWriteConcern(cmd, self, options);
	
	  // Ensure primary only
	  options = assign({}, this.s.options, {readPreference: ReadPreference.PRIMARY});
	
	  // Check if the callback is in fact a string
	  if(typeof callback == 'function') return this.command(cmd, options, function(err, result) {
	    // Did the user destroy the topology
	    if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	    if(callback == null) return;
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, null, result.ok ? true : false);
	  });
	
	  // Execute the command
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    // Execute command
	    self.command(cmd, options, function(err, result) {
	      // Did the user destroy the topology
	      if(self.serverConfig && self.serverConfig.isDestroyed()) return reject(new MongoError('topology was destroyed'));
	      if(err) return reject(err);
	      if(result.ok) return resolve(true);
	      resolve(false);
	    });
	  });
	}
	
	define.classMethod('dropDatabase', {callback: true, promise:true});
	
	/**
	 * The callback format for the collections method.
	 * @callback Db~collectionsResultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection[]} collections An array of all the collections objects for the db instance.
	 */
	var collections = function(self, callback) {
	  // Let's get the collection names
	  self.listCollections().toArray(function(err, documents) {
	    if(err != null) return handleCallback(callback, err, null);
	    // Filter collections removing any illegal ones
	    documents = documents.filter(function(doc) {
	      return doc.name.indexOf('$') == -1;
	    });
	
	    // Return the collection objects
	    handleCallback(callback, null, documents.map(function(d) {
	      return new Collection(self, self.s.topology, self.s.databaseName, d.name, self.s.pkFactory, self.s.options);
	    }));
	  });
	}
	
	/**
	 * Fetch all collections for the current db.
	 *
	 * @method
	 * @param {Db~collectionsResultCallback} [callback] The results callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.collections = function(callback) {
	  var self = this;
	
	  // Return the callback
	  if(typeof callback == 'function') return collections(self, callback);
	  // Return the promise
	  return new self.s.promiseLibrary(function(resolve, reject) {
	    collections(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	define.classMethod('collections', {callback: true, promise:true});
	
	/**
	 * Runs a command on the database as admin.
	 * @method
	 * @param {object} command The command hash
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.executeDbAdminCommand = function(selector, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Return the callback
	  if(typeof callback == 'function') {
	    // Convert read preference
	    if(options.readPreference) {
	      options.readPreference = convertReadPreference(options.readPreference)
	    }
	
	    return self.s.topology.command('admin.$cmd', selector, options, function(err, result) {
	      // Did the user destroy the topology
	      if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	      if(err) return handleCallback(callback, err);
	      handleCallback(callback, null, result.result);
	    });
	  }
	
	  // Return promise
	  return new self.s.promiseLibrary(function(resolve, reject) {
	    self.s.topology.command('admin.$cmd', selector, options, function(err, result) {
	      // Did the user destroy the topology
	      if(self.serverConfig && self.serverConfig.isDestroyed()) return reject(new MongoError('topology was destroyed'));
	      if(err) return reject(err);
	      resolve(result.result);
	    });
	  });
	};
	
	define.classMethod('executeDbAdminCommand', {callback: true, promise:true});
	
	/**
	 * Creates an index on the db and collection collection.
	 * @method
	 * @param {string} name Name of the collection to create the index on.
	 * @param {(string|object)} fieldOrSpec Defines the index.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.unique=false] Creates an unique index.
	 * @param {boolean} [options.sparse=false] Creates a sparse index.
	 * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.
	 * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
	 * @param {number} [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
	 * @param {number} [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
	 * @param {number} [options.v=null] Specify the format version of the indexes.
	 * @param {number} [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
	 * @param {number} [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
	 * @param {object} [options.partialFilterExpression=null] Creates a partial index based on the given filter object (MongoDB 3.2 or higher)
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.createIndex = function(name, fieldOrSpec, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() || {} : {};
	  options = typeof callback === 'function' ? options : callback;
	  options = options == null ? {} : options;
	  // Shallow clone the options
	  options = shallowClone(options);
	
	  // If we have a callback fallback
	  if(typeof callback == 'function') return createIndex(self, name, fieldOrSpec, options, callback);
	  // Return a promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    createIndex(self, name, fieldOrSpec, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var createIndex = function(self, name, fieldOrSpec, options, callback) {
	  // Get the write concern options
	  var finalOptions = writeConcern({}, self, options, { readPreference: ReadPreference.PRIMARY });
	  // Ensure we have a callback
	  if(finalOptions.writeConcern && typeof callback != 'function') {
	    throw MongoError.create({message: "Cannot use a writeConcern without a provided callback", driver:true});
	  }
	
	  // Run only against primary
	  options.readPreference = ReadPreference.PRIMARY;
	
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	
	  // Attempt to run using createIndexes command
	  createIndexUsingCreateIndexes(self, name, fieldOrSpec, options, function(err, result) {
	    if(err == null) return handleCallback(callback, err, result);
	
	    // 67 = 'CannotCreateIndex' (malformed index options)
	    // 85 = 'IndexOptionsConflict' (index already exists with different options)
	    // 11000 = 'DuplicateKey' (couldn't build unique index because of dupes)
	    // 11600 = 'InterruptedAtShutdown' (interrupted at shutdown)
	    // These errors mean that the server recognized `createIndex` as a command
	    // and so we don't need to fallback to an insert.
	    if(err.code === 67 || err.code == 11000 || err.code === 85 || err.code == 11600) {
	      return handleCallback(callback, err, result);
	    }
	
	    // Create command
	    var doc = createCreateIndexCommand(self, name, fieldOrSpec, options);
	    // Set no key checking
	    finalOptions.checkKeys = false;
	    // Insert document
	    self.s.topology.insert(f("%s.%s", self.s.databaseName, Db.SYSTEM_INDEX_COLLECTION), doc, finalOptions, function(err, result) {
	      if(callback == null) return;
	      if(err) return handleCallback(callback, err);
	      if(result == null) return handleCallback(callback, null, null);
	      if(result.result.writeErrors) return handleCallback(callback, MongoError.create(result.result.writeErrors[0]), null);
	      handleCallback(callback, null, doc.name);
	    });
	  });
	}
	
	define.classMethod('createIndex', {callback: true, promise:true});
	
	/**
	 * Ensures that an index exists, if it does not it creates it
	 * @method
	 * @deprecated since version 2.0
	 * @param {string} name The index name
	 * @param {(string|object)} fieldOrSpec Defines the index.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.unique=false] Creates an unique index.
	 * @param {boolean} [options.sparse=false] Creates a sparse index.
	 * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.
	 * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
	 * @param {number} [options.min=null] For geospatial indexes set the lower bound for the co-ordinates.
	 * @param {number} [options.max=null] For geospatial indexes set the high bound for the co-ordinates.
	 * @param {number} [options.v=null] Specify the format version of the indexes.
	 * @param {number} [options.expireAfterSeconds=null] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
	 * @param {number} [options.name=null] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.ensureIndex = function(name, fieldOrSpec, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // If we have a callback fallback
	  if(typeof callback == 'function') return ensureIndex(self, name, fieldOrSpec, options, callback);
	
	  // Return a promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    ensureIndex(self, name, fieldOrSpec, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var ensureIndex = function(self, name, fieldOrSpec, options, callback) {
	  // Get the write concern options
	  var finalOptions = writeConcern({}, self, options);
	  // Create command
	  var selector = createCreateIndexCommand(self, name, fieldOrSpec, options);
	  var index_name = selector.name;
	
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	
	  // Merge primary readPreference
	  finalOptions.readPreference = ReadPreference.PRIMARY
	
	  // Check if the index allready exists
	  self.indexInformation(name, finalOptions, function(err, indexInformation) {
	    if(err != null && err.code != 26) return handleCallback(callback, err, null);
	    // If the index does not exist, create it
	    if(indexInformation == null || !indexInformation[index_name])  {
	      self.createIndex(name, fieldOrSpec, options, callback);
	    } else {
	      if(typeof callback === 'function') return handleCallback(callback, null, index_name);
	    }
	  });
	}
	
	define.classMethod('ensureIndex', {callback: true, promise:true});
	
	Db.prototype.addChild = function(db) {
	  if(this.s.parentDb) return this.s.parentDb.addChild(db);
	  this.s.children.push(db);
	}
	
	/**
	 * Create a new Db instance sharing the current socket connections. Be aware that the new db instances are
	 * related in a parent-child relationship to the original instance so that events are correctly emitted on child
	 * db instances. Child db instances are cached so performing db('db1') twice will return the same instance.
	 * You can control these behaviors with the options noListener and returnNonCachedInstance.
	 *
	 * @method
	 * @param {string} name The name of the database we want to use.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.noListener=false] Do not make the db an event listener to the original connection.
	 * @param {boolean} [options.returnNonCachedInstance=false] Control if you want to return a cached instance or have a new one created
	 * @return {Db}
	 */
	Db.prototype.db = function(dbName, options) {
	  options = options || {};
	
	  // Copy the options and add out internal override of the not shared flag
	  var finalOptions = assign({}, this.options, options);
	
	  // Do we have the db in the cache already
	  if(this.s.dbCache[dbName] && finalOptions.returnNonCachedInstance !== true) {
	    return this.s.dbCache[dbName];
	  }
	
	  // Add current db as parentDb
	  if(finalOptions.noListener == null || finalOptions.noListener == false) {
	    finalOptions.parentDb = this;
	  }
	
	  // Add promiseLibrary
	  finalOptions.promiseLibrary = this.s.promiseLibrary;
	
	  // Return the db object
	  var db = new Db(dbName, this.s.topology, finalOptions)
	
	  // Add as child
	  if(finalOptions.noListener == null || finalOptions.noListener == false) {
	    this.addChild(db);
	  }
	
	  // Add the db to the cache
	  this.s.dbCache[dbName] = db;
	  // Return the database
	  return db;
	};
	
	define.classMethod('db', {callback: false, promise:false, returns: [Db]});
	
	var _executeAuthCreateUserCommand = function(self, username, password, options, callback) {
	  // Special case where there is no password ($external users)
	  if(typeof username == 'string'
	    && password != null && typeof password == 'object') {
	    options = password;
	    password = null;
	  }
	
	  // Unpack all options
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  // Error out if we digestPassword set
	  if(options.digestPassword != null) {
	    throw toError("The digestPassword option is not supported via add_user. Please use db.command('createUser', ...) instead for this option.");
	  }
	
	  // Get additional values
	  var customData = options.customData != null ? options.customData : {};
	  var roles = Array.isArray(options.roles) ? options.roles : [];
	  var maxTimeMS = typeof options.maxTimeMS == 'number' ? options.maxTimeMS : null;
	
	  // If not roles defined print deprecated message
	  if(roles.length == 0) {
	    console.log("Creating a user without roles is deprecated in MongoDB >= 2.6");
	  }
	
	  // Get the error options
	  var commandOptions = {writeCommand:true};
	  if(options['dbName']) commandOptions.dbName = options['dbName'];
	
	  // Add maxTimeMS to options if set
	  if(maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;
	
	  // Check the db name and add roles if needed
	  if((self.databaseName.toLowerCase() == 'admin' || options.dbName == 'admin') && !Array.isArray(options.roles)) {
	    roles = ['root']
	  } else if(!Array.isArray(options.roles)) {
	    roles = ['dbOwner']
	  }
	
	  // Build the command to execute
	  var command = {
	      createUser: username
	    , customData: customData
	    , roles: roles
	    , digestPassword:false
	  }
	
	  // Apply write concern to command
	  command = writeConcern(command, self, options);
	
	  // Use node md5 generator
	  var md5 = crypto.createHash('md5');
	  // Generate keys used for authentication
	  md5.update(username + ":mongo:" + password);
	  var userPassword = md5.digest('hex');
	
	  // No password
	  if(typeof password == 'string') {
	    command.pwd = userPassword;
	  }
	
	  // Force write using primary
	  commandOptions.readPreference = ReadPreference.primary;
	
	  // Execute the command
	  self.command(command, commandOptions, function(err, result) {
	    if(err && err.ok == 0 && err.code == undefined) return handleCallback(callback, {code: -5000}, null);
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, !result.ok ? toError(result) : null
	      , result.ok ? [{user: username, pwd: ''}] : null);
	  })
	}
	
	var addUser = function(self, username, password, options, callback) {
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	  // Attempt to execute auth command
	  _executeAuthCreateUserCommand(self, username, password, options, function(err, r) {
	    // We need to perform the backward compatible insert operation
	    if(err && err.code == -5000) {
	      var finalOptions = writeConcern(shallowClone(options), self, options);
	      // Use node md5 generator
	      var md5 = crypto.createHash('md5');
	      // Generate keys used for authentication
	      md5.update(username + ":mongo:" + password);
	      var userPassword = md5.digest('hex');
	
	      // If we have another db set
	      var db = options.dbName ? self.db(options.dbName) : self;
	
	      // Fetch a user collection
	      var collection = db.collection(Db.SYSTEM_USER_COLLECTION);
	
	      // Check if we are inserting the first user
	      collection.count({}, function(err, count) {
	        // We got an error (f.ex not authorized)
	        if(err != null) return handleCallback(callback, err, null);
	        // Check if the user exists and update i
	        collection.find({user: username}, {dbName: options['dbName']}).toArray(function(err) {
	          // We got an error (f.ex not authorized)
	          if(err != null) return handleCallback(callback, err, null);
	          // Add command keys
	          finalOptions.upsert = true;
	
	          // We have a user, let's update the password or upsert if not
	          collection.update({user: username},{$set: {user: username, pwd: userPassword}}, finalOptions, function(err) {
	            if(count == 0 && err) return handleCallback(callback, null, [{user:username, pwd:userPassword}]);
	            if(err) return handleCallback(callback, err, null)
	            handleCallback(callback, null, [{user:username, pwd:userPassword}]);
	          });
	        });
	      });
	
	      return;
	    }
	
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, err, r);
	  });
	}
	
	/**
	 * Add a user to the database.
	 * @method
	 * @param {string} username The username.
	 * @param {string} password The password.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {object} [options.customData=null] Custom data associated with the user (only Mongodb 2.6 or higher)
	 * @param {object[]} [options.roles=null] Roles associated with the created user (only Mongodb 2.6 or higher)
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.addUser = function(username, password, options, callback) {
	  // Unpack the parameters
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() || {} : {};
	
	  // If we have a callback fallback
	  if(typeof callback == 'function') return addUser(self, username, password, options, callback);
	
	  // Return a promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    addUser(self, username, password, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	define.classMethod('addUser', {callback: true, promise:true});
	
	var _executeAuthRemoveUserCommand = function(self, username, options, callback) {
	  if(typeof options == 'function') callback = options, options = {};
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	  // Get the error options
	  var commandOptions = {writeCommand:true};
	  if(options['dbName']) commandOptions.dbName = options['dbName'];
	
	  // Get additional values
	  var maxTimeMS = typeof options.maxTimeMS == 'number' ? options.maxTimeMS : null;
	
	  // Add maxTimeMS to options if set
	  if(maxTimeMS != null) commandOptions.maxTimeMS = maxTimeMS;
	
	  // Build the command to execute
	  var command = {
	    dropUser: username
	  }
	
	  // Apply write concern to command
	  command = writeConcern(command, self, options);
	
	  // Force write using primary
	  commandOptions.readPreference = ReadPreference.primary;
	
	  // Execute the command
	  self.command(command, commandOptions, function(err, result) {
	    if(err && !err.ok && err.code == undefined) return handleCallback(callback, {code: -5000});
	    if(err) return handleCallback(callback, err, null);
	    handleCallback(callback, null, result.ok ? true : false);
	  })
	}
	
	var removeUser = function(self, username, options, callback) {
	  // Attempt to execute command
	  _executeAuthRemoveUserCommand(self, username, options, function(err, result) {
	    if(err && err.code == -5000) {
	      var finalOptions = writeConcern(shallowClone(options), self, options);
	      // If we have another db set
	      var db = options.dbName ? self.db(options.dbName) : self;
	
	      // Fetch a user collection
	      var collection = db.collection(Db.SYSTEM_USER_COLLECTION);
	
	      // Locate the user
	      collection.findOne({user: username}, {}, function(err, user) {
	        if(user == null) return handleCallback(callback, err, false);
	        collection.remove({user: username}, finalOptions, function(err) {
	          handleCallback(callback, err, true);
	        });
	      });
	
	      return;
	    }
	
	    if(err) return handleCallback(callback, err);
	    handleCallback(callback, err, result);
	  });
	}
	
	define.classMethod('removeUser', {callback: true, promise:true});
	
	/**
	 * Remove a user from a database
	 * @method
	 * @param {string} username The username.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.removeUser = function(username, options, callback) {
	  // Unpack the parameters
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() || {} : {};
	
	  // If we have a callback fallback
	  if(typeof callback == 'function') return removeUser(self, username, options, callback);
	
	  // Return a promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    removeUser(self, username, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	/**
	 * Authenticate a user against the server.
	 * @method
	 * @param {string} username The username.
	 * @param {string} [password] The password.
	 * @param {object} [options=null] Optional settings.
	 * @param {string} [options.authMechanism=MONGODB-CR] The authentication mechanism to use, GSSAPI, MONGODB-CR, MONGODB-X509, PLAIN
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated This method will no longer be available in the next major release 3.x as MongoDB 3.6 will only allow auth against users in the admin db and will no longer allow multiple credentials on a socket. Please authenticate using MongoClient.connect with auth credentials.
	 */
	Db.prototype.authenticate = function(username, password, options, callback) {
	  console.warn("Db.prototype.authenticate method will no longer be available in the next major release 3.x as MongoDB 3.6 will only allow auth against users in the admin db and will no longer allow multiple credentials on a socket. Please authenticate using MongoClient.connect with auth credentials.");
	  return authenticate.apply(this, [this].concat(Array.prototype.slice.call(arguments)));
	};
	
	define.classMethod('authenticate', {callback: true, promise:true});
	
	/**
	 * Logout user from server, fire off on all connections and remove all auth info
	 * @method
	 * @param {object} [options=null] Optional settings.
	 * @param {string} [options.dbName=null] Logout against different database than current.
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.logout = function(options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // Establish the correct database name
	  var dbName = this.s.authSource ? this.s.authSource : this.s.databaseName;
	  dbName = options.dbName ? options.dbName : dbName;
	
	  // If we have a callback
	  if(typeof callback == 'function') {
	    return self.s.topology.logout(dbName, function(err) {
	      if(err) return callback(err);
	      callback(null, true);
	    });
	  }
	
	  // Return a promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.topology.logout(dbName, function(err) {
	      if(err) return reject(err);
	      resolve(true);
	    });
	  });
	}
	
	define.classMethod('logout', {callback: true, promise:true});
	
	/**
	 * Retrieves this collections index info.
	 * @method
	 * @param {string} name The name of the collection.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.full=false] Returns the full raw index information.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {Db~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Db.prototype.indexInformation = function(name, options, callback) {
	  var self = this;
	  if(typeof options == 'function') callback = options, options = {};
	  options = options || {};
	
	  // If we have a callback fallback
	  if(typeof callback == 'function') return indexInformation(self, name, options, callback);
	
	  // Return a promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    indexInformation(self, name, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var indexInformation = function(self, name, options, callback) {
	    // If we specified full information
	  var full = options['full'] == null ? false : options['full'];
	
	  // Did the user destroy the topology
	  if(self.serverConfig && self.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed'));
	  // Process all the results from the index command and collection
	  var processResults = function(indexes) {
	    // Contains all the information
	    var info = {};
	    // Process all the indexes
	    for(var i = 0; i < indexes.length; i++) {
	      var index = indexes[i];
	      // Let's unpack the object
	      info[index.name] = [];
	      for(var name in index.key) {
	        info[index.name].push([name, index.key[name]]);
	      }
	    }
	
	    return info;
	  }
	
	  // Get the list of indexes of the specified collection
	  self.collection(name).listIndexes(options).toArray(function(err, indexes) {
	    if(err) return callback(toError(err));
	    if(!Array.isArray(indexes)) return handleCallback(callback, null, []);
	    if(full) return handleCallback(callback, null, indexes);
	    handleCallback(callback, null, processResults(indexes));
	  });
	}
	
	define.classMethod('indexInformation', {callback: true, promise:true});
	
	var createCreateIndexCommand = function(db, name, fieldOrSpec, options) {
	  var indexParameters = parseIndexOptions(fieldOrSpec);
	  var fieldHash = indexParameters.fieldHash;
	
	  // Generate the index name
	  var indexName = typeof options.name == 'string' ? options.name : indexParameters.name;
	  var selector = {
	    'ns': db.databaseName + "." + name, 'key': fieldHash, 'name': indexName
	  }
	
	  // Ensure we have a correct finalUnique
	  var finalUnique = options == null || 'object' === typeof options ? false : options;
	  // Set up options
	  options = options == null || typeof options == 'boolean' ? {} : options;
	
	  // Add all the options
	  var keysToOmit = Object.keys(selector);
	  for(var optionName in options) {
	    if(keysToOmit.indexOf(optionName) == -1) {
	      selector[optionName] = options[optionName];
	    }
	  }
	
	  if(selector['unique'] == null) selector['unique'] = finalUnique;
	
	  // Remove any write concern operations
	  var removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference'];
	  for(var i = 0; i < removeKeys.length; i++) {
	    delete selector[removeKeys[i]];
	  }
	
	  // Return the command creation selector
	  return selector;
	}
	
	var createIndexUsingCreateIndexes = function(self, name, fieldOrSpec, options, callback) {
	  // Build the index
	  var indexParameters = parseIndexOptions(fieldOrSpec);
	  // Generate the index name
	  var indexName = typeof options.name == 'string' ? options.name : indexParameters.name;
	  // Set up the index
	  var indexes = [{ name: indexName, key: indexParameters.fieldHash }];
	  // merge all the options
	  var keysToOmit = Object.keys(indexes[0]);
	  for(var optionName in options) {
	    if(keysToOmit.indexOf(optionName) == -1) {
	      indexes[0][optionName] = options[optionName];
	    }
	
	    // Remove any write concern operations
	    var removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference'];
	    for(var i = 0; i < removeKeys.length; i++) {
	      delete indexes[0][removeKeys[i]];
	    }
	  }
	
	  // Get capabilities
	  var capabilities = self.s.topology.capabilities();
	
	  // Did the user pass in a collation, check if our write server supports it
	  if(indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {
	    // Create a new error
	    var error = new MongoError(f('server/primary/mongos does not support collation'));
	    error.code = 67;
	    // Return the error
	    return callback(error);
	  }
	
	  // Create command, apply write concern to command
	  var cmd = writeConcern({createIndexes: name, indexes: indexes}, self, options);
	
	  // Decorate command with writeConcern if supported
	  decorateWithWriteConcern(cmd, self, options);
	
	  // ReadPreference primary
	  options.readPreference = ReadPreference.PRIMARY;
	
	  // Build the command
	  self.command(cmd, options, function(err, result) {
	    if(err) return handleCallback(callback, err, null);
	    if(result.ok == 0) return handleCallback(callback, toError(result), null);
	    // Return the indexName for backward compatibility
	    handleCallback(callback, null, indexName);
	  });
	}
	
	// Validate the database name
	var validateDatabaseName = function(databaseName) {
	  if(typeof databaseName !== 'string') throw MongoError.create({message: "database name must be a string", driver:true});
	  if(databaseName.length === 0) throw MongoError.create({message: "database name cannot be the empty string", driver:true});
	  if(databaseName == '$external') return;
	
	  var invalidChars = [" ", ".", "$", "/", "\\"];
	  for(var i = 0; i < invalidChars.length; i++) {
	    if(databaseName.indexOf(invalidChars[i]) != -1) throw MongoError.create({message: "database names cannot contain the character '" + invalidChars[i] + "'", driver:true});
	  }
	}
	
	// Get write concern
	var writeConcern = function(target, db, options) {
	  if(options.w != null || options.j != null || options.fsync != null) {
	    var opts = {};
	    if(options.w) opts.w = options.w;
	    if(options.wtimeout) opts.wtimeout = options.wtimeout;
	    if(options.j) opts.j = options.j;
	    if(options.fsync) opts.fsync = options.fsync;
	    target.writeConcern = opts;
	  } else if(db.writeConcern.w != null || db.writeConcern.j != null || db.writeConcern.fsync != null) {
	    target.writeConcern = db.writeConcern;
	  }
	
	  return target
	}
	
	// Add listeners to topology
	var createListener = function(self, e, object) {
	  var listener = function(err) {
	    if(object.listeners(e).length > 0) {
	      object.emit(e, err, self);
	
	      // Emit on all associated db's if available
	      for(var i = 0; i < self.s.children.length; i++) {
	        self.s.children[i].emit(e, err, self.s.children[i]);
	      }
	    }
	  }
	  return listener;
	}
	
	
	/**
	 * Unref all sockets
	 * @method
	 */
	Db.prototype.unref = function() {
	  this.s.topology.unref();
	}
	
	/**
	 * Db close event
	 *
	 * Emitted after a socket closed against a single server or mongos proxy.
	 *
	 * @event Db#close
	 * @type {MongoError}
	 */
	
	/**
	 * Db authenticated event
	 *
	 * Emitted after all server members in the topology (single server, replicaset or mongos) have successfully authenticated.
	 *
	 * @event Db#authenticated
	 * @type {object}
	 */
	
	/**
	 * Db reconnect event
	 *
	 *  * Server: Emitted when the driver has reconnected and re-authenticated.
	 *  * ReplicaSet: N/A
	 *  * Mongos: Emitted when the driver reconnects and re-authenticates successfully against a Mongos.
	 *
	 * @event Db#reconnect
	 * @type {object}
	 */
	
	/**
	 * Db error event
	 *
	 * Emitted after an error occurred against a single server or mongos proxy.
	 *
	 * @event Db#error
	 * @type {MongoError}
	 */
	
	/**
	 * Db timeout event
	 *
	 * Emitted after a socket timeout occurred against a single server or mongos proxy.
	 *
	 * @event Db#timeout
	 * @type {MongoError}
	 */
	
	/**
	 * Db parseError event
	 *
	 * The parseError event is emitted if the driver detects illegal or corrupt BSON being received from the server.
	 *
	 * @event Db#parseError
	 * @type {MongoError}
	 */
	
	/**
	 * Db fullsetup event, emitted when all servers in the topology have been connected to at start up time.
	 *
	 * * Server: Emitted when the driver has connected to the single server and has authenticated.
	 * * ReplSet: Emitted after the driver has attempted to connect to all replicaset members.
	 * * Mongos: Emitted after the driver has attempted to connect to all mongos proxies.
	 *
	 * @event Db#fullsetup
	 * @type {Db}
	 */
	
	// Constants
	Db.SYSTEM_NAMESPACE_COLLECTION = "system.namespaces";
	Db.SYSTEM_INDEX_COLLECTION = "system.indexes";
	Db.SYSTEM_PROFILE_COLLECTION = "system.profile";
	Db.SYSTEM_USER_COLLECTION = "system.users";
	Db.SYSTEM_COMMAND_COLLECTION = "$cmd";
	Db.SYSTEM_JS_COLLECTION = "system.js";
	
	module.exports = Db;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var StrictModeError = __webpack_require__(93);
	var Types = __webpack_require__(139);
	var util = __webpack_require__(1);
	var utils = __webpack_require__(4);
	
	var ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];
	
	/**
	 * Handles internal casting for queries
	 *
	 * @param {Schema} schema
	 * @param {Object} obj Object to cast
	 * @param {Object} options the query options
	 * @param {Query} context passed to setters
	 * @api private
	 */
	module.exports = function cast(schema, obj, options, context) {
	  if (Array.isArray(obj)) {
	    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));
	  }
	
	  var paths = Object.keys(obj);
	  var i = paths.length;
	  var _keys;
	  var any$conditionals;
	  var schematype;
	  var nested;
	  var path;
	  var type;
	  var val;
	
	  while (i--) {
	    path = paths[i];
	    val = obj[path];
	
	    if (path === '$or' || path === '$nor' || path === '$and') {
	      var k = val.length;
	
	      while (k--) {
	        val[k] = cast(schema, val[k], options, context);
	      }
	    } else if (path === '$where') {
	      type = typeof val;
	
	      if (type !== 'string' && type !== 'function') {
	        throw new Error('Must have a string or function for $where');
	      }
	
	      if (type === 'function') {
	        obj[path] = val.toString();
	      }
	
	      continue;
	    } else if (path === '$elemMatch') {
	      val = cast(schema, val, options, context);
	    } else {
	      if (!schema) {
	        // no casting for Mixed types
	        continue;
	      }
	
	      schematype = schema.path(path);
	
	      if (!schematype) {
	        // Handle potential embedded array queries
	        var split = path.split('.'),
	            j = split.length,
	            pathFirstHalf,
	            pathLastHalf,
	            remainingConds;
	
	        // Find the part of the var path that is a path of the Schema
	        while (j--) {
	          pathFirstHalf = split.slice(0, j).join('.');
	          schematype = schema.path(pathFirstHalf);
	          if (schematype) {
	            break;
	          }
	        }
	
	        // If a substring of the input path resolves to an actual real path...
	        if (schematype) {
	          // Apply the casting; similar code for $elemMatch in schema/array.js
	          if (schematype.caster && schematype.caster.schema) {
	            remainingConds = {};
	            pathLastHalf = split.slice(j).join('.');
	            remainingConds[pathLastHalf] = val;
	            obj[path] = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];
	          } else {
	            obj[path] = val;
	          }
	          continue;
	        }
	
	        if (utils.isObject(val)) {
	          // handle geo schemas that use object notation
	          // { loc: { long: Number, lat: Number }
	
	          var geo = '';
	          if (val.$near) {
	            geo = '$near';
	          } else if (val.$nearSphere) {
	            geo = '$nearSphere';
	          } else if (val.$within) {
	            geo = '$within';
	          } else if (val.$geoIntersects) {
	            geo = '$geoIntersects';
	          } else if (val.$geoWithin) {
	            geo = '$geoWithin';
	          }
	
	          if (geo) {
	            var numbertype = new Types.Number('__QueryCasting__');
	            var value = val[geo];
	
	            if (val.$maxDistance != null) {
	              val.$maxDistance = numbertype.castForQueryWrapper({
	                val: val.$maxDistance,
	                context: context
	              });
	            }
	            if (val.$minDistance != null) {
	              val.$minDistance = numbertype.castForQueryWrapper({
	                val: val.$minDistance,
	                context: context
	              });
	            }
	
	            if (geo === '$within') {
	              var withinType = value.$center
	                  || value.$centerSphere
	                  || value.$box
	                  || value.$polygon;
	
	              if (!withinType) {
	                throw new Error('Bad $within paramater: ' + JSON.stringify(val));
	              }
	
	              value = withinType;
	            } else if (geo === '$near' &&
	                typeof value.type === 'string' && Array.isArray(value.coordinates)) {
	              // geojson; cast the coordinates
	              value = value.coordinates;
	            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&
	                value.$geometry && typeof value.$geometry.type === 'string' &&
	                Array.isArray(value.$geometry.coordinates)) {
	              if (value.$maxDistance != null) {
	                value.$maxDistance = numbertype.castForQueryWrapper({
	                  val: value.$maxDistance,
	                  context: context
	                });
	              }
	              if (value.$minDistance != null) {
	                value.$minDistance = numbertype.castForQueryWrapper({
	                  val: value.$minDistance,
	                  context: context
	                });
	              }
	              if (utils.isMongooseObject(value.$geometry)) {
	                value.$geometry = value.$geometry.toObject({
	                  transform: false,
	                  virtuals: false
	                });
	              }
	              value = value.$geometry.coordinates;
	            } else if (geo === '$geoWithin') {
	              if (value.$geometry) {
	                if (utils.isMongooseObject(value.$geometry)) {
	                  value.$geometry = value.$geometry.toObject({ virtuals: false });
	                }
	                var geoWithinType = value.$geometry.type;
	                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {
	                  throw new Error('Invalid geoJSON type for $geoWithin "' +
	                    geoWithinType + '", must be "Polygon" or "MultiPolygon"');
	                }
	                value = value.$geometry.coordinates;
	              } else {
	                value = value.$box || value.$polygon || value.$center ||
	                  value.$centerSphere;
	                if (utils.isMongooseObject(value)) {
	                  value = value.toObject({ virtuals: false });
	                }
	              }
	            }
	
	            _cast(value, numbertype, context);
	            continue;
	          }
	        }
	
	        if (options && options.upsert && options.strict && !schema.nested[path]) {
	          if (options.strict === 'throw') {
	            throw new StrictModeError(path);
	          }
	          throw new StrictModeError(path, 'Path "' + path + '" is not in ' +
	            'schema, strict mode is `true`, and upsert is `true`.');
	        } else if (options && options.strictQuery === 'throw') {
	          throw new StrictModeError(path, 'Path "' + path + '" is not in ' +
	            'schema and strictQuery is true.');
	        }
	      } else if (val === null || val === undefined) {
	        obj[path] = null;
	        continue;
	      } else if (val.constructor.name === 'Object') {
	        any$conditionals = Object.keys(val).some(function(k) {
	          return k.charAt(0) === '$' && k !== '$id' && k !== '$ref';
	        });
	
	        if (!any$conditionals) {
	          obj[path] = schematype.castForQueryWrapper({
	            val: val,
	            context: context
	          });
	        } else {
	          var ks = Object.keys(val),
	              $cond;
	
	          k = ks.length;
	
	          while (k--) {
	            $cond = ks[k];
	            nested = val[$cond];
	
	            if ($cond === '$not') {
	              if (nested && schematype && !schematype.caster) {
	                _keys = Object.keys(nested);
	                if (_keys.length && _keys[0].charAt(0) === '$') {
	                  for (var key in nested) {
	                    nested[key] = schematype.castForQueryWrapper({
	                      $conditional: key,
	                      val: nested[key],
	                      context: context
	                    });
	                  }
	                } else {
	                  val[$cond] = schematype.castForQueryWrapper({
	                    $conditional: $cond,
	                    val: nested,
	                    context: context
	                  });
	                }
	                continue;
	              }
	              cast(schematype.caster ? schematype.caster.schema : schema, nested, options, context);
	            } else {
	              val[$cond] = schematype.castForQueryWrapper({
	                $conditional: $cond,
	                val: nested,
	                context: context
	              });
	            }
	          }
	        }
	      } else if (val.constructor.name === 'Array' && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {
	        var casted = [];
	        for (var valIndex = 0; valIndex < val.length; valIndex++) {
	          casted.push(schematype.castForQueryWrapper({
	            val: val[valIndex],
	            context: context
	          }));
	        }
	
	        obj[path] = { $in: casted };
	      } else {
	        obj[path] = schematype.castForQueryWrapper({
	          val: val,
	          context: context
	        });
	      }
	    }
	  }
	
	  return obj;
	};
	
	function _cast(val, numbertype, context) {
	  if (Array.isArray(val)) {
	    val.forEach(function(item, i) {
	      if (Array.isArray(item) || utils.isObject(item)) {
	        return _cast(item, numbertype, context);
	      }
	      val[i] = numbertype.castForQueryWrapper({ val: item, context: context });
	    });
	  } else {
	    var nearKeys = Object.keys(val);
	    var nearLen = nearKeys.length;
	    while (nearLen--) {
	      var nkey = nearKeys[nearLen];
	      var item = val[nkey];
	      if (Array.isArray(item) || utils.isObject(item)) {
	        _cast(item, numbertype, context);
	        val[nkey] = item;
	      } else {
	        val[nkey] = numbertype.castForQuery({ val: item, context: context });
	      }
	    }
	  }
	}


/***/ }),
/* 84 */
/***/ (function(module, exports) {

	/*!
	 * ignore
	 */
	
	module.exports = function() {};


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var Binary = __webpack_require__(25).Binary;
	
	/*!
	 * Module exports.
	 */
	
	module.exports = exports = Binary;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	
	/*!
	 * [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) ObjectId
	 * @constructor NodeMongoDbObjectId
	 * @see ObjectId
	 */
	
	var ObjectId = __webpack_require__(25).ObjectID;
	
	/*!
	 * ignore
	 */
	
	module.exports = exports = ObjectId;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var mongodb = __webpack_require__(22);
	var ReadPref = mongodb.ReadPreference;
	
	/*!
	 * Converts arguments to ReadPrefs the driver
	 * can understand.
	 *
	 * @param {String|Array} pref
	 * @param {Array} [tags]
	 */
	
	module.exports = function readPref(pref, tags) {
	  if (Array.isArray(pref)) {
	    tags = pref[1];
	    pref = pref[0];
	  }
	
	  if (pref instanceof ReadPref) {
	    return pref;
	  }
	
	  switch (pref) {
	    case 'p':
	      pref = 'primary';
	      break;
	    case 'pp':
	      pref = 'primaryPreferred';
	      break;
	    case 's':
	      pref = 'secondary';
	      break;
	    case 'sp':
	      pref = 'secondaryPreferred';
	      break;
	    case 'n':
	      pref = 'nearest';
	      break;
	  }
	
	  return new ReadPref(pref, tags);
	};


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var Binary = __webpack_require__(22).Binary;
	
	module.exports = exports = Binary;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseCollection = __webpack_require__(130);
	var Collection = __webpack_require__(22).Collection;
	var util = __webpack_require__(1);
	var utils = __webpack_require__(4);
	
	/**
	 * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) collection implementation.
	 *
	 * All methods methods from the [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver are copied and wrapped in queue management.
	 *
	 * @inherits Collection
	 * @api private
	 */
	
	function NativeCollection() {
	  this.collection = null;
	  MongooseCollection.apply(this, arguments);
	}
	
	/*!
	 * Inherit from abstract Collection.
	 */
	
	NativeCollection.prototype.__proto__ = MongooseCollection.prototype;
	
	/**
	 * Called when the connection opens.
	 *
	 * @api private
	 */
	
	NativeCollection.prototype.onOpen = function() {
	  var _this = this;
	
	  // always get a new collection in case the user changed host:port
	  // of parent db instance when re-opening the connection.
	
	  if (!_this.opts.capped.size) {
	    // non-capped
	    callback(null, _this.conn.db.collection(_this.name));
	    return _this.collection;
	  }
	
	  // capped
	  return _this.conn.db.collection(_this.name, function(err, c) {
	    if (err) return callback(err);
	
	    // discover if this collection exists and if it is capped
	    _this.conn.db.listCollections({name: _this.name}).toArray(function(err, docs) {
	      if (err) {
	        return callback(err);
	      }
	      var doc = docs[0];
	      var exists = !!doc;
	
	      if (exists) {
	        if (doc.options && doc.options.capped) {
	          callback(null, c);
	        } else {
	          var msg = 'A non-capped collection exists with the name: ' + _this.name + '\n\n'
	              + ' To use this collection as a capped collection, please '
	              + 'first convert it.\n'
	              + ' http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-Convertingacollectiontocapped';
	          err = new Error(msg);
	          callback(err);
	        }
	      } else {
	        // create
	        var opts = utils.clone(_this.opts.capped);
	        opts.capped = true;
	        _this.conn.db.createCollection(_this.name, opts, callback);
	      }
	    });
	  });
	
	  function callback(err, collection) {
	    if (err) {
	      // likely a strict mode error
	      _this.conn.emit('error', err);
	    } else {
	      _this.collection = collection;
	      MongooseCollection.prototype.onOpen.call(_this);
	    }
	  }
	};
	
	/**
	 * Called when the connection closes
	 *
	 * @api private
	 */
	
	NativeCollection.prototype.onClose = function(force) {
	  MongooseCollection.prototype.onClose.call(this, force);
	};
	
	/*!
	 * Copy the collection methods and make them subject to queues
	 */
	
	function iter(i) {
	  NativeCollection.prototype[i] = function() {
	    // If user force closed, queueing will hang forever. See #5664
	    if (this.opts.$wasForceClosed) {
	      return this.conn.db.collection(this.name)[i].apply(collection, args);
	    }
	    if (this.buffer) {
	      this.addQueue(i, arguments);
	      return;
	    }
	
	    var collection = this.collection;
	    var args = arguments;
	    var _this = this;
	    var debug = _this.conn.base.options.debug;
	
	    if (debug) {
	      if (typeof debug === 'function') {
	        debug.apply(_this,
	          [_this.name, i].concat(utils.args(args, 0, args.length - 1)));
	      } else {
	        this.$print(_this.name, i, args);
	      }
	    }
	
	    try {
	      return collection[i].apply(collection, args);
	    } catch (error) {
	      // Collection operation may throw because of max bson size, catch it here
	      // See gh-3906
	      if (args.length > 0 &&
	          typeof args[args.length - 1] === 'function') {
	        args[args.length - 1](error);
	      } else {
	        throw error;
	      }
	    }
	  };
	}
	
	for (var i in Collection.prototype) {
	  // Janky hack to work around gh-3005 until we can get rid of the mongoose
	  // collection abstraction
	  try {
	    if (typeof Collection.prototype[i] !== 'function') {
	      continue;
	    }
	  } catch (e) {
	    continue;
	  }
	
	  iter(i);
	}
	
	/*!
	 * ignore
	 */
	
	Collection.prototype.ensureIndex = util.deprecate(Collection.prototype.ensureIndex,
	  '`ensureIndex()` is deprecated in Mongoose >= 4.12.0, use `createIndex()` instead');
	
	/**
	 * Debug print helper
	 *
	 * @api public
	 * @method $print
	 */
	
	NativeCollection.prototype.$print = function(name, i, args) {
	  var moduleName = '\x1B[0;36mMongoose:\x1B[0m ';
	  var functionCall = [name, i].join('.');
	  var _args = [];
	  for (var j = args.length - 1; j >= 0; --j) {
	    if (this.$format(args[j]) || _args.length) {
	      _args.unshift(this.$format(args[j]));
	    }
	  }
	  var params = '(' + _args.join(', ') + ')';
	
	  console.error(moduleName + functionCall + params);
	};
	
	/**
	 * Formatter for debug print args
	 *
	 * @api public
	 * @method $format
	 */
	
	NativeCollection.prototype.$format = function(arg) {
	  var type = typeof arg;
	  if (type === 'function' || type === 'undefined') return '';
	  return format(arg);
	};
	
	/*!
	 * Debug print helper
	 */
	
	function map(o) {
	  return format(o, true);
	}
	function formatObjectId(x, key) {
	  var representation = 'ObjectId("' + x[key].toHexString() + '")';
	  x[key] = {inspect: function() { return representation; }};
	}
	function formatDate(x, key) {
	  var representation = 'new Date("' + x[key].toUTCString() + '")';
	  x[key] = {inspect: function() { return representation; }};
	}
	function format(obj, sub) {
	  if (obj && typeof obj.toBSON === 'function') {
	    obj = obj.toBSON();
	  }
	  var x = utils.clone(obj, {retainKeyOrder: 1, transform: false});
	  var representation;
	
	  if (x != null) {
	    if (x.constructor.name === 'Binary') {
	      x = 'BinData(' + x.sub_type + ', "' + x.toString('base64') + '")';
	    } else if (x.constructor.name === 'ObjectID') {
	      representation = 'ObjectId("' + x.toHexString() + '")';
	      x = {inspect: function() { return representation; }};
	    } else if (x.constructor.name === 'Date') {
	      representation = 'new Date("' + x.toUTCString() + '")';
	      x = {inspect: function() { return representation; }};
	    } else if (x.constructor.name === 'Object') {
	      var keys = Object.keys(x);
	      var numKeys = keys.length;
	      var key;
	      for (var i = 0; i < numKeys; ++i) {
	        key = keys[i];
	        if (x[key]) {
	          if (typeof x[key].toBSON === 'function') {
	            x[key] = x[key].toBSON();
	          }
	          if (x[key].constructor.name === 'Binary') {
	            x[key] = 'BinData(' + x[key].sub_type + ', "' +
	              x[key].buffer.toString('base64') + '")';
	          } else if (x[key].constructor.name === 'Object') {
	            x[key] = format(x[key], true);
	          } else if (x[key].constructor.name === 'ObjectID') {
	            formatObjectId(x, key);
	          } else if (x[key].constructor.name === 'Date') {
	            formatDate(x, key);
	          } else if (Array.isArray(x[key])) {
	            x[key] = x[key].map(map);
	          }
	        }
	      }
	    }
	    if (sub) return x;
	  }
	
	  return __webpack_require__(1)
	  .inspect(x, false, 10, true)
	  .replace(/\n/g, '')
	  .replace(/\s{2,}/g, ' ');
	}
	
	/**
	 * Retreives information about this collections indexes.
	 *
	 * @param {Function} callback
	 * @method getIndexes
	 * @api public
	 */
	
	NativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;
	
	/*!
	 * Module exports.
	 */
	
	module.exports = NativeCollection;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseConnection = __webpack_require__(131);
	var mongo = __webpack_require__(22);
	var Db = mongo.Db;
	var Server = mongo.Server;
	var Mongos = mongo.Mongos;
	var STATES = __webpack_require__(61);
	var ReplSetServers = mongo.ReplSet;
	var DisconnectedError = __webpack_require__(213);
	
	/**
	 * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.
	 *
	 * @inherits Connection
	 * @api private
	 */
	
	function NativeConnection() {
	  MongooseConnection.apply(this, arguments);
	  this._listening = false;
	}
	
	/**
	 * Expose the possible connection states.
	 * @api public
	 */
	
	NativeConnection.STATES = STATES;
	
	/*!
	 * Inherits from Connection.
	 */
	
	NativeConnection.prototype.__proto__ = MongooseConnection.prototype;
	
	/**
	 * Opens the connection to MongoDB.
	 *
	 * @param {Function} fn
	 * @return {Connection} this
	 * @api private
	 */
	
	NativeConnection.prototype.doOpen = function(fn) {
	  var _this = this;
	  var server = new Server(this.host, this.port, this.options.server);
	
	  if (this.options && this.options.mongos) {
	    var mongos = new Mongos([server], this.options.mongos);
	    this.db = new Db(this.name, mongos, this.options.db);
	  } else {
	    this.db = new Db(this.name, server, this.options.db);
	  }
	
	  this.db.open(function(err) {
	    listen(_this);
	
	    if (!mongos) {
	      server.s.server.on('error', function(error) {
	        if (/after \d+ attempts/.test(error.message)) {
	          _this.emit('error', new DisconnectedError(server.s.server.name));
	        }
	      });
	    }
	
	    if (err) return fn(err);
	
	    fn();
	  });
	
	  return this;
	};
	
	/**
	 * Switches to a different database using the same connection pool.
	 *
	 * Returns a new connection object, with the new db.
	 *
	 * @param {String} name The database name
	 * @return {Connection} New Connection Object
	 * @api public
	 */
	
	NativeConnection.prototype.useDb = function(name) {
	  // we have to manually copy all of the attributes...
	  var newConn = new this.constructor();
	  newConn.name = name;
	  newConn.base = this.base;
	  newConn.collections = {};
	  newConn.models = {};
	  newConn.replica = this.replica;
	  newConn.hosts = this.hosts;
	  newConn.host = this.host;
	  newConn.port = this.port;
	  newConn.user = this.user;
	  newConn.pass = this.pass;
	  newConn.options = this.options;
	  newConn._readyState = this._readyState;
	  newConn._closeCalled = this._closeCalled;
	  newConn._hasOpened = this._hasOpened;
	  newConn._listening = false;
	
	  // First, when we create another db object, we are not guaranteed to have a
	  // db object to work with. So, in the case where we have a db object and it
	  // is connected, we can just proceed with setting everything up. However, if
	  // we do not have a db or the state is not connected, then we need to wait on
	  // the 'open' event of the connection before doing the rest of the setup
	  // the 'connected' event is the first time we'll have access to the db object
	
	  var _this = this;
	
	  if (this.db && this._readyState === STATES.connected) {
	    wireup();
	  } else {
	    this.once('connected', wireup);
	  }
	
	  function wireup() {
	    newConn.db = _this.db.db(name);
	    newConn.onOpen();
	    // setup the events appropriately
	    listen(newConn);
	  }
	
	  newConn.name = name;
	
	  // push onto the otherDbs stack, this is used when state changes
	  this.otherDbs.push(newConn);
	  newConn.otherDbs.push(this);
	
	  return newConn;
	};
	
	/*!
	 * Register listeners for important events and bubble appropriately.
	 */
	
	function listen(conn) {
	  if (conn.db._listening) {
	    return;
	  }
	  conn.db._listening = true;
	
	  conn.db.on('close', function(force) {
	    if (conn._closeCalled) return;
	
	    // the driver never emits an `open` event. auto_reconnect still
	    // emits a `close` event but since we never get another
	    // `open` we can't emit close
	    if (conn.db.serverConfig.autoReconnect) {
	      conn.readyState = STATES.disconnected;
	      conn.emit('close');
	      return;
	    }
	    conn.onClose(force);
	  });
	  conn.db.on('error', function(err) {
	    conn.emit('error', err);
	  });
	  conn.db.on('reconnect', function() {
	    conn.readyState = STATES.connected;
	    conn.emit('reconnected');
	    conn.onOpen();
	  });
	  conn.db.on('timeout', function(err) {
	    conn.emit('timeout', err);
	  });
	  conn.db.on('open', function(err, db) {
	    if (STATES.disconnected === conn.readyState && db && db.databaseName) {
	      conn.readyState = STATES.connected;
	      conn.emit('reconnected');
	    }
	  });
	  conn.db.on('parseError', function(err) {
	    conn.emit('parseError', err);
	  });
	}
	
	/**
	 * Opens a connection to a MongoDB ReplicaSet.
	 *
	 * See description of [doOpen](#NativeConnection-doOpen) for server options. In this case `options.replset` is also passed to ReplSetServers.
	 *
	 * @param {Function} fn
	 * @api private
	 * @return {Connection} this
	 */
	
	NativeConnection.prototype.doOpenSet = function(fn) {
	  var servers = [],
	      _this = this;
	
	  this.hosts.forEach(function(server) {
	    var host = server.host || server.ipc;
	    var port = server.port || 27017;
	    servers.push(new Server(host, port, _this.options.server));
	  });
	
	  var server = this.options.mongos
	    ? new Mongos(servers, this.options.mongos)
	    : new ReplSetServers(servers, this.options.replset || this.options.replSet);
	  this.db = new Db(this.name, server, this.options.db);
	
	  this.db.on('fullsetup', function() {
	    _this.emit('fullsetup');
	  });
	
	  this.db.on('all', function() {
	    _this.emit('all');
	  });
	
	  this.db.open(function(err) {
	    if (err) return fn(err);
	    fn();
	    listen(_this);
	  });
	
	  return this;
	};
	
	/**
	 * Closes the connection
	 *
	 * @param {Boolean} [force]
	 * @param {Function} [fn]
	 * @return {Connection} this
	 * @api private
	 */
	
	NativeConnection.prototype.doClose = function(force, fn) {
	  this.db.close(force, fn);
	  return this;
	};
	
	/**
	 * Prepares default connection options for the node-mongodb-native driver.
	 *
	 * _NOTE: `passed` options take precedence over connection string options._
	 *
	 * @param {Object} passed options that were passed directly during connection
	 * @param {Object} [connStrOptions] options that were passed in the connection string
	 * @api private
	 */
	
	NativeConnection.prototype.parseOptions = function(passed, connStrOpts) {
	  var o = passed ? __webpack_require__(4).clone(passed) : {};
	
	  o.db || (o.db = {});
	  o.auth || (o.auth = {});
	  o.server || (o.server = {});
	  o.replset || (o.replset = o.replSet) || (o.replset = {});
	  o.server.socketOptions || (o.server.socketOptions = {});
	  o.replset.socketOptions || (o.replset.socketOptions = {});
	  o.mongos || (o.mongos = (connStrOpts && connStrOpts.mongos));
	  (o.mongos === true) && (o.mongos = {});
	
	  var opts = connStrOpts || {};
	  Object.keys(opts).forEach(function(name) {
	    switch (name) {
	      case 'ssl':
	        o.server.ssl = opts.ssl;
	        o.replset.ssl = opts.ssl;
	        o.mongos && (o.mongos.ssl = opts.ssl);
	        break;
	      case 'poolSize':
	        if (typeof o.server[name] === 'undefined') {
	          o.server[name] = o.replset[name] = opts[name];
	        }
	        break;
	      case 'slaveOk':
	        if (typeof o.server.slave_ok === 'undefined') {
	          o.server.slave_ok = opts[name];
	        }
	        break;
	      case 'autoReconnect':
	        if (typeof o.server.auto_reconnect === 'undefined') {
	          o.server.auto_reconnect = opts[name];
	        }
	        break;
	      case 'socketTimeoutMS':
	      case 'connectTimeoutMS':
	        if (typeof o.server.socketOptions[name] === 'undefined') {
	          o.server.socketOptions[name] = o.replset.socketOptions[name] = opts[name];
	        }
	        break;
	      case 'authdb':
	        if (typeof o.auth.authdb === 'undefined') {
	          o.auth.authdb = opts[name];
	        }
	        break;
	      case 'authSource':
	        if (typeof o.auth.authSource === 'undefined') {
	          o.auth.authSource = opts[name];
	        }
	        break;
	      case 'authMechanism':
	        if (typeof o.auth.authMechanism === 'undefined') {
	          o.auth.authMechanism = opts[name];
	        }
	        break;
	      case 'retries':
	      case 'reconnectWait':
	      case 'rs_name':
	        if (typeof o.replset[name] === 'undefined') {
	          o.replset[name] = opts[name];
	        }
	        break;
	      case 'replicaSet':
	        if (typeof o.replset.rs_name === 'undefined') {
	          o.replset.rs_name = opts[name];
	        }
	        break;
	      case 'readSecondary':
	        if (typeof o.replset.read_secondary === 'undefined') {
	          o.replset.read_secondary = opts[name];
	        }
	        break;
	      case 'nativeParser':
	        if (typeof o.db.native_parser === 'undefined') {
	          o.db.native_parser = opts[name];
	        }
	        break;
	      case 'w':
	      case 'safe':
	      case 'fsync':
	      case 'journal':
	      case 'wtimeoutMS':
	        if (typeof o.db[name] === 'undefined') {
	          o.db[name] = opts[name];
	        }
	        break;
	      case 'readPreference':
	        if (typeof o.db.readPreference === 'undefined') {
	          o.db.readPreference = opts[name];
	        }
	        break;
	      case 'readPreferenceTags':
	        if (typeof o.db.read_preference_tags === 'undefined') {
	          o.db.read_preference_tags = opts[name];
	        }
	        break;
	      case 'sslValidate':
	        o.server.sslValidate = opts.sslValidate;
	        o.replset.sslValidate = opts.sslValidate;
	        o.mongos && (o.mongos.sslValidate = opts.sslValidate);
	    }
	  });
	
	  if (!('auto_reconnect' in o.server)) {
	    o.server.auto_reconnect = true;
	  }
	
	  // mongoose creates its own ObjectIds
	  o.db.forceServerObjectId = false;
	
	  // default safe using new nomenclature
	  if (!('journal' in o.db || 'j' in o.db ||
	        'fsync' in o.db || 'safe' in o.db || 'w' in o.db)) {
	    o.db.w = 1;
	  }
	
	  if (o.promiseLibrary) {
	    o.db.promiseLibrary = o.promiseLibrary;
	  }
	
	  validate(o);
	  return o;
	};
	
	/*!
	 * Validates the driver db options.
	 *
	 * @param {Object} o
	 */
	
	function validate(o) {
	  if (o.db.w === -1 || o.db.w === 0) {
	    if (o.db.journal || o.db.fsync || o.db.safe) {
	      throw new Error(
	          'Invalid writeConcern: '
	        + 'w set to -1 or 0 cannot be combined with safe|fsync|journal');
	    }
	  }
	}
	
	/*!
	 * Module exports.
	 */
	
	module.exports = NativeConnection;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module exports.
	 */
	
	exports.Binary = __webpack_require__(88);
	exports.ObjectId = __webpack_require__(92);
	exports.ReadPreference = __webpack_require__(87);


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	
	/*!
	 * [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) ObjectId
	 * @constructor NodeMongoDbObjectId
	 * @see ObjectId
	 */
	
	var ObjectId = __webpack_require__(22).ObjectId;
	
	/*!
	 * ignore
	 */
	
	module.exports = exports = ObjectId;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(5);
	
	/**
	 * Strict mode error constructor
	 *
	 * @param {String} type
	 * @param {String} value
	 * @inherits MongooseError
	 * @api private
	 */
	
	function StrictModeError(path, msg) {
	  msg = msg || 'Field `' + path + '` is not in schema and strict ' +
	    'mode is set to throw.';
	  MongooseError.call(this, msg);
	  this.name = 'StrictModeError';
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	  this.path = path;
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	StrictModeError.prototype = Object.create(MongooseError.prototype);
	StrictModeError.prototype.constructor = MongooseError;
	
	module.exports = StrictModeError;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var CastError = __webpack_require__(44);
	var ObjectParameterError = __webpack_require__(219);
	var PromiseProvider = __webpack_require__(14);
	var QueryCursor = __webpack_require__(211);
	var QueryStream = __webpack_require__(230);
	var cast = __webpack_require__(83);
	var castUpdate = __webpack_require__(146);
	var hasDollarKeys = __webpack_require__(238);
	var helpers = __webpack_require__(63);
	var mquery = __webpack_require__(104);
	var readPref = __webpack_require__(29).ReadPreference;
	var selectPopulatedFields = __webpack_require__(239);
	var setDefaultsOnInsert = __webpack_require__(240);
	var updateValidators = __webpack_require__(241);
	var util = __webpack_require__(1);
	var utils = __webpack_require__(4);
	
	/**
	 * Query constructor used for building queries.
	 *
	 * ####Example:
	 *
	 *     var query = new Query();
	 *     query.setOptions({ lean : true });
	 *     query.collection(model.collection);
	 *     query.where('age').gte(21).exec(callback);
	 *
	 * @param {Object} [options]
	 * @param {Object} [model]
	 * @param {Object} [conditions]
	 * @param {Object} [collection] Mongoose collection
	 * @api private
	 */
	
	function Query(conditions, options, model, collection) {
	  // this stuff is for dealing with custom queries created by #toConstructor
	  if (!this._mongooseOptions) {
	    this._mongooseOptions = {};
	  }
	
	  // this is the case where we have a CustomQuery, we need to check if we got
	  // options passed in, and if we did, merge them in
	  if (options) {
	    var keys = Object.keys(options);
	    for (var i = 0; i < keys.length; ++i) {
	      var k = keys[i];
	      this._mongooseOptions[k] = options[k];
	    }
	  }
	
	  if (collection) {
	    this.mongooseCollection = collection;
	  }
	
	  if (model) {
	    this.model = model;
	    this.schema = model.schema;
	  }
	
	  // this is needed because map reduce returns a model that can be queried, but
	  // all of the queries on said model should be lean
	  if (this.model && this.model._mapreduce) {
	    this.lean();
	  }
	
	  // inherit mquery
	  mquery.call(this, this.mongooseCollection, options);
	
	  if (conditions) {
	    this.find(conditions);
	  }
	
	  this.options = this.options || {};
	  if (this.schema != null && this.schema.options.collation != null) {
	    this.options.collation = this.schema.options.collation;
	  }
	
	  if (this.schema) {
	    var kareemOptions = {
	      useErrorHandlers: true,
	      numCallbackParams: 1,
	      nullResultByDefault: true
	    };
	    this._count = this.model.hooks.createWrapper('count',
	        Query.prototype._count, this, kareemOptions);
	    this._execUpdate = this.model.hooks.createWrapper('update',
	        Query.prototype._execUpdate, this, kareemOptions);
	    this._find = this.model.hooks.createWrapper('find',
	        Query.prototype._find, this, kareemOptions);
	    this._findOne = this.model.hooks.createWrapper('findOne',
	        Query.prototype._findOne, this, kareemOptions);
	    this._findOneAndRemove = this.model.hooks.createWrapper('findOneAndRemove',
	        Query.prototype._findOneAndRemove, this, kareemOptions);
	    this._findOneAndUpdate = this.model.hooks.createWrapper('findOneAndUpdate',
	        Query.prototype._findOneAndUpdate, this, kareemOptions);
	    this._replaceOne = this.model.hooks.createWrapper('replaceOne',
	        Query.prototype._replaceOne, this, kareemOptions);
	    this._updateMany = this.model.hooks.createWrapper('updateMany',
	        Query.prototype._updateMany, this, kareemOptions);
	    this._updateOne = this.model.hooks.createWrapper('updateOne',
	        Query.prototype._updateOne, this, kareemOptions);
	  }
	}
	
	/*!
	 * inherit mquery
	 */
	
	Query.prototype = new mquery;
	Query.prototype.constructor = Query;
	Query.base = mquery.prototype;
	
	/**
	 * Flag to opt out of using `$geoWithin`.
	 *
	 *     mongoose.Query.use$geoWithin = false;
	 *
	 * MongoDB 2.4 deprecated the use of `$within`, replacing it with `$geoWithin`. Mongoose uses `$geoWithin` by default (which is 100% backward compatible with $within). If you are running an older version of MongoDB, set this flag to `false` so your `within()` queries continue to work.
	 *
	 * @see http://docs.mongodb.org/manual/reference/operator/geoWithin/
	 * @default true
	 * @property use$geoWithin
	 * @memberOf Query
	 * @receiver Query
	 * @api public
	 */
	
	Query.use$geoWithin = mquery.use$geoWithin;
	
	/**
	 * Converts this query to a customized, reusable query constructor with all arguments and options retained.
	 *
	 * ####Example
	 *
	 *     // Create a query for adventure movies and read from the primary
	 *     // node in the replica-set unless it is down, in which case we'll
	 *     // read from a secondary node.
	 *     var query = Movie.find({ tags: 'adventure' }).read('primaryPreferred');
	 *
	 *     // create a custom Query constructor based off these settings
	 *     var Adventure = query.toConstructor();
	 *
	 *     // Adventure is now a subclass of mongoose.Query and works the same way but with the
	 *     // default query parameters and options set.
	 *     Adventure().exec(callback)
	 *
	 *     // further narrow down our query results while still using the previous settings
	 *     Adventure().where({ name: /^Life/ }).exec(callback);
	 *
	 *     // since Adventure is a stand-alone constructor we can also add our own
	 *     // helper methods and getters without impacting global queries
	 *     Adventure.prototype.startsWith = function (prefix) {
	 *       this.where({ name: new RegExp('^' + prefix) })
	 *       return this;
	 *     }
	 *     Object.defineProperty(Adventure.prototype, 'highlyRated', {
	 *       get: function () {
	 *         this.where({ rating: { $gt: 4.5 }});
	 *         return this;
	 *       }
	 *     })
	 *     Adventure().highlyRated.startsWith('Life').exec(callback)
	 *
	 * New in 3.7.3
	 *
	 * @return {Query} subclass-of-Query
	 * @api public
	 */
	
	Query.prototype.toConstructor = function toConstructor() {
	  var model = this.model;
	  var coll = this.mongooseCollection;
	
	  var CustomQuery = function(criteria, options) {
	    if (!(this instanceof CustomQuery)) {
	      return new CustomQuery(criteria, options);
	    }
	    this._mongooseOptions = utils.clone(p._mongooseOptions);
	    Query.call(this, criteria, options || null, model, coll);
	  };
	
	  util.inherits(CustomQuery, Query);
	
	  // set inherited defaults
	  var p = CustomQuery.prototype;
	
	  p.options = {};
	
	  p.setOptions(this.options);
	
	  p.op = this.op;
	  p._conditions = utils.clone(this._conditions, { retainKeyOrder: true });
	  p._fields = utils.clone(this._fields);
	  p._update = utils.clone(this._update, {
	    flattenDecimals: false,
	    retainKeyOrder: true
	  });
	  p._path = this._path;
	  p._distinct = this._distinct;
	  p._collection = this._collection;
	  p._mongooseOptions = this._mongooseOptions;
	
	  return CustomQuery;
	};
	
	/**
	 * Specifies a javascript function or expression to pass to MongoDBs query system.
	 *
	 * ####Example
	 *
	 *     query.$where('this.comments.length === 10 || this.name.length === 5')
	 *
	 *     // or
	 *
	 *     query.$where(function () {
	 *       return this.comments.length === 10 || this.name.length === 5;
	 *     })
	 *
	 * ####NOTE:
	 *
	 * Only use `$where` when you have a condition that cannot be met using other MongoDB operators like `$lt`.
	 * **Be sure to read about all of [its caveats](http://docs.mongodb.org/manual/reference/operator/where/) before using.**
	 *
	 * @see $where http://docs.mongodb.org/manual/reference/operator/where/
	 * @method $where
	 * @param {String|Function} js javascript string or function
	 * @return {Query} this
	 * @memberOf Query
	 * @method $where
	 * @api public
	 */
	
	/**
	 * Specifies a `path` for use with chaining.
	 *
	 * ####Example
	 *
	 *     // instead of writing:
	 *     User.find({age: {$gte: 21, $lte: 65}}, callback);
	 *
	 *     // we can instead write:
	 *     User.where('age').gte(21).lte(65);
	 *
	 *     // passing query conditions is permitted
	 *     User.find().where({ name: 'vonderful' })
	 *
	 *     // chaining
	 *     User
	 *     .where('age').gte(21).lte(65)
	 *     .where('name', /^vonderful/i)
	 *     .where('friends').slice(10)
	 *     .exec(callback)
	 *
	 * @method where
	 * @memberOf Query
	 * @param {String|Object} [path]
	 * @param {any} [val]
	 * @return {Query} this
	 * @api public
	 */
	
	/**
	 * Specifies the complementary comparison value for paths specified with `where()`
	 *
	 * ####Example
	 *
	 *     User.where('age').equals(49);
	 *
	 *     // is the same as
	 *
	 *     User.where('age', 49);
	 *
	 * @method equals
	 * @memberOf Query
	 * @param {Object} val
	 * @return {Query} this
	 * @api public
	 */
	
	/**
	 * Specifies arguments for an `$or` condition.
	 *
	 * ####Example
	 *
	 *     query.or([{ color: 'red' }, { status: 'emergency' }])
	 *
	 * @see $or http://docs.mongodb.org/manual/reference/operator/or/
	 * @method or
	 * @memberOf Query
	 * @param {Array} array array of conditions
	 * @return {Query} this
	 * @api public
	 */
	
	/**
	 * Specifies arguments for a `$nor` condition.
	 *
	 * ####Example
	 *
	 *     query.nor([{ color: 'green' }, { status: 'ok' }])
	 *
	 * @see $nor http://docs.mongodb.org/manual/reference/operator/nor/
	 * @method nor
	 * @memberOf Query
	 * @param {Array} array array of conditions
	 * @return {Query} this
	 * @api public
	 */
	
	/**
	 * Specifies arguments for a `$and` condition.
	 *
	 * ####Example
	 *
	 *     query.and([{ color: 'green' }, { status: 'ok' }])
	 *
	 * @method and
	 * @memberOf Query
	 * @see $and http://docs.mongodb.org/manual/reference/operator/and/
	 * @param {Array} array array of conditions
	 * @return {Query} this
	 * @api public
	 */
	
	/**
	 * Specifies a $gt query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * ####Example
	 *
	 *     Thing.find().where('age').gt(21)
	 *
	 *     // or
	 *     Thing.find().gt('age', 21)
	 *
	 * @method gt
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @see $gt http://docs.mongodb.org/manual/reference/operator/gt/
	 * @api public
	 */
	
	/**
	 * Specifies a $gte query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method gte
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @see $gte http://docs.mongodb.org/manual/reference/operator/gte/
	 * @api public
	 */
	
	/**
	 * Specifies a $lt query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method lt
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @see $lt http://docs.mongodb.org/manual/reference/operator/lt/
	 * @api public
	 */
	
	/**
	 * Specifies a $lte query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method lte
	 * @see $lte http://docs.mongodb.org/manual/reference/operator/lte/
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $ne query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @see $ne http://docs.mongodb.org/manual/reference/operator/ne/
	 * @method ne
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies an $in query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @see $in http://docs.mongodb.org/manual/reference/operator/in/
	 * @method in
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies an $nin query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @see $nin http://docs.mongodb.org/manual/reference/operator/nin/
	 * @method nin
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies an $all query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @see $all http://docs.mongodb.org/manual/reference/operator/all/
	 * @method all
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $size query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * ####Example
	 *
	 *     MyModel.where('tags').size(0).exec(function (err, docs) {
	 *       if (err) return handleError(err);
	 *
	 *       assert(Array.isArray(docs));
	 *       console.log('documents with 0 tags', docs);
	 *     })
	 *
	 * @see $size http://docs.mongodb.org/manual/reference/operator/size/
	 * @method size
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $regex query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @see $regex http://docs.mongodb.org/manual/reference/operator/regex/
	 * @method regex
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {String|RegExp} val
	 * @api public
	 */
	
	/**
	 * Specifies a $maxDistance query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @see $maxDistance http://docs.mongodb.org/manual/reference/operator/maxDistance/
	 * @method maxDistance
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a `$mod` condition
	 *
	 * @method mod
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @return {Query} this
	 * @see $mod http://docs.mongodb.org/manual/reference/operator/mod/
	 * @api public
	 */
	
	/**
	 * Specifies an `$exists` condition
	 *
	 * ####Example
	 *
	 *     // { name: { $exists: true }}
	 *     Thing.where('name').exists()
	 *     Thing.where('name').exists(true)
	 *     Thing.find().exists('name')
	 *
	 *     // { name: { $exists: false }}
	 *     Thing.where('name').exists(false);
	 *     Thing.find().exists('name', false);
	 *
	 * @method exists
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @return {Query} this
	 * @see $exists http://docs.mongodb.org/manual/reference/operator/exists/
	 * @api public
	 */
	
	/**
	 * Specifies an `$elemMatch` condition
	 *
	 * ####Example
	 *
	 *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})
	 *
	 *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})
	 *
	 *     query.elemMatch('comment', function (elem) {
	 *       elem.where('author').equals('autobot');
	 *       elem.where('votes').gte(5);
	 *     })
	 *
	 *     query.where('comment').elemMatch(function (elem) {
	 *       elem.where({ author: 'autobot' });
	 *       elem.where('votes').gte(5);
	 *     })
	 *
	 * @method elemMatch
	 * @memberOf Query
	 * @param {String|Object|Function} path
	 * @param {Object|Function} criteria
	 * @return {Query} this
	 * @see $elemMatch http://docs.mongodb.org/manual/reference/operator/elemMatch/
	 * @api public
	 */
	
	/**
	 * Defines a `$within` or `$geoWithin` argument for geo-spatial queries.
	 *
	 * ####Example
	 *
	 *     query.where(path).within().box()
	 *     query.where(path).within().circle()
	 *     query.where(path).within().geometry()
	 *
	 *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });
	 *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });
	 *     query.where('loc').within({ polygon: [[],[],[],[]] });
	 *
	 *     query.where('loc').within([], [], []) // polygon
	 *     query.where('loc').within([], []) // box
	 *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry
	 *
	 * **MUST** be used after `where()`.
	 *
	 * ####NOTE:
	 *
	 * As of Mongoose 3.7, `$geoWithin` is always used for queries. To change this behavior, see [Query.use$geoWithin](#query_Query-use%2524geoWithin).
	 *
	 * ####NOTE:
	 *
	 * In Mongoose 3.7, `within` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).
	 *
	 * @method within
	 * @see $polygon http://docs.mongodb.org/manual/reference/operator/polygon/
	 * @see $box http://docs.mongodb.org/manual/reference/operator/box/
	 * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/
	 * @see $center http://docs.mongodb.org/manual/reference/operator/center/
	 * @see $centerSphere http://docs.mongodb.org/manual/reference/operator/centerSphere/
	 * @memberOf Query
	 * @return {Query} this
	 * @api public
	 */
	
	/**
	 * Specifies a $slice projection for an array.
	 *
	 * ####Example
	 *
	 *     query.slice('comments', 5)
	 *     query.slice('comments', -5)
	 *     query.slice('comments', [10, 5])
	 *     query.where('comments').slice(5)
	 *     query.where('comments').slice([-10, 5])
	 *
	 * @method slice
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val number/range of elements to slice
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements
	 * @see $slice http://docs.mongodb.org/manual/reference/projection/slice/#prj._S_slice
	 * @api public
	 */
	
	/**
	 * Specifies the maximum number of documents the query will return.
	 *
	 * ####Example
	 *
	 *     query.limit(20)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method limit
	 * @memberOf Query
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies the number of documents to skip.
	 *
	 * ####Example
	 *
	 *     query.skip(100).limit(20)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method skip
	 * @memberOf Query
	 * @param {Number} val
	 * @see cursor.skip http://docs.mongodb.org/manual/reference/method/cursor.skip/
	 * @api public
	 */
	
	/**
	 * Specifies the maxScan option.
	 *
	 * ####Example
	 *
	 *     query.maxScan(100)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method maxScan
	 * @memberOf Query
	 * @param {Number} val
	 * @see maxScan http://docs.mongodb.org/manual/reference/operator/maxScan/
	 * @api public
	 */
	
	/**
	 * Specifies the batchSize option.
	 *
	 * ####Example
	 *
	 *     query.batchSize(100)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method batchSize
	 * @memberOf Query
	 * @param {Number} val
	 * @see batchSize http://docs.mongodb.org/manual/reference/method/cursor.batchSize/
	 * @api public
	 */
	
	/**
	 * Specifies the `comment` option.
	 *
	 * ####Example
	 *
	 *     query.comment('login query')
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method comment
	 * @memberOf Query
	 * @param {Number} val
	 * @see comment http://docs.mongodb.org/manual/reference/operator/comment/
	 * @api public
	 */
	
	/**
	 * Specifies this query as a `snapshot` query.
	 *
	 * ####Example
	 *
	 *     query.snapshot() // true
	 *     query.snapshot(true)
	 *     query.snapshot(false)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method snapshot
	 * @memberOf Query
	 * @see snapshot http://docs.mongodb.org/manual/reference/operator/snapshot/
	 * @return {Query} this
	 * @api public
	 */
	
	/**
	 * Sets query hints.
	 *
	 * ####Example
	 *
	 *     query.hint({ indexA: 1, indexB: -1})
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method hint
	 * @memberOf Query
	 * @param {Object} val a hint object
	 * @return {Query} this
	 * @see $hint http://docs.mongodb.org/manual/reference/operator/hint/
	 * @api public
	 */
	
	/**
	 * Specifies which document fields to include or exclude (also known as the query "projection")
	 *
	 * When using string syntax, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included. Lastly, if a path is prefixed with `+`, it forces inclusion of the path, which is useful for paths excluded at the [schema level](/docs/api.html#schematype_SchemaType-select).
	 *
	 * A projection _must_ be either inclusive or exclusive. In other words, you must
	 * either list the fields to include (which excludes all others), or list the fields
	 * to exclude (which implies all other fields are included). The [`_id` field is the only exception because MongoDB includes it by default](https://docs.mongodb.com/manual/tutorial/project-fields-from-query-results/#suppress-id-field).
	 *
	 * ####Example
	 *
	 *     // include a and b, exclude other fields
	 *     query.select('a b');
	 *
	 *     // exclude c and d, include other fields
	 *     query.select('-c -d');
	 *
	 *     // or you may use object notation, useful when
	 *     // you have keys already prefixed with a "-"
	 *     query.select({ a: 1, b: 1 });
	 *     query.select({ c: 0, d: 0 });
	 *
	 *     // force inclusion of field excluded at schema level
	 *     query.select('+path')
	 *
	 * @method select
	 * @memberOf Query
	 * @param {Object|String} arg
	 * @return {Query} this
	 * @see SchemaType
	 * @api public
	 */
	
	Query.prototype.select = function select() {
	  var arg = arguments[0];
	  if (!arg) return this;
	  var i;
	  var len;
	
	  if (arguments.length !== 1) {
	    throw new Error('Invalid select: select only takes 1 argument');
	  }
	
	  this._validate('select');
	
	  var fields = this._fields || (this._fields = {});
	  var userProvidedFields = this._userProvidedFields || (this._userProvidedFields = {});
	  var type = typeof arg;
	
	  if (('string' == type || Object.prototype.toString.call(arg) === '[object Arguments]') &&
	    'number' == typeof arg.length || Array.isArray(arg)) {
	    if ('string' == type)
	      arg = arg.split(/\s+/);
	
	    for (i = 0, len = arg.length; i < len; ++i) {
	      var field = arg[i];
	      if (!field) continue;
	      var include = '-' == field[0] ? 0 : 1;
	      if (include === 0) field = field.substring(1);
	      fields[field] = include;
	      userProvidedFields[field] = include;
	    }
	
	    return this;
	  }
	
	  if (utils.isObject(arg)) {
	    var keys = Object.keys(arg);
	    for (i = 0; i < keys.length; ++i) {
	      fields[keys[i]] = arg[keys[i]];
	      userProvidedFields[keys[i]] = arg[keys[i]];
	    }
	    return this;
	  }
	
	  throw new TypeError('Invalid select() argument. Must be string or object.');
	};
	
	/**
	 * _DEPRECATED_ Sets the slaveOk option.
	 *
	 * **Deprecated** in MongoDB 2.2 in favor of [read preferences](#query_Query-read).
	 *
	 * ####Example:
	 *
	 *     query.slaveOk() // true
	 *     query.slaveOk(true)
	 *     query.slaveOk(false)
	 *
	 * @method slaveOk
	 * @memberOf Query
	 * @deprecated use read() preferences instead if on mongodb >= 2.2
	 * @param {Boolean} v defaults to true
	 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
	 * @see slaveOk http://docs.mongodb.org/manual/reference/method/rs.slaveOk/
	 * @see read() #query_Query-read
	 * @return {Query} this
	 * @api public
	 */
	
	/**
	 * Determines the MongoDB nodes from which to read.
	 *
	 * ####Preferences:
	 *
	 *     primary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.
	 *     secondary            Read from secondary if available, otherwise error.
	 *     primaryPreferred     Read from primary if available, otherwise a secondary.
	 *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.
	 *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.
	 *
	 * Aliases
	 *
	 *     p   primary
	 *     pp  primaryPreferred
	 *     s   secondary
	 *     sp  secondaryPreferred
	 *     n   nearest
	 *
	 * ####Example:
	 *
	 *     new Query().read('primary')
	 *     new Query().read('p')  // same as primary
	 *
	 *     new Query().read('primaryPreferred')
	 *     new Query().read('pp') // same as primaryPreferred
	 *
	 *     new Query().read('secondary')
	 *     new Query().read('s')  // same as secondary
	 *
	 *     new Query().read('secondaryPreferred')
	 *     new Query().read('sp') // same as secondaryPreferred
	 *
	 *     new Query().read('nearest')
	 *     new Query().read('n')  // same as nearest
	 *
	 *     // read from secondaries with matching tags
	 *     new Query().read('s', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }])
	 *
	 * Read more about how to use read preferrences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).
	 *
	 * @method read
	 * @memberOf Query
	 * @param {String} pref one of the listed preference options or aliases
	 * @param {Array} [tags] optional tags for this query
	 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
	 * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.read = function read(pref, tags) {
	  // first cast into a ReadPreference object to support tags
	  var read = readPref.call(readPref, pref, tags);
	  this.options.readPreference = read;
	  return this;
	};
	
	/**
	 * Merges another Query or conditions object into this one.
	 *
	 * When a Query is passed, conditions, field selection and options are merged.
	 *
	 * New in 3.7.0
	 *
	 * @method merge
	 * @memberOf Query
	 * @param {Query|Object} source
	 * @return {Query} this
	 */
	
	/**
	 * Sets query options.
	 *
	 * ####Options:
	 *
	 * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *
	 * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\)%7D%7D) *
	 * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *
	 * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *
	 * - [maxscan](https://docs.mongodb.org/v3.2/reference/operator/meta/maxScan/#metaOp._S_maxScan) *
	 * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *
	 * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *
	 * - [snapshot](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D) *
	 * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *
	 * - [readPreference](http://docs.mongodb.org/manual/applications/replication/#read-preference) **
	 * - [lean](./api.html#query_Query-lean) *
	 * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)
	 *
	 * _* denotes a query helper method is also available_
	 * _** query helper method to set `readPreference` is `read()`_
	 *
	 * @param {Object} options
	 * @api public
	 */
	
	Query.prototype.setOptions = function(options, overwrite) {
	  // overwrite is only for internal use
	  if (overwrite) {
	    // ensure that _mongooseOptions & options are two different objects
	    this._mongooseOptions = (options && utils.clone(options)) || {};
	    this.options = options || {};
	
	    if ('populate' in options) {
	      this.populate(this._mongooseOptions);
	    }
	    return this;
	  }
	
	  if (!(options && options.constructor.name === 'Object')) {
	    return this;
	  }
	
	  if (options && Array.isArray(options.populate)) {
	    var populate = options.populate;
	    delete options.populate;
	    var _numPopulate = populate.length;
	    for (var i = 0; i < _numPopulate; ++i) {
	      this.populate(populate[i]);
	    }
	  }
	
	  return Query.base.setOptions.call(this, options);
	};
	
	/**
	 * Returns the current query conditions as a JSON object.
	 *
	 * ####Example:
	 *
	 *     var query = new Query();
	 *     query.find({ a: 1 }).where('b').gt(2);
	 *     query.getQuery(); // { a: 1, b: { $gt: 2 } }
	 *
	 * @return {Object} current query conditions
	 * @api public
	 */
	
	Query.prototype.getQuery = function() {
	  return this._conditions;
	};
	
	/**
	 * Returns the current update operations as a JSON object.
	 *
	 * ####Example:
	 *
	 *     var query = new Query();
	 *     query.update({}, { $set: { a: 5 } });
	 *     query.getUpdate(); // { $set: { a: 5 } }
	 *
	 * @return {Object} current update operations
	 * @api public
	 */
	
	Query.prototype.getUpdate = function() {
	  return this._update;
	};
	
	/**
	 * Returns fields selection for this query.
	 *
	 * @method _fieldsForExec
	 * @return {Object}
	 * @api private
	 * @receiver Query
	 */
	
	/**
	 * Return an update document with corrected $set operations.
	 *
	 * @method _updateForExec
	 * @api private
	 * @receiver Query
	 */
	
	Query.prototype._updateForExec = function() {
	  var update = utils.clone(this._update, {
	    retainKeyOrder: true,
	    transform: false,
	    depopulate: true
	  });
	  var ops = Object.keys(update);
	  var i = ops.length;
	  var ret = {};
	
	  while (i--) {
	    var op = ops[i];
	
	    if (this.options.overwrite) {
	      ret[op] = update[op];
	      continue;
	    }
	
	    if ('$' !== op[0]) {
	      // fix up $set sugar
	      if (!ret.$set) {
	        if (update.$set) {
	          ret.$set = update.$set;
	        } else {
	          ret.$set = {};
	        }
	      }
	      ret.$set[op] = update[op];
	      ops.splice(i, 1);
	      if (!~ops.indexOf('$set')) ops.push('$set');
	    } else if ('$set' === op) {
	      if (!ret.$set) {
	        ret[op] = update[op];
	      }
	    } else {
	      ret[op] = update[op];
	    }
	  }
	
	  return ret;
	};
	
	/**
	 * Makes sure _path is set.
	 *
	 * @method _ensurePath
	 * @param {String} method
	 * @api private
	 * @receiver Query
	 */
	
	/**
	 * Determines if `conds` can be merged using `mquery().merge()`
	 *
	 * @method canMerge
	 * @memberOf Query
	 * @param {Object} conds
	 * @return {Boolean}
	 * @api private
	 */
	
	/**
	 * Returns default options for this query.
	 *
	 * @param {Model} model
	 * @api private
	 */
	
	Query.prototype._optionsForExec = function(model) {
	  var options = Query.base._optionsForExec.call(this);
	
	  delete options.populate;
	  delete options.retainKeyOrder;
	  model = model || this.model;
	
	  if (!model) {
	    return options;
	  }
	
	  if (!('safe' in options) && model.schema.options.safe) {
	    options.safe = model.schema.options.safe;
	  }
	
	  if (!('readPreference' in options) && model.schema.options.read) {
	    options.readPreference = model.schema.options.read;
	  }
	
	  return options;
	};
	
	/**
	 * Sets the lean option.
	 *
	 * Documents returned from queries with the `lean` option enabled are plain javascript objects, not [MongooseDocuments](#document-js). They have no `save` method, getters/setters or other Mongoose magic applied.
	 *
	 * ####Example:
	 *
	 *     new Query().lean() // true
	 *     new Query().lean(true)
	 *     new Query().lean(false)
	 *
	 *     Model.find().lean().exec(function (err, docs) {
	 *       docs[0] instanceof mongoose.Document // false
	 *     });
	 *
	 * This is a [great](https://groups.google.com/forum/#!topic/mongoose-orm/u2_DzDydcnA/discussion) option in high-performance read-only scenarios, especially when combined with [stream](#query_Query-stream).
	 *
	 * @param {Boolean|Object} bool defaults to true
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.lean = function(v) {
	  this._mongooseOptions.lean = arguments.length ? v : true;
	  return this;
	};
	
	/**
	 * Gets/sets the error flag on this query. If this flag is not null or
	 * undefined, the `exec()` promise will reject without executing.
	 *
	 * ####Example:
	 *
	 *     Query().error(); // Get current error value
	 *     Query().error(null); // Unset the current error
	 *     Query().error(new Error('test')); // `exec()` will resolve with test
	 *     Schema.pre('find', function() {
	 *       if (!this.getQuery().userId) {
	 *         this.error(new Error('Not allowed to query without setting userId'));
	 *       }
	 *     });
	 *
	 * Note that query casting runs **after** hooks, so cast errors will override
	 * custom errors.
	 *
	 * ####Example:
	 *     var TestSchema = new Schema({ num: Number });
	 *     var TestModel = db.model('Test', TestSchema);
	 *     TestModel.find({ num: 'not a number' }).error(new Error('woops')).exec(function(error) {
	 *       // `error` will be a cast error because `num` failed to cast
	 *     });
	 *
	 * @param {Error|null} err if set, `exec()` will fail fast before sending the query to MongoDB
	 * @returns {Query} this
	 * @api public
	 */
	
	Query.prototype.error = function error(err) {
	  if (arguments.length === 0) {
	    return this._error;
	  }
	
	  this._error = err;
	  return this;
	};
	
	/*!
	 * ignore
	 */
	
	Query.prototype._unsetCastError = function _unsetCastError() {
	  if (this._error != null && !(this._error instanceof CastError)) {
	    return;
	  }
	  return this.error(null);
	};
	
	/**
	 * Getter/setter around the current mongoose-specific options for this query
	 * (populate, lean, etc.)
	 *
	 * @param {Object} options if specified, overwrites the current options
	 * @returns {Object} the options
	 * @api public
	 */
	
	Query.prototype.mongooseOptions = function(v) {
	  if (arguments.length > 0) {
	    this._mongooseOptions = v;
	  }
	  return this._mongooseOptions;
	};
	
	/*!
	 * ignore
	 */
	
	Query.prototype._castConditions = function() {
	  try {
	    this.cast(this.model);
	    this._unsetCastError();
	  } catch (err) {
	    this.error(err);
	  }
	};
	
	/**
	 * Thunk around find()
	 *
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api private
	 */
	Query.prototype._find = function(callback) {
	  this._castConditions();
	
	  if (this.error() != null) {
	    callback(this.error());
	    return this;
	  }
	
	  this._applyPaths();
	  this._fields = this._castFields(this._fields);
	
	  var fields = this._fieldsForExec();
	  var options = this._mongooseOptions;
	  var _this = this;
	  var userProvidedFields = _this._userProvidedFields || {};
	
	  var cb = function(err, docs) {
	    if (err) {
	      return callback(err);
	    }
	
	    if (docs.length === 0) {
	      return callback(null, docs);
	    }
	
	    if (!options.populate) {
	      return !!options.lean === true
	          ? callback(null, docs)
	          : completeMany(_this.model, docs, fields, userProvidedFields, null, callback);
	    }
	
	    var pop = helpers.preparePopulationOptionsMQ(_this, options);
	    pop.__noPromise = true;
	    _this.model.populate(docs, pop, function(err, docs) {
	      if (err) return callback(err);
	      return !!options.lean === true
	          ? callback(null, docs)
	          : completeMany(_this.model, docs, fields, userProvidedFields, pop, callback);
	    });
	  };
	
	  return Query.base.find.call(this, {}, cb);
	};
	
	/**
	 * Finds documents.
	 *
	 * When no `callback` is passed, the query is not executed. When the query is executed, the result will be an array of documents.
	 *
	 * ####Example
	 *
	 *     query.find({ name: 'Los Pollos Hermanos' }).find(callback)
	 *
	 * @param {Object} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.find = function(conditions, callback) {
	  if (typeof conditions === 'function') {
	    callback = conditions;
	    conditions = {};
	  }
	
	  conditions = utils.toObject(conditions);
	
	  if (mquery.canMerge(conditions)) {
	    this.merge(conditions);
	  }
	
	  prepareDiscriminatorCriteria(this);
	
	  // if we don't have a callback, then just return the query object
	  if (!callback) {
	    return Query.base.find.call(this);
	  }
	
	  this._find(callback);
	
	  return this;
	};
	
	/**
	 * Merges another Query or conditions object into this one.
	 *
	 * When a Query is passed, conditions, field selection and options are merged.
	 *
	 * @param {Query|Object} source
	 * @return {Query} this
	 */
	
	Query.prototype.merge = function(source) {
	  if (!source) {
	    return this;
	  }
	
	  var opts = { retainKeyOrder: this.options.retainKeyOrder, overwrite: true };
	
	  if (source instanceof Query) {
	    // if source has a feature, apply it to ourselves
	
	    if (source._conditions) {
	      utils.merge(this._conditions, source._conditions, opts);
	    }
	
	    if (source._fields) {
	      this._fields || (this._fields = {});
	      utils.merge(this._fields, source._fields, opts);
	    }
	
	    if (source.options) {
	      this.options || (this.options = {});
	      utils.merge(this.options, source.options, opts);
	    }
	
	    if (source._update) {
	      this._update || (this._update = {});
	      utils.mergeClone(this._update, source._update);
	    }
	
	    if (source._distinct) {
	      this._distinct = source._distinct;
	    }
	
	    return this;
	  }
	
	  // plain object
	  utils.merge(this._conditions, source, opts);
	
	  return this;
	};
	
	/*!
	 * hydrates many documents
	 *
	 * @param {Model} model
	 * @param {Array} docs
	 * @param {Object} fields
	 * @param {Query} self
	 * @param {Array} [pop] array of paths used in population
	 * @param {Function} callback
	 */
	
	function completeMany(model, docs, fields, userProvidedFields, pop, callback) {
	  var arr = [];
	  var count = docs.length;
	  var len = count;
	  var opts = pop ? { populated: pop } : undefined;
	  var error = null;
	  function init(_error) {
	    if (error != null) {
	      return;
	    }
	    if (_error != null) {
	      error = _error;
	      return callback(error);
	    }
	    --count || callback(null, arr);
	  }
	  for (var i = 0; i < len; ++i) {
	    arr[i] = helpers.createModel(model, docs[i], fields, userProvidedFields);
	    arr[i].init(docs[i], opts, init);
	  }
	}
	
	/**
	 * Adds a collation to this op (MongoDB 3.4 and up)
	 *
	 * @param {Object} value
	 * @return {Query} this
	 * @see MongoDB docs https://docs.mongodb.com/manual/reference/method/cursor.collation/#cursor.collation
	 * @api public
	 */
	
	Query.prototype.collation = function(value) {
	  if (this.options == null) {
	    this.options = {};
	  }
	  this.options.collation = value;
	  return this;
	};
	
	/**
	 * Thunk around findOne()
	 *
	 * @param {Function} [callback]
	 * @see findOne http://docs.mongodb.org/manual/reference/method/db.collection.findOne/
	 * @api private
	 */
	
	Query.prototype._findOne = function(callback) {
	  this._castConditions();
	
	  if (this.error()) {
	    return callback(this.error());
	  }
	
	  this._applyPaths();
	  this._fields = this._castFields(this._fields);
	
	  var options = this._mongooseOptions;
	  var projection = this._fieldsForExec();
	  var userProvidedFields = this._userProvidedFields || {};
	  var _this = this;
	
	  // don't pass in the conditions because we already merged them in
	  Query.base.findOne.call(_this, {}, function(err, doc) {
	    if (err) {
	      return callback(err);
	    }
	    if (!doc) {
	      return callback(null, null);
	    }
	
	    if (!options.populate) {
	      return !!options.lean === true
	          ? callback(null, doc)
	          : completeOne(_this.model, doc, null, {}, projection, userProvidedFields, null, callback);
	    }
	
	    var pop = helpers.preparePopulationOptionsMQ(_this, options);
	    pop.__noPromise = true;
	    _this.model.populate(doc, pop, function(err, doc) {
	      if (err) {
	        return callback(err);
	      }
	      return !!options.lean === true
	          ? callback(null, doc)
	          : completeOne(_this.model, doc, null, {}, projection, userProvidedFields, pop, callback);
	    });
	  });
	};
	
	/**
	 * Declares the query a findOne operation. When executed, the first found document is passed to the callback.
	 *
	 * Passing a `callback` executes the query. The result of the query is a single document.
	 *
	 * * *Note:* `conditions` is optional, and if `conditions` is null or undefined,
	 * mongoose will send an empty `findOne` command to MongoDB, which will return
	 * an arbitrary document. If you're querying by `_id`, use `Model.findById()`
	 * instead.
	 *
	 * This function triggers the following middleware:
	 * - `findOne()`
	 *
	 * ####Example
	 *
	 *     var query  = Kitten.where({ color: 'white' });
	 *     query.findOne(function (err, kitten) {
	 *       if (err) return handleError(err);
	 *       if (kitten) {
	 *         // doc may be null if no document matched
	 *       }
	 *     });
	 *
	 * @param {Object|Query} [criteria] mongodb selector
	 * @param {Object} [projection] optional fields to return
	 * @param {Function} [callback] optional params are (error, document)
	 * @return {Query} this
	 * @see findOne http://docs.mongodb.org/manual/reference/method/db.collection.findOne/
	 * @see Query.select #query_Query-select
	 * @api public
	 */
	
	Query.prototype.findOne = function(conditions, projection, options, callback) {
	  if (typeof conditions === 'function') {
	    callback = conditions;
	    conditions = null;
	    projection = null;
	    options = null;
	  } else if (typeof projection === 'function') {
	    callback = projection;
	    options = null;
	    projection = null;
	  } else if (typeof options === 'function') {
	    callback = options;
	    options = null;
	  }
	
	  // make sure we don't send in the whole Document to merge()
	  conditions = utils.toObject(conditions);
	
	  this.op = 'findOne';
	
	  if (options) {
	    this.setOptions(options);
	  }
	
	  if (projection) {
	    this.select(projection);
	  }
	
	  if (mquery.canMerge(conditions)) {
	    this.merge(conditions);
	  } else if (conditions != null) {
	    throw new Error('Invalid argument to findOne(): ' +
	      util.inspect(conditions));
	  }
	
	  prepareDiscriminatorCriteria(this);
	
	  try {
	    this.cast(this.model);
	    this.error(null);
	  } catch (err) {
	    this.error(err);
	  }
	
	  if (!callback) {
	    // already merged in the conditions, don't need to send them in.
	    return Query.base.findOne.call(this);
	  }
	
	  this._findOne(callback);
	
	  return this;
	};
	
	/**
	 * Thunk around count()
	 *
	 * @param {Function} [callback]
	 * @see count http://docs.mongodb.org/manual/reference/method/db.collection.count/
	 * @api private
	 */
	
	Query.prototype._count = function(callback) {
	  try {
	    this.cast(this.model);
	  } catch (err) {
	    this.error(err);
	  }
	
	  if (this.error()) {
	    return callback(this.error());
	  }
	
	  var conds = this._conditions;
	  var options = this._optionsForExec();
	
	  this._collection.count(conds, options, utils.tick(callback));
	};
	
	/**
	 * Specifying this query as a `count` query.
	 *
	 * Passing a `callback` executes the query.
	 *
	 * This function triggers the following middleware:
	 * - `count()`
	 *
	 * ####Example:
	 *
	 *     var countQuery = model.where({ 'color': 'black' }).count();
	 *
	 *     query.count({ color: 'black' }).count(callback)
	 *
	 *     query.count({ color: 'black' }, callback)
	 *
	 *     query.where('color', 'black').count(function (err, count) {
	 *       if (err) return handleError(err);
	 *       console.log('there are %d kittens', count);
	 *     })
	 *
	 * @param {Object} [criteria] mongodb selector
	 * @param {Function} [callback] optional params are (error, count)
	 * @return {Query} this
	 * @see count http://docs.mongodb.org/manual/reference/method/db.collection.count/
	 * @api public
	 */
	
	Query.prototype.count = function(conditions, callback) {
	  if (typeof conditions === 'function') {
	    callback = conditions;
	    conditions = undefined;
	  }
	
	  if (mquery.canMerge(conditions)) {
	    this.merge(conditions);
	  }
	
	  this.op = 'count';
	  if (!callback) {
	    return this;
	  }
	
	  this._count(callback);
	
	  return this;
	};
	
	/**
	 * Declares or executes a distict() operation.
	 *
	 * Passing a `callback` executes the query.
	 *
	 * This function does not trigger any middleware.
	 *
	 * ####Example
	 *
	 *     distinct(field, conditions, callback)
	 *     distinct(field, conditions)
	 *     distinct(field, callback)
	 *     distinct(field)
	 *     distinct(callback)
	 *     distinct()
	 *
	 * @param {String} [field]
	 * @param {Object|Query} [criteria]
	 * @param {Function} [callback] optional params are (error, arr)
	 * @return {Query} this
	 * @see distinct http://docs.mongodb.org/manual/reference/method/db.collection.distinct/
	 * @api public
	 */
	
	Query.prototype.distinct = function(field, conditions, callback) {
	  if (!callback) {
	    if (typeof conditions === 'function') {
	      callback = conditions;
	      conditions = undefined;
	    } else if (typeof field === 'function') {
	      callback = field;
	      field = undefined;
	      conditions = undefined;
	    }
	  }
	
	  conditions = utils.toObject(conditions);
	
	  if (mquery.canMerge(conditions)) {
	    this.merge(conditions);
	  }
	
	  try {
	    this.cast(this.model);
	  } catch (err) {
	    if (!callback) {
	      throw err;
	    }
	    callback(err);
	    return this;
	  }
	
	  return Query.base.distinct.call(this, {}, field, callback);
	};
	
	/**
	 * Sets the sort order
	 *
	 * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.
	 *
	 * If a string is passed, it must be a space delimited list of path names. The
	 * sort order of each path is ascending unless the path name is prefixed with `-`
	 * which will be treated as descending.
	 *
	 * ####Example
	 *
	 *     // sort by "field" ascending and "test" descending
	 *     query.sort({ field: 'asc', test: -1 });
	 *
	 *     // equivalent
	 *     query.sort('field -test');
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @param {Object|String} arg
	 * @return {Query} this
	 * @see cursor.sort http://docs.mongodb.org/manual/reference/method/cursor.sort/
	 * @api public
	 */
	
	Query.prototype.sort = function(arg) {
	  if (arguments.length > 1) {
	    throw new Error('sort() only takes 1 Argument');
	  }
	
	  return Query.base.sort.call(this, arg);
	};
	
	/**
	 * Declare and/or execute this query as a remove() operation.
	 *
	 * This function does not trigger any middleware
	 *
	 * ####Example
	 *
	 *     Model.remove({ artist: 'Anne Murray' }, callback)
	 *
	 * ####Note
	 *
	 * The operation is only executed when a callback is passed. To force execution without a callback, you must first call `remove()` and then execute it by using the `exec()` method.
	 *
	 *     // not executed
	 *     var query = Model.find().remove({ name: 'Anne Murray' })
	 *
	 *     // executed
	 *     query.remove({ name: 'Anne Murray' }, callback)
	 *     query.remove({ name: 'Anne Murray' }).remove(callback)
	 *
	 *     // executed without a callback
	 *     query.exec()
	 *
	 *     // summary
	 *     query.remove(conds, fn); // executes
	 *     query.remove(conds)
	 *     query.remove(fn) // executes
	 *     query.remove()
	 *
	 * @param {Object|Query} [filter] mongodb selector
	 * @param {Function} [callback] optional params are (error, writeOpResult)
	 * @return {Query} this
	 * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult
	 * @see remove http://docs.mongodb.org/manual/reference/method/db.collection.remove/
	 * @api public
	 */
	
	Query.prototype.remove = function(filter, callback) {
	  if (typeof filter === 'function') {
	    callback = filter;
	    filter = null;
	  }
	
	  filter = utils.toObject(filter, { retainKeyOrder: true });
	
	  try {
	    this.cast(this.model, filter);
	    this.merge(filter);
	  } catch (err) {
	    this.error(err);
	  }
	
	  prepareDiscriminatorCriteria(this);
	
	  if (!callback) {
	    return Query.base.remove.call(this);
	  }
	
	  return this._remove(callback);
	};
	
	/*!
	 * ignore
	 */
	
	Query.prototype._remove = function(callback) {
	  if (this.error() != null) {
	    callback(this.error());
	    return this;
	  }
	
	  return Query.base.remove.call(this, callback);
	};
	
	/**
	 * Declare and/or execute this query as a `deleteOne()` operation. Works like
	 * remove, except it deletes at most one document regardless of the `single`
	 * option.
	 *
	 * This function does not trigger any middleware.
	 *
	 * ####Example
	 *
	 *     Character.deleteOne({ name: 'Eddard Stark' }, callback)
	 *     Character.deleteOne({ name: 'Eddard Stark' }).then(next)
	 *
	 * @param {Object|Query} [filter] mongodb selector
	 * @param {Function} [callback] optional params are (error, writeOpResult)
	 * @return {Query} this
	 * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult
	 * @see remove http://docs.mongodb.org/manual/reference/method/db.collection.remove/
	 * @api public
	 */
	
	Query.prototype.deleteOne = function(filter, callback) {
	  if (typeof filter === 'function') {
	    callback = filter;
	    filter = null;
	  }
	
	  filter = utils.toObject(filter, { retainKeyOrder: true });
	
	  try {
	    this.cast(this.model, filter);
	    this.merge(filter);
	  } catch (err) {
	    this.error(err);
	  }
	
	  prepareDiscriminatorCriteria(this);
	
	  if (!callback) {
	    return Query.base.deleteOne.call(this);
	  }
	
	  return this._deleteOne.call(this, callback);
	};
	
	/*!
	 * ignore
	 */
	
	Query.prototype._deleteOne = function(callback) {
	  if (this.error() != null) {
	    callback(this.error());
	    return this;
	  }
	
	  return Query.base.deleteOne.call(this, callback);
	};
	
	/**
	 * Declare and/or execute this query as a `deleteMany()` operation. Works like
	 * remove, except it deletes _every_ document that matches `criteria` in the
	 * collection, regardless of the value of `single`.
	 *
	 * This function does not trigger any middleware
	 *
	 * ####Example
	 *
	 *     Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }, callback)
	 *     Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }).then(next)
	 *
	 * @param {Object|Query} [filter] mongodb selector
	 * @param {Function} [callback] optional params are (error, writeOpResult)
	 * @return {Query} this
	 * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult
	 * @see remove http://docs.mongodb.org/manual/reference/method/db.collection.remove/
	 * @api public
	 */
	
	Query.prototype.deleteMany = function(filter, callback) {
	  if (typeof filter === 'function') {
	    callback = filter;
	    filter = null;
	  }
	
	  filter = utils.toObject(filter, { retainKeyOrder: true });
	
	  try {
	    this.cast(this.model, filter);
	    this.merge(filter);
	  } catch (err) {
	    this.error(err);
	  }
	
	  prepareDiscriminatorCriteria(this);
	
	  if (!callback) {
	    return Query.base.deleteMany.call(this);
	  }
	
	  return this._deleteMany.call(this, callback);
	};
	
	/*!
	 * ignore
	 */
	
	Query.prototype._deleteMany = function(callback) {
	  if (this.error() != null) {
	    callback(this.error());
	    return this;
	  }
	
	  return Query.base.deleteMany.call(this, callback);
	};
	
	/*!
	 * hydrates a document
	 *
	 * @param {Model} model
	 * @param {Document} doc
	 * @param {Object} res 3rd parameter to callback
	 * @param {Object} fields
	 * @param {Query} self
	 * @param {Array} [pop] array of paths used in population
	 * @param {Function} callback
	 */
	
	function completeOne(model, doc, res, options, fields, userProvidedFields, pop, callback) {
	  var opts = pop ?
	  {populated: pop}
	      : undefined;
	
	  var casted = helpers.createModel(model, doc, fields, userProvidedFields);
	  casted.init(doc, opts, function(err) {
	    if (err) {
	      return callback(err);
	    }
	
	    if (options.rawResult) {
	      res.value = casted;
	      return callback(null, res);
	    }
	    if (options.passRawResult) {
	      return callback(null, casted, decorateResult(res));
	    }
	    callback(null, casted);
	  });
	}
	
	/*!
	 * If the model is a discriminator type and not root, then add the key & value to the criteria.
	 */
	
	function prepareDiscriminatorCriteria(query) {
	  if (!query || !query.model || !query.model.schema) {
	    return;
	  }
	
	  var schema = query.model.schema;
	
	  if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
	    query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
	  }
	}
	
	/**
	 * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.
	 *
	 * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed.
	 *
	 * This function triggers the following middleware:
	 * - `findOneAndUpdate()`
	 *
	 * ####Available options
	 *
	 * - `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)
	 * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.
	 * - `fields`: {Object|String} - Field selection. Equivalent to `.select(fields).findOneAndUpdate()`
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0
	 * - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.
	 * - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).
	 * - `passRawResult`: if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)
	 * - `context` (string) if set to 'query' and `runValidators` is on, `this` will refer to the query in custom validator functions that update validation runs. Does nothing if `runValidators` is false.
	 * - `runSettersOnQuery`: bool - if true, run all setters defined on the associated model's schema for all fields defined in the query and the update.
	 *
	 * ####Callback Signature
	 *     function(error, doc) {
	 *       // error: any errors that occurred
	 *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`
	 *     }
	 *
	 * ####Examples
	 *
	 *     query.findOneAndUpdate(conditions, update, options, callback) // executes
	 *     query.findOneAndUpdate(conditions, update, options)  // returns Query
	 *     query.findOneAndUpdate(conditions, update, callback) // executes
	 *     query.findOneAndUpdate(conditions, update)           // returns Query
	 *     query.findOneAndUpdate(update, callback)             // returns Query
	 *     query.findOneAndUpdate(update)                       // returns Query
	 *     query.findOneAndUpdate(callback)                     // executes
	 *     query.findOneAndUpdate()                             // returns Query
	 *
	 * @method findOneAndUpdate
	 * @memberOf Query
	 * @param {Object|Query} [query]
	 * @param {Object} [doc]
	 * @param {Object} [options]
	 * @param {Boolean} [options.passRawResult] if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)
	 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)
	 * @param {Function} [callback] optional params are (error, doc), _unless_ `passRawResult` is used, in which case params are (error, doc, writeOpResult)
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.findOneAndUpdate = function(criteria, doc, options, callback) {
	  this.op = 'findOneAndUpdate';
	  this._validate();
	
	  switch (arguments.length) {
	    case 3:
	      if (typeof options === 'function') {
	        callback = options;
	        options = {};
	      }
	      break;
	    case 2:
	      if (typeof doc === 'function') {
	        callback = doc;
	        doc = criteria;
	        criteria = undefined;
	      }
	      options = undefined;
	      break;
	    case 1:
	      if (typeof criteria === 'function') {
	        callback = criteria;
	        criteria = options = doc = undefined;
	      } else {
	        doc = criteria;
	        criteria = options = undefined;
	      }
	  }
	
	  if (mquery.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  // apply doc
	  if (doc) {
	    this._mergeUpdate(doc);
	  }
	
	  if (options) {
	    options = utils.clone(options, { retainKeyOrder: true });
	    if (options.projection) {
	      this.select(options.projection);
	      delete options.projection;
	    }
	    if (options.fields) {
	      this.select(options.fields);
	      delete options.fields;
	    }
	
	    this.setOptions(options);
	  }
	
	  if (!callback) {
	    return this;
	  }
	
	  return this._findOneAndUpdate(callback);
	};
	
	/*!
	 * Thunk around findOneAndUpdate()
	 *
	 * @param {Function} [callback]
	 * @api private
	 */
	
	Query.prototype._findOneAndUpdate = function(callback) {
	  this._castConditions();
	
	  if (this.error() != null) {
	    return callback(this.error());
	  }
	
	  this._findAndModify('update', callback);
	  return this;
	};
	
	/**
	 * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.
	 *
	 * Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if `callback` is passed.
	 *
	 * This function triggers the following middleware:
	 * - `findOneAndRemove()`
	 *
	 * ####Available options
	 *
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0
	 * - `passRawResult`: if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)
	 *
	 * ####Callback Signature
	 *     function(error, doc, result) {
	 *       // error: any errors that occurred
	 *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`
	 *       // result: [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)
	 *     }
	 *
	 * ####Examples
	 *
	 *     A.where().findOneAndRemove(conditions, options, callback) // executes
	 *     A.where().findOneAndRemove(conditions, options)  // return Query
	 *     A.where().findOneAndRemove(conditions, callback) // executes
	 *     A.where().findOneAndRemove(conditions) // returns Query
	 *     A.where().findOneAndRemove(callback)   // executes
	 *     A.where().findOneAndRemove()           // returns Query
	 *
	 * @method findOneAndRemove
	 * @memberOf Query
	 * @param {Object} [conditions]
	 * @param {Object} [options]
	 * @param {Boolean} [options.passRawResult] if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)
	 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)
	 * @param {Function} [callback] optional params are (error, document)
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 * @api public
	 */
	
	Query.prototype.findOneAndRemove = function(conditions, options, callback) {
	  this.op = 'findOneAndRemove';
	  this._validate();
	
	  switch (arguments.length) {
	    case 2:
	      if (typeof options === 'function') {
	        callback = options;
	        options = {};
	      }
	      break;
	    case 1:
	      if (typeof conditions === 'function') {
	        callback = conditions;
	        conditions = undefined;
	        options = undefined;
	      }
	      break;
	  }
	
	  if (mquery.canMerge(conditions)) {
	    this.merge(conditions);
	  }
	
	  options && this.setOptions(options);
	
	  if (!callback) {
	    return this;
	  }
	
	  this._findOneAndRemove(callback);
	
	  return this;
	};
	
	/*!
	 * Thunk around findOneAndRemove()
	 *
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api private
	 */
	Query.prototype._findOneAndRemove = function(callback) {
	  this._castConditions();
	
	  if (this.error() != null) {
	    return callback(this.error());
	  }
	
	  Query.base.findOneAndRemove.call(this, callback);
	};
	
	/*!
	 * ignore
	 */
	
	function decorateResult(res) {
	  if (res) {
	    res._kareemIgnore = true;
	  }
	  return res;
	}
	
	/*!
	 * Override mquery.prototype._findAndModify to provide casting etc.
	 *
	 * @param {String} type - either "remove" or "update"
	 * @param {Function} callback
	 * @api private
	 */
	
	Query.prototype._findAndModify = function(type, callback) {
	  if (typeof callback !== 'function') {
	    throw new Error('Expected callback in _findAndModify');
	  }
	
	  var model = this.model;
	  var schema = model.schema;
	  var _this = this;
	  var castedQuery;
	  var castedDoc = this._update;
	  var fields;
	  var opts;
	  var doValidate;
	
	  castedQuery = castQuery(this);
	  if (castedQuery instanceof Error) {
	    return callback(castedQuery);
	  }
	
	  opts = this._optionsForExec(model);
	
	  if ('strict' in opts) {
	    this._mongooseOptions.strict = opts.strict;
	  }
	
	  var isOverwriting = this.options.overwrite && !hasDollarKeys(castedDoc);
	  if (isOverwriting) {
	    castedDoc = new this.model(castedDoc, null, true);
	  }
	
	  if (type === 'remove') {
	    opts.remove = true;
	  } else {
	    if (!('new' in opts)) {
	      opts.new = false;
	    }
	    if (!('upsert' in opts)) {
	      opts.upsert = false;
	    }
	    if (opts.upsert || opts['new']) {
	      opts.remove = false;
	    }
	
	    if (isOverwriting) {
	      doValidate = function(callback) {
	        castedDoc.validate(callback);
	      };
	    } else {
	      castedDoc = castDoc(this, opts.overwrite);
	      castedDoc = setDefaultsOnInsert(this, schema, castedDoc, opts);
	      if (!castedDoc) {
	        if (opts.upsert) {
	          // still need to do the upsert to empty doc
	          var doc = utils.clone(castedQuery);
	          delete doc._id;
	          castedDoc = {$set: doc};
	        } else {
	          return this.findOne(callback);
	        }
	      } else if (castedDoc instanceof Error) {
	        return callback(castedDoc);
	      } else {
	        // In order to make MongoDB 2.6 happy (see
	        // https://jira.mongodb.org/browse/SERVER-12266 and related issues)
	        // if we have an actual update document but $set is empty, junk the $set.
	        if (castedDoc.$set && Object.keys(castedDoc.$set).length === 0) {
	          delete castedDoc.$set;
	        }
	      }
	
	      doValidate = updateValidators(this, schema, castedDoc, opts);
	    }
	  }
	
	  this._applyPaths();
	  var userProvidedFields = this._userProvidedFields || {};
	
	  var options = this._mongooseOptions;
	
	  if (this._fields) {
	    fields = utils.clone(this._fields);
	    opts.fields = this._castFields(fields);
	    if (opts.fields instanceof Error) {
	      return callback(opts.fields);
	    }
	  }
	
	  if (opts.sort) convertSortToArray(opts);
	
	  var cb = function(err, doc, res) {
	    if (err) {
	      return callback(err);
	    }
	
	    if (!doc || (utils.isObject(doc) && Object.keys(doc).length === 0)) {
	      if (opts.rawResult) {
	        return callback(null, res);
	      }
	      // opts.passRawResult will be deprecated soon
	      if (opts.passRawResult) {
	        return callback(null, null, decorateResult(res));
	      }
	      return callback(null, null);
	    }
	
	    if (!options.populate) {
	      if (!!options.lean === true) {
	        return _completeOneLean(doc, res, opts, callback);
	      }
	      return completeOne(_this.model, doc, res, opts, fields, userProvidedFields, null, callback);
	    }
	
	    var pop = helpers.preparePopulationOptionsMQ(_this, options);
	    pop.__noPromise = true;
	    _this.model.populate(doc, pop, function(err, doc) {
	      if (err) {
	        return callback(err);
	      }
	
	      if (!!options.lean === true) {
	        return _completeOneLean(doc, res, opts, callback);
	      }
	      return completeOne(_this.model, doc, res, opts, fields, userProvidedFields, pop, callback);
	    });
	  };
	
	  if (opts.runValidators && doValidate) {
	    var _callback = function(error) {
	      if (error) {
	        return callback(error);
	      }
	      if (castedDoc && castedDoc.toBSON) {
	        castedDoc = castedDoc.toBSON();
	      }
	      _this._collection.findAndModify(castedQuery, castedDoc, opts, utils.tick(function(error, res) {
	        return cb(error, res ? res.value : res, res);
	      }));
	    };
	
	    try {
	      doValidate(_callback);
	    } catch (error) {
	      callback(error);
	    }
	  } else {
	    if (castedDoc && castedDoc.toBSON) {
	      castedDoc = castedDoc.toBSON();
	    }
	    this._collection.findAndModify(castedQuery, castedDoc, opts, utils.tick(function(error, res) {
	      return cb(error, res ? res.value : res, res);
	    }));
	  }
	
	  return this;
	};
	
	/*!
	 * ignore
	 */
	
	function _completeOneLean(doc, res, opts, callback) {
	  if (opts.rawResult) {
	    return callback(null, res);
	  }
	  if (opts.passRawResult) {
	    return callback(null, doc, decorateResult(res));
	  }
	  return callback(null, doc);
	}
	
	/*!
	 * Override mquery.prototype._mergeUpdate to handle mongoose objects in
	 * updates.
	 *
	 * @param {Object} doc
	 * @api private
	 */
	
	Query.prototype._mergeUpdate = function(doc) {
	  if (!this._update) this._update = {};
	  if (doc instanceof Query) {
	    if (doc._update) {
	      utils.mergeClone(this._update, doc._update);
	    }
	  } else {
	    utils.mergeClone(this._update, doc);
	  }
	};
	
	/*!
	 * The mongodb driver 1.3.23 only supports the nested array sort
	 * syntax. We must convert it or sorting findAndModify will not work.
	 */
	
	function convertSortToArray(opts) {
	  if (Array.isArray(opts.sort)) {
	    return;
	  }
	  if (!utils.isObject(opts.sort)) {
	    return;
	  }
	
	  var sort = [];
	
	  for (var key in opts.sort) {
	    if (utils.object.hasOwnProperty(opts.sort, key)) {
	      sort.push([key, opts.sort[key]]);
	    }
	  }
	
	  opts.sort = sort;
	}
	
	/*!
	 * Internal thunk for .update()
	 *
	 * @param {Function} callback
	 * @see Model.update #model_Model.update
	 * @api private
	 */
	Query.prototype._execUpdate = function(callback) {
	  var schema = this.model.schema;
	  var doValidate;
	  var _this;
	
	  this._castConditions();
	
	  var castedQuery = this._conditions;
	  var castedDoc = this._update;
	  var options = this.options;
	
	  if (this.error() != null) {
	    callback(this.error());
	    return this;
	  }
	
	  var isOverwriting = this.options.overwrite && !hasDollarKeys(castedDoc);
	  if (isOverwriting) {
	    castedDoc = new this.model(castedDoc, null, true);
	  }
	
	  if (this.options.runValidators) {
	    _this = this;
	    if (isOverwriting) {
	      doValidate = function(callback) {
	        castedDoc.validate(callback);
	      };
	    } else {
	      doValidate = updateValidators(this, schema, castedDoc, options);
	    }
	    var _callback = function(err) {
	      if (err) {
	        return callback(err);
	      }
	
	      if (castedDoc.toBSON) {
	        castedDoc = castedDoc.toBSON();
	      }
	      Query.base.update.call(_this, castedQuery, castedDoc, options, callback);
	    };
	    try {
	      doValidate(_callback);
	    } catch (err) {
	      process.nextTick(function() {
	        callback(err);
	      });
	    }
	    return this;
	  }
	
	  if (castedDoc.toBSON) {
	    castedDoc = castedDoc.toBSON();
	  }
	  Query.base.update.call(this, castedQuery, castedDoc, options, callback);
	  return this;
	};
	
	/*!
	 * Internal thunk for .updateMany()
	 *
	 * @param {Function} callback
	 * @see Model.update #model_Model.update
	 * @api private
	 */
	Query.prototype._updateMany = function(callback) {
	  var schema = this.model.schema;
	  var doValidate;
	  var _this;
	
	  this._castConditions();
	
	  var castedQuery = this._conditions;
	  var castedDoc = this._update;
	  var options = this.options;
	
	  if (this.error() != null) {
	    callback(this.error());
	    return this;
	  }
	
	  if (this.options.runValidators) {
	    _this = this;
	    doValidate = updateValidators(this, schema, castedDoc, options);
	    var _callback = function(err) {
	      if (err) {
	        return callback(err);
	      }
	
	      Query.base.updateMany.call(_this, castedQuery, castedDoc, options, callback);
	    };
	    try {
	      doValidate(_callback);
	    } catch (err) {
	      process.nextTick(function() {
	        callback(err);
	      });
	    }
	    return this;
	  }
	
	  Query.base.updateMany.call(this, castedQuery, castedDoc, options, callback);
	  return this;
	};
	
	/*!
	 * Internal thunk for .updateOne()
	 *
	 * @param {Function} callback
	 * @see Model.update #model_Model.update
	 * @api private
	 */
	Query.prototype._updateOne = function(callback) {
	  var schema = this.model.schema;
	  var doValidate;
	  var _this;
	
	  this._castConditions();
	
	  var castedQuery = this._conditions;
	  var castedDoc = this._update;
	  var options = this.options;
	
	  if (this.error() != null) {
	    callback(this.error());
	    return this;
	  }
	
	  if (this.options.runValidators) {
	    _this = this;
	    doValidate = updateValidators(this, schema, castedDoc, options);
	    var _callback = function(err) {
	      if (err) {
	        return callback(err);
	      }
	
	      Query.base.updateOne.call(_this, castedQuery, castedDoc, options, callback);
	    };
	    try {
	      doValidate(_callback);
	    } catch (err) {
	      process.nextTick(function() {
	        callback(err);
	      });
	    }
	    return this;
	  }
	
	  Query.base.updateOne.call(this, castedQuery, castedDoc, options, callback);
	  return this;
	};
	
	/*!
	 * Internal thunk for .replaceOne()
	 *
	 * @param {Function} callback
	 * @see Model.replaceOne #model_Model.replaceOne
	 * @api private
	 */
	Query.prototype._replaceOne = function(callback) {
	  var schema = this.model.schema;
	  var doValidate;
	  var _this;
	
	  var castedQuery = this._conditions;
	  var castedDoc = this._update;
	  var options = this.options;
	
	  if (this.error() != null) {
	    callback(this.error());
	    return this;
	  }
	
	  if (this.options.runValidators) {
	    _this = this;
	    doValidate = updateValidators(this, schema, castedDoc, options);
	    var _callback = function(err) {
	      if (err) {
	        return callback(err);
	      }
	
	      Query.base.replaceOne.call(_this, castedQuery, castedDoc, options, callback);
	    };
	    try {
	      doValidate(_callback);
	    } catch (err) {
	      process.nextTick(function() {
	        callback(err);
	      });
	    }
	    return this;
	  }
	
	  Query.base.replaceOne.call(this, castedQuery, castedDoc, options, callback);
	  return this;
	};
	
	/**
	 * Declare and/or execute this query as an update() operation.
	 *
	 * _All paths passed that are not $atomic operations will become $set ops._
	 *
	 * This function triggers the following middleware:
	 * - `update()`
	 *
	 * ####Example
	 *
	 *     Model.where({ _id: id }).update({ title: 'words' })
	 *
	 *     // becomes
	 *
	 *     Model.where({ _id: id }).update({ $set: { title: 'words' }})
	 *
	 * ####Valid options:
	 *
	 *  - `safe` (boolean) safe mode (defaults to value set in schema (true))
	 *  - `upsert` (boolean) whether to create the doc if it doesn't match (false)
	 *  - `multi` (boolean) whether multiple documents should be updated (false)
	 *  - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.
	 *  - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).
	 *  - `strict` (boolean) overrides the `strict` option for this update
	 *  - `overwrite` (boolean) disables update-only mode, allowing you to overwrite the doc (false)
	 *  - `context` (string) if set to 'query' and `runValidators` is on, `this` will refer to the query in custom validator functions that update validation runs. Does nothing if `runValidators` is false.
	 *
	 * ####Note
	 *
	 * Passing an empty object `{}` as the doc will result in a no-op unless the `overwrite` option is passed. Without the `overwrite` option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.
	 *
	 * ####Note
	 *
	 * The operation is only executed when a callback is passed. To force execution without a callback, we must first call update() and then execute it by using the `exec()` method.
	 *
	 *     var q = Model.where({ _id: id });
	 *     q.update({ $set: { name: 'bob' }}).update(); // not executed
	 *
	 *     q.update({ $set: { name: 'bob' }}).exec(); // executed
	 *
	 *     // keys that are not $atomic ops become $set.
	 *     // this executes the same command as the previous example.
	 *     q.update({ name: 'bob' }).exec();
	 *
	 *     // overwriting with empty docs
	 *     var q = Model.where({ _id: id }).setOptions({ overwrite: true })
	 *     q.update({ }, callback); // executes
	 *
	 *     // multi update with overwrite to empty doc
	 *     var q = Model.where({ _id: id });
	 *     q.setOptions({ multi: true, overwrite: true })
	 *     q.update({ });
	 *     q.update(callback); // executed
	 *
	 *     // multi updates
	 *     Model.where()
	 *          .update({ name: /^match/ }, { $set: { arr: [] }}, { multi: true }, callback)
	 *
	 *     // more multi updates
	 *     Model.where()
	 *          .setOptions({ multi: true })
	 *          .update({ $set: { arr: [] }}, callback)
	 *
	 *     // single update by default
	 *     Model.where({ email: 'address@example.com' })
	 *          .update({ $inc: { counter: 1 }}, callback)
	 *
	 * API summary
	 *
	 *     update(criteria, doc, options, cb) // executes
	 *     update(criteria, doc, options)
	 *     update(criteria, doc, cb) // executes
	 *     update(criteria, doc)
	 *     update(doc, cb) // executes
	 *     update(doc)
	 *     update(cb) // executes
	 *     update(true) // executes
	 *     update()
	 *
	 * @param {Object} [criteria]
	 * @param {Object} [doc] the update command
	 * @param {Object} [options]
	 * @param {Function} [callback] optional, params are (error, writeOpResult)
	 * @return {Query} this
	 * @see Model.update #model_Model.update
	 * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/
	 * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult
	 * @api public
	 */
	
	Query.prototype.update = function(conditions, doc, options, callback) {
	  if (typeof options === 'function') {
	    // .update(conditions, doc, callback)
	    callback = options;
	    options = null;
	  } else if (typeof doc === 'function') {
	    // .update(doc, callback);
	    callback = doc;
	    doc = conditions;
	    conditions = {};
	    options = null;
	  } else if (typeof conditions === 'function') {
	    // .update(callback)
	    callback = conditions;
	    conditions = undefined;
	    doc = undefined;
	    options = undefined;
	  } else if (typeof conditions === 'object' && !doc && !options && !callback) {
	    // .update(doc)
	    doc = conditions;
	    conditions = undefined;
	    options = undefined;
	    callback = undefined;
	  }
	
	  return _update(this, 'update', conditions, doc, options, callback);
	};
	
	/**
	 * Declare and/or execute this query as an updateMany() operation. Same as
	 * `update()`, except MongoDB will update _all_ documents that match
	 * `criteria` (as opposed to just the first one) regardless of the value of
	 * the `multi` option.
	 *
	 * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`
	 * and `post('updateMany')` instead.
	 *
	 * This function triggers the following middleware:
	 * - `updateMany()`
	 *
	 * @param {Object} [criteria]
	 * @param {Object} [doc] the update command
	 * @param {Object} [options]
	 * @param {Function} [callback] optional params are (error, writeOpResult)
	 * @return {Query} this
	 * @see Model.update #model_Model.update
	 * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/
	 * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult
	 * @api public
	 */
	
	Query.prototype.updateMany = function(conditions, doc, options, callback) {
	  if (typeof options === 'function') {
	    // .update(conditions, doc, callback)
	    callback = options;
	    options = null;
	  } else if (typeof doc === 'function') {
	    // .update(doc, callback);
	    callback = doc;
	    doc = conditions;
	    conditions = {};
	    options = null;
	  } else if (typeof conditions === 'function') {
	    // .update(callback)
	    callback = conditions;
	    conditions = undefined;
	    doc = undefined;
	    options = undefined;
	  } else if (typeof conditions === 'object' && !doc && !options && !callback) {
	    // .update(doc)
	    doc = conditions;
	    conditions = undefined;
	    options = undefined;
	    callback = undefined;
	  }
	
	  return _update(this, 'updateMany', conditions, doc, options, callback);
	};
	
	/**
	 * Declare and/or execute this query as an updateOne() operation. Same as
	 * `update()`, except MongoDB will update _only_ the first document that
	 * matches `criteria` regardless of the value of the `multi` option.
	 *
	 * **Note** updateOne will _not_ fire update middleware. Use `pre('updateOne')`
	 * and `post('updateOne')` instead.
	 *
	 * This function triggers the following middleware:
	 * - `updateOne()`
	 *
	 * @param {Object} [criteria]
	 * @param {Object} [doc] the update command
	 * @param {Object} [options]
	 * @param {Function} [callback] params are (error, writeOpResult)
	 * @return {Query} this
	 * @see Model.update #model_Model.update
	 * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/
	 * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult
	 * @api public
	 */
	
	Query.prototype.updateOne = function(conditions, doc, options, callback) {
	  if (typeof options === 'function') {
	    // .update(conditions, doc, callback)
	    callback = options;
	    options = null;
	  } else if (typeof doc === 'function') {
	    // .update(doc, callback);
	    callback = doc;
	    doc = conditions;
	    conditions = {};
	    options = null;
	  } else if (typeof conditions === 'function') {
	    // .update(callback)
	    callback = conditions;
	    conditions = undefined;
	    doc = undefined;
	    options = undefined;
	  } else if (typeof conditions === 'object' && !doc && !options && !callback) {
	    // .update(doc)
	    doc = conditions;
	    conditions = undefined;
	    options = undefined;
	    callback = undefined;
	  }
	
	  return _update(this, 'updateOne', conditions, doc, options, callback);
	};
	
	/**
	 * Declare and/or execute this query as a replaceOne() operation. Same as
	 * `update()`, except MongoDB will replace the existing document and will
	 * not accept any atomic operators (`$set`, etc.)
	 *
	 * **Note** replaceOne will _not_ fire update middleware. Use `pre('replaceOne')`
	 * and `post('replaceOne')` instead.
	 *
	 * This function triggers the following middleware:
	 * - `replaceOne()`
	 *
	 * @param {Object} [criteria]
	 * @param {Object} [doc] the update command
	 * @param {Object} [options]
	 * @param {Function} [callback] optional params are (error, writeOpResult)
	 * @return {Query} this
	 * @see Model.update #model_Model.update
	 * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/
	 * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult
	 * @api public
	 */
	
	Query.prototype.replaceOne = function(conditions, doc, options, callback) {
	  if (typeof options === 'function') {
	    // .update(conditions, doc, callback)
	    callback = options;
	    options = null;
	  } else if (typeof doc === 'function') {
	    // .update(doc, callback);
	    callback = doc;
	    doc = conditions;
	    conditions = {};
	    options = null;
	  } else if (typeof conditions === 'function') {
	    // .update(callback)
	    callback = conditions;
	    conditions = undefined;
	    doc = undefined;
	    options = undefined;
	  } else if (typeof conditions === 'object' && !doc && !options && !callback) {
	    // .update(doc)
	    doc = conditions;
	    conditions = undefined;
	    options = undefined;
	    callback = undefined;
	  }
	
	  this.setOptions({ overwrite: true });
	  return _update(this, 'replaceOne', conditions, doc, options, callback);
	};
	
	/*!
	 * Internal helper for update, updateMany, updateOne, replaceOne
	 */
	
	function _update(query, op, conditions, doc, options, callback) {
	  // make sure we don't send in the whole Document to merge()
	  query.op = op;
	  conditions = utils.toObject(conditions);
	
	  var oldCb = callback;
	  if (oldCb) {
	    if (typeof oldCb === 'function') {
	      callback = function(error, result) {
	        oldCb(error, result ? result.result : {ok: 0, n: 0, nModified: 0});
	      };
	    } else {
	      throw new Error('Invalid callback() argument.');
	    }
	  }
	
	  // strict is an option used in the update checking, make sure it gets set
	  if (options) {
	    if ('strict' in options) {
	      query._mongooseOptions.strict = options.strict;
	    }
	  }
	
	  // if doc is undefined at this point, this means this function is being
	  // executed by exec(not always see below). Grab the update doc from here in
	  // order to validate
	  // This could also be somebody calling update() or update({}). Probably not a
	  // common use case, check for _update to make sure we don't do anything bad
	  if (!doc && query._update) {
	    doc = query._updateForExec();
	  }
	
	  if (!(conditions instanceof Query) &&
	      conditions != null &&
	      conditions.toString() !== '[object Object]') {
	    query.error(new ObjectParameterError(conditions, 'filter', op));
	  } else {
	    query.merge(conditions);
	  }
	
	  // validate the selector part of the query
	  var castedQuery = castQuery(query);
	  if (castedQuery instanceof Error) {
	    query.error(castedQuery);
	    if (callback) {
	      callback(castedQuery);
	      return query;
	    } else if (!options || !options.dontThrowCastError) {
	      throw castedQuery;
	    }
	  }
	
	  // validate the update part of the query
	  var castedDoc;
	  try {
	    var $options = {retainKeyOrder: true};
	    if (options && options.minimize) {
	      $options.minimize = true;
	    }
	    castedDoc = query._castUpdate(utils.clone(doc, $options),
	      (options && options.overwrite) || op === 'replaceOne');
	  } catch (err) {
	    query.error(castedQuery);
	    if (callback) {
	      callback(err);
	      return query;
	    } else if (!options || !options.dontThrowCastError) {
	      throw err;
	    }
	  }
	
	  castedDoc = setDefaultsOnInsert(query, query.schema, castedDoc, options);
	  if (!castedDoc) {
	    // Make sure promises know that this is still an update, see gh-2796
	    query.op = op;
	    callback && callback(null);
	    return query;
	  }
	
	  if (utils.isObject(options)) {
	    query.setOptions(options);
	  }
	
	  if (!query._update) {
	    query._update = castedDoc;
	  }
	
	  // Hooks
	  if (callback) {
	    if (op === 'update') {
	      return query._execUpdate(callback);
	    }
	    return query['_' + op](callback);
	  }
	
	  return Query.base[op].call(query, castedQuery, castedDoc, options, callback);
	}
	
	/**
	 * Executes the query
	 *
	 * ####Examples:
	 *
	 *     var promise = query.exec();
	 *     var promise = query.exec('update');
	 *
	 *     query.exec(callback);
	 *     query.exec('find', callback);
	 *
	 * @param {String|Function} [operation]
	 * @param {Function} [callback] optional params depend on the function being called
	 * @return {Promise}
	 * @api public
	 */
	
	Query.prototype.exec = function exec(op, callback) {
	  var Promise = PromiseProvider.get();
	  var _this = this;
	
	  if (typeof op === 'function') {
	    callback = op;
	    op = null;
	  } else if (typeof op === 'string') {
	    this.op = op;
	  }
	
	  var _results;
	  var promise = new Promise.ES6(function(resolve, reject) {
	    if (!_this.op) {
	      resolve();
	      return;
	    }
	
	    _this[_this.op].call(_this, function(error, res) {
	      if (error) {
	        reject(error);
	        return;
	      }
	      _results = arguments;
	      resolve(res);
	    });
	  });
	
	  if (callback) {
	    promise.then(
	      function() {
	        callback.apply(null, _results);
	        return null;
	      },
	      function(error) {
	        callback(error, null);
	      }).
	      catch(function(error) {
	        // If we made it here, we must have an error in the callback re:
	        // gh-4500, so we need to emit.
	        setImmediate(function() {
	          _this.model.emit('error', error);
	        });
	      });
	  }
	
	  return promise;
	};
	
	/**
	 * Executes the query returning a `Promise` which will be
	 * resolved with either the doc(s) or rejected with the error.
	 *
	 * @param {Function} [resolve]
	 * @param {Function} [reject]
	 * @return {Promise}
	 * @api public
	 */
	
	Query.prototype.then = function(resolve, reject) {
	  return this.exec().then(resolve, reject);
	};
	
	/**
	 * Executes the query returning a `Promise` which will be
	 * resolved with either the doc(s) or rejected with the error.
	 * Like `.then()`, but only takes a rejection handler.
	 *
	 * @param {Function} [reject]
	 * @return {Promise}
	 * @api public
	 */
	
	Query.prototype.catch = function(reject) {
	  return this.exec().then(null, reject);
	};
	
	/*!
	 * Casts obj for an update command.
	 *
	 * @param {Object} obj
	 * @return {Object} obj after casting its values
	 * @api private
	 */
	
	Query.prototype._castUpdate = function _castUpdate(obj, overwrite) {
	  var strict;
	  if ('strict' in this._mongooseOptions) {
	    strict = this._mongooseOptions.strict;
	  } else if (this.schema && this.schema.options) {
	    strict = this.schema.options.strict;
	  } else {
	    strict = true;
	  }
	  return castUpdate(this.schema, obj, {
	    overwrite: overwrite,
	    strict: strict
	  }, this);
	};
	
	/*!
	 * castQuery
	 * @api private
	 */
	
	function castQuery(query) {
	  try {
	    return query.cast(query.model);
	  } catch (err) {
	    return err;
	  }
	}
	
	/*!
	 * castDoc
	 * @api private
	 */
	
	function castDoc(query, overwrite) {
	  try {
	    return query._castUpdate(query._update, overwrite);
	  } catch (err) {
	    return err;
	  }
	}
	
	/**
	 * Specifies paths which should be populated with other documents.
	 *
	 * ####Example:
	 *
	 *     Kitten.findOne().populate('owner').exec(function (err, kitten) {
	 *       console.log(kitten.owner.name) // Max
	 *     })
	 *
	 *     Kitten.find().populate({
	 *         path: 'owner'
	 *       , select: 'name'
	 *       , match: { color: 'black' }
	 *       , options: { sort: { name: -1 }}
	 *     }).exec(function (err, kittens) {
	 *       console.log(kittens[0].owner.name) // Zoopa
	 *     })
	 *
	 *     // alternatively
	 *     Kitten.find().populate('owner', 'name', null, {sort: { name: -1 }}).exec(function (err, kittens) {
	 *       console.log(kittens[0].owner.name) // Zoopa
	 *     })
	 *
	 * Paths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.
	 *
	 * @param {Object|String} path either the path to populate or an object specifying all parameters
	 * @param {Object|String} [select] Field selection for the population query
	 * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.
	 * @param {Object} [match] Conditions for the population query
	 * @param {Object} [options] Options for the population query (sort, etc)
	 * @see population ./populate.html
	 * @see Query#select #query_Query-select
	 * @see Model.populate #model_Model.populate
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.populate = function() {
	  if (arguments.length === 0) {
	    return this;
	  }
	
	  var i;
	
	  var res = utils.populate.apply(null, arguments);
	
	  // Propagate readPreference from parent query, unless one already specified
	  if (this.options && this.options.readPreference != null) {
	    for (i = 0; i < res.length; ++i) {
	      if (!res[i].options || res[i].options.readPreference == null) {
	        res[i].options = res[i].options || {};
	        res[i].options.readPreference = this.options.readPreference;
	      }
	    }
	  }
	
	  var opts = this._mongooseOptions;
	
	  if (!utils.isObject(opts.populate)) {
	    opts.populate = {};
	  }
	
	  var pop = opts.populate;
	
	  for (i = 0; i < res.length; ++i) {
	    var path = res[i].path;
	    if (pop[path] && pop[path].populate && res[i].populate) {
	      res[i].populate = pop[path].populate.concat(res[i].populate);
	    }
	    pop[res[i].path] = res[i];
	  }
	
	  return this;
	};
	
	/**
	 * Casts this query to the schema of `model`
	 *
	 * ####Note
	 *
	 * If `obj` is present, it is cast instead of this query.
	 *
	 * @param {Model} model
	 * @param {Object} [obj]
	 * @return {Object}
	 * @api public
	 */
	
	Query.prototype.cast = function(model, obj) {
	  obj || (obj = this._conditions);
	
	  try {
	    return cast(model.schema, obj, {
	      upsert: this.options && this.options.upsert,
	      strict: (this.options && 'strict' in this.options) ?
	        this.options.strict :
	        (model.schema.options && model.schema.options.strict),
	      strictQuery: (this.options && this.options.strictQuery) ||
	        (model.schema.options && model.schema.options.strictQuery)
	    }, this);
	  } catch (err) {
	    // CastError, assign model
	    if (typeof err.setModel === 'function') {
	      err.setModel(model);
	    }
	    throw err;
	  }
	};
	
	/**
	 * Casts selected field arguments for field selection with mongo 2.2
	 *
	 *     query.select({ ids: { $elemMatch: { $in: [hexString] }})
	 *
	 * @param {Object} fields
	 * @see https://github.com/Automattic/mongoose/issues/1091
	 * @see http://docs.mongodb.org/manual/reference/projection/elemMatch/
	 * @api private
	 */
	
	Query.prototype._castFields = function _castFields(fields) {
	  var selected,
	      elemMatchKeys,
	      keys,
	      key,
	      out,
	      i;
	
	  if (fields) {
	    keys = Object.keys(fields);
	    elemMatchKeys = [];
	    i = keys.length;
	
	    // collect $elemMatch args
	    while (i--) {
	      key = keys[i];
	      if (fields[key].$elemMatch) {
	        selected || (selected = {});
	        selected[key] = fields[key];
	        elemMatchKeys.push(key);
	      }
	    }
	  }
	
	  if (selected) {
	    // they passed $elemMatch, cast em
	    try {
	      out = this.cast(this.model, selected);
	    } catch (err) {
	      return err;
	    }
	
	    // apply the casted field args
	    i = elemMatchKeys.length;
	    while (i--) {
	      key = elemMatchKeys[i];
	      fields[key] = out[key];
	    }
	  }
	
	  return fields;
	};
	
	/**
	 * Applies schematype selected options to this query.
	 * @api private
	 */
	
	Query.prototype._applyPaths = function applyPaths() {
	  this._fields = this._fields || {};
	  helpers.applyPaths(this._fields, this.model.schema);
	  selectPopulatedFields(this);
	};
	
	/**
	 * Returns a Node.js 0.8 style [read stream](http://nodejs.org/docs/v0.8.21/api/stream.html#stream_readable_stream) interface.
	 *
	 * ####Example
	 *
	 *     // follows the nodejs 0.8 stream api
	 *     Thing.find({ name: /^hello/ }).stream().pipe(res)
	 *
	 *     // manual streaming
	 *     var stream = Thing.find({ name: /^hello/ }).stream();
	 *
	 *     stream.on('data', function (doc) {
	 *       // do something with the mongoose document
	 *     }).on('error', function (err) {
	 *       // handle the error
	 *     }).on('close', function () {
	 *       // the stream is closed
	 *     });
	 *
	 * ####Valid options
	 *
	 *   - `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data`.
	 *
	 * ####Example
	 *
	 *     // JSON.stringify all documents before emitting
	 *     var stream = Thing.find().stream({ transform: JSON.stringify });
	 *     stream.pipe(writeStream);
	 *
	 * @return {QueryStream}
	 * @param {Object} [options]
	 * @see QueryStream
	 * @api public
	 */
	
	Query.prototype.stream = function stream(opts) {
	  this._applyPaths();
	  this._fields = this._castFields(this._fields);
	  this._castConditions();
	  return new QueryStream(this, opts);
	};
	Query.prototype.stream = util.deprecate(Query.prototype.stream, 'Mongoose: ' +
	  'Query.prototype.stream() is deprecated in mongoose >= 4.5.0, ' +
	  'use Query.prototype.cursor() instead');
	
	/**
	 * Returns a wrapper around a [mongodb driver cursor](http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html).
	 * A QueryCursor exposes a [Streams3](https://strongloop.com/strongblog/whats-new-io-js-beta-streams3/)-compatible
	 * interface, as well as a `.next()` function.
	 *
	 * The `.cursor()` function triggers pre find hooks, but **not** post find hooks.
	 *
	 * ####Example
	 *
	 *     // There are 2 ways to use a cursor. First, as a stream:
	 *     Thing.
	 *       find({ name: /^hello/ }).
	 *       cursor().
	 *       on('data', function(doc) { console.log(doc); }).
	 *       on('end', function() { console.log('Done!'); });
	 *
	 *     // Or you can use `.next()` to manually get the next doc in the stream.
	 *     // `.next()` returns a promise, so you can use promises or callbacks.
	 *     var cursor = Thing.find({ name: /^hello/ }).cursor();
	 *     cursor.next(function(error, doc) {
	 *       console.log(doc);
	 *     });
	 *
	 *     // Because `.next()` returns a promise, you can use co
	 *     // to easily iterate through all documents without loading them
	 *     // all into memory.
	 *     co(function*() {
	 *       const cursor = Thing.find({ name: /^hello/ }).cursor();
	 *       for (let doc = yield cursor.next(); doc != null; doc = yield cursor.next()) {
	 *         console.log(doc);
	 *       }
	 *     });
	 *
	 * ####Valid options
	 *
	 *   - `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data` and returned by `.next()`.
	 *
	 * @return {QueryCursor}
	 * @param {Object} [options]
	 * @see QueryCursor
	 * @api public
	 */
	
	Query.prototype.cursor = function cursor(opts) {
	  this._applyPaths();
	  this._fields = this._castFields(this._fields);
	  this.setOptions({ fields: this._fieldsForExec() });
	  if (opts) {
	    this.setOptions(opts);
	  }
	
	  try {
	    this.cast(this.model);
	  } catch (err) {
	    return (new QueryCursor(this, this.options))._markError(err);
	  }
	
	  return new QueryCursor(this, this.options);
	};
	
	// the rest of these are basically to support older Mongoose syntax with mquery
	
	/**
	 * _DEPRECATED_ Alias of `maxScan`
	 *
	 * @deprecated
	 * @see maxScan #query_Query-maxScan
	 * @method maxscan
	 * @memberOf Query
	 */
	
	Query.prototype.maxscan = Query.base.maxScan;
	
	/**
	 * Sets the tailable option (for use with capped collections).
	 *
	 * ####Example
	 *
	 *     query.tailable() // true
	 *     query.tailable(true)
	 *     query.tailable(false)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @param {Boolean} bool defaults to true
	 * @param {Object} [opts] options to set
	 * @param {Number} [opts.numberOfRetries] if cursor is exhausted, retry this many times before giving up
	 * @param {Number} [opts.tailableRetryInterval] if cursor is exhausted, wait this many milliseconds before retrying
	 * @see tailable http://docs.mongodb.org/manual/tutorial/create-tailable-cursor/
	 * @api public
	 */
	
	Query.prototype.tailable = function(val, opts) {
	  // we need to support the tailable({ awaitdata : true }) as well as the
	  // tailable(true, {awaitdata :true}) syntax that mquery does not support
	  if (val && val.constructor.name === 'Object') {
	    opts = val;
	    val = true;
	  }
	
	  if (val === undefined) {
	    val = true;
	  }
	
	  if (opts && typeof opts === 'object') {
	    for (var key in opts) {
	      if (key === 'awaitdata') {
	        // For backwards compatibility
	        this.options[key] = !!opts[key];
	      } else {
	        this.options[key] = opts[key];
	      }
	    }
	  }
	
	  return Query.base.tailable.call(this, val);
	};
	
	/**
	 * Declares an intersects query for `geometry()`.
	 *
	 * ####Example
	 *
	 *     query.where('path').intersects().geometry({
	 *         type: 'LineString'
	 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
	 *     })
	 *
	 *     query.where('path').intersects({
	 *         type: 'LineString'
	 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
	 *     })
	 *
	 * ####NOTE:
	 *
	 * **MUST** be used after `where()`.
	 *
	 * ####NOTE:
	 *
	 * In Mongoose 3.7, `intersects` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).
	 *
	 * @method intersects
	 * @memberOf Query
	 * @param {Object} [arg]
	 * @return {Query} this
	 * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/
	 * @see geoIntersects http://docs.mongodb.org/manual/reference/operator/geoIntersects/
	 * @api public
	 */
	
	/**
	 * Specifies a `$geometry` condition
	 *
	 * ####Example
	 *
	 *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]
	 *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })
	 *
	 *     // or
	 *     var polyB = [[ 0, 0 ], [ 1, 1 ]]
	 *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })
	 *
	 *     // or
	 *     var polyC = [ 0, 0 ]
	 *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })
	 *
	 *     // or
	 *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })
	 *
	 * The argument is assigned to the most recent path passed to `where()`.
	 *
	 * ####NOTE:
	 *
	 * `geometry()` **must** come after either `intersects()` or `within()`.
	 *
	 * The `object` argument must contain `type` and `coordinates` properties.
	 * - type {String}
	 * - coordinates {Array}
	 *
	 * @method geometry
	 * @memberOf Query
	 * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.
	 * @return {Query} this
	 * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/
	 * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	/**
	 * Specifies a `$near` or `$nearSphere` condition
	 *
	 * These operators return documents sorted by distance.
	 *
	 * ####Example
	 *
	 *     query.where('loc').near({ center: [10, 10] });
	 *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });
	 *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });
	 *     query.near('loc', { center: [10, 10], maxDistance: 5 });
	 *
	 * @method near
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Object} val
	 * @return {Query} this
	 * @see $near http://docs.mongodb.org/manual/reference/operator/near/
	 * @see $nearSphere http://docs.mongodb.org/manual/reference/operator/nearSphere/
	 * @see $maxDistance http://docs.mongodb.org/manual/reference/operator/maxDistance/
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	/*!
	 * Overwriting mquery is needed to support a couple different near() forms found in older
	 * versions of mongoose
	 * near([1,1])
	 * near(1,1)
	 * near(field, [1,2])
	 * near(field, 1, 2)
	 * In addition to all of the normal forms supported by mquery
	 */
	
	Query.prototype.near = function() {
	  var params = [];
	  var sphere = this._mongooseOptions.nearSphere;
	
	  // TODO refactor
	
	  if (arguments.length === 1) {
	    if (Array.isArray(arguments[0])) {
	      params.push({center: arguments[0], spherical: sphere});
	    } else if (typeof arguments[0] === 'string') {
	      // just passing a path
	      params.push(arguments[0]);
	    } else if (utils.isObject(arguments[0])) {
	      if (typeof arguments[0].spherical !== 'boolean') {
	        arguments[0].spherical = sphere;
	      }
	      params.push(arguments[0]);
	    } else {
	      throw new TypeError('invalid argument');
	    }
	  } else if (arguments.length === 2) {
	    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
	      params.push({center: [arguments[0], arguments[1]], spherical: sphere});
	    } else if (typeof arguments[0] === 'string' && Array.isArray(arguments[1])) {
	      params.push(arguments[0]);
	      params.push({center: arguments[1], spherical: sphere});
	    } else if (typeof arguments[0] === 'string' && utils.isObject(arguments[1])) {
	      params.push(arguments[0]);
	      if (typeof arguments[1].spherical !== 'boolean') {
	        arguments[1].spherical = sphere;
	      }
	      params.push(arguments[1]);
	    } else {
	      throw new TypeError('invalid argument');
	    }
	  } else if (arguments.length === 3) {
	    if (typeof arguments[0] === 'string' && typeof arguments[1] === 'number'
	        && typeof arguments[2] === 'number') {
	      params.push(arguments[0]);
	      params.push({center: [arguments[1], arguments[2]], spherical: sphere});
	    } else {
	      throw new TypeError('invalid argument');
	    }
	  } else {
	    throw new TypeError('invalid argument');
	  }
	
	  return Query.base.near.apply(this, params);
	};
	
	/**
	 * _DEPRECATED_ Specifies a `$nearSphere` condition
	 *
	 * ####Example
	 *
	 *     query.where('loc').nearSphere({ center: [10, 10], maxDistance: 5 });
	 *
	 * **Deprecated.** Use `query.near()` instead with the `spherical` option set to `true`.
	 *
	 * ####Example
	 *
	 *     query.where('loc').near({ center: [10, 10], spherical: true });
	 *
	 * @deprecated
	 * @see near() #query_Query-near
	 * @see $near http://docs.mongodb.org/manual/reference/operator/near/
	 * @see $nearSphere http://docs.mongodb.org/manual/reference/operator/nearSphere/
	 * @see $maxDistance http://docs.mongodb.org/manual/reference/operator/maxDistance/
	 */
	
	Query.prototype.nearSphere = function() {
	  this._mongooseOptions.nearSphere = true;
	  this.near.apply(this, arguments);
	  return this;
	};
	
	/**
	 * Specifies a $polygon condition
	 *
	 * ####Example
	 *
	 *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])
	 *     query.polygon('loc', [10,20], [13, 25], [7,15])
	 *
	 * @method polygon
	 * @memberOf Query
	 * @param {String|Array} [path]
	 * @param {Array|Object} [coordinatePairs...]
	 * @return {Query} this
	 * @see $polygon http://docs.mongodb.org/manual/reference/operator/polygon/
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	/**
	 * Specifies a $box condition
	 *
	 * ####Example
	 *
	 *     var lowerLeft = [40.73083, -73.99756]
	 *     var upperRight= [40.741404,  -73.988135]
	 *
	 *     query.where('loc').within().box(lowerLeft, upperRight)
	 *     query.box({ ll : lowerLeft, ur : upperRight })
	 *
	 * @method box
	 * @memberOf Query
	 * @see $box http://docs.mongodb.org/manual/reference/operator/box/
	 * @see within() Query#within #query_Query-within
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @param {Object} val
	 * @param [Array] Upper Right Coords
	 * @return {Query} this
	 * @api public
	 */
	
	/*!
	 * this is needed to support the mongoose syntax of:
	 * box(field, { ll : [x,y], ur : [x2,y2] })
	 * box({ ll : [x,y], ur : [x2,y2] })
	 */
	
	Query.prototype.box = function(ll, ur) {
	  if (!Array.isArray(ll) && utils.isObject(ll)) {
	    ur = ll.ur;
	    ll = ll.ll;
	  }
	  return Query.base.box.call(this, ll, ur);
	};
	
	/**
	 * Specifies a $center or $centerSphere condition.
	 *
	 * ####Example
	 *
	 *     var area = { center: [50, 50], radius: 10, unique: true }
	 *     query.where('loc').within().circle(area)
	 *     // alternatively
	 *     query.circle('loc', area);
	 *
	 *     // spherical calculations
	 *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true }
	 *     query.where('loc').within().circle(area)
	 *     // alternatively
	 *     query.circle('loc', area);
	 *
	 * New in 3.7.0
	 *
	 * @method circle
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Object} area
	 * @return {Query} this
	 * @see $center http://docs.mongodb.org/manual/reference/operator/center/
	 * @see $centerSphere http://docs.mongodb.org/manual/reference/operator/centerSphere/
	 * @see $geoWithin http://docs.mongodb.org/manual/reference/operator/geoWithin/
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	/**
	 * _DEPRECATED_ Alias for [circle](#query_Query-circle)
	 *
	 * **Deprecated.** Use [circle](#query_Query-circle) instead.
	 *
	 * @deprecated
	 * @method center
	 * @memberOf Query
	 * @api public
	 */
	
	Query.prototype.center = Query.base.circle;
	
	/**
	 * _DEPRECATED_ Specifies a $centerSphere condition
	 *
	 * **Deprecated.** Use [circle](#query_Query-circle) instead.
	 *
	 * ####Example
	 *
	 *     var area = { center: [50, 50], radius: 10 };
	 *     query.where('loc').within().centerSphere(area);
	 *
	 * @deprecated
	 * @param {String} [path]
	 * @param {Object} val
	 * @return {Query} this
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @see $centerSphere http://docs.mongodb.org/manual/reference/operator/centerSphere/
	 * @api public
	 */
	
	Query.prototype.centerSphere = function() {
	  if (arguments[0] && arguments[0].constructor.name === 'Object') {
	    arguments[0].spherical = true;
	  }
	
	  if (arguments[1] && arguments[1].constructor.name === 'Object') {
	    arguments[1].spherical = true;
	  }
	
	  Query.base.circle.apply(this, arguments);
	};
	
	/**
	 * Determines if field selection has been made.
	 *
	 * @method selected
	 * @memberOf Query
	 * @return {Boolean}
	 * @api public
	 */
	
	/**
	 * Determines if inclusive field selection has been made.
	 *
	 *     query.selectedInclusively() // false
	 *     query.select('name')
	 *     query.selectedInclusively() // true
	 *
	 * @method selectedInclusively
	 * @memberOf Query
	 * @return {Boolean}
	 * @api public
	 */
	
	Query.prototype.selectedInclusively = function selectedInclusively() {
	  if (!this._fields) {
	    return false;
	  }
	
	  var keys = Object.keys(this._fields);
	  if (keys.length === 0) {
	    return false;
	  }
	
	  for (var i = 0; i < keys.length; ++i) {
	    var key = keys[i];
	    if (this._fields[key] === 0 || this._fields[key] === false) {
	      return false;
	    }
	    if (this._fields[key] &&
	        typeof this._fields[key] === 'object' &&
	        this._fields[key].$meta) {
	      return false;
	    }
	  }
	
	  return true;
	};
	
	/**
	 * Determines if exclusive field selection has been made.
	 *
	 *     query.selectedExclusively() // false
	 *     query.select('-name')
	 *     query.selectedExclusively() // true
	 *     query.selectedInclusively() // false
	 *
	 * @method selectedExclusively
	 * @memberOf Query
	 * @return {Boolean}
	 * @api public
	 */
	
	Query.prototype.selectedExclusively = function selectedExclusively() {
	  if (!this._fields) {
	    return false;
	  }
	
	  var keys = Object.keys(this._fields);
	  if (keys.length === 0) {
	    return false;
	  }
	
	  for (var i = 0; i < keys.length; ++i) {
	    var key = keys[i];
	    if (key === '_id') {
	      continue;
	    }
	    if (this._fields[key] === 0 || this._fields[key] === false) {
	      return true;
	    }
	  }
	
	  return false;
	};
	
	/*!
	 * Export
	 */
	
	module.exports = Query;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var $exists = __webpack_require__(98);
	var $type = __webpack_require__(142);
	var SchemaType = __webpack_require__(12);
	var CastError = SchemaType.CastError;
	var Types = {
	  Array: SchemaArray,
	  Boolean: __webpack_require__(136),
	  Date: __webpack_require__(138),
	  Number: __webpack_require__(96),
	  String: __webpack_require__(143),
	  ObjectId: __webpack_require__(97),
	  Buffer: __webpack_require__(137)
	};
	var MongooseArray = __webpack_require__(31).Array;
	var EmbeddedDoc = __webpack_require__(31).Embedded;
	var Mixed = __webpack_require__(64);
	var cast = __webpack_require__(83);
	var util = __webpack_require__(1);
	var utils = __webpack_require__(4);
	var castToNumber = __webpack_require__(65).castToNumber;
	var geospatial = __webpack_require__(141);
	
	/**
	 * Array SchemaType constructor
	 *
	 * @param {String} key
	 * @param {SchemaType} cast
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function SchemaArray(key, cast, options, schemaOptions) {
	  var typeKey = 'type';
	  if (schemaOptions && schemaOptions.typeKey) {
	    typeKey = schemaOptions.typeKey;
	  }
	
	  if (cast) {
	    var castOptions = {};
	
	    if (utils.getFunctionName(cast.constructor) === 'Object') {
	      if (cast[typeKey]) {
	        // support { type: Woot }
	        castOptions = utils.clone(cast); // do not alter user arguments
	        delete castOptions[typeKey];
	        cast = cast[typeKey];
	      } else {
	        cast = Mixed;
	      }
	    }
	
	    // support { type: 'String' }
	    var name = typeof cast === 'string'
	        ? cast
	        : utils.getFunctionName(cast);
	
	    var caster = name in Types
	        ? Types[name]
	        : cast;
	
	    this.casterConstructor = caster;
	    if (typeof caster === 'function' && !caster.$isArraySubdocument) {
	      this.caster = new caster(null, castOptions);
	    } else {
	      this.caster = caster;
	    }
	
	    if (!(this.caster instanceof EmbeddedDoc)) {
	      this.caster.path = key;
	    }
	  }
	
	  this.$isMongooseArray = true;
	
	  SchemaType.call(this, key, options, 'Array');
	
	  var defaultArr;
	  var fn;
	
	  if (this.defaultValue != null) {
	    defaultArr = this.defaultValue;
	    fn = typeof defaultArr === 'function';
	  }
	
	  if (!('defaultValue' in this) || this.defaultValue !== void 0) {
	    this.default(function() {
	      var arr = [];
	      if (fn) {
	        arr = defaultArr();
	      } else if (defaultArr != null) {
	        arr = defaultArr;
	      }
	      // Leave it up to `cast()` to convert the array
	      return arr;
	    });
	  }
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	SchemaArray.schemaName = 'Array';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaArray.prototype = Object.create(SchemaType.prototype);
	SchemaArray.prototype.constructor = SchemaArray;
	
	/**
	 * Check if the given value satisfies a required validator. The given value
	 * must be not null nor undefined, and have a positive length.
	 *
	 * @param {Any} value
	 * @return {Boolean}
	 * @api public
	 */
	
	SchemaArray.prototype.checkRequired = function(value) {
	  return !!(value && value.length);
	};
	
	/**
	 * Overrides the getters application for the population special-case
	 *
	 * @param {Object} value
	 * @param {Object} scope
	 * @api private
	 */
	
	SchemaArray.prototype.applyGetters = function(value, scope) {
	  if (this.caster.options && this.caster.options.ref) {
	    // means the object id was populated
	    return value;
	  }
	
	  return SchemaType.prototype.applyGetters.call(this, value, scope);
	};
	
	/**
	 * Casts values for set().
	 *
	 * @param {Object} value
	 * @param {Document} doc document that triggers the casting
	 * @param {Boolean} init whether this is an initialization cast
	 * @api private
	 */
	
	SchemaArray.prototype.cast = function(value, doc, init) {
	  if (Array.isArray(value)) {
	    if (!value.length && doc) {
	      var indexes = doc.schema.indexedPaths();
	
	      for (var i = 0, l = indexes.length; i < l; ++i) {
	        var pathIndex = indexes[i][0][this.path];
	        if (pathIndex === '2dsphere' || pathIndex === '2d') {
	          return;
	        }
	      }
	    }
	
	    if (!(value && value.isMongooseArray)) {
	      value = new MongooseArray(value, this.path, doc);
	    } else if (value && value.isMongooseArray) {
	      // We need to create a new array, otherwise change tracking will
	      // update the old doc (gh-4449)
	      value = new MongooseArray(value, this.path, doc);
	    }
	
	    if (this.caster) {
	      try {
	        for (i = 0, l = value.length; i < l; i++) {
	          value[i] = this.caster.cast(value[i], doc, init);
	        }
	      } catch (e) {
	        // rethrow
	        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path, e);
	      }
	    }
	
	    return value;
	  }
	  // gh-2442: if we're loading this from the db and its not an array, mark
	  // the whole array as modified.
	  if (!!doc && !!init) {
	    doc.markModified(this.path);
	  }
	  return this.cast([value], doc, init);
	};
	
	/**
	 * Casts values for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [value]
	 * @api private
	 */
	
	SchemaArray.prototype.castForQuery = function($conditional, value) {
	  var handler,
	      val;
	
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	
	    if (!handler) {
	      throw new Error('Can\'t use ' + $conditional + ' with Array.');
	    }
	
	    val = handler.call(this, value);
	  } else {
	    val = $conditional;
	    var Constructor = this.casterConstructor;
	
	    if (val &&
	        Constructor.discriminators &&
	        Constructor.schema.options.discriminatorKey &&
	        typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&
	        Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {
	      Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];
	    }
	
	    var proto = this.casterConstructor.prototype;
	    var method = proto && (proto.castForQuery || proto.cast);
	    if (!method && Constructor.castForQuery) {
	      method = Constructor.castForQuery;
	    }
	    var caster = this.caster;
	
	    if (Array.isArray(val)) {
	      val = val.map(function(v) {
	        if (utils.isObject(v) && v.$elemMatch) {
	          return v;
	        }
	        if (method) {
	          v = method.call(caster, v);
	          return v;
	        }
	        if (v != null) {
	          v = new Constructor(v);
	          return v;
	        }
	        return v;
	      });
	    } else if (method) {
	      val = method.call(caster, val);
	    } else if (val != null) {
	      val = new Constructor(val);
	    }
	  }
	
	  return val;
	};
	
	function cast$all(val) {
	  if (!Array.isArray(val)) {
	    val = [val];
	  }
	
	  val = val.map(function(v) {
	    if (utils.isObject(v)) {
	      var o = {};
	      o[this.path] = v;
	      return cast(this.casterConstructor.schema, o)[this.path];
	    }
	    return v;
	  }, this);
	
	  return this.castForQuery(val);
	}
	
	function cast$elemMatch(val) {
	  var keys = Object.keys(val);
	  var numKeys = keys.length;
	  var key;
	  var value;
	  for (var i = 0; i < numKeys; ++i) {
	    key = keys[i];
	    value = val[key];
	    if (key.indexOf('$') === 0 && value) {
	      val[key] = this.castForQuery(key, value);
	    }
	  }
	
	  return cast(this.casterConstructor.schema, val);
	}
	
	var handle = SchemaArray.prototype.$conditionalHandlers = {};
	
	handle.$all = cast$all;
	handle.$options = String;
	handle.$elemMatch = cast$elemMatch;
	handle.$geoIntersects = geospatial.cast$geoIntersects;
	handle.$or = handle.$and = function(val) {
	  if (!Array.isArray(val)) {
	    throw new TypeError('conditional $or/$and require array');
	  }
	
	  var ret = [];
	  for (var i = 0; i < val.length; ++i) {
	    ret.push(cast(this.casterConstructor.schema, val[i]));
	  }
	
	  return ret;
	};
	
	handle.$near =
	handle.$nearSphere = geospatial.cast$near;
	
	handle.$within =
	handle.$geoWithin = geospatial.cast$within;
	
	handle.$size =
	handle.$minDistance =
	handle.$maxDistance = castToNumber;
	
	handle.$exists = $exists;
	handle.$type = $type;
	
	handle.$eq =
	handle.$gt =
	handle.$gte =
	handle.$in =
	handle.$lt =
	handle.$lte =
	handle.$ne =
	handle.$nin =
	handle.$regex = SchemaArray.prototype.castForQuery;
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaArray;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module requirements.
	 */
	
	var SchemaType = __webpack_require__(12);
	var CastError = SchemaType.CastError;
	var handleBitwiseOperator = __webpack_require__(140);
	var MongooseError = __webpack_require__(5);
	var utils = __webpack_require__(4);
	var Document;
	
	/**
	 * Number SchemaType constructor.
	 *
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function SchemaNumber(key, options) {
	  SchemaType.call(this, key, options, 'Number');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	SchemaNumber.schemaName = 'Number';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaNumber.prototype = Object.create(SchemaType.prototype);
	SchemaNumber.prototype.constructor = SchemaNumber;
	
	/**
	 * Check if the given value satisfies a required validator.
	 *
	 * @param {Any} value
	 * @param {Document} doc
	 * @return {Boolean}
	 * @api public
	 */
	
	SchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {
	  if (SchemaType._isRef(this, value, doc, true)) {
	    return !!value;
	  }
	  return typeof value === 'number' || value instanceof Number;
	};
	
	/**
	 * Sets a minimum number validator.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ n: { type: Number, min: 10 })
	 *     var M = db.model('M', s)
	 *     var m = new M({ n: 9 })
	 *     m.save(function (err) {
	 *       console.error(err) // validator error
	 *       m.n = 10;
	 *       m.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MIN} token which will be replaced with the invalid value
	 *     var min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];
	 *     var schema = new Schema({ n: { type: Number, min: min })
	 *     var M = mongoose.model('Measurement', schema);
	 *     var s= new M({ n: 4 });
	 *     s.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).
	 *     })
	 *
	 * @param {Number} value minimum number
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaNumber.prototype.min = function(value, message) {
	  if (this.minValidator) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator !== this.minValidator;
	    }, this);
	  }
	
	  if (value !== null && value !== undefined) {
	    var msg = message || MongooseError.messages.Number.min;
	    msg = msg.replace(/{MIN}/, value);
	    this.validators.push({
	      validator: this.minValidator = function(v) {
	        return v == null || v >= value;
	      },
	      message: msg,
	      type: 'min',
	      min: value
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Sets a maximum number validator.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ n: { type: Number, max: 10 })
	 *     var M = db.model('M', s)
	 *     var m = new M({ n: 11 })
	 *     m.save(function (err) {
	 *       console.error(err) // validator error
	 *       m.n = 10;
	 *       m.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MAX} token which will be replaced with the invalid value
	 *     var max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];
	 *     var schema = new Schema({ n: { type: Number, max: max })
	 *     var M = mongoose.model('Measurement', schema);
	 *     var s= new M({ n: 4 });
	 *     s.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).
	 *     })
	 *
	 * @param {Number} maximum number
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaNumber.prototype.max = function(value, message) {
	  if (this.maxValidator) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator !== this.maxValidator;
	    }, this);
	  }
	
	  if (value !== null && value !== undefined) {
	    var msg = message || MongooseError.messages.Number.max;
	    msg = msg.replace(/{MAX}/, value);
	    this.validators.push({
	      validator: this.maxValidator = function(v) {
	        return v == null || v <= value;
	      },
	      message: msg,
	      type: 'max',
	      max: value
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Casts to number
	 *
	 * @param {Object} value value to cast
	 * @param {Document} doc document that triggers the casting
	 * @param {Boolean} init
	 * @api private
	 */
	
	SchemaNumber.prototype.cast = function(value, doc, init) {
	  if (SchemaType._isRef(this, value, doc, init)) {
	    // wait! we may need to cast this to a document
	
	    if (value === null || value === undefined) {
	      return value;
	    }
	
	    // lazy load
	    Document || (Document = __webpack_require__(8));
	
	    if (value instanceof Document) {
	      value.$__.wasPopulated = true;
	      return value;
	    }
	
	    // setting a populated path
	    if (typeof value === 'number') {
	      return value;
	    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {
	      throw new CastError('number', value, this.path);
	    }
	
	    // Handle the case where user directly sets a populated
	    // path to a plain object; cast to the Model used in
	    // the population query.
	    var path = doc.$__fullPath(this.path);
	    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
	    var pop = owner.populated(path, true);
	    var ret = new pop.options.model(value);
	    ret.$__.wasPopulated = true;
	    return ret;
	  }
	
	  var val = value && typeof value._id !== 'undefined' ?
	    value._id : // documents
	    value;
	
	  if (!isNaN(val)) {
	    if (val === null) {
	      return val;
	    }
	    if (val === '') {
	      return null;
	    }
	    if (typeof val === 'string' || typeof val === 'boolean') {
	      val = Number(val);
	    }
	    if (val instanceof Number) {
	      return val;
	    }
	    if (typeof val === 'number') {
	      return val;
	    }
	    if (val.toString && !Array.isArray(val) && val.toString() == Number(val)) {
	      return new Number(val);
	    }
	  }
	
	  throw new CastError('number', value, this.path);
	};
	
	/*!
	 * ignore
	 */
	
	function handleSingle(val) {
	  return this.cast(val);
	}
	
	function handleArray(val) {
	  var _this = this;
	  if (!Array.isArray(val)) {
	    return [this.cast(val)];
	  }
	  return val.map(function(m) {
	    return _this.cast(m);
	  });
	}
	
	SchemaNumber.prototype.$conditionalHandlers =
	    utils.options(SchemaType.prototype.$conditionalHandlers, {
	      $bitsAllClear: handleBitwiseOperator,
	      $bitsAnyClear: handleBitwiseOperator,
	      $bitsAllSet: handleBitwiseOperator,
	      $bitsAnySet: handleBitwiseOperator,
	      $gt: handleSingle,
	      $gte: handleSingle,
	      $lt: handleSingle,
	      $lte: handleSingle,
	      $mod: handleArray
	    });
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [value]
	 * @api private
	 */
	
	SchemaNumber.prototype.castForQuery = function($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	    if (!handler) {
	      throw new Error('Can\'t use ' + $conditional + ' with Number.');
	    }
	    return handler.call(this, val);
	  }
	  val = this._castForQuery($conditional);
	  return val;
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaNumber;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint no-empty: 1 */
	
	/*!
	 * Module dependencies.
	 */
	
	var SchemaType = __webpack_require__(12),
	    CastError = SchemaType.CastError,
	    oid = __webpack_require__(24),
	    utils = __webpack_require__(4),
	    Document;
	
	/**
	 * ObjectId SchemaType constructor.
	 *
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function ObjectId(key, options) {
	  var isKeyHexStr = typeof key === 'string' && /^a-f0-9$/i.test(key);
	  var suppressWarning = options && options.suppressWarning;
	  if ((isKeyHexStr || typeof key === 'undefined') && !suppressWarning) {
	    console.warn('mongoose: To create a new ObjectId please try ' +
	      '`Mongoose.Types.ObjectId` instead of using ' +
	      '`Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if ' +
	      'you\'re trying to create a hex char path in your schema.');
	    console.trace();
	  }
	  SchemaType.call(this, key, options, 'ObjectID');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	ObjectId.schemaName = 'ObjectId';
	
	/*!
	 * Inherits from SchemaType.
	 */
	ObjectId.prototype = Object.create(SchemaType.prototype);
	ObjectId.prototype.constructor = ObjectId;
	
	/**
	 * Adds an auto-generated ObjectId default if turnOn is true.
	 * @param {Boolean} turnOn auto generated ObjectId defaults
	 * @api public
	 * @return {SchemaType} this
	 */
	
	ObjectId.prototype.auto = function(turnOn) {
	  if (turnOn) {
	    this.default(defaultId);
	    this.set(resetId);
	  }
	
	  return this;
	};
	
	/**
	 * Check if the given value satisfies a required validator.
	 *
	 * @param {Any} value
	 * @param {Document} doc
	 * @return {Boolean}
	 * @api public
	 */
	
	ObjectId.prototype.checkRequired = function checkRequired(value, doc) {
	  if (SchemaType._isRef(this, value, doc, true)) {
	    return !!value;
	  }
	  return value instanceof oid;
	};
	
	/**
	 * Casts to ObjectId
	 *
	 * @param {Object} value
	 * @param {Object} doc
	 * @param {Boolean} init whether this is an initialization cast
	 * @api private
	 */
	
	ObjectId.prototype.cast = function(value, doc, init) {
	  if (SchemaType._isRef(this, value, doc, init)) {
	    // wait! we may need to cast this to a document
	
	    if (value === null || value === undefined) {
	      return value;
	    }
	
	    // lazy load
	    Document || (Document = __webpack_require__(8));
	
	    if (value instanceof Document) {
	      value.$__.wasPopulated = true;
	      return value;
	    }
	
	    // setting a populated path
	    if (value instanceof oid) {
	      return value;
	    } else if ((value.constructor.name || '').toLowerCase() === 'objectid') {
	      return new oid(value.toHexString());
	    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {
	      throw new CastError('ObjectId', value, this.path);
	    }
	
	    // Handle the case where user directly sets a populated
	    // path to a plain object; cast to the Model used in
	    // the population query.
	    var path = doc.$__fullPath(this.path);
	    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
	    var pop = owner.populated(path, true);
	    var ret = value;
	    if (!doc.$__.populated ||
	        !doc.$__.populated[path] ||
	        !doc.$__.populated[path].options ||
	        !doc.$__.populated[path].options.options ||
	        !doc.$__.populated[path].options.options.lean) {
	      ret = new pop.options.model(value);
	      ret.$__.wasPopulated = true;
	    }
	
	    return ret;
	  }
	
	  if (value === null || value === undefined) {
	    return value;
	  }
	
	  if (value instanceof oid) {
	    return value;
	  }
	
	  if (value._id) {
	    if (value._id instanceof oid) {
	      return value._id;
	    }
	    if (value._id.toString instanceof Function) {
	      try {
	        return new oid(value._id.toString());
	      } catch (e) {
	      }
	    }
	  }
	
	  if (value.toString instanceof Function) {
	    try {
	      return new oid(value.toString());
	    } catch (err) {
	      throw new CastError('ObjectId', value, this.path);
	    }
	  }
	
	  throw new CastError('ObjectId', value, this.path);
	};
	
	/*!
	 * ignore
	 */
	
	function handleSingle(val) {
	  return this.cast(val);
	}
	
	ObjectId.prototype.$conditionalHandlers =
	    utils.options(SchemaType.prototype.$conditionalHandlers, {
	      $gt: handleSingle,
	      $gte: handleSingle,
	      $lt: handleSingle,
	      $lte: handleSingle
	    });
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [val]
	 * @api private
	 */
	
	ObjectId.prototype.castForQuery = function($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	    if (!handler) {
	      throw new Error('Can\'t use ' + $conditional + ' with ObjectId.');
	    }
	    return handler.call(this, val);
	  }
	  return this._castForQuery($conditional);
	};
	
	/*!
	 * ignore
	 */
	
	function defaultId() {
	  return new oid();
	}
	
	function resetId(v) {
	  Document || (Document = __webpack_require__(8));
	
	  if (v === void 0) {
	    var _v = new oid;
	    this.$__._id = _v;
	    return _v;
	  }
	
	  if (this instanceof Document) {
	    this.$__._id = v;
	  }
	  return v;
	}
	
	/*!
	 * Module exports.
	 */
	
	module.exports = ObjectId;


/***/ }),
/* 98 */
/***/ (function(module, exports) {

	'use strict';
	
	/*!
	 * ignore
	 */
	
	module.exports = function(val) {
	  if (typeof val !== 'boolean') {
	    throw new Error('$exists parameter must be a boolean!');
	  }
	
	  return val;
	};


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var Document;
	var utils = __webpack_require__(4);
	
	/*!
	 * exports
	 */
	
	exports.compile = compile;
	exports.defineKey = defineKey;
	
	/*!
	 * Compiles schemas.
	 */
	
	function compile(tree, proto, prefix, options) {
	  Document = Document || __webpack_require__(8);
	  var keys = Object.keys(tree);
	  var i = keys.length;
	  var len = keys.length;
	  var limb;
	  var key;
	
	  if (options.retainKeyOrder) {
	    for (i = 0; i < len; ++i) {
	      key = keys[i];
	      limb = tree[key];
	
	      defineKey(key,
	          ((utils.getFunctionName(limb.constructor) === 'Object'
	          && Object.keys(limb).length)
	          && (!limb[options.typeKey] || (options.typeKey === 'type' && limb.type.type))
	              ? limb
	              : null)
	          , proto
	          , prefix
	          , keys
	          , options);
	    }
	  } else {
	    while (i--) {
	      key = keys[i];
	      limb = tree[key];
	
	      defineKey(key,
	          ((utils.getFunctionName(limb.constructor) === 'Object'
	          && Object.keys(limb).length)
	          && (!limb[options.typeKey] || (options.typeKey === 'type' && limb.type.type))
	              ? limb
	              : null)
	          , proto
	          , prefix
	          , keys
	          , options);
	    }
	  }
	}
	
	/*!
	 * Defines the accessor named prop on the incoming prototype.
	 */
	
	function defineKey(prop, subprops, prototype, prefix, keys, options) {
	  Document = Document || __webpack_require__(8);
	  var path = (prefix ? prefix + '.' : '') + prop;
	  prefix = prefix || '';
	
	  if (subprops) {
	    Object.defineProperty(prototype, prop, {
	      enumerable: true,
	      configurable: true,
	      get: function() {
	        var _this = this;
	        if (!this.$__.getters) {
	          this.$__.getters = {};
	        }
	
	        if (!this.$__.getters[path]) {
	          var nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this));
	
	          // save scope for nested getters/setters
	          if (!prefix) {
	            nested.$__.scope = this;
	          }
	
	          Object.defineProperty(nested, 'schema', {
	            enumerable: false,
	            configurable: true,
	            writable: false,
	            value: prototype.schema
	          });
	
	          Object.defineProperty(nested, 'toObject', {
	            enumerable: false,
	            configurable: true,
	            writable: false,
	            value: function() {
	              return utils.clone(_this.get(path), { retainKeyOrder: true });
	            }
	          });
	
	          Object.defineProperty(nested, 'toJSON', {
	            enumerable: false,
	            configurable: true,
	            writable: false,
	            value: function() {
	              return _this.get(path);
	            }
	          });
	
	          Object.defineProperty(nested, '$__isNested', {
	            enumerable: false,
	            configurable: true,
	            writable: false,
	            value: true
	          });
	
	          compile(subprops, nested, path, options);
	          this.$__.getters[path] = nested;
	        }
	
	        return this.$__.getters[path];
	      },
	      set: function(v) {
	        if (v instanceof Document) {
	          v = v.toObject({ transform: false });
	        }
	        return (this.$__.scope || this).set(path, v);
	      }
	    });
	  } else {
	    Object.defineProperty(prototype, prop, {
	      enumerable: true,
	      configurable: true,
	      get: function() {
	        return this.get.call(this.$__.scope || this, path);
	      },
	      set: function(v) {
	        return this.set.call(this.$__.scope || this, path, v);
	      }
	    });
	  }
	}
	
	// gets descriptors for all properties of `object`
	// makes all properties non-enumerable to match previous behavior to #2211
	function getOwnPropertyDescriptors(object) {
	  var result = {};
	
	  Object.getOwnPropertyNames(object).forEach(function(key) {
	    result[key] = Object.getOwnPropertyDescriptor(object, key);
	    // Assume these are schema paths, ignore them re: #5470
	    if (result[key].get) {
	      delete result[key];
	      return;
	    }
	    result[key].enumerable = ['isNew', '$__', 'errors', '_doc'].indexOf(key) === -1;
	  });
	
	  return result;
	}


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var defineKey = __webpack_require__(99).defineKey;
	var utils = __webpack_require__(4);
	
	var CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {
	  toJSON: true,
	  toObject: true,
	  _id: true,
	  id: true
	};
	
	/*!
	 * ignore
	 */
	
	module.exports = function discriminator(model, name, schema) {
	  if (!(schema && schema.instanceOfSchema)) {
	    throw new Error('You must pass a valid discriminator Schema');
	  }
	
	  if (model.base && model.base.options.applyPluginsToDiscriminators) {
	    model.base._applyPlugins(schema);
	  }
	
	  if (model.schema.discriminatorMapping &&
	      !model.schema.discriminatorMapping.isRoot) {
	    throw new Error('Discriminator "' + name +
	        '" can only be a discriminator of the root model');
	  }
	
	  var key = model.schema.options.discriminatorKey;
	
	  var baseSchemaAddition = {};
	  baseSchemaAddition[key] = {
	    default: void 0,
	    select: true,
	    set: function(newName) {
	      if (newName === name) {
	        return name;
	      }
	      throw new Error('Can\'t set discriminator key "' + key + '", "' +
	        name + '" !== "' + newName + '"');
	    },
	    $skipDiscriminatorCheck: true
	  };
	  baseSchemaAddition[key][model.schema.options.typeKey] = String;
	  model.schema.add(baseSchemaAddition);
	  defineKey(key, null, model.prototype, null, [key], model.schema.options);
	
	  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {
	    throw new Error('Discriminator "' + name +
	        '" cannot have field with name "' + key + '"');
	  }
	
	  function merge(schema, baseSchema) {
	    if (baseSchema.paths._id &&
	        baseSchema.paths._id.options &&
	        !baseSchema.paths._id.options.auto) {
	      var originalSchema = schema;
	      utils.merge(schema, originalSchema, { retainKeyOrder: true });
	      delete schema.paths._id;
	      delete schema.tree._id;
	    }
	    utils.merge(schema, baseSchema, { retainKeyOrder: true });
	
	    var obj = {};
	    obj[key] = {
	      default: name,
	      select: true,
	      set: function(newName) {
	        if (newName === name) {
	          return name;
	        }
	        throw new Error('Can\'t set discriminator key "' + key + '"');
	      },
	      $skipDiscriminatorCheck: true
	    };
	    obj[key][schema.options.typeKey] = String;
	    schema.add(obj);
	    schema.discriminatorMapping = {key: key, value: name, isRoot: false};
	
	    if (baseSchema.options.collection) {
	      schema.options.collection = baseSchema.options.collection;
	    }
	
	    var toJSON = schema.options.toJSON;
	    var toObject = schema.options.toObject;
	    var _id = schema.options._id;
	    var id = schema.options.id;
	
	    var keys = Object.keys(schema.options);
	    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;
	
	    for (var i = 0; i < keys.length; ++i) {
	      var _key = keys[i];
	      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {
	        if (!utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {
	          throw new Error('Can\'t customize discriminator option ' + _key +
	              ' (can only modify ' +
	              Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') +
	              ')');
	        }
	      }
	    }
	
	    schema.options = utils.clone(baseSchema.options);
	    if (toJSON) schema.options.toJSON = toJSON;
	    if (toObject) schema.options.toObject = toObject;
	    if (typeof _id !== 'undefined') {
	      schema.options._id = _id;
	    }
	    schema.options.id = id;
	    schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);
	
	    schema.plugins = Array.prototype.slice(baseSchema.plugins);
	    schema.callQueue = baseSchema.callQueue.
	      concat(schema.callQueue.slice(schema._defaultMiddleware.length));
	    schema._requiredpaths = undefined; // reset just in case Schema#requiredPaths() was called on either schema
	  }
	
	  // merges base schema into new discriminator schema and sets new type field.
	  merge(schema, model.schema);
	
	  if (!model.discriminators) {
	    model.discriminators = {};
	  }
	
	  if (!model.schema.discriminatorMapping) {
	    model.schema.discriminatorMapping = {key: key, value: null, isRoot: true};
	  }
	
	  if (model.discriminators[name]) {
	    throw new Error('Discriminator with name "' + name + '" already exists');
	  }
	
	  return schema;
	};


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var EmbeddedDocument = __webpack_require__(30);
	var Document = __webpack_require__(8);
	var ObjectId = __webpack_require__(24);
	var cleanModifiedSubpaths = __webpack_require__(145);
	var utils = __webpack_require__(4);
	
	var isMongooseObject = utils.isMongooseObject;
	
	/**
	 * Mongoose Array constructor.
	 *
	 * ####NOTE:
	 *
	 * _Values always have to be passed to the constructor to initialize, otherwise `MongooseArray#push` will mark the array as modified._
	 *
	 * @param {Array} values
	 * @param {String} path
	 * @param {Document} doc parent document
	 * @api private
	 * @inherits Array
	 * @see http://bit.ly/f6CnZU
	 */
	
	function MongooseArray(values, path, doc) {
	  var arr = [].concat(values);
	
	  var keysMA = Object.keys(MongooseArray.mixin);
	  var numKeys = keysMA.length;
	  for (var i = 0; i < numKeys; ++i) {
	    arr[keysMA[i]] = MongooseArray.mixin[keysMA[i]];
	  }
	
	  arr._path = path;
	  arr.isMongooseArray = true;
	  arr.validators = [];
	  arr._atomics = {};
	  arr._schema = void 0;
	
	  // Because doc comes from the context of another function, doc === global
	  // can happen if there was a null somewhere up the chain (see #3020)
	  // RB Jun 17, 2015 updated to check for presence of expected paths instead
	  // to make more proof against unusual node environments
	  if (doc && doc instanceof Document) {
	    arr._parent = doc;
	    arr._schema = doc.schema.path(path);
	  }
	
	  return arr;
	}
	
	MongooseArray.mixin = {
	  /*!
	   * ignore
	   */
	  toBSON: function() {
	    return this.toObject({
	      transform: false,
	      virtuals: false,
	      _skipDepopulateTopLevel: true,
	      depopulate: true,
	      flattenDecimals: false
	    });
	  },
	
	  /**
	   * Stores a queue of atomic operations to perform
	   *
	   * @property _atomics
	   * @api private
	   */
	
	  _atomics: undefined,
	
	  /**
	   * Parent owner document
	   *
	   * @property _parent
	   * @api private
	   * @receiver MongooseArray
	   */
	
	  _parent: undefined,
	
	  /**
	   * Casts a member based on this arrays schema.
	   *
	   * @param {any} value
	   * @return value the casted value
	   * @method _cast
	   * @api private
	   * @receiver MongooseArray
	   */
	
	  _cast: function(value) {
	    var populated = false;
	    var Model;
	
	    if (this._parent) {
	      populated = this._parent.populated(this._path, true);
	    }
	
	    if (populated && value !== null && value !== undefined) {
	      // cast to the populated Models schema
	      Model = populated.options.model || populated.options.Model;
	
	      // only objects are permitted so we can safely assume that
	      // non-objects are to be interpreted as _id
	      if (Buffer.isBuffer(value) ||
	          value instanceof ObjectId || !utils.isObject(value)) {
	        value = {_id: value};
	      }
	
	      // gh-2399
	      // we should cast model only when it's not a discriminator
	      var isDisc = value.schema && value.schema.discriminatorMapping &&
	          value.schema.discriminatorMapping.key !== undefined;
	      if (!isDisc) {
	        value = new Model(value);
	      }
	      return this._schema.caster.applySetters(value, this._parent, true);
	    }
	
	    return this._schema.caster.applySetters(value, this._parent, false);
	  },
	
	  /**
	   * Marks this array as modified.
	   *
	   * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)
	   *
	   * @param {EmbeddedDocument} embeddedDoc the embedded doc that invoked this method on the Array
	   * @param {String} embeddedPath the path which changed in the embeddedDoc
	   * @method _markModified
	   * @api private
	   * @receiver MongooseArray
	   */
	
	  _markModified: function(elem, embeddedPath) {
	    var parent = this._parent,
	        dirtyPath;
	
	    if (parent) {
	      dirtyPath = this._path;
	
	      if (arguments.length) {
	        if (embeddedPath != null) {
	          // an embedded doc bubbled up the change
	          dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;
	        } else {
	          // directly set an index
	          dirtyPath = dirtyPath + '.' + elem;
	        }
	      }
	
	      parent.markModified(dirtyPath, arguments.length > 0 ? elem : parent);
	    }
	
	    return this;
	  },
	
	  /**
	   * Register an atomic operation with the parent.
	   *
	   * @param {Array} op operation
	   * @param {any} val
	   * @method _registerAtomic
	   * @api private
	   * @receiver MongooseArray
	   */
	
	  _registerAtomic: function(op, val) {
	    if (op === '$set') {
	      // $set takes precedence over all other ops.
	      // mark entire array modified.
	      this._atomics = {$set: val};
	      return this;
	    }
	
	    var atomics = this._atomics;
	
	    // reset pop/shift after save
	    if (op === '$pop' && !('$pop' in atomics)) {
	      var _this = this;
	      this._parent.once('save', function() {
	        _this._popped = _this._shifted = null;
	      });
	    }
	
	    // check for impossible $atomic combos (Mongo denies more than one
	    // $atomic op on a single path
	    if (this._atomics.$set ||
	        Object.keys(atomics).length && !(op in atomics)) {
	      // a different op was previously registered.
	      // save the entire thing.
	      this._atomics = {$set: this};
	      return this;
	    }
	
	    var selector;
	
	    if (op === '$pullAll' || op === '$pushAll' || op === '$addToSet') {
	      atomics[op] || (atomics[op] = []);
	      atomics[op] = atomics[op].concat(val);
	    } else if (op === '$pullDocs') {
	      var pullOp = atomics['$pull'] || (atomics['$pull'] = {});
	      if (val[0] instanceof EmbeddedDocument) {
	        selector = pullOp['$or'] || (pullOp['$or'] = []);
	        Array.prototype.push.apply(selector, val.map(function(v) {
	          return v.toObject({transform: false, virtuals: false});
	        }));
	      } else {
	        selector = pullOp['_id'] || (pullOp['_id'] = {$in: []});
	        selector['$in'] = selector['$in'].concat(val);
	      }
	    } else {
	      atomics[op] = val;
	    }
	
	    return this;
	  },
	
	  /**
	   * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.
	   *
	   * If no atomics exist, we return all array values after conversion.
	   *
	   * @return {Array}
	   * @method $__getAtomics
	   * @memberOf MongooseArray
	   * @api private
	   */
	
	  $__getAtomics: function() {
	    var ret = [];
	    var keys = Object.keys(this._atomics);
	    var i = keys.length;
	
	    if (i === 0) {
	      ret[0] = ['$set', this.toObject({depopulate: 1, transform: false, _isNested: true, virtuals: false})];
	      return ret;
	    }
	
	    while (i--) {
	      var op = keys[i];
	      var val = this._atomics[op];
	
	      // the atomic values which are arrays are not MongooseArrays. we
	      // need to convert their elements as if they were MongooseArrays
	      // to handle populated arrays versus DocumentArrays properly.
	      if (isMongooseObject(val)) {
	        val = val.toObject({depopulate: 1, transform: false, _isNested: true, virtuals: false});
	      } else if (Array.isArray(val)) {
	        val = this.toObject.call(val, {depopulate: 1, transform: false, _isNested: true});
	      } else if (val.valueOf) {
	        val = val.valueOf();
	      }
	
	      if (op === '$addToSet') {
	        val = {$each: val};
	      }
	
	      ret.push([op, val]);
	    }
	
	    return ret;
	  },
	
	  /**
	   * Returns the number of pending atomic operations to send to the db for this array.
	   *
	   * @api private
	   * @return {Number}
	   * @method hasAtomics
	   * @receiver MongooseArray
	   */
	
	  hasAtomics: function hasAtomics() {
	    if (!(this._atomics && this._atomics.constructor.name === 'Object')) {
	      return 0;
	    }
	
	    return Object.keys(this._atomics).length;
	  },
	
	  /**
	   * Internal helper for .map()
	   *
	   * @api private
	   * @return {Number}
	   * @method _mapCast
	   * @receiver MongooseArray
	   */
	  _mapCast: function(val, index) {
	    return this._cast(val, this.length + index);
	  },
	
	  /**
	   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.
	   *
	   * @param {Object} [args...]
	   * @api public
	   * @method push
	   * @receiver MongooseArray
	   */
	
	  push: function() {
	    _checkManualPopulation(this, arguments);
	    var values = [].map.call(arguments, this._mapCast, this);
	    values = this._schema.applySetters(values, this._parent, undefined,
	        undefined, { skipDocumentArrayCast: true });
	    var ret = [].push.apply(this, values);
	
	    // $pushAll might be fibbed (could be $push). But it makes it easier to
	    // handle what could have been $push, $pushAll combos
	    this._registerAtomic('$pushAll', values);
	    this._markModified();
	    return ret;
	  },
	
	  /**
	   * Pushes items to the array non-atomically.
	   *
	   * ####NOTE:
	   *
	   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @param {any} [args...]
	   * @api public
	   * @method nonAtomicPush
	   * @receiver MongooseArray
	   */
	
	  nonAtomicPush: function() {
	    var values = [].map.call(arguments, this._mapCast, this);
	    var ret = [].push.apply(this, values);
	    this._registerAtomic('$set', this);
	    this._markModified();
	    return ret;
	  },
	
	  /**
	   * Pops the array atomically at most one time per document `save()`.
	   *
	   * #### NOTE:
	   *
	   * _Calling this mulitple times on an array before saving sends the same command as calling it once._
	   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._
	   *
	   *      doc.array = [1,2,3];
	   *
	   *      var popped = doc.array.$pop();
	   *      console.log(popped); // 3
	   *      console.log(doc.array); // [1,2]
	   *
	   *      // no affect
	   *      popped = doc.array.$pop();
	   *      console.log(doc.array); // [1,2]
	   *
	   *      doc.save(function (err) {
	   *        if (err) return handleError(err);
	   *
	   *        // we saved, now $pop works again
	   *        popped = doc.array.$pop();
	   *        console.log(popped); // 2
	   *        console.log(doc.array); // [1]
	   *      })
	   *
	   * @api public
	   * @method $pop
	   * @memberOf MongooseArray
	   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop
	   * @method $pop
	   * @receiver MongooseArray
	   */
	
	  $pop: function() {
	    this._registerAtomic('$pop', 1);
	    this._markModified();
	
	    // only allow popping once
	    if (this._popped) {
	      return;
	    }
	    this._popped = true;
	
	    return [].pop.call(this);
	  },
	
	  /**
	   * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.
	   *
	   * ####Note:
	   *
	   * _marks the entire array as modified which will pass the entire thing to $set potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @see MongooseArray#$pop #types_array_MongooseArray-%24pop
	   * @api public
	   * @method pop
	   * @receiver MongooseArray
	   */
	
	  pop: function() {
	    var ret = [].pop.call(this);
	    this._registerAtomic('$set', this);
	    this._markModified();
	    return ret;
	  },
	
	  /**
	   * Atomically shifts the array at most one time per document `save()`.
	   *
	   * ####NOTE:
	   *
	   * _Calling this mulitple times on an array before saving sends the same command as calling it once._
	   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._
	   *
	   *      doc.array = [1,2,3];
	   *
	   *      var shifted = doc.array.$shift();
	   *      console.log(shifted); // 1
	   *      console.log(doc.array); // [2,3]
	   *
	   *      // no affect
	   *      shifted = doc.array.$shift();
	   *      console.log(doc.array); // [2,3]
	   *
	   *      doc.save(function (err) {
	   *        if (err) return handleError(err);
	   *
	   *        // we saved, now $shift works again
	   *        shifted = doc.array.$shift();
	   *        console.log(shifted ); // 2
	   *        console.log(doc.array); // [3]
	   *      })
	   *
	   * @api public
	   * @memberOf MongooseArray
	   * @method $shift
	   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop
	   */
	
	  $shift: function $shift() {
	    this._registerAtomic('$pop', -1);
	    this._markModified();
	
	    // only allow shifting once
	    if (this._shifted) {
	      return;
	    }
	    this._shifted = true;
	
	    return [].shift.call(this);
	  },
	
	  /**
	   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
	   *
	   * ####Example:
	   *
	   *     doc.array = [2,3];
	   *     var res = doc.array.shift();
	   *     console.log(res) // 2
	   *     console.log(doc.array) // [3]
	   *
	   * ####Note:
	   *
	   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @api public
	   * @method shift
	   * @receiver MongooseArray
	   */
	
	  shift: function() {
	    var ret = [].shift.call(this);
	    this._registerAtomic('$set', this);
	    this._markModified();
	    return ret;
	  },
	
	  /**
	   * Pulls items from the array atomically. Equality is determined by casting
	   * the provided value to an embedded document and comparing using
	   * [the `Document.equals()` function.](./api.html#document_Document-equals)
	   *
	   * ####Examples:
	   *
	   *     doc.array.pull(ObjectId)
	   *     doc.array.pull({ _id: 'someId' })
	   *     doc.array.pull(36)
	   *     doc.array.pull('tag 1', 'tag 2')
	   *
	   * To remove a document from a subdocument array we may pass an object with a matching `_id`.
	   *
	   *     doc.subdocs.push({ _id: 4815162342 })
	   *     doc.subdocs.pull({ _id: 4815162342 }) // removed
	   *
	   * Or we may passing the _id directly and let mongoose take care of it.
	   *
	   *     doc.subdocs.push({ _id: 4815162342 })
	   *     doc.subdocs.pull(4815162342); // works
	   *
	   * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.
	   *
	   * @param {any} [args...]
	   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull
	   * @api public
	   * @method pull
	   * @receiver MongooseArray
	   */
	
	  pull: function() {
	    var values = [].map.call(arguments, this._cast, this),
	        cur = this._parent.get(this._path),
	        i = cur.length,
	        mem;
	
	    while (i--) {
	      mem = cur[i];
	      if (mem instanceof Document) {
	        var some = values.some(function(v) {
	          return mem.equals(v);
	        });
	        if (some) {
	          [].splice.call(cur, i, 1);
	        }
	      } else if (~cur.indexOf.call(values, mem)) {
	        [].splice.call(cur, i, 1);
	      }
	    }
	
	    if (values[0] instanceof EmbeddedDocument) {
	      this._registerAtomic('$pullDocs', values.map(function(v) {
	        return v._id || v;
	      }));
	    } else {
	      this._registerAtomic('$pullAll', values);
	    }
	
	    this._markModified();
	
	    // Might have modified child paths and then pulled, like
	    // `doc.children[1].name = 'test';` followed by
	    // `doc.children.remove(doc.children[0]);`. In this case we fall back
	    // to a `$set` on the whole array. See #3511
	    if (cleanModifiedSubpaths(this._parent, this._path) > 0) {
	      this._registerAtomic('$set', this);
	    }
	
	    return this;
	  },
	
	  /**
	   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.
	   *
	   * ####Note:
	   *
	   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @api public
	   * @method splice
	   * @receiver MongooseArray
	   */
	
	  splice: function splice() {
	    var ret;
	    var vals;
	    var i;
	
	    _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));
	
	    if (arguments.length) {
	      vals = [];
	      for (i = 0; i < arguments.length; ++i) {
	        vals[i] = i < 2
	            ? arguments[i]
	            : this._cast(arguments[i], arguments[0] + (i - 2));
	      }
	      ret = [].splice.apply(this, vals);
	      this._registerAtomic('$set', this);
	      this._markModified();
	    }
	
	    return ret;
	  },
	
	  /**
	   * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
	   *
	   * ####Note:
	   *
	   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @api public
	   * @method unshift
	   * @receiver MongooseArray
	   */
	
	  unshift: function() {
	    _checkManualPopulation(this, arguments);
	
	    var values = [].map.call(arguments, this._cast, this);
	    values = this._schema.applySetters(values, this._parent);
	    [].unshift.apply(this, values);
	    this._registerAtomic('$set', this);
	    this._markModified();
	    return this.length;
	  },
	
	  /**
	   * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.
	   *
	   * ####NOTE:
	   *
	   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
	   *
	   * @api public
	   * @method sort
	   * @receiver MongooseArray
	   */
	
	  sort: function() {
	    var ret = [].sort.apply(this, arguments);
	    this._registerAtomic('$set', this);
	    this._markModified();
	    return ret;
	  },
	
	  /**
	   * Adds values to the array if not already present.
	   *
	   * ####Example:
	   *
	   *     console.log(doc.array) // [2,3,4]
	   *     var added = doc.array.addToSet(4,5);
	   *     console.log(doc.array) // [2,3,4,5]
	   *     console.log(added)     // [5]
	   *
	   * @param {any} [args...]
	   * @return {Array} the values that were added
	   * @receiver MongooseArray
	   * @api public
	   * @method addToSet
	   */
	
	  addToSet: function addToSet() {
	    _checkManualPopulation(this, arguments);
	
	    var values = [].map.call(arguments, this._mapCast, this);
	    values = this._schema.applySetters(values, this._parent);
	    var added = [];
	    var type = '';
	    if (values[0] instanceof EmbeddedDocument) {
	      type = 'doc';
	    } else if (values[0] instanceof Date) {
	      type = 'date';
	    }
	
	    values.forEach(function(v) {
	      var found;
	      switch (type) {
	        case 'doc':
	          found = this.some(function(doc) {
	            return doc.equals(v);
	          });
	          break;
	        case 'date':
	          var val = +v;
	          found = this.some(function(d) {
	            return +d === val;
	          });
	          break;
	        default:
	          found = ~this.indexOf(v);
	      }
	
	      if (!found) {
	        [].push.call(this, v);
	        this._registerAtomic('$addToSet', v);
	        this._markModified();
	        [].push.call(added, v);
	      }
	    }, this);
	
	    return added;
	  },
	
	  /**
	   * Sets the casted `val` at index `i` and marks the array modified.
	   *
	   * ####Example:
	   *
	   *     // given documents based on the following
	   *     var Doc = mongoose.model('Doc', new Schema({ array: [Number] }));
	   *
	   *     var doc = new Doc({ array: [2,3,4] })
	   *
	   *     console.log(doc.array) // [2,3,4]
	   *
	   *     doc.array.set(1,"5");
	   *     console.log(doc.array); // [2,5,4] // properly cast to number
	   *     doc.save() // the change is saved
	   *
	   *     // VS not using array#set
	   *     doc.array[1] = "5";
	   *     console.log(doc.array); // [2,"5",4] // no casting
	   *     doc.save() // change is not saved
	   *
	   * @return {Array} this
	   * @api public
	   * @method set
	   * @receiver MongooseArray
	   */
	
	  set: function set(i, val) {
	    var value = this._cast(val, i);
	    this[i] = value;
	    this._markModified(i);
	    return this;
	  },
	
	  /**
	   * Returns a native js Array.
	   *
	   * @param {Object} options
	   * @return {Array}
	   * @api public
	   * @method toObject
	   * @receiver MongooseArray
	   */
	
	  toObject: function(options) {
	    if (options && options.depopulate) {
	      options._isNested = true;
	      return this.map(function(doc) {
	        return doc instanceof Document
	            ? doc.toObject(options)
	            : doc;
	      });
	    }
	
	    return this.slice();
	  },
	
	  /**
	   * Helper for console.log
	   *
	   * @api public
	   * @method inspect
	   * @receiver MongooseArray
	   */
	
	  inspect: function() {
	    return JSON.stringify(this);
	  },
	
	  /**
	   * Return the index of `obj` or `-1` if not found.
	   *
	   * @param {Object} obj the item to look for
	   * @return {Number}
	   * @api public
	   * @method indexOf
	   * @receiver MongooseArray
	   */
	
	  indexOf: function indexOf(obj) {
	    if (obj instanceof ObjectId) {
	      obj = obj.toString();
	    }
	    for (var i = 0, len = this.length; i < len; ++i) {
	      if (obj == this[i]) {
	        return i;
	      }
	    }
	    return -1;
	  }
	};
	
	/**
	 * Alias of [pull](#types_array_MongooseArray-pull)
	 *
	 * @see MongooseArray#pull #types_array_MongooseArray-pull
	 * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull
	 * @api public
	 * @memberOf MongooseArray
	 * @method remove
	 */
	
	MongooseArray.mixin.remove = MongooseArray.mixin.pull;
	
	/*!
	 * ignore
	 */
	
	function _isAllSubdocs(docs, ref) {
	  if (!ref) {
	    return false;
	  }
	  for (var i = 0; i < docs.length; ++i) {
	    var arg = docs[i];
	    if (arg == null) {
	      return false;
	    }
	    var model = arg.constructor;
	    if (!(arg instanceof Document) ||
	      (model.modelName !== ref && model.baseModelName !== ref)) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	/*!
	 * ignore
	 */
	
	function _checkManualPopulation(arr, docs) {
	  var ref = arr._schema.caster.options && arr._schema.caster.options.ref;
	  if (arr.length === 0 &&
	      docs.length > 0) {
	    if (_isAllSubdocs(docs, ref)) {
	      arr._parent.populated(arr._path, [], { model: docs[0].constructor });
	    }
	  }
	}
	
	/*!
	 * Module exports.
	 */
	
	module.exports = exports = MongooseArray;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * ObjectId type constructor
	 *
	 * ####Example
	 *
	 *     var id = new mongoose.Types.ObjectId;
	 *
	 * @constructor ObjectId
	 */
	
	module.exports = __webpack_require__(25).Decimal128;


/***/ }),
/* 103 */
/***/ (function(module, exports) {

	
	/**
	 * VirtualType constructor
	 *
	 * This is what mongoose uses to define virtual attributes via `Schema.prototype.virtual`.
	 *
	 * ####Example:
	 *
	 *     var fullname = schema.virtual('fullname');
	 *     fullname instanceof mongoose.VirtualType // true
	 *
	 * @parma {Object} options
	 * @api public
	 */
	
	function VirtualType(options, name) {
	  this.path = name;
	  this.getters = [];
	  this.setters = [];
	  this.options = options || {};
	}
	
	/**
	 * Defines a getter.
	 *
	 * ####Example:
	 *
	 *     var virtual = schema.virtual('fullname');
	 *     virtual.get(function () {
	 *       return this.name.first + ' ' + this.name.last;
	 *     });
	 *
	 * @param {Function} fn
	 * @return {VirtualType} this
	 * @api public
	 */
	
	VirtualType.prototype.get = function(fn) {
	  this.getters.push(fn);
	  return this;
	};
	
	/**
	 * Defines a setter.
	 *
	 * ####Example:
	 *
	 *     var virtual = schema.virtual('fullname');
	 *     virtual.set(function (v) {
	 *       var parts = v.split(' ');
	 *       this.name.first = parts[0];
	 *       this.name.last = parts[1];
	 *     });
	 *
	 * @param {Function} fn
	 * @return {VirtualType} this
	 * @api public
	 */
	
	VirtualType.prototype.set = function(fn) {
	  this.setters.push(fn);
	  return this;
	};
	
	/**
	 * Applies getters to `value` using optional `scope`.
	 *
	 * @param {Object} value
	 * @param {Object} scope
	 * @return {any} the value after applying all getters
	 * @api public
	 */
	
	VirtualType.prototype.applyGetters = function(value, scope) {
	  var v = value;
	  for (var l = this.getters.length - 1; l >= 0; l--) {
	    v = this.getters[l].call(scope, v, this);
	  }
	  return v;
	};
	
	/**
	 * Applies setters to `value` using optional `scope`.
	 *
	 * @param {Object} value
	 * @param {Object} scope
	 * @return {any} the value after applying all setters
	 * @api public
	 */
	
	VirtualType.prototype.applySetters = function(value, scope) {
	  var v = value;
	  for (var l = this.setters.length - 1; l >= 0; l--) {
	    v = this.setters[l].call(scope, v, this);
	  }
	  return v;
	};
	
	/*!
	 * exports
	 */
	
	module.exports = VirtualType;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Dependencies
	 */
	
	var slice = __webpack_require__(249)
	var assert = __webpack_require__(152)
	var util = __webpack_require__(1)
	var utils = __webpack_require__(149)
	var debug = __webpack_require__(270)('mquery');
	
	/**
	 * Query constructor used for building queries.
	 *
	 * ####Example:
	 *
	 *     var query = new Query({ name: 'mquery' });
	 *     query.setOptions({ collection: moduleCollection })
	 *     query.where('age').gte(21).exec(callback);
	 *
	 * @param {Object} [criteria]
	 * @param {Object} [options]
	 * @api public
	 */
	
	function Query (criteria, options) {
	  if (!(this instanceof Query))
	    return new Query(criteria, options);
	
	  var proto = this.constructor.prototype;
	
	  this.op = proto.op || undefined;
	
	  this.options = {};
	  this.setOptions(proto.options);
	
	  this._conditions = proto._conditions
	    ? utils.clone(proto._conditions, { retainKeyOrder: this.options.retainKeyOrder })
	    : {};
	
	  this._fields = proto._fields
	    ? utils.clone(proto._fields, { retainKeyOrder: this.options.retainKeyOrder })
	    : undefined;
	
	  this._update = proto._update
	    ? utils.clone(proto._update, { retainKeyOrder: this.options.retainKeyOrder })
	    : undefined;
	
	  this._path = proto._path || undefined;
	  this._distinct = proto._distinct || undefined;
	  this._collection = proto._collection || undefined;
	  this._traceFunction = proto._traceFunction || undefined;
	
	  if (options) {
	    this.setOptions(options);
	  }
	
	  if (criteria) {
	    if (criteria.find && criteria.remove && criteria.update) {
	      // quack quack!
	      this.collection(criteria);
	    } else {
	      this.find(criteria);
	    }
	  }
	}
	
	/**
	 * This is a parameter that the user can set which determines if mquery
	 * uses $within or $geoWithin for queries. It defaults to true which
	 * means $geoWithin will be used. If using MongoDB < 2.4 you should
	 * set this to false.
	 *
	 * @api public
	 * @property use$geoWithin
	 */
	
	var $withinCmd = '$geoWithin';
	Object.defineProperty(Query, 'use$geoWithin', {
	    get: function ( ) { return $withinCmd == '$geoWithin' }
	  , set: function (v) {
	      if (true === v) {
	        // mongodb >= 2.4
	        $withinCmd = '$geoWithin';
	      } else {
	        $withinCmd = '$within';
	      }
	    }
	});
	
	/**
	 * Converts this query to a constructor function with all arguments and options retained.
	 *
	 * ####Example
	 *
	 *     // Create a query that will read documents with a "video" category from
	 *     // `aCollection` on the primary node in the replica-set unless it is down,
	 *     // in which case we'll read from a secondary node.
	 *     var query = mquery({ category: 'video' })
	 *     query.setOptions({ collection: aCollection, read: 'primaryPreferred' });
	 *
	 *     // create a constructor based off these settings
	 *     var Video = query.toConstructor();
	 *
	 *     // Video is now a subclass of mquery() and works the same way but with the
	 *     // default query parameters and options set.
	 *
	 *     // run a query with the previous settings but filter for movies with names
	 *     // that start with "Life".
	 *     Video().where({ name: /^Life/ }).exec(cb);
	 *
	 * @return {Query} new Query
	 * @api public
	 */
	
	Query.prototype.toConstructor = function toConstructor () {
	  function CustomQuery (criteria, options) {
	    if (!(this instanceof CustomQuery))
	      return new CustomQuery(criteria, options);
	    Query.call(this, criteria, options);
	  }
	
	  utils.inherits(CustomQuery, Query);
	
	  // set inherited defaults
	  var p = CustomQuery.prototype;
	
	  p.options = {};
	  p.setOptions(this.options);
	
	  p.op = this.op;
	  p._conditions = utils.clone(this._conditions, { retainKeyOrder: this.options.retainKeyOrder });
	  p._fields = utils.clone(this._fields, { retainKeyOrder: this.options.retainKeyOrder });
	  p._update = utils.clone(this._update, { retainKeyOrder: this.options.retainKeyOrder });
	  p._path = this._path;
	  p._distinct = this._distinct;
	  p._collection = this._collection;
	  p._traceFunction = this._traceFunction;
	
	  return CustomQuery;
	}
	
	/**
	 * Sets query options.
	 *
	 * ####Options:
	 *
	 * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *
	 * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\)%7D%7D) *
	 * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *
	 * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *
	 * - [maxScan](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan) *
	 * - [maxTime](http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS) *
	 * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *
	 * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *
	 * - [snapshot](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D) *
	 * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *
	 * - [slaveOk](http://docs.mongodb.org/manual/applications/replication/#read-preference) *
	 * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)
	 * - collection the collection to query against
	 *
	 * _* denotes a query helper method is also available_
	 *
	 * @param {Object} options
	 * @api public
	 */
	
	Query.prototype.setOptions = function (options) {
	  if (!(options && utils.isObject(options)))
	    return this;
	
	  // set arbitrary options
	  var methods = utils.keys(options)
	    , method
	
	  for (var i = 0; i < methods.length; ++i) {
	    method = methods[i];
	
	    // use methods if exist (safer option manipulation)
	    if ('function' == typeof this[method]) {
	      var args = utils.isArray(options[method])
	        ? options[method]
	        : [options[method]];
	      this[method].apply(this, args)
	    } else {
	      this.options[method] = options[method];
	    }
	  }
	
	  return this;
	}
	
	/**
	 * Sets this Querys collection.
	 *
	 * @param {Collection} coll
	 * @return {Query} this
	 */
	
	Query.prototype.collection = function collection (coll) {
	  this._collection = new Query.Collection(coll);
	
	  return this;
	}
	
	/**
	 * Specifies a `$where` condition
	 *
	 * Use `$where` when you need to select documents using a JavaScript expression.
	 *
	 * ####Example
	 *
	 *     query.$where('this.comments.length > 10 || this.name.length > 5')
	 *
	 *     query.$where(function () {
	 *       return this.comments.length > 10 || this.name.length > 5;
	 *     })
	 *
	 * @param {String|Function} js javascript string or function
	 * @return {Query} this
	 * @memberOf Query
	 * @method $where
	 * @api public
	 */
	
	Query.prototype.$where = function (js) {
	  this._conditions.$where = js;
	  return this;
	}
	
	/**
	 * Specifies a `path` for use with chaining.
	 *
	 * ####Example
	 *
	 *     // instead of writing:
	 *     User.find({age: {$gte: 21, $lte: 65}}, callback);
	 *
	 *     // we can instead write:
	 *     User.where('age').gte(21).lte(65);
	 *
	 *     // passing query conditions is permitted
	 *     User.find().where({ name: 'vonderful' })
	 *
	 *     // chaining
	 *     User
	 *     .where('age').gte(21).lte(65)
	 *     .where('name', /^vonderful/i)
	 *     .where('friends').slice(10)
	 *     .exec(callback)
	 *
	 * @param {String} [path]
	 * @param {Object} [val]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.where = function () {
	  if (!arguments.length) return this;
	  if (!this.op) this.op = 'find';
	
	  var type = typeof arguments[0];
	
	  if ('string' == type) {
	    this._path = arguments[0];
	
	    if (2 === arguments.length) {
	      this._conditions[this._path] = arguments[1];
	    }
	
	    return this;
	  }
	
	  if ('object' == type && !Array.isArray(arguments[0])) {
	    return this.merge(arguments[0]);
	  }
	
	  throw new TypeError('path must be a string or object');
	}
	
	/**
	 * Specifies the complementary comparison value for paths specified with `where()`
	 *
	 * ####Example
	 *
	 *     User.where('age').equals(49);
	 *
	 *     // is the same as
	 *
	 *     User.where('age', 49);
	 *
	 * @param {Object} val
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.equals = function equals (val) {
	  this._ensurePath('equals');
	  var path = this._path;
	  this._conditions[path] = val;
	  return this;
	}
	
	/**
	 * Specifies the complementary comparison value for paths specified with `where()`
	 * This is alias of `equals`
	 *
	 * ####Example
	 *
	 *     User.where('age').eq(49);
	 *
	 *     // is the same as
	 *
	 *     User.shere('age').equals(49);
	 *
	 *     // is the same as
	 *
	 *     User.where('age', 49);
	 *
	 * @param {Object} val
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.eq = function eq (val) {
	  this._ensurePath('eq');
	  var path = this._path;
	  this._conditions[path] = val;
	  return this;
	}
	
	/**
	 * Specifies arguments for an `$or` condition.
	 *
	 * ####Example
	 *
	 *     query.or([{ color: 'red' }, { status: 'emergency' }])
	 *
	 * @param {Array} array array of conditions
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.or = function or (array) {
	  var or = this._conditions.$or || (this._conditions.$or = []);
	  if (!utils.isArray(array)) array = [array];
	  or.push.apply(or, array);
	  return this;
	}
	
	/**
	 * Specifies arguments for a `$nor` condition.
	 *
	 * ####Example
	 *
	 *     query.nor([{ color: 'green' }, { status: 'ok' }])
	 *
	 * @param {Array} array array of conditions
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.nor = function nor (array) {
	  var nor = this._conditions.$nor || (this._conditions.$nor = []);
	  if (!utils.isArray(array)) array = [array];
	  nor.push.apply(nor, array);
	  return this;
	}
	
	/**
	 * Specifies arguments for a `$and` condition.
	 *
	 * ####Example
	 *
	 *     query.and([{ color: 'green' }, { status: 'ok' }])
	 *
	 * @see $and http://docs.mongodb.org/manual/reference/operator/and/
	 * @param {Array} array array of conditions
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.and = function and (array) {
	  var and = this._conditions.$and || (this._conditions.$and = []);
	  if (!Array.isArray(array)) array = [array];
	  and.push.apply(and, array);
	  return this;
	}
	
	/**
	 * Specifies a $gt query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * ####Example
	 *
	 *     Thing.find().where('age').gt(21)
	 *
	 *     // or
	 *     Thing.find().gt('age', 21)
	 *
	 * @method gt
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $gte query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method gte
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $lt query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method lt
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $lte query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method lte
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $ne query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method ne
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies an $in query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method in
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies an $nin query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method nin
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies an $all query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method all
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $size query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method size
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/**
	 * Specifies a $regex query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method regex
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {String|RegExp} val
	 * @api public
	 */
	
	/**
	 * Specifies a $maxDistance query condition.
	 *
	 * When called with one argument, the most recent path passed to `where()` is used.
	 *
	 * @method maxDistance
	 * @memberOf Query
	 * @param {String} [path]
	 * @param {Number} val
	 * @api public
	 */
	
	/*!
	 * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance
	 *
	 *     Thing.where('type').nin(array)
	 */
	
	'gt gte lt lte ne in nin all regex size maxDistance minDistance'.split(' ').forEach(function ($conditional) {
	  Query.prototype[$conditional] = function () {
	    var path, val;
	
	    if (1 === arguments.length) {
	      this._ensurePath($conditional);
	      val = arguments[0];
	      path = this._path;
	    } else {
	      val = arguments[1];
	      path = arguments[0];
	    }
	
	    var conds = this._conditions[path] === null || typeof this._conditions[path] === 'object' ?
	      this._conditions[path] :
	      (this._conditions[path] = {});
	    conds['$' + $conditional] = val;
	    return this;
	  };
	})
	
	/**
	 * Specifies a `$mod` condition
	 *
	 * @param {String} [path]
	 * @param {Number} val
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.mod = function () {
	  var val, path;
	
	  if (1 === arguments.length) {
	    this._ensurePath('mod')
	    val = arguments[0];
	    path = this._path;
	  } else if (2 === arguments.length && !utils.isArray(arguments[1])) {
	    this._ensurePath('mod')
	    val = slice(arguments);
	    path = this._path;
	  } else if (3 === arguments.length) {
	    val = slice(arguments, 1);
	    path = arguments[0];
	  } else {
	    val = arguments[1];
	    path = arguments[0];
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds.$mod = val;
	  return this;
	}
	
	/**
	 * Specifies an `$exists` condition
	 *
	 * ####Example
	 *
	 *     // { name: { $exists: true }}
	 *     Thing.where('name').exists()
	 *     Thing.where('name').exists(true)
	 *     Thing.find().exists('name')
	 *
	 *     // { name: { $exists: false }}
	 *     Thing.where('name').exists(false);
	 *     Thing.find().exists('name', false);
	 *
	 * @param {String} [path]
	 * @param {Number} val
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.exists = function () {
	  var path, val;
	
	  if (0 === arguments.length) {
	    this._ensurePath('exists');
	    path = this._path;
	    val = true;
	  } else if (1 === arguments.length) {
	    if ('boolean' === typeof arguments[0]) {
	      this._ensurePath('exists');
	      path = this._path;
	      val = arguments[0];
	    } else {
	      path = arguments[0];
	      val = true;
	    }
	  } else if (2 === arguments.length) {
	    path = arguments[0];
	    val = arguments[1];
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds.$exists = val;
	  return this;
	}
	
	/**
	 * Specifies an `$elemMatch` condition
	 *
	 * ####Example
	 *
	 *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})
	 *
	 *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})
	 *
	 *     query.elemMatch('comment', function (elem) {
	 *       elem.where('author').equals('autobot');
	 *       elem.where('votes').gte(5);
	 *     })
	 *
	 *     query.where('comment').elemMatch(function (elem) {
	 *       elem.where({ author: 'autobot' });
	 *       elem.where('votes').gte(5);
	 *     })
	 *
	 * @param {String|Object|Function} path
	 * @param {Object|Function} criteria
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.elemMatch = function () {
	  if (null == arguments[0])
	    throw new TypeError("Invalid argument");
	
	  var fn, path, criteria;
	
	  if ('function' === typeof arguments[0]) {
	    this._ensurePath('elemMatch');
	    path = this._path;
	    fn = arguments[0];
	  } else if (utils.isObject(arguments[0])) {
	    this._ensurePath('elemMatch');
	    path = this._path;
	    criteria = arguments[0];
	  } else if ('function' === typeof arguments[1]) {
	    path = arguments[0];
	    fn = arguments[1];
	  } else if (arguments[1] && utils.isObject(arguments[1])) {
	    path = arguments[0];
	    criteria = arguments[1];
	  } else {
	    throw new TypeError("Invalid argument");
	  }
	
	  if (fn) {
	    criteria = new Query;
	    fn(criteria);
	    criteria = criteria._conditions;
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds.$elemMatch = criteria;
	  return this;
	}
	
	// Spatial queries
	
	/**
	 * Sugar for geo-spatial queries.
	 *
	 * ####Example
	 *
	 *     query.within().box()
	 *     query.within().circle()
	 *     query.within().geometry()
	 *
	 *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });
	 *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });
	 *     query.where('loc').within({ polygon: [[],[],[],[]] });
	 *
	 *     query.where('loc').within([], [], []) // polygon
	 *     query.where('loc').within([], []) // box
	 *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry
	 *
	 * ####NOTE:
	 *
	 * Must be used after `where()`.
	 *
	 * @memberOf Query
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.within = function within () {
	  // opinionated, must be used after where
	  this._ensurePath('within');
	  this._geoComparison = $withinCmd;
	
	  if (0 === arguments.length) {
	    return this;
	  }
	
	  if (2 === arguments.length) {
	    return this.box.apply(this, arguments);
	  } else if (2 < arguments.length) {
	    return this.polygon.apply(this, arguments);
	  }
	
	  var area = arguments[0];
	
	  if (!area)
	    throw new TypeError('Invalid argument');
	
	  if (area.center)
	    return this.circle(area);
	
	  if (area.box)
	    return this.box.apply(this, area.box);
	
	  if (area.polygon)
	    return this.polygon.apply(this, area.polygon);
	
	  if (area.type && area.coordinates)
	    return this.geometry(area);
	
	  throw new TypeError('Invalid argument');
	}
	
	/**
	 * Specifies a $box condition
	 *
	 * ####Example
	 *
	 *     var lowerLeft = [40.73083, -73.99756]
	 *     var upperRight= [40.741404,  -73.988135]
	 *
	 *     query.where('loc').within().box(lowerLeft, upperRight)
	 *     query.box('loc', lowerLeft, upperRight )
	 *
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @see Query#within #query_Query-within
	 * @param {String} path
	 * @param {Object} val
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.box = function () {
	  var path, box;
	
	  if (3 === arguments.length) {
	    // box('loc', [], [])
	    path = arguments[0];
	    box = [arguments[1], arguments[2]];
	  } else if (2 === arguments.length) {
	    // box([], [])
	    this._ensurePath('box');
	    path = this._path;
	    box = [arguments[0], arguments[1]];
	  } else {
	    throw new TypeError("Invalid argument");
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds[this._geoComparison || $withinCmd] = { '$box': box  };
	  return this;
	}
	
	/**
	 * Specifies a $polygon condition
	 *
	 * ####Example
	 *
	 *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])
	 *     query.polygon('loc', [10,20], [13, 25], [7,15])
	 *
	 * @param {String|Array} [path]
	 * @param {Array|Object} [val]
	 * @return {Query} this
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	Query.prototype.polygon = function () {
	  var val, path;
	
	  if ('string' == typeof arguments[0]) {
	    // polygon('loc', [],[],[])
	    path = arguments[0];
	    val = slice(arguments, 1);
	  } else {
	    // polygon([],[],[])
	    this._ensurePath('polygon');
	    path = this._path;
	    val = slice(arguments);
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds[this._geoComparison || $withinCmd] = { '$polygon': val };
	  return this;
	}
	
	/**
	 * Specifies a $center or $centerSphere condition.
	 *
	 * ####Example
	 *
	 *     var area = { center: [50, 50], radius: 10, unique: true }
	 *     query.where('loc').within().circle(area)
	 *     query.center('loc', area);
	 *
	 *     // for spherical calculations
	 *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true }
	 *     query.where('loc').within().circle(area)
	 *     query.center('loc', area);
	 *
	 * @param {String} [path]
	 * @param {Object} area
	 * @return {Query} this
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	Query.prototype.circle = function () {
	  var path, val;
	
	  if (1 === arguments.length) {
	    this._ensurePath('circle');
	    path = this._path;
	    val = arguments[0];
	  } else if (2 === arguments.length) {
	    path = arguments[0];
	    val = arguments[1];
	  } else {
	    throw new TypeError("Invalid argument");
	  }
	
	  if (!('radius' in val && val.center))
	    throw new Error('center and radius are required');
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	
	  var type = val.spherical
	    ? '$centerSphere'
	    : '$center';
	
	  var wKey = this._geoComparison || $withinCmd;
	  conds[wKey] = {};
	  conds[wKey][type] = [val.center, val.radius];
	
	  if ('unique' in val)
	    conds[wKey].$uniqueDocs = !! val.unique;
	
	  return this;
	}
	
	/**
	 * Specifies a `$near` or `$nearSphere` condition
	 *
	 * These operators return documents sorted by distance.
	 *
	 * ####Example
	 *
	 *     query.where('loc').near({ center: [10, 10] });
	 *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });
	 *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });
	 *     query.near('loc', { center: [10, 10], maxDistance: 5 });
	 *     query.near({ center: { type: 'Point', coordinates: [..] }})
	 *     query.near().geometry({ type: 'Point', coordinates: [..] })
	 *
	 * @param {String} [path]
	 * @param {Object} val
	 * @return {Query} this
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @api public
	 */
	
	Query.prototype.near = function near () {
	  var path, val;
	
	  this._geoComparison = '$near';
	
	  if (0 === arguments.length) {
	    return this;
	  } else if (1 === arguments.length) {
	    this._ensurePath('near');
	    path = this._path;
	    val = arguments[0];
	  } else if (2 === arguments.length) {
	    path = arguments[0];
	    val = arguments[1];
	  } else {
	    throw new TypeError("Invalid argument");
	  }
	
	  if (!val.center) {
	    throw new Error('center is required');
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	
	  var type = val.spherical
	    ? '$nearSphere'
	    : '$near';
	
	  // center could be a GeoJSON object or an Array
	  if (Array.isArray(val.center)) {
	    conds[type] = val.center;
	
	    var radius = 'maxDistance' in val
	      ? val.maxDistance
	      : null;
	
	    if (null != radius) {
	      conds.$maxDistance = radius;
	    }
	    if (null != val.minDistance) {
	      conds.$minDistance = val.minDistance;
	    }
	  } else {
	    // GeoJSON?
	    if (val.center.type != 'Point' || !Array.isArray(val.center.coordinates)) {
	      throw new Error(util.format("Invalid GeoJSON specified for %s", type));
	    }
	    conds[type] = { $geometry : val.center };
	
	    // MongoDB 2.6 insists on maxDistance being in $near / $nearSphere
	    if ('maxDistance' in val) {
	      conds[type]['$maxDistance'] = val.maxDistance;
	    }
	    if ('minDistance' in val) {
	      conds[type]['$minDistance'] = val.minDistance;
	    }
	  }
	
	  return this;
	}
	
	/**
	 * Declares an intersects query for `geometry()`.
	 *
	 * ####Example
	 *
	 *     query.where('path').intersects().geometry({
	 *         type: 'LineString'
	 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
	 *     })
	 *
	 *     query.where('path').intersects({
	 *         type: 'LineString'
	 *       , coordinates: [[180.0, 11.0], [180, 9.0]]
	 *     })
	 *
	 * @param {Object} [arg]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.intersects = function intersects () {
	  // opinionated, must be used after where
	  this._ensurePath('intersects');
	
	  this._geoComparison = '$geoIntersects';
	
	  if (0 === arguments.length) {
	    return this;
	  }
	
	  var area = arguments[0];
	
	  if (null != area && area.type && area.coordinates)
	    return this.geometry(area);
	
	  throw new TypeError('Invalid argument');
	}
	
	/**
	 * Specifies a `$geometry` condition
	 *
	 * ####Example
	 *
	 *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]
	 *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })
	 *
	 *     // or
	 *     var polyB = [[ 0, 0 ], [ 1, 1 ]]
	 *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })
	 *
	 *     // or
	 *     var polyC = [ 0, 0 ]
	 *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })
	 *
	 *     // or
	 *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })
	 *
	 * ####NOTE:
	 *
	 * `geometry()` **must** come after either `intersects()` or `within()`.
	 *
	 * The `object` argument must contain `type` and `coordinates` properties.
	 * - type {String}
	 * - coordinates {Array}
	 *
	 * The most recent path passed to `where()` is used.
	 *
	 * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.
	 * @return {Query} this
	 * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry
	 * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
	 * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/
	 * @api public
	 */
	
	Query.prototype.geometry = function geometry () {
	  if (!('$within' == this._geoComparison ||
	        '$geoWithin' == this._geoComparison ||
	        '$near' == this._geoComparison ||
	        '$geoIntersects' == this._geoComparison)) {
	    throw new Error('geometry() must come after `within()`, `intersects()`, or `near()');
	  }
	
	  var val, path;
	
	  if (1 === arguments.length) {
	    this._ensurePath('geometry');
	    path = this._path;
	    val = arguments[0];
	  } else {
	    throw new TypeError("Invalid argument");
	  }
	
	  if (!(val.type && Array.isArray(val.coordinates))) {
	    throw new TypeError('Invalid argument');
	  }
	
	  var conds = this._conditions[path] || (this._conditions[path] = {});
	  conds[this._geoComparison] = { $geometry: val };
	
	  return this;
	}
	
	// end spatial
	
	/**
	 * Specifies which document fields to include or exclude
	 *
	 * ####String syntax
	 *
	 * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.
	 *
	 * ####Example
	 *
	 *     // include a and b, exclude c
	 *     query.select('a b -c');
	 *
	 *     // or you may use object notation, useful when
	 *     // you have keys already prefixed with a "-"
	 *     query.select({a: 1, b: 1, c: 0});
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @param {Object|String} arg
	 * @return {Query} this
	 * @see SchemaType
	 * @api public
	 */
	
	Query.prototype.select = function select () {
	  var arg = arguments[0];
	  if (!arg) return this;
	
	  if (arguments.length !== 1) {
	    throw new Error("Invalid select: select only takes 1 argument");
	  }
	
	  this._validate('select');
	
	  var fields = this._fields || (this._fields = {});
	  var type = typeof arg;
	
	  if (('string' == type || utils.isArgumentsObject(arg)) &&
	    'number' == typeof arg.length || Array.isArray(arg)) {
	    if ('string' == type)
	      arg = arg.split(/\s+/);
	
	    for (var i = 0, len = arg.length; i < len; ++i) {
	      var field = arg[i];
	      if (!field) continue;
	      var include = '-' == field[0] ? 0 : 1;
	      if (include === 0) field = field.substring(1);
	      fields[field] = include;
	    }
	
	    return this;
	  }
	
	  if (utils.isObject(arg)) {
	    var keys = utils.keys(arg);
	    for (var i = 0; i < keys.length; ++i) {
	      fields[keys[i]] = arg[keys[i]];
	    }
	    return this;
	  }
	
	  throw new TypeError('Invalid select() argument. Must be string or object.');
	}
	
	/**
	 * Specifies a $slice condition for a `path`
	 *
	 * ####Example
	 *
	 *     query.slice('comments', 5)
	 *     query.slice('comments', -5)
	 *     query.slice('comments', [10, 5])
	 *     query.where('comments').slice(5)
	 *     query.where('comments').slice([-10, 5])
	 *
	 * @param {String} [path]
	 * @param {Number} val number/range of elements to slice
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements
	 * @api public
	 */
	
	Query.prototype.slice = function () {
	  if (0 === arguments.length)
	    return this;
	
	  this._validate('slice');
	
	  var path, val;
	
	  if (1 === arguments.length) {
	    var arg = arguments[0];
	    if (typeof arg === 'object' && !Array.isArray(arg)) {
	      var keys = Object.keys(arg);
	      var numKeys = keys.length;
	      for (var i = 0; i < numKeys; ++i) {
	        this.slice(keys[i], arg[keys[i]]);
	      }
	      return this;
	    }
	    this._ensurePath('slice');
	    path = this._path;
	    val = arguments[0];
	  } else if (2 === arguments.length) {
	    if ('number' === typeof arguments[0]) {
	      this._ensurePath('slice');
	      path = this._path;
	      val = slice(arguments);
	    } else {
	      path = arguments[0];
	      val = arguments[1];
	    }
	  } else if (3 === arguments.length) {
	    path = arguments[0];
	    val = slice(arguments, 1);
	  }
	
	  var myFields = this._fields || (this._fields = {});
	  myFields[path] = { '$slice': val };
	  return this;
	}
	
	/**
	 * Sets the sort order
	 *
	 * If an object is passed, values allowed are 'asc', 'desc', 'ascending', 'descending', 1, and -1.
	 *
	 * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.
	 *
	 * ####Example
	 *
	 *     // these are equivalent
	 *     query.sort({ field: 'asc', test: -1 });
	 *     query.sort('field -test');
	 *     query.sort([['field', 1], ['test', -1]]);
	 *
	 * ####Note
	 *
	 *  - The array syntax `.sort([['field', 1], ['test', -1]])` can only be used with [mongodb driver >= 2.0.46](https://github.com/mongodb/node-mongodb-native/blob/2.1/HISTORY.md#2046-2015-10-15).
	 *  - Cannot be used with `distinct()`
	 *
	 * @param {Object|String|Array} arg
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.sort = function (arg) {
	  if (!arg) return this;
	  var len;
	
	  this._validate('sort');
	
	  var type = typeof arg;
	
	  // .sort([['field', 1], ['test', -1]])
	  if (Array.isArray(arg)) {
	    len = arg.length;
	    for (var i = 0; i < arg.length; ++i) {
	      if (!Array.isArray(arg[i])) {
	        throw new Error('Invalid sort() argument, must be array of arrays');
	      }
	      _pushArr(this.options, arg[i][0], arg[i][1]);
	    }
	    return this;
	  }
	
	  // .sort('field -test')
	  if (1 === arguments.length && 'string' == type) {
	    arg = arg.split(/\s+/);
	    len = arg.length;
	    for (var i = 0; i < len; ++i) {
	      var field = arg[i];
	      if (!field) continue;
	      var ascend = '-' == field[0] ? -1 : 1;
	      if (ascend === -1) field = field.substring(1);
	      push(this.options, field, ascend);
	    }
	
	    return this;
	  }
	
	  // .sort({ field: 1, test: -1 })
	  if (utils.isObject(arg)) {
	    var keys = utils.keys(arg);
	    for (var i = 0; i < keys.length; ++i) {
	      var field = keys[i];
	      push(this.options, field, arg[field]);
	    }
	
	    return this;
	  }
	
	  if (typeof Map !== 'undefined' && arg instanceof Map) {
	    _pushMap(this.options, arg);
	    return this;
	  }
	
	  throw new TypeError('Invalid sort() argument. Must be a string, object, or array.');
	}
	
	/*!
	 * @ignore
	 */
	
	function push (opts, field, value) {
	  if (Array.isArray(opts.sort)) {
	    throw new TypeError("Can't mix sort syntaxes. Use either array or object:" +
	      "\n- `.sort([['field', 1], ['test', -1]])`" +
	      "\n- `.sort({ field: 1, test: -1 })`");
	  }
	
	  if (value && value.$meta) {
	    var s = opts.sort || (opts.sort = {});
	    s[field] = { $meta : value.$meta };
	    return;
	  }
	
	  var val = String(value || 1).toLowerCase();
	  if (!/^(?:ascending|asc|descending|desc|1|-1)$/.test(val)) {
	    if (utils.isArray(value)) value = '['+value+']';
	    throw new TypeError('Invalid sort value: {' + field + ': ' + value + ' }');
	  }
	  // store `sort` in a sane format
	  var s = opts.sort || (opts.sort = {});
	  var valueStr = value.toString()
	                  .replace("asc", "1")
	                  .replace("ascending", "1")
	                  .replace("desc", "-1")
	                  .replace("descending", "-1");
	  s[field] = parseInt(valueStr, 10);
	}
	
	function _pushArr (opts, field, value) {
	  opts.sort = opts.sort || [];
	  if (!Array.isArray(opts.sort)) {
	    throw new TypeError("Can't mix sort syntaxes. Use either array or object:" +
	      "\n- `.sort([['field', 1], ['test', -1]])`" +
	      "\n- `.sort({ field: 1, test: -1 })`");
	  }
	  var valueStr = value.toString()
	    .replace("asc", "1")
	    .replace("ascending", "1")
	    .replace("desc", "-1")
	    .replace("descending", "-1");
	  opts.sort.push([field, value]);
	}
	
	function _pushMap (opts, map) {
	  opts.sort = opts.sort || new Map();
	  if (!(opts.sort instanceof Map)) {
	    throw new TypeError("Can't mix sort syntaxes. Use either array or " +
	      "object or map consistently");
	  }
	  map.forEach(function(value, key) {
	    var valueStr = value.toString()
	      .replace("asc", "1")
	      .replace("ascending", "1")
	      .replace("desc", "-1")
	      .replace("descending", "-1");
	    opts.sort.set(key, valueStr);
	  });
	}
	
	/**
	 * Specifies the limit option.
	 *
	 * ####Example
	 *
	 *     query.limit(20)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method limit
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D
	 * @api public
	 */
	/**
	 * Specifies the skip option.
	 *
	 * ####Example
	 *
	 *     query.skip(100).limit(20)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method skip
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D
	 * @api public
	 */
	/**
	 * Specifies the maxScan option.
	 *
	 * ####Example
	 *
	 *     query.maxScan(100)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method maxScan
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan
	 * @api public
	 */
	/**
	 * Specifies the batchSize option.
	 *
	 * ####Example
	 *
	 *     query.batchSize(100)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method batchSize
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D
	 * @api public
	 */
	/**
	 * Specifies the `comment` option.
	 *
	 * ####Example
	 *
	 *     query.comment('login query')
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @method comment
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment
	 * @api public
	 */
	
	/*!
	 * limit, skip, maxScan, batchSize, comment
	 *
	 * Sets these associated options.
	 *
	 *     query.comment('feed query');
	 */
	
	;['limit', 'skip', 'maxScan', 'batchSize', 'comment'].forEach(function (method) {
	  Query.prototype[method] = function (v) {
	    this._validate(method);
	    this.options[method] = v;
	    return this;
	  };
	})
	
	/**
	 * Specifies the maxTimeMS option.
	 *
	 * ####Example
	 *
	 *     query.maxTime(100)
	 *
	 * @method maxTime
	 * @memberOf Query
	 * @param {Number} val
	 * @see mongodb http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS
	 * @api public
	 */
	
	Query.prototype.maxTime = function (v) {
	  this._validate('maxTime');
	  this.options.maxTimeMS = v;
	  return this;
	};
	
	/**
	 * Specifies this query as a `snapshot` query.
	 *
	 * ####Example
	 *
	 *     mquery().snapshot() // true
	 *     mquery().snapshot(true)
	 *     mquery().snapshot(false)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.snapshot = function () {
	  this._validate('snapshot');
	
	  this.options.snapshot = arguments.length
	    ? !! arguments[0]
	    : true
	
	  return this;
	}
	
	/**
	 * Sets query hints.
	 *
	 * ####Example
	 *
	 *     query.hint({ indexA: 1, indexB: -1});
	 *     query.hint('indexA_1_indexB_1');
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @param {Object|string} val a hint object or the index name
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint
	 * @api public
	 */
	
	Query.prototype.hint = function () {
	  if (0 === arguments.length) return this;
	
	  this._validate('hint');
	
	  var arg = arguments[0];
	  if (utils.isObject(arg)) {
	    var hint = this.options.hint || (this.options.hint = {});
	
	    // must keep object keys in order so don't use Object.keys()
	    for (var k in arg) {
	      hint[k] = arg[k];
	    }
	
	    return this;
	  }
	  if (typeof arg === 'string') {
	    this.options.hint = arg;
	    return this;
	  }
	
	  throw new TypeError('Invalid hint. ' + arg);
	}
	
	/**
	 * Sets the slaveOk option. _Deprecated_ in MongoDB 2.2 in favor of read preferences.
	 *
	 * ####Example:
	 *
	 *     query.slaveOk() // true
	 *     query.slaveOk(true)
	 *     query.slaveOk(false)
	 *
	 * @deprecated use read() preferences instead if on mongodb >= 2.2
	 * @param {Boolean} v defaults to true
	 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
	 * @see read()
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.slaveOk = function (v) {
	  this.options.slaveOk = arguments.length ? !!v : true;
	  return this;
	}
	
	/**
	 * Sets the readPreference option for the query.
	 *
	 * ####Example:
	 *
	 *     new Query().read('primary')
	 *     new Query().read('p')  // same as primary
	 *
	 *     new Query().read('primaryPreferred')
	 *     new Query().read('pp') // same as primaryPreferred
	 *
	 *     new Query().read('secondary')
	 *     new Query().read('s')  // same as secondary
	 *
	 *     new Query().read('secondaryPreferred')
	 *     new Query().read('sp') // same as secondaryPreferred
	 *
	 *     new Query().read('nearest')
	 *     new Query().read('n')  // same as nearest
	 *
	 *     // you can also use mongodb.ReadPreference class to also specify tags
	 *     new Query().read(mongodb.ReadPreference('secondary', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }]))
	 *
	 * ####Preferences:
	 *
	 *     primary - (default)  Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.
	 *     secondary            Read from secondary if available, otherwise error.
	 *     primaryPreferred     Read from primary if available, otherwise a secondary.
	 *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.
	 *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.
	 *
	 * Aliases
	 *
	 *     p   primary
	 *     pp  primaryPreferred
	 *     s   secondary
	 *     sp  secondaryPreferred
	 *     n   nearest
	 *
	 * Read more about how to use read preferences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).
	 *
	 * @param {String|ReadPreference} pref one of the listed preference options or their aliases
	 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
	 * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.read = function (pref) {
	  if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {
	    console.error("Deprecation warning: 'tags' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.");
	    Query.prototype.read.deprecationWarningIssued = true;
	  }
	  this.options.readPreference = utils.readPref(pref);
	  return this;
	}
	
	/**
	 * Sets tailable option.
	 *
	 * ####Example
	 *
	 *     query.tailable() <== true
	 *     query.tailable(true)
	 *     query.tailable(false)
	 *
	 * ####Note
	 *
	 * Cannot be used with `distinct()`
	 *
	 * @param {Boolean} v defaults to true
	 * @see mongodb http://www.mongodb.org/display/DOCS/Tailable+Cursors
	 * @api public
	 */
	
	Query.prototype.tailable = function () {
	  this._validate('tailable');
	
	  this.options.tailable = arguments.length
	    ? !! arguments[0]
	    : true;
	
	  return this;
	}
	
	/**
	 * Merges another Query or conditions object into this one.
	 *
	 * When a Query is passed, conditions, field selection and options are merged.
	 *
	 * @param {Query|Object} source
	 * @return {Query} this
	 */
	
	Query.prototype.merge = function (source) {
	  if (!source)
	    return this;
	
	  if (!Query.canMerge(source))
	    throw new TypeError('Invalid argument. Expected instanceof mquery or plain object');
	
	  if (source instanceof Query) {
	    // if source has a feature, apply it to ourselves
	
	    if (source._conditions) {
	      utils.merge(this._conditions, source._conditions);
	    }
	
	    if (source._fields) {
	      this._fields || (this._fields = {});
	      utils.merge(this._fields, source._fields);
	    }
	
	    if (source.options) {
	      this.options || (this.options = {});
	      utils.merge(this.options, source.options);
	    }
	
	    if (source._update) {
	      this._update || (this._update = {});
	      utils.mergeClone(this._update, source._update);
	    }
	
	    if (source._distinct) {
	      this._distinct = source._distinct;
	    }
	
	    return this;
	  }
	
	  // plain object
	  utils.merge(this._conditions, source);
	
	  return this;
	}
	
	/**
	 * Finds documents.
	 *
	 * Passing a `callback` executes the query.
	 *
	 * ####Example
	 *
	 *     query.find()
	 *     query.find(callback)
	 *     query.find({ name: 'Burning Lights' }, callback)
	 *
	 * @param {Object} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.find = function (criteria, callback) {
	  this.op = 'find';
	
	  if ('function' === typeof criteria) {
	    callback = criteria;
	    criteria = undefined;
	  } else if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  if (!callback) return this;
	
	  var self = this
	    , conds = this._conditions
	    , options = this._optionsForExec()
	
	  options.fields = this._fieldsForExec()
	
	  debug('find', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('find', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.find(conds, options, utils.tick(callback));
	  return this;
	}
	
	/**
	 * Returns the query cursor
	 *
	 * ####Examples
	 *
	 *     query.find().cursor();
	 *     query.cursor({ name: 'Burning Lights' });
	 *
	 * @param {Object} [criteria] mongodb selector
	 * @return {Object} cursor
	 * @api public
	 */
	
	Query.prototype.cursor = function cursor (criteria) {
	  if (this.op) {
	    if (this.op !== 'find') {
	      throw new TypeError(".cursor only support .find method");
	    }
	  } else {
	    this.find(criteria);
	  }
	
	  var conds = this._conditions
	    , options = this._optionsForExec()
	
	  options.fields = this._fieldsForExec()
	
	  debug('findCursor', this._collection.collectionName, conds, options);
	  return this._collection.findCursor(conds, options);
	}
	
	/**
	 * Executes the query as a findOne() operation.
	 *
	 * Passing a `callback` executes the query.
	 *
	 * ####Example
	 *
	 *     query.findOne().where('name', /^Burning/);
	 *
	 *     query.findOne({ name: /^Burning/ })
	 *
	 *     query.findOne({ name: /^Burning/ }, callback); // executes
	 *
	 *     query.findOne(function (err, doc) {
	 *       if (err) return handleError(err);
	 *       if (doc) {
	 *         // doc may be null if no document matched
	 *
	 *       }
	 *     });
	 *
	 * @param {Object|Query} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.findOne = function (criteria, callback) {
	  this.op = 'findOne';
	
	  if ('function' === typeof criteria) {
	    callback = criteria;
	    criteria = undefined;
	  } else if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  if (!callback) return this;
	
	  var self = this
	    , conds = this._conditions
	    , options = this._optionsForExec()
	
	  options.fields = this._fieldsForExec();
	
	  debug('findOne', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('findOne', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.findOne(conds, options, utils.tick(callback));
	
	  return this;
	}
	
	/**
	 * Exectues the query as a count() operation.
	 *
	 * Passing a `callback` executes the query.
	 *
	 * ####Example
	 *
	 *     query.count().where('color', 'black').exec(callback);
	 *
	 *     query.count({ color: 'black' }).count(callback)
	 *
	 *     query.count({ color: 'black' }, callback)
	 *
	 *     query.where('color', 'black').count(function (err, count) {
	 *       if (err) return handleError(err);
	 *       console.log('there are %d kittens', count);
	 *     })
	 *
	 * @param {Object} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Count
	 * @api public
	 */
	
	Query.prototype.count = function (criteria, callback) {
	  this.op = 'count';
	  this._validate();
	
	  if ('function' === typeof criteria) {
	    callback = criteria;
	    criteria = undefined;
	  } else if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  if (!callback) return this;
	
	  var conds = this._conditions
	    , options = this._optionsForExec()
	
	  debug('count', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('count', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.count(conds, options, utils.tick(callback));
	  return this;
	}
	
	/**
	 * Declares or executes a distinct() operation.
	 *
	 * Passing a `callback` executes the query.
	 *
	 * ####Example
	 *
	 *     distinct(criteria, field, fn)
	 *     distinct(criteria, field)
	 *     distinct(field, fn)
	 *     distinct(field)
	 *     distinct(fn)
	 *     distinct()
	 *
	 * @param {Object|Query} [criteria]
	 * @param {String} [field]
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Distinct
	 * @api public
	 */
	
	Query.prototype.distinct = function (criteria, field, callback) {
	  this.op = 'distinct';
	  this._validate();
	
	  if (!callback) {
	    switch (typeof field) {
	      case 'function':
	        callback = field;
	        if ('string' == typeof criteria) {
	          field = criteria;
	          criteria = undefined;
	        }
	        break;
	      case 'undefined':
	      case 'string':
	        break;
	      default:
	        throw new TypeError('Invalid `field` argument. Must be string or function')
	        break;
	    }
	
	    switch (typeof criteria) {
	      case 'function':
	        callback = criteria;
	        criteria = field = undefined;
	        break;
	      case 'string':
	        field = criteria;
	        criteria = undefined;
	        break;
	    }
	  }
	
	  if ('string' == typeof field) {
	    this._distinct = field;
	  }
	
	  if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  if (!callback) {
	    return this;
	  }
	
	  if (!this._distinct) {
	    throw new Error('No value for `distinct` has been declared');
	  }
	
	  var conds = this._conditions
	    , options = this._optionsForExec()
	
	  debug('distinct', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('distinct', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.distinct(this._distinct, conds, options, utils.tick(callback));
	
	  return this;
	}
	
	/**
	 * Declare and/or execute this query as an update() operation. By default,
	 * `update()` only modifies the _first_ document that matches `criteria`.
	 *
	 * _All paths passed that are not $atomic operations will become $set ops._
	 *
	 * ####Example
	 *
	 *     mquery({ _id: id }).update({ title: 'words' }, ...)
	 *
	 * becomes
	 *
	 *     collection.update({ _id: id }, { $set: { title: 'words' }}, ...)
	 *
	 * ####Note
	 *
	 * Passing an empty object `{}` as the doc will result in a no-op unless the `overwrite` option is passed. Without the `overwrite` option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.
	 *
	 * ####Note
	 *
	 * The operation is only executed when a callback is passed. To force execution without a callback (which would be an unsafe write), we must first call update() and then execute it by using the `exec()` method.
	 *
	 *     var q = mquery(collection).where({ _id: id });
	 *     q.update({ $set: { name: 'bob' }}).update(); // not executed
	 *
	 *     var q = mquery(collection).where({ _id: id });
	 *     q.update({ $set: { name: 'bob' }}).exec(); // executed as unsafe
	 *
	 *     // keys that are not $atomic ops become $set.
	 *     // this executes the same command as the previous example.
	 *     q.update({ name: 'bob' }).where({ _id: id }).exec();
	 *
	 *     var q = mquery(collection).update(); // not executed
	 *
	 *     // overwriting with empty docs
	 *     var q.where({ _id: id }).setOptions({ overwrite: true })
	 *     q.update({ }, callback); // executes
	 *
	 *     // multi update with overwrite to empty doc
	 *     var q = mquery(collection).where({ _id: id });
	 *     q.setOptions({ multi: true, overwrite: true })
	 *     q.update({ });
	 *     q.update(callback); // executed
	 *
	 *     // multi updates
	 *     mquery()
	 *       .collection(coll)
	 *       .update({ name: /^match/ }, { $set: { arr: [] }}, { multi: true }, callback)
	 *     // more multi updates
	 *     mquery({ })
	 *       .collection(coll)
	 *       .setOptions({ multi: true })
	 *       .update({ $set: { arr: [] }}, callback)
	 *
	 *     // single update by default
	 *     mquery({ email: 'address@example.com' })
	 *      .collection(coll)
	 *      .update({ $inc: { counter: 1 }}, callback)
	 *
	 *     // summary
	 *     update(criteria, doc, opts, cb) // executes
	 *     update(criteria, doc, opts)
	 *     update(criteria, doc, cb) // executes
	 *     update(criteria, doc)
	 *     update(doc, cb) // executes
	 *     update(doc)
	 *     update(cb) // executes
	 *     update(true) // executes (unsafe write)
	 *     update()
	 *
	 * @param {Object} [criteria]
	 * @param {Object} [doc] the update command
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.update = function update (criteria, doc, options, callback) {
	  var force;
	
	  switch (arguments.length) {
	    case 3:
	      if ('function' == typeof options) {
	        callback = options;
	        options = undefined;
	      }
	      break;
	    case 2:
	      if ('function' == typeof doc) {
	        callback = doc;
	        doc = criteria;
	        criteria = undefined;
	      }
	      break;
	    case 1:
	      switch (typeof criteria) {
	        case 'function':
	          callback = criteria;
	          criteria = options = doc = undefined;
	          break;
	        case 'boolean':
	          // execution with no callback (unsafe write)
	          force = criteria;
	          criteria = undefined;
	          break;
	        default:
	          doc = criteria;
	          criteria = options = undefined;
	          break;
	      }
	  }
	
	  return _update(this, 'update', criteria, doc, options, force, callback);
	}
	
	/**
	 * Declare and/or execute this query as an `updateMany()` operation. Identical
	 * to `update()` except `updateMany()` will update _all_ documents that match
	 * `criteria`, rather than just the first one.
	 *
	 * _All paths passed that are not $atomic operations will become $set ops._
	 *
	 * ####Example
	 *
	 *     // Update every document whose `title` contains 'test'
	 *     mquery().updateMany({ title: /test/ }, { year: 2017 })
	 *
	 * @param {Object} [criteria]
	 * @param {Object} [doc] the update command
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.updateMany = function updateMany (criteria, doc, options, callback) {
	  var force;
	
	  switch (arguments.length) {
	    case 3:
	      if ('function' == typeof options) {
	        callback = options;
	        options = undefined;
	      }
	      break;
	    case 2:
	      if ('function' == typeof doc) {
	        callback = doc;
	        doc = criteria;
	        criteria = undefined;
	      }
	      break;
	    case 1:
	      switch (typeof criteria) {
	        case 'function':
	          callback = criteria;
	          criteria = options = doc = undefined;
	          break;
	        case 'boolean':
	          // execution with no callback (unsafe write)
	          force = criteria;
	          criteria = undefined;
	          break;
	        default:
	          doc = criteria;
	          criteria = options = undefined;
	          break;
	      }
	  }
	
	  return _update(this, 'updateMany', criteria, doc, options, force, callback);
	}
	
	/**
	 * Declare and/or execute this query as an `updateOne()` operation. Identical
	 * to `update()` except `updateOne()` will _always_ update just one document,
	 * regardless of the `multi` option.
	 *
	 * _All paths passed that are not $atomic operations will become $set ops._
	 *
	 * ####Example
	 *
	 *     // Update the first document whose `title` contains 'test'
	 *     mquery().updateMany({ title: /test/ }, { year: 2017 })
	 *
	 * @param {Object} [criteria]
	 * @param {Object} [doc] the update command
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.updateOne = function updateOne (criteria, doc, options, callback) {
	  var force;
	
	  switch (arguments.length) {
	    case 3:
	      if ('function' == typeof options) {
	        callback = options;
	        options = undefined;
	      }
	      break;
	    case 2:
	      if ('function' == typeof doc) {
	        callback = doc;
	        doc = criteria;
	        criteria = undefined;
	      }
	      break;
	    case 1:
	      switch (typeof criteria) {
	        case 'function':
	          callback = criteria;
	          criteria = options = doc = undefined;
	          break;
	        case 'boolean':
	          // execution with no callback (unsafe write)
	          force = criteria;
	          criteria = undefined;
	          break;
	        default:
	          doc = criteria;
	          criteria = options = undefined;
	          break;
	      }
	  }
	
	  return _update(this, 'updateOne', criteria, doc, options, force, callback);
	}
	
	/**
	 * Declare and/or execute this query as an `replaceOne()` operation. Similar
	 * to `updateOne()`, except `replaceOne()` is not allowed to use atomic
	 * modifiers (`$set`, `$push`, etc.). Calling `replaceOne()` will always
	 * replace the existing doc.
	 *
	 * ####Example
	 *
	 *     // Replace the document with `_id` 1 with `{ _id: 1, year: 2017 }`
	 *     mquery().replaceOne({ _id: 1 }, { year: 2017 })
	 *
	 * @param {Object} [criteria]
	 * @param {Object} [doc] the update command
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.replaceOne = function replaceOne (criteria, doc, options, callback) {
	  var force;
	
	  switch (arguments.length) {
	    case 3:
	      if ('function' == typeof options) {
	        callback = options;
	        options = undefined;
	      }
	      break;
	    case 2:
	      if ('function' == typeof doc) {
	        callback = doc;
	        doc = criteria;
	        criteria = undefined;
	      }
	      break;
	    case 1:
	      switch (typeof criteria) {
	        case 'function':
	          callback = criteria;
	          criteria = options = doc = undefined;
	          break;
	        case 'boolean':
	          // execution with no callback (unsafe write)
	          force = criteria;
	          criteria = undefined;
	          break;
	        default:
	          doc = criteria;
	          criteria = options = undefined;
	          break;
	      }
	  }
	
	  this.setOptions({ overwrite: true });
	  return _update(this, 'replaceOne', criteria, doc, options, force, callback);
	}
	
	
	/*!
	 * Internal helper for update, updateMany, updateOne
	 */
	
	function _update (query, op, criteria, doc, options, force, callback) {
	  query.op = op;
	
	  if (Query.canMerge(criteria)) {
	    query.merge(criteria);
	  }
	
	  if (doc) {
	    query._mergeUpdate(doc);
	  }
	
	  if (utils.isObject(options)) {
	    // { overwrite: true }
	    query.setOptions(options);
	  }
	
	  // we are done if we don't have callback and they are
	  // not forcing an unsafe write.
	  if (!(force || callback)) {
	    return query;
	  }
	
	  if (!query._update ||
	      !query.options.overwrite && 0 === utils.keys(query._update).length) {
	    callback && utils.soon(callback.bind(null, null, 0));
	    return query;
	  }
	
	  options = query._optionsForExec();
	  if (!callback) options.safe = false;
	
	  var criteria = query._conditions;
	  doc = query._updateForExec();
	
	  debug('update', query._collection.collectionName, criteria, doc, options);
	  callback = query._wrapCallback(op, callback, {
	    conditions: criteria
	  , doc: doc
	  , options: options
	  });
	
	  query._collection[op](criteria, doc, options, utils.tick(callback));
	
	  return query;
	}
	
	/**
	 * Declare and/or execute this query as a remove() operation.
	 *
	 * ####Example
	 *
	 *     mquery(collection).remove({ artist: 'Anne Murray' }, callback)
	 *
	 * ####Note
	 *
	 * The operation is only executed when a callback is passed. To force execution without a callback (which would be an unsafe write), we must first call remove() and then execute it by using the `exec()` method.
	 *
	 *     // not executed
	 *     var query = mquery(collection).remove({ name: 'Anne Murray' })
	 *
	 *     // executed
	 *     mquery(collection).remove({ name: 'Anne Murray' }, callback)
	 *     mquery(collection).remove({ name: 'Anne Murray' }).remove(callback)
	 *
	 *     // executed without a callback (unsafe write)
	 *     query.exec()
	 *
	 *     // summary
	 *     query.remove(conds, fn); // executes
	 *     query.remove(conds)
	 *     query.remove(fn) // executes
	 *     query.remove()
	 *
	 * @param {Object|Query} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.remove = function (criteria, callback) {
	  this.op = 'remove';
	  var force;
	
	  if ('function' === typeof criteria) {
	    callback = criteria;
	    criteria = undefined;
	  } else if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  } else if (true === criteria) {
	    force = criteria;
	    criteria = undefined;
	  }
	
	  if (!(force || callback))
	    return this;
	
	  var options = this._optionsForExec()
	  if (!callback) options.safe = false;
	
	  var conds = this._conditions;
	
	  debug('remove', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('remove', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.remove(conds, options, utils.tick(callback));
	
	  return this;
	}
	
	/**
	 * Declare and/or execute this query as a `deleteOne()` operation. Behaves like
	 * `remove()`, except for ignores the `justOne` option and always deletes at
	 * most one document.
	 *
	 * ####Example
	 *
	 *     mquery(collection).deleteOne({ artist: 'Anne Murray' }, callback)
	 *
	 * @param {Object|Query} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.deleteOne = function (criteria, callback) {
	  this.op = 'deleteOne';
	  var force;
	
	  if ('function' === typeof criteria) {
	    callback = criteria;
	    criteria = undefined;
	  } else if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  } else if (true === criteria) {
	    force = criteria;
	    criteria = undefined;
	  }
	
	  if (!(force || callback))
	    return this;
	
	  var options = this._optionsForExec()
	  if (!callback) options.safe = false;
	  delete options.justOne;
	
	  var conds = this._conditions;
	
	  debug('deleteOne', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('deleteOne', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.deleteOne(conds, options, utils.tick(callback));
	
	  return this;
	}
	
	/**
	 * Declare and/or execute this query as a `deleteMany()` operation. Behaves like
	 * `remove()`, except for ignores the `justOne` option and always deletes
	 * _every_ document that matches `criteria`.
	 *
	 * ####Example
	 *
	 *     mquery(collection).deleteMany({ artist: 'Anne Murray' }, callback)
	 *
	 * @param {Object|Query} [criteria] mongodb selector
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.deleteMany = function (criteria, callback) {
	  this.op = 'deleteMany';
	  var force;
	
	  if ('function' === typeof criteria) {
	    callback = criteria;
	    criteria = undefined;
	  } else if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  } else if (true === criteria) {
	    force = criteria;
	    criteria = undefined;
	  }
	
	  if (!(force || callback))
	    return this;
	
	  var options = this._optionsForExec()
	  if (!callback) options.safe = false;
	  delete options.justOne;
	
	  var conds = this._conditions;
	
	  debug('deleteOne', this._collection.collectionName, conds, options);
	  callback = this._wrapCallback('deleteOne', callback, {
	    conditions: conds
	  , options: options
	  });
	
	  this._collection.deleteMany(conds, options, utils.tick(callback));
	
	  return this;
	}
	
	/**
	 * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.
	 *
	 * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed.
	 *
	 * ####Available options
	 *
	 * - `new`: bool - true to return the modified document rather than the original. defaults to true
	 * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 *
	 * ####Examples
	 *
	 *     query.findOneAndUpdate(conditions, update, options, callback) // executes
	 *     query.findOneAndUpdate(conditions, update, options)  // returns Query
	 *     query.findOneAndUpdate(conditions, update, callback) // executes
	 *     query.findOneAndUpdate(conditions, update)           // returns Query
	 *     query.findOneAndUpdate(update, callback)             // returns Query
	 *     query.findOneAndUpdate(update)                       // returns Query
	 *     query.findOneAndUpdate(callback)                     // executes
	 *     query.findOneAndUpdate()                             // returns Query
	 *
	 * @param {Object|Query} [query]
	 * @param {Object} [doc]
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 * @return {Query} this
	 * @api public
	 */
	
	Query.prototype.findOneAndUpdate = function (criteria, doc, options, callback) {
	  this.op = 'findOneAndUpdate';
	  this._validate();
	
	  switch (arguments.length) {
	    case 3:
	      if ('function' == typeof options) {
	        callback = options;
	        options = {};
	      }
	      break;
	    case 2:
	      if ('function' == typeof doc) {
	        callback = doc;
	        doc = criteria;
	        criteria = undefined;
	      }
	      options = undefined;
	      break;
	    case 1:
	      if ('function' == typeof criteria) {
	        callback = criteria;
	        criteria = options = doc = undefined;
	      } else {
	        doc = criteria;
	        criteria = options = undefined;
	      }
	  }
	
	  if (Query.canMerge(criteria)) {
	    this.merge(criteria);
	  }
	
	  // apply doc
	  if (doc) {
	    this._mergeUpdate(doc);
	  }
	
	  options && this.setOptions(options);
	
	  if (!callback) return this;
	  return this._findAndModify('update', callback);
	}
	
	/**
	 * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.
	 *
	 * Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if `callback` is passed.
	 *
	 * ####Available options
	 *
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 *
	 * ####Examples
	 *
	 *     A.where().findOneAndRemove(conditions, options, callback) // executes
	 *     A.where().findOneAndRemove(conditions, options)  // return Query
	 *     A.where().findOneAndRemove(conditions, callback) // executes
	 *     A.where().findOneAndRemove(conditions) // returns Query
	 *     A.where().findOneAndRemove(callback)   // executes
	 *     A.where().findOneAndRemove()           // returns Query
	 *
	 * @param {Object} [conditions]
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query} this
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 * @api public
	 */
	
	Query.prototype.findOneAndRemove = function (conditions, options, callback) {
	  this.op = 'findOneAndRemove';
	  this._validate();
	
	  if ('function' == typeof options) {
	    callback = options;
	    options = undefined;
	  } else if ('function' == typeof conditions) {
	    callback = conditions;
	    conditions = undefined;
	  }
	
	  // apply conditions
	  if (Query.canMerge(conditions)) {
	    this.merge(conditions);
	  }
	
	  // apply options
	  options && this.setOptions(options);
	
	  if (!callback) return this;
	
	  return this._findAndModify('remove', callback);
	}
	
	/**
	 * _findAndModify
	 *
	 * @param {String} type - either "remove" or "update"
	 * @param {Function} callback
	 * @api private
	 */
	
	Query.prototype._findAndModify = function (type, callback) {
	  assert.equal('function', typeof callback);
	
	  var opts = this._optionsForExec()
	    , self = this
	    , fields
	    , sort
	    , doc
	
	  if ('remove' == type) {
	    opts.remove = true;
	  } else {
	    if (!('new' in opts)) opts.new = true;
	    if (!('upsert' in opts)) opts.upsert = false;
	
	    doc = this._updateForExec()
	    if (!doc) {
	      if (opts.upsert) {
	        // still need to do the upsert to empty doc
	        doc = { $set: {} };
	      } else {
	        return this.findOne(callback);
	      }
	    }
	  }
	
	  var fields = this._fieldsForExec();
	  if (fields) {
	    opts.fields = fields;
	  }
	
	  var conds = this._conditions;
	
	  debug('findAndModify', this._collection.collectionName, conds, doc, opts);
	  callback = this._wrapCallback('findAndModify', callback, {
	    conditions: conds
	  , doc: doc
	  , options: opts
	  });
	
	  this._collection
	  .findAndModify(conds, doc, opts, utils.tick(callback));
	
	  return this;
	}
	
	/**
	 * Wrap callback to add tracing
	 *
	 * @param {Function} callback
	 * @param {Object} [queryInfo]
	 * @api private
	 */
	Query.prototype._wrapCallback = function (method, callback, queryInfo) {
	  var traceFunction = this._traceFunction || Query.traceFunction;
	
	  if (traceFunction) {
	    queryInfo.collectionName = this._collection.collectionName;
	
	    var traceCallback = traceFunction &&
	      traceFunction.call(null, method, queryInfo, this);
	
	    var startTime = new Date().getTime();
	
	    return function wrapperCallback (err, result) {
	      if (traceCallback) {
	        var millis = new Date().getTime() - startTime;
	        traceCallback.call(null, err, result, millis);
	      }
	
	      if (callback) {
	        callback.apply(null, arguments);
	      }
	    };
	  }
	
	  return callback;
	}
	
	/**
	 * Add trace function that gets called when the query is executed.
	 * The function will be called with (method, queryInfo, query) and
	 * should return a callback function which will be called
	 * with (err, result, millis) when the query is complete.
	 *
	 * queryInfo is an object containing: {
	 *   collectionName: <name of the collection>,
	 *   conditions: <query criteria>,
	 *   options: <comment, fields, readPreference, etc>,
	 *   doc: [document to update, if applicable]
	 * }
	 *
	 * NOTE: Does not trace stream queries.
	 *
	 * @param {Function} traceFunction
	 * @return {Query} this
	 * @api public
	 */
	Query.prototype.setTraceFunction = function (traceFunction) {
	  this._traceFunction = traceFunction;
	  return this;
	}
	
	/**
	 * Executes the query
	 *
	 * ####Examples
	 *
	 *     query.exec();
	 *     query.exec(callback);
	 *     query.exec('update');
	 *     query.exec('find', callback);
	 *
	 * @param {String|Function} [operation]
	 * @param {Function} [callback]
	 * @api public
	 */
	
	Query.prototype.exec = function exec (op, callback) {
	  switch (typeof op) {
	    case 'function':
	      callback = op;
	      op = null;
	      break;
	    case 'string':
	      this.op = op;
	      break;
	  }
	
	  assert.ok(this.op, "Missing query type: (find, update, etc)");
	
	  if ('update' == this.op || 'remove' == this.op) {
	    callback || (callback = true);
	  }
	
	  var self = this;
	
	  if ('function' == typeof callback) {
	    this[this.op](callback);
	  } else {
	    return new Query.Promise(function(success, error) {
	      self[self.op](function(err, val) {
	        if (err) error(err);
	        else success(val);
	        self = success = error = null;
	      });
	    });
	  }
	}
	
	/**
	 * Returns a thunk which when called runs this.exec()
	 *
	 * The thunk receives a callback function which will be
	 * passed to `this.exec()`
	 *
	 * @return {Function}
	 * @api public
	 */
	
	Query.prototype.thunk = function() {
	  var self = this;
	  return function(cb) {
	    self.exec(cb);
	  }
	}
	
	/**
	 * Executes the query returning a `Promise` which will be
	 * resolved with either the doc(s) or rejected with the error.
	 *
	 * @param {Function} [resolve]
	 * @param {Function} [reject]
	 * @return {Promise}
	 * @api public
	 */
	
	Query.prototype.then = function(resolve, reject) {
	  var self = this;
	  var promise = new Query.Promise(function(success, error) {
	    self.exec(function(err, val) {
	      if (err) error(err);
	      else success(val);
	      self = success = error = null;
	    });
	  });
	  return promise.then(resolve, reject);
	}
	
	/**
	 * Returns a stream for the given find query.
	 *
	 * @throws Error if operation is not a find
	 * @returns {Stream} Node 0.8 style
	 */
	
	Query.prototype.stream = function(streamOptions) {
	  if ('find' != this.op)
	    throw new Error('stream() is only available for find');
	
	  var conds = this._conditions;
	
	  var options = this._optionsForExec()
	  options.fields = this._fieldsForExec()
	
	  debug('stream', this._collection.collectionName, conds, options, streamOptions);
	
	  return this._collection.findStream(conds, options, streamOptions);
	}
	
	/**
	 * Determines if field selection has been made.
	 *
	 * @return {Boolean}
	 * @api public
	 */
	
	Query.prototype.selected = function selected () {
	  return !! (this._fields && Object.keys(this._fields).length > 0);
	}
	
	/**
	 * Determines if inclusive field selection has been made.
	 *
	 *     query.selectedInclusively() // false
	 *     query.select('name')
	 *     query.selectedInclusively() // true
	 *     query.selectedExlusively() // false
	 *
	 * @returns {Boolean}
	 */
	
	Query.prototype.selectedInclusively = function selectedInclusively () {
	  if (!this._fields) return false;
	
	  var keys = Object.keys(this._fields);
	  if (0 === keys.length) return false;
	
	  for (var i = 0; i < keys.length; ++i) {
	    var key = keys[i];
	    if (0 === this._fields[key]) return false;
	    if (this._fields[key] &&
	        typeof this._fields[key] === 'object' &&
	        this._fields[key].$meta) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	/**
	 * Determines if exclusive field selection has been made.
	 *
	 *     query.selectedExlusively() // false
	 *     query.select('-name')
	 *     query.selectedExlusively() // true
	 *     query.selectedInclusively() // false
	 *
	 * @returns {Boolean}
	 */
	
	Query.prototype.selectedExclusively = function selectedExclusively () {
	  if (!this._fields) return false;
	
	  var keys = Object.keys(this._fields);
	  if (0 === keys.length) return false;
	
	  for (var i = 0; i < keys.length; ++i) {
	    var key = keys[i];
	    if (0 === this._fields[key]) return true;
	  }
	
	  return false;
	}
	
	/**
	 * Merges `doc` with the current update object.
	 *
	 * @param {Object} doc
	 */
	
	Query.prototype._mergeUpdate = function (doc) {
	  if (!this._update) this._update = {};
	  if (doc instanceof Query) {
	    if (doc._update) {
	      utils.mergeClone(this._update, doc._update);
	    }
	  } else {
	    utils.mergeClone(this._update, doc);
	  }
	}
	
	/**
	 * Returns default options.
	 *
	 * @return {Object}
	 * @api private
	 */
	
	Query.prototype._optionsForExec = function () {
	  var options = utils.clone(this.options, { retainKeyOrder: true });
	  return options;
	}
	
	/**
	 * Returns fields selection for this query.
	 *
	 * @return {Object}
	 * @api private
	 */
	
	Query.prototype._fieldsForExec = function () {
	  return utils.clone(this._fields, { retainKeyOrder: true });
	}
	
	/**
	 * Return an update document with corrected $set operations.
	 *
	 * @api private
	 */
	
	Query.prototype._updateForExec = function () {
	  var update = utils.clone(this._update, { retainKeyOrder: true })
	    , ops = utils.keys(update)
	    , i = ops.length
	    , ret = {}
	    , hasKeys
	    , val
	
	  while (i--) {
	    var op = ops[i];
	
	    if (this.options.overwrite) {
	      ret[op] = update[op];
	      continue;
	    }
	
	    if ('$' !== op[0]) {
	      // fix up $set sugar
	      if (!ret.$set) {
	        if (update.$set) {
	          ret.$set = update.$set;
	        } else {
	          ret.$set = {};
	        }
	      }
	      ret.$set[op] = update[op];
	      ops.splice(i, 1);
	      if (!~ops.indexOf('$set')) ops.push('$set');
	    } else if ('$set' === op) {
	      if (!ret.$set) {
	        ret[op] = update[op];
	      }
	    } else {
	      ret[op] = update[op];
	    }
	  }
	
	  this._compiledUpdate = ret;
	  return ret;
	}
	
	/**
	 * Make sure _path is set.
	 *
	 * @parmam {String} method
	 */
	
	Query.prototype._ensurePath = function (method) {
	  if (!this._path) {
	    var msg = method + '() must be used after where() '
	                     + 'when called with these arguments'
	    throw new Error(msg);
	  }
	}
	
	/*!
	 * Permissions
	 */
	
	Query.permissions = __webpack_require__(248);
	
	Query._isPermitted = function (a, b) {
	  var denied = Query.permissions[b];
	  if (!denied) return true;
	  return true !== denied[a];
	}
	
	Query.prototype._validate = function (action) {
	  var fail;
	  var validator;
	
	  if (undefined === action) {
	
	    validator = Query.permissions[this.op];
	    if ('function' != typeof validator) return true;
	
	    fail = validator(this);
	
	  } else if (!Query._isPermitted(action, this.op)) {
	    fail = action;
	  }
	
	  if (fail) {
	    throw new Error(fail + ' cannot be used with ' + this.op);
	  }
	}
	
	/**
	 * Determines if `conds` can be merged using `mquery().merge()`
	 *
	 * @param {Object} conds
	 * @return {Boolean}
	 */
	
	Query.canMerge = function (conds) {
	  return conds instanceof Query || utils.isObject(conds);
	}
	
	/**
	 * Set a trace function that will get called whenever a
	 * query is executed.
	 *
	 * See `setTraceFunction()` for details.
	 *
	 * @param {Object} conds
	 * @return {Boolean}
	 */
	Query.setGlobalTraceFunction = function (traceFunction) {
	  Query.traceFunction = traceFunction;
	}
	
	/*!
	 * Exports.
	 */
	
	Query.utils = utils;
	Query.env = __webpack_require__(148)
	Query.Collection = __webpack_require__(246);
	Query.BaseCollection = __webpack_require__(68);
	Query.Promise = __webpack_require__(268);
	module.exports = exports = Query;
	
	// TODO
	// test utils


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	var map = {
		"./index": 20,
		"./index.js": 20,
		"./test/nestedTest/index": 106,
		"./test/nestedTest/index.js": 106,
		"./test/require_optional_tests": 151,
		"./test/require_optional_tests.js": 151
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 105;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	var require_optional = __webpack_require__(20)
	
	function findPackage(packageName) {
	  var pkg = require_optional(packageName);
	  return pkg;
	}
	
	module.exports.findPackage = findPackage


/***/ }),
/* 107 */
/***/ (function(module, exports) {

	module.exports = require("webpack");

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = eachLimit;
	
	var _eachOf = __webpack_require__(109);
	
	var _eachOf2 = _interopRequireDefault(_eachOf);
	
	var _withoutIndex = __webpack_require__(162);
	
	var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Applies the function `iteratee` to each item in `coll`, in parallel.
	 * The `iteratee` is called with an item from the list, and a callback for when
	 * it has finished. If the `iteratee` passes an error to its `callback`, the
	 * main `callback` (for the `each` function) is immediately called with the
	 * error.
	 *
	 * Note, that since this function applies `iteratee` to each item in parallel,
	 * there is no guarantee that the iteratee functions will complete in order.
	 *
	 * @name each
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias forEach
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each item
	 * in `coll`. The iteratee is passed a `callback(err)` which must be called once
	 * it has completed. If no error has occurred, the `callback` should be run
	 * without arguments or with an explicit `null` argument. The array index is not
	 * passed to the iteratee. Invoked with (item, callback). If you need the index,
	 * use `eachOf`.
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 * @example
	 *
	 * // assuming openFiles is an array of file names and saveFile is a function
	 * // to save the modified contents of that file:
	 *
	 * async.each(openFiles, saveFile, function(err){
	 *   // if any of the saves produced an error, err would equal that error
	 * });
	 *
	 * // assuming openFiles is an array of file names
	 * async.each(openFiles, function(file, callback) {
	 *
	 *     // Perform operation on file here.
	 *     console.log('Processing file ' + file);
	 *
	 *     if( file.length > 32 ) {
	 *       console.log('This file name is too long');
	 *       callback('File name too long');
	 *     } else {
	 *       // Do work to process file here
	 *       console.log('File processed');
	 *       callback();
	 *     }
	 * }, function(err) {
	 *     // if any of the file processing produced an error, err would equal that error
	 *     if( err ) {
	 *       // One of the iterations produced an error.
	 *       // All processing will now stop.
	 *       console.log('A file failed to process');
	 *     } else {
	 *       console.log('All files have been processed successfully');
	 *     }
	 * });
	 */
	function eachLimit(coll, iteratee, callback) {
	  (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)(iteratee), callback);
	}
	module.exports = exports['default'];

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	exports.default = function (coll, iteratee, callback) {
	    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
	    eachOfImplementation(coll, iteratee, callback);
	};
	
	var _isArrayLike = __webpack_require__(51);
	
	var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
	
	var _eachOfLimit = __webpack_require__(156);
	
	var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
	
	var _doLimit = __webpack_require__(158);
	
	var _doLimit2 = _interopRequireDefault(_doLimit);
	
	var _noop = __webpack_require__(74);
	
	var _noop2 = _interopRequireDefault(_noop);
	
	var _once = __webpack_require__(111);
	
	var _once2 = _interopRequireDefault(_once);
	
	var _onlyOnce = __webpack_require__(112);
	
	var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// eachOf implementation optimized for array-likes
	function eachOfArrayLike(coll, iteratee, callback) {
	    callback = (0, _once2.default)(callback || _noop2.default);
	    var index = 0,
	        completed = 0,
	        length = coll.length;
	    if (length === 0) {
	        callback(null);
	    }
	
	    function iteratorCallback(err) {
	        if (err) {
	            callback(err);
	        } else if (++completed === length) {
	            callback(null);
	        }
	    }
	
	    for (; index < length; index++) {
	        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
	    }
	}
	
	// a generic version of eachOf which can handle array, object, and iterator cases.
	var eachOfGeneric = (0, _doLimit2.default)(_eachOfLimit2.default, Infinity);
	
	/**
	 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
	 * to the iteratee.
	 *
	 * @name eachOf
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias forEachOf
	 * @category Collection
	 * @see [async.each]{@link module:Collections.each}
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A function to apply to each
	 * item in `coll`. The `key` is the item's key, or index in the case of an
	 * array. The iteratee is passed a `callback(err)` which must be called once it
	 * has completed. If no error has occurred, the callback should be run without
	 * arguments or with an explicit `null` argument. Invoked with
	 * (item, key, callback).
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 * @example
	 *
	 * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
	 * var configs = {};
	 *
	 * async.forEachOf(obj, function (value, key, callback) {
	 *     fs.readFile(__dirname + value, "utf8", function (err, data) {
	 *         if (err) return callback(err);
	 *         try {
	 *             configs[key] = JSON.parse(data);
	 *         } catch (e) {
	 *             return callback(e);
	 *         }
	 *         callback();
	 *     });
	 * }, function (err) {
	 *     if (err) console.error(err.message);
	 *     // configs is now a map of JSON data
	 *     doSomethingWith(configs);
	 * });
	 */
	module.exports = exports['default'];

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = _eachOfLimit;
	
	var _noop = __webpack_require__(74);
	
	var _noop2 = _interopRequireDefault(_noop);
	
	var _once = __webpack_require__(111);
	
	var _once2 = _interopRequireDefault(_once);
	
	var _iterator = __webpack_require__(160);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _onlyOnce = __webpack_require__(112);
	
	var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
	
	var _breakLoop = __webpack_require__(157);
	
	var _breakLoop2 = _interopRequireDefault(_breakLoop);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _eachOfLimit(limit) {
	    return function (obj, iteratee, callback) {
	        callback = (0, _once2.default)(callback || _noop2.default);
	        if (limit <= 0 || !obj) {
	            return callback(null);
	        }
	        var nextElem = (0, _iterator2.default)(obj);
	        var done = false;
	        var running = 0;
	
	        function iterateeCallback(err, value) {
	            running -= 1;
	            if (err) {
	                done = true;
	                callback(err);
	            } else if (value === _breakLoop2.default || done && running <= 0) {
	                done = true;
	                return callback(null);
	            } else {
	                replenish();
	            }
	        }
	
	        function replenish() {
	            while (running < limit && !done) {
	                var elem = nextElem();
	                if (elem === null) {
	                    done = true;
	                    if (running <= 0) {
	                        callback(null);
	                    }
	                    return;
	                }
	                running += 1;
	                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
	            }
	        }
	
	        replenish();
	    };
	}
	module.exports = exports['default'];

/***/ }),
/* 111 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = once;
	function once(fn) {
	    return function () {
	        if (fn === null) return;
	        var callFn = fn;
	        fn = null;
	        callFn.apply(this, arguments);
	    };
	}
	module.exports = exports["default"];

/***/ }),
/* 112 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = onlyOnce;
	function onlyOnce(fn) {
	    return function () {
	        if (fn === null) throw new Error("Callback was already called.");
	        var callFn = fn;
	        fn = null;
	        callFn.apply(this, arguments);
	    };
	}
	module.exports = exports["default"];

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = _parallel;
	
	var _noop = __webpack_require__(74);
	
	var _noop2 = _interopRequireDefault(_noop);
	
	var _isArrayLike = __webpack_require__(51);
	
	var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
	
	var _rest = __webpack_require__(161);
	
	var _rest2 = _interopRequireDefault(_rest);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _parallel(eachfn, tasks, callback) {
	    callback = callback || _noop2.default;
	    var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
	
	    eachfn(tasks, function (task, key, callback) {
	        task((0, _rest2.default)(function (err, args) {
	            if (args.length <= 1) {
	                args = args[0];
	            }
	            results[key] = args;
	            callback(err);
	        }));
	    }, function (err) {
	        callback(err, results);
	    });
	}
	module.exports = exports['default'];

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = parallelLimit;
	
	var _eachOf = __webpack_require__(109);
	
	var _eachOf2 = _interopRequireDefault(_eachOf);
	
	var _parallel = __webpack_require__(113);
	
	var _parallel2 = _interopRequireDefault(_parallel);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Run the `tasks` collection of functions in parallel, without waiting until
	 * the previous function has completed. If any of the functions pass an error to
	 * its callback, the main `callback` is immediately called with the value of the
	 * error. Once the `tasks` have completed, the results are passed to the final
	 * `callback` as an array.
	 *
	 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
	 * parallel execution of code.  If your tasks do not use any timers or perform
	 * any I/O, they will actually be executed in series.  Any synchronous setup
	 * sections for each task will happen one after the other.  JavaScript remains
	 * single-threaded.
	 *
	 * It is also possible to use an object instead of an array. Each property will
	 * be run as a function and the results will be passed to the final `callback`
	 * as an object instead of an array. This can be a more readable way of handling
	 * results from {@link async.parallel}.
	 *
	 * @name parallel
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array|Iterable|Object} tasks - A collection containing functions to run.
	 * Each function is passed a `callback(err, result)` which it must call on
	 * completion with an error `err` (which can be `null`) and an optional `result`
	 * value.
	 * @param {Function} [callback] - An optional callback to run once all the
	 * functions have completed successfully. This function gets a results array
	 * (or object) containing all the result arguments passed to the task callbacks.
	 * Invoked with (err, results).
	 * @example
	 * async.parallel([
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'one');
	 *         }, 200);
	 *     },
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'two');
	 *         }, 100);
	 *     }
	 * ],
	 * // optional callback
	 * function(err, results) {
	 *     // the results array will equal ['one','two'] even though
	 *     // the second function had a shorter timeout.
	 * });
	 *
	 * // an example using an object instead of an array
	 * async.parallel({
	 *     one: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 1);
	 *         }, 200);
	 *     },
	 *     two: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 2);
	 *         }, 100);
	 *     }
	 * }, function(err, results) {
	 *     // results is now equals to: {one: 1, two: 2}
	 * });
	 */
	function parallelLimit(tasks, callback) {
	  (0, _parallel2.default)(_eachOf2.default, tasks, callback);
	}
	module.exports = exports['default'];

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	var root = __webpack_require__(117);
	
	/** Built-in value references. */
	var Symbol = root.Symbol;
	
	module.exports = Symbol;


/***/ }),
/* 116 */
/***/ (function(module, exports) {

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	module.exports = freeGlobal;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(116);
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	module.exports = root;


/***/ }),
/* 118 */
/***/ (function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	module.exports = isLength;


/***/ }),
/* 119 */
/***/ (function(module, exports) {

	"use strict";
	
	/**
	 * Creates a new CommandResult instance
	 * @class
	 * @param {object} result CommandResult object
	 * @param {Connection} connection A connection instance associated with this result
	 * @return {CommandResult} A cursor instance
	 */
	var CommandResult = function(result, connection, message) {
	  this.result = result;
	  this.connection = connection;
	  this.message = message;
	}
	
	/**
	 * Convert CommandResult to JSON
	 * @method
	 * @return {object}
	 */
	CommandResult.prototype.toJSON = function() {
	  return this.result;
	}
	
	/**
	 * Convert CommandResult to String representation
	 * @method
	 * @return {string}
	 */
	CommandResult.prototype.toString = function() {
	  return JSON.stringify(this.toJSON());
	}
	
	module.exports = CommandResult;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var inherits = __webpack_require__(1).inherits
	  , EventEmitter = __webpack_require__(6).EventEmitter
	  , net = __webpack_require__(276)
	  , tls = __webpack_require__(280)
	  , crypto = __webpack_require__(48)
	  , f = __webpack_require__(1).format
	  , debugOptions = __webpack_require__(11).debugOptions
	  , Response = __webpack_require__(9).Response
	  , MongoError = __webpack_require__(7)
	  , Logger = __webpack_require__(19);
	
	var _id = 0;
	var debugFields = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay'
	  , 'connectionTimeout', 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'crl', 'cert'
	  , 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'checkServerIdentity'];
	var connectionAccounting = false;
	var connections = {};
	
	/**
	 * Creates a new Connection instance
	 * @class
	 * @param {string} options.host The server host
	 * @param {number} options.port The server port
	 * @param {number} [options.family=4] Version of IP stack. Defaults to 4.
	 * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled
	 * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled
	 * @param {boolean} [options.noDelay=true] TCP Connection no delay
	 * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting
	 * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting
	 * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed
	 * @param {boolean} [options.ssl=false] Use SSL for connection
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {Buffer} [options.ca] SSL Certificate store binary buffer
	 * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer
	 * @param {Buffer} [options.cert] SSL Certificate binary buffer
	 * @param {Buffer} [options.key] SSL Key file binary buffer
	 * @param {string} [options.passphrase] SSL Certificate pass phrase
	 * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates
	 * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
	 * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
	 * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
	 * @fires Connection#connect
	 * @fires Connection#close
	 * @fires Connection#error
	 * @fires Connection#timeout
	 * @fires Connection#parseError
	 * @return {Connection} A cursor instance
	 */
	var Connection = function(messageHandler, options) {
	  // Add event listener
	  EventEmitter.call(this);
	  // Set empty if no options passed
	  this.options = options || {};
	  // Identification information
	  this.id = _id++;
	  // Logger instance
	  this.logger = Logger('Connection', options);
	  // No bson parser passed in
	  if(!options.bson) throw new Error("must pass in valid bson parser");
	  // Get bson parser
	  this.bson = options.bson;
	  // Grouping tag used for debugging purposes
	  this.tag = options.tag;
	  // Message handler
	  this.messageHandler = messageHandler;
	
	  // Max BSON message size
	  this.maxBsonMessageSize = options.maxBsonMessageSize || (1024 * 1024 * 16 * 4);
	  // Debug information
	  if(this.logger.isDebug()) this.logger.debug(f('creating connection %s with options [%s]', this.id, JSON.stringify(debugOptions(debugFields, options))));
	
	  // Default options
	  this.port = options.port || 27017;
	  this.host = options.host || 'localhost';
	  this.family = typeof options.family == 'number' ? options.family : 4;
	  this.keepAlive = typeof options.keepAlive == 'boolean' ? options.keepAlive : true;
	  this.keepAliveInitialDelay = typeof options.keepAliveInitialDelay == 'number' 
	    ? options.keepAliveInitialDelay : 300000;
	  this.noDelay = typeof options.noDelay == 'boolean' ? options.noDelay : true;
	  this.connectionTimeout = typeof options.connectionTimeout == 'number'
	    ? options.connectionTimeout : 30000;
	  this.socketTimeout = typeof options.socketTimeout == 'number'
	    ? options.socketTimeout : 360000;
	
	  // Is the keepAliveInitialDelay > socketTimeout set it to half of socketTimeout
	  if(this.keepAliveInitialDelay > this.socketTimeout) {
	    this.keepAliveInitialDelay = Math.round(this.socketTimeout/2);
	  }
	
	  // If connection was destroyed
	  this.destroyed = false;
	
	  // Check if we have a domain socket
	  this.domainSocket = this.host.indexOf('\/') != -1;
	
	  // Serialize commands using function
	  this.singleBufferSerializtion = typeof options.singleBufferSerializtion == 'boolean' ? options.singleBufferSerializtion : true;
	  this.serializationFunction = this.singleBufferSerializtion ? 'toBinUnified' : 'toBin';
	
	  // SSL options
	  this.ca = options.ca || null;
	  this.crl = options.crl || null;
	  this.cert = options.cert || null;
	  this.key = options.key || null;
	  this.passphrase = options.passphrase || null;
	  this.ssl = typeof options.ssl == 'boolean' ? options.ssl : false;
	  this.rejectUnauthorized = typeof options.rejectUnauthorized == 'boolean' ? options.rejectUnauthorized : true;
	  this.checkServerIdentity = typeof options.checkServerIdentity == 'boolean'
	    || typeof options.checkServerIdentity == 'function' ? options.checkServerIdentity : true;
	
	  // If ssl not enabled
	  if(!this.ssl) this.rejectUnauthorized = false;
	
	  // Response options
	  this.responseOptions = {
	    promoteLongs: typeof options.promoteLongs == 'boolean' ?  options.promoteLongs : true,
	    promoteValues: typeof options.promoteValues == 'boolean' ? options.promoteValues : true,
	    promoteBuffers: typeof options.promoteBuffers == 'boolean' ? options.promoteBuffers: false
	  }
	
	  // Flushing
	  this.flushing = false;
	  this.queue = [];
	
	  // Internal state
	  this.connection = null;
	  this.writeStream = null;
	
	  // Create hash method
	  var hash = crypto.createHash('sha1');
	  hash.update(f('%s:%s', this.host, this.port));
	
	  // Create a hash name
	  this.hashedName = hash.digest('hex');
	
	  // All operations in flight on the connection
	  this.workItems = [];
	}
	
	inherits(Connection, EventEmitter);
	
	Connection.prototype.setSocketTimeout = function(value) {
	  if(this.connection) {
	    this.connection.setTimeout(value);
	  }
	}
	
	Connection.prototype.resetSocketTimeout = function() {
	  if(this.connection) {
	    this.connection.setTimeout(this.socketTimeout);
	  }
	}
	
	Connection.enableConnectionAccounting = function() {
	  connectionAccounting = true;
	  connections = {};
	}
	
	Connection.disableConnectionAccounting = function() {
	  connectionAccounting = false;
	}
	
	Connection.connections = function() {
	  return connections;
	}
	
	function deleteConnection(id) {
	  // console.log("=== deleted connection " + id + " :: " + (connections[id] ? connections[id].port : ''))
	  delete connections[id];
	}
	
	function addConnection(id, connection) {
	  // console.log("=== added connection " + id + " :: " + connection.port)
	  connections[id] = connection;
	}
	
	//
	// Connection handlers
	var errorHandler = function(self) {
	  return function(err) {
	    if(connectionAccounting) deleteConnection(self.id);
	    // Debug information
	    if(self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] errored out with [%s]', self.id, self.host, self.port, JSON.stringify(err)));
	    // Emit the error
	    if(self.listeners('error').length > 0) self.emit("error", MongoError.create(err), self);
	  }
	}
	
	var timeoutHandler = function(self) {
	  return function() {
	    if(connectionAccounting) deleteConnection(self.id);
	    // Debug information
	    if(self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] timed out', self.id, self.host, self.port));
	    // Emit timeout error
	    self.emit("timeout"
	      , MongoError.create(f("connection %s to %s:%s timed out", self.id, self.host, self.port))
	      , self);
	  }
	}
	
	var closeHandler = function(self) {
	  return function(hadError) {
	    if(connectionAccounting) deleteConnection(self.id);
	    // Debug information
	    if(self.logger.isDebug()) self.logger.debug(f('connection %s with for [%s:%s] closed', self.id, self.host, self.port));
	
	    // Emit close event
	    if(!hadError) {
	      self.emit("close"
	        , MongoError.create(f("connection %s to %s:%s closed", self.id, self.host, self.port))
	        , self);
	    }
	  }
	}
	
	var dataHandler = function(self) {
	  return function(data) {
	    // Parse until we are done with the data
	    while(data.length > 0) {
	      // If we still have bytes to read on the current message
	      if(self.bytesRead > 0 && self.sizeOfMessage > 0) {
	        // Calculate the amount of remaining bytes
	        var remainingBytesToRead = self.sizeOfMessage - self.bytesRead;
	        // Check if the current chunk contains the rest of the message
	        if(remainingBytesToRead > data.length) {
	          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)
	          data.copy(self.buffer, self.bytesRead);
	          // Adjust the number of bytes read so it point to the correct index in the buffer
	          self.bytesRead = self.bytesRead + data.length;
	
	          // Reset state of buffer
	          data = new Buffer(0);
	        } else {
	          // Copy the missing part of the data into our current buffer
	          data.copy(self.buffer, self.bytesRead, 0, remainingBytesToRead);
	          // Slice the overflow into a new buffer that we will then re-parse
	          data = data.slice(remainingBytesToRead);
	
	          // Emit current complete message
	          try {
	            var emitBuffer = self.buffer;
	            // Reset state of buffer
	            self.buffer = null;
	            self.sizeOfMessage = 0;
	            self.bytesRead = 0;
	            self.stubBuffer = null;
	            // Emit the buffer
	            self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);
	          } catch(err) {
	            var errorObject = {err:"socketHandler", trace:err, bin:self.buffer, parseState:{
	              sizeOfMessage:self.sizeOfMessage,
	              bytesRead:self.bytesRead,
	              stubBuffer:self.stubBuffer}};
	            // We got a parse Error fire it off then keep going
	            self.emit("parseError", errorObject, self);
	          }
	        }
	      } else {
	        // Stub buffer is kept in case we don't get enough bytes to determine the
	        // size of the message (< 4 bytes)
	        if(self.stubBuffer != null && self.stubBuffer.length > 0) {
	          // If we have enough bytes to determine the message size let's do it
	          if(self.stubBuffer.length + data.length > 4) {
	            // Prepad the data
	            var newData = new Buffer(self.stubBuffer.length + data.length);
	            self.stubBuffer.copy(newData, 0);
	            data.copy(newData, self.stubBuffer.length);
	            // Reassign for parsing
	            data = newData;
	
	            // Reset state of buffer
	            self.buffer = null;
	            self.sizeOfMessage = 0;
	            self.bytesRead = 0;
	            self.stubBuffer = null;
	
	          } else {
	
	            // Add the the bytes to the stub buffer
	            var newStubBuffer = new Buffer(self.stubBuffer.length + data.length);
	            // Copy existing stub buffer
	            self.stubBuffer.copy(newStubBuffer, 0);
	            // Copy missing part of the data
	            data.copy(newStubBuffer, self.stubBuffer.length);
	            // Exit parsing loop
	            data = new Buffer(0);
	          }
	        } else {
	          if(data.length > 4) {
	            // Retrieve the message size
	            // var sizeOfMessage = data.readUInt32LE(0);
	            var sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;
	            // If we have a negative sizeOfMessage emit error and return
	            if(sizeOfMessage < 0 || sizeOfMessage > self.maxBsonMessageSize) {
	              errorObject = {err:"socketHandler", trace:'', bin:self.buffer, parseState:{
	                sizeOfMessage: sizeOfMessage,
	                bytesRead: self.bytesRead,
	                stubBuffer: self.stubBuffer}};
	              // We got a parse Error fire it off then keep going
	              self.emit("parseError", errorObject, self);
	              return;
	            }
	
	            // Ensure that the size of message is larger than 0 and less than the max allowed
	            if(sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage > data.length) {
	              self.buffer = new Buffer(sizeOfMessage);
	              // Copy all the data into the buffer
	              data.copy(self.buffer, 0);
	              // Update bytes read
	              self.bytesRead = data.length;
	              // Update sizeOfMessage
	              self.sizeOfMessage = sizeOfMessage;
	              // Ensure stub buffer is null
	              self.stubBuffer = null;
	              // Exit parsing loop
	              data = new Buffer(0);
	
	            } else if(sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage == data.length) {
	              try {
	                emitBuffer = data;
	                // Reset state of buffer
	                self.buffer = null;
	                self.sizeOfMessage = 0;
	                self.bytesRead = 0;
	                self.stubBuffer = null;
	                // Exit parsing loop
	                data = new Buffer(0);
	                // Emit the message
	                self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);
	              } catch (err) {
	                self.emit("parseError", err, self);
	              }
	            } else if(sizeOfMessage <= 4 || sizeOfMessage > self.maxBsonMessageSize) {
	              errorObject = {err:"socketHandler", trace:null, bin:data, parseState:{
	                sizeOfMessage:sizeOfMessage,
	                bytesRead:0,
	                buffer:null,
	                stubBuffer:null}};
	              // We got a parse Error fire it off then keep going
	              self.emit("parseError", errorObject, self);
	
	              // Clear out the state of the parser
	              self.buffer = null;
	              self.sizeOfMessage = 0;
	              self.bytesRead = 0;
	              self.stubBuffer = null;
	              // Exit parsing loop
	              data = new Buffer(0);
	            } else {
	              emitBuffer = data.slice(0, sizeOfMessage);
	              // Reset state of buffer
	              self.buffer = null;
	              self.sizeOfMessage = 0;
	              self.bytesRead = 0;
	              self.stubBuffer = null;
	              // Copy rest of message
	              data = data.slice(sizeOfMessage);
	              // Emit the message
	              self.messageHandler(new Response(self.bson, emitBuffer, self.responseOptions), self);
	            }
	          } else {
	            // Create a buffer that contains the space for the non-complete message
	            self.stubBuffer = new Buffer(data.length)
	            // Copy the data to the stub buffer
	            data.copy(self.stubBuffer, 0);
	            // Exit parsing loop
	            data = new Buffer(0);
	          }
	        }
	      }
	    }
	  }
	}
	
	// List of socket level valid ssl options
	var legalSslSocketOptions = ['pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers'
	  , 'NPNProtocols', 'ALPNProtocols', 'servername'
	  , 'secureProtocol', 'secureContext', 'session'
	  , 'minDHSize'];
	
	function merge(options1, options2) {
	  // Merge in any allowed ssl options
	  for(var name in options2) {
	    if(options2[name] != null && legalSslSocketOptions.indexOf(name) != -1) {
	      options1[name] = options2[name];
	    }
	  }
	}
	
	/**
	 * Connect
	 * @method
	 */
	Connection.prototype.connect = function(_options) {
	  var self = this;
	  _options = _options || {};
	  // Set the connections
	  if(connectionAccounting) addConnection(this.id, this);
	  // Check if we are overriding the promoteLongs
	  if(typeof _options.promoteLongs == 'boolean') {
	    self.responseOptions.promoteLongs = _options.promoteLongs;
	    self.responseOptions.promoteValues = _options.promoteValues;
	    self.responseOptions.promoteBuffers = _options.promoteBuffers;
	  }
	
	  // Create new connection instance
	  var connection_options = self.domainSocket
	    ? {path: self.host}
	    : {port: self.port, host: self.host, family: self.family};
	  self.connection = net.createConnection(connection_options);
	
	  // Set the options for the connection
	  self.connection.setKeepAlive(self.keepAlive, self.keepAliveInitialDelay);
	  self.connection.setTimeout(self.connectionTimeout);
	  self.connection.setNoDelay(self.noDelay);
	
	  // If we have ssl enabled
	  if(self.ssl) {
	    var sslOptions = {
	        socket: self.connection
	      , rejectUnauthorized: self.rejectUnauthorized
	    }
	
	    // Merge in options
	    merge(sslOptions, this.options);
	    merge(sslOptions, _options);
	
	    // Set options for ssl
	    if(self.ca) sslOptions.ca = self.ca;
	    if(self.crl) sslOptions.crl = self.crl;
	    if(self.cert) sslOptions.cert = self.cert;
	    if(self.key) sslOptions.key = self.key;
	    if(self.passphrase) sslOptions.passphrase = self.passphrase;
	
	    // Override checkServerIdentity behavior
	    if(self.checkServerIdentity == false) {
	      // Skip the identiy check by retuning undefined as per node documents
	      // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback
	      sslOptions.checkServerIdentity = function() {
	        return undefined;
	      }
	    } else if(typeof self.checkServerIdentity == 'function') {
	      sslOptions.checkServerIdentity = self.checkServerIdentity;
	    }
	
	    // Set default sni servername to be the same as host
	    if(sslOptions.servername == null) {
	      sslOptions.servername = self.host;
	    }
	
	    // Attempt SSL connection
	    self.connection = tls.connect(self.port, self.host, sslOptions, function() {
	      // Error on auth or skip
	      if(self.connection.authorizationError && self.rejectUnauthorized) {
	        return self.emit("error", self.connection.authorizationError, self, {ssl:true});
	      }
	
	      // Set socket timeout instead of connection timeout
	      self.connection.setTimeout(self.socketTimeout);
	      // We are done emit connect
	      self.emit('connect', self);
	    });
	    self.connection.setTimeout(self.connectionTimeout);
	  } else {
	    self.connection.on('connect', function() {
	      // Set socket timeout instead of connection timeout
	      self.connection.setTimeout(self.socketTimeout);
	      // Emit connect event
	      self.emit('connect', self);
	    });
	  }
	
	  // Add handlers for events
	  self.connection.once('error', errorHandler(self));
	  self.connection.once('timeout', timeoutHandler(self));
	  self.connection.once('close', closeHandler(self));
	  self.connection.on('data', dataHandler(self));
	}
	
	/**
	 * Unref this connection
	 * @method
	 * @return {boolean}
	 */
	Connection.prototype.unref = function() {
	  if (this.connection) this.connection.unref();
	  else {
	    var self = this;
	    this.once('connect', function() {
	      self.connection.unref();
	    });
	  }
	}
	
	/**
	 * Destroy connection
	 * @method
	 */
	Connection.prototype.destroy = function() {
	  // Set the connections
	  if(connectionAccounting) deleteConnection(this.id);
	  if(this.connection) {
	    // Catch posssible exception thrown by node 0.10.x
	    try { this.connection.end(); } catch (err) {}
	    // Destroy connection
	    this.connection.destroy();
	  }
	
	  this.destroyed = true;
	}
	
	/**
	 * Write to connection
	 * @method
	 * @param {Command} command Command to write out need to implement toBin and toBinUnified
	 */
	Connection.prototype.write = function(buffer) {
	  var i;
	  // Debug Log
	  if(this.logger.isDebug()) {
	    if(!Array.isArray(buffer)) {
	      this.logger.debug(f('writing buffer [%s] to %s:%s', buffer.toString('hex'), this.host, this.port));
	    } else {
	      for(i = 0; i < buffer.length; i++)
	        this.logger.debug(f('writing buffer [%s] to %s:%s', buffer[i].toString('hex'), this.host, this.port));
	    }
	  }
	
	  // Double check that the connection is not destroyed
	  if(this.connection.destroyed === false) {
	    // Write out the command
	    if(!Array.isArray(buffer)) {
	      this.connection.write(buffer, 'binary');
	      return true;
	    }
	
	    // Iterate over all buffers and write them in order to the socket
	    for(i = 0; i < buffer.length; i++) this.connection.write(buffer[i], 'binary');
	    return true;
	  } 
	
	  // Connection is destroyed return write failed
	  return false;
	}
	
	/**
	 * Return id of connection as a string
	 * @method
	 * @return {string}
	 */
	Connection.prototype.toString = function() {
	  return "" + this.id;
	}
	
	/**
	 * Return json object of connection
	 * @method
	 * @return {object}
	 */
	Connection.prototype.toJSON = function() {
	  return {id: this.id, host: this.host, port: this.port};
	}
	
	/**
	 * Is the connection connected
	 * @method
	 * @return {boolean}
	 */
	Connection.prototype.isConnected = function() {
	  if(this.destroyed) return false;
	  return !this.connection.destroyed && this.connection.writable;
	}
	
	/**
	 * A server connect event, used to verify that the connection is up and running
	 *
	 * @event Connection#connect
	 * @type {Connection}
	 */
	
	/**
	 * The server connection closed, all pool connections closed
	 *
	 * @event Connection#close
	 * @type {Connection}
	 */
	
	/**
	 * The server connection caused an error, all pool connections closed
	 *
	 * @event Connection#error
	 * @type {Connection}
	 */
	
	/**
	 * The server connection timed out, all pool connections closed
	 *
	 * @event Connection#timeout
	 * @type {Connection}
	 */
	
	/**
	 * The driver experienced an invalid message, all pool connections closed
	 *
	 * @event Connection#parseError
	 * @type {Connection}
	 */
	
	module.exports = Connection;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var toError = __webpack_require__(2).toError,
	  Define = __webpack_require__(13),
	  shallowClone = __webpack_require__(2).shallowClone,
	  assign = __webpack_require__(2).assign,
	  authenticate = __webpack_require__(79);
	
	/**
	 * @fileOverview The **Admin** class is an internal class that allows convenient access to
	 * the admin functionality and commands for MongoDB.
	 *
	 * **ADMIN Cannot directly be instantiated**
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Use the admin database for the operation
	 *   var adminDb = db.admin();
	 *
	 *   // List all the available databases
	 *   adminDb.listDatabases(function(err, dbs) {
	 *     test.equal(null, err);
	 *     test.ok(dbs.databases.length > 0);
	 *     db.close();
	 *   });
	 * });
	 */
	
	/**
	 * Create a new Admin instance (INTERNAL TYPE, do not instantiate directly)
	 * @class
	 * @return {Admin} a collection instance.
	 */
	var Admin = function(db, topology, promiseLibrary) {
	  if(!(this instanceof Admin)) return new Admin(db, topology);
	
	  // Internal state
	  this.s = {
	      db: db
	    , topology: topology
	    , promiseLibrary: promiseLibrary
	  }
	}
	
	var define = Admin.define = new Define('Admin', Admin, false);
	
	/**
	 * The callback format for results
	 * @callback Admin~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object} result The result object if the command was executed successfully.
	 */
	
	/**
	 * Execute a command
	 * @method
	 * @param {object} command The command hash
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {number} [options.maxTimeMS=null] Number of milliseconds to wait before aborting the query.
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.command = function(command, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() : {};
	
	  // Execute using callback
	  if(typeof callback == 'function') return this.s.db.executeDbAdminCommand(command, options, function(err, doc) {
	    return callback != null ? callback(err, doc) : null;
	  });
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.executeDbAdminCommand(command, options, function(err, doc) {
	      if(err) return reject(err);
	      resolve(doc);
	    });
	  });
	}
	
	define.classMethod('command', {callback: true, promise:true});
	
	/**
	 * Retrieve the server information for the current
	 * instance of the db client
	 *
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.buildInfo = function(callback) {
	  var self = this;
	  // Execute using callback
	  if(typeof callback == 'function') return this.serverInfo(callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.serverInfo(function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('buildInfo', {callback: true, promise:true});
	
	/**
	 * Retrieve the server information for the current
	 * instance of the db client
	 *
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.serverInfo = function(callback) {
	  var self = this;
	  // Execute using callback
	  if(typeof callback == 'function') return this.s.db.executeDbAdminCommand({buildinfo:1}, function(err, doc) {
	    if(err != null) return callback(err, null);
	    callback(null, doc);
	  });
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.executeDbAdminCommand({buildinfo:1}, function(err, doc) {
	      if(err) return reject(err);
	      resolve(doc);
	    });
	  });
	}
	
	define.classMethod('serverInfo', {callback: true, promise:true});
	
	/**
	 * Retrieve this db's server status.
	 *
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.serverStatus = function(callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return serverStatus(self, callback)
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    serverStatus(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var serverStatus = function(self, callback) {
	  self.s.db.executeDbAdminCommand({serverStatus: 1}, function(err, doc) {
	    if(err == null && doc.ok === 1) {
	      callback(null, doc);
	    } else {
	      if(err) return callback(err, false);
	      return callback(toError(doc), false);
	    }
	  });
	}
	
	define.classMethod('serverStatus', {callback: true, promise:true});
	
	/**
	 * Retrieve the current profiling Level for MongoDB
	 *
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.profilingLevel = function(callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return profilingLevel(self, callback)
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    profilingLevel(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var profilingLevel = function(self, callback) {
	  self.s.db.executeDbAdminCommand({profile:-1}, function(err, doc) {
	    if(err == null && doc.ok === 1) {
	      var was = doc.was;
	      if(was == 0) return callback(null, "off");
	      if(was == 1) return callback(null, "slow_only");
	      if(was == 2) return callback(null, "all");
	        return callback(new Error("Error: illegal profiling level value " + was), null);
	    } else {
	      err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
	    }
	  });
	}
	
	define.classMethod('profilingLevel', {callback: true, promise:true});
	
	/**
	 * Ping the MongoDB server and retrieve results
	 *
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.ping = function(options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	
	  // Execute using callback
	  if(typeof callback == 'function') return this.s.db.executeDbAdminCommand({ping: 1}, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.executeDbAdminCommand({ping: 1}, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('ping', {callback: true, promise:true});
	
	/**
	 * Authenticate a user against the server.
	 * @method
	 * @param {string} username The username.
	 * @param {string} [password] The password.
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated This method will no longer be available in the next major release 3.x as MongoDB 3.6 will only allow auth against users in the admin db and will no longer allow multiple credentials on a socket. Please authenticate using MongoClient.connect with auth credentials.
	 */
	Admin.prototype.authenticate = function(username, password, options, callback) {
	  console.warn("Admin.prototype.authenticate method will no longer be available in the next major release 3.x as MongoDB 3.6 will only allow auth against users in the admin db and will no longer allow multiple credentials on a socket. Please authenticate using MongoClient.connect with auth credentials.");
	  var finalArguments = [this.s.db];
	  if(typeof username == 'string') finalArguments.push(username);
	  if(typeof password == 'string') finalArguments.push(password);
	  if(typeof options == 'function') { 
	    finalArguments.push({ authdb: 'admin' });
	    finalArguments.push(options);
	  } else {
	    finalArguments.push(assign({}, options, { authdb: 'admin' }));
	  }
	
	  if(typeof callback == 'function') finalArguments.push(callback);
	  // Excute authenticate method
	  return authenticate.apply(this.s.db, finalArguments);
	}
	
	define.classMethod('authenticate', {callback: true, promise:true});
	
	/**
	 * Logout user from server, fire off on all connections and remove all auth info
	 * @method
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.logout = function(callback) {
	  var self = this;
	  // Execute using callback
	  if(typeof callback == 'function') return this.s.db.logout({dbName: 'admin'}, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.logout({dbName: 'admin'}, function(err) {
	      if(err) return reject(err);
	      resolve(true);
	    });
	  });
	}
	
	define.classMethod('logout', {callback: true, promise:true});
	
	// Get write concern
	var writeConcern = function(options, db) {
	  options = shallowClone(options);
	
	  // If options already contain write concerns return it
	  if(options.w || options.wtimeout || options.j || options.fsync) {
	    return options;
	  }
	
	  // Set db write concern if available
	  if(db.writeConcern) {
	    if(options.w) options.w = db.writeConcern.w;
	    if(options.wtimeout) options.wtimeout = db.writeConcern.wtimeout;
	    if(options.j) options.j = db.writeConcern.j;
	    if(options.fsync) options.fsync = db.writeConcern.fsync;
	  }
	
	  // Return modified options
	  return options;
	}
	
	/**
	 * Add a user to the database.
	 * @method
	 * @param {string} username The username.
	 * @param {string} password The password.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.fsync=false] Specify a file sync write concern.
	 * @param {object} [options.customData=null] Custom data associated with the user (only Mongodb 2.6 or higher)
	 * @param {object[]} [options.roles=null] Roles associated with the created user (only Mongodb 2.6 or higher)
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.addUser = function(username, password, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() : {};
	  options = options || {};
	  // Get the options
	  options = writeConcern(options, self.s.db)
	  // Set the db name to admin
	  options.dbName = 'admin';
	
	  // Execute using callback
	  if(typeof callback == 'function')
	    return self.s.db.addUser(username, password, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.addUser(username, password, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('addUser', {callback: true, promise:true});
	
	/**
	 * Remove a user from a database
	 * @method
	 * @param {string} username The username.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.fsync=false] Specify a file sync write concern.
	 * @param {Admin~resultCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.removeUser = function(username, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() : {};
	  options = options || {};
	  // Get the options
	  options = writeConcern(options, self.s.db)
	  // Set the db name
	  options.dbName = 'admin';
	
	  // Execute using callback
	  if(typeof callback == 'function')
	    return self.s.db.removeUser(username, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.removeUser(username, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('removeUser', {callback: true, promise:true});
	
	/**
	 * Set the current profiling level of MongoDB
	 *
	 * @param {string} level The new profiling level (off, slow_only, all).
	 * @param {Admin~resultCallback} [callback] The command result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.setProfilingLevel = function(level, callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return setProfilingLevel(self, level, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    setProfilingLevel(self, level, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var setProfilingLevel = function(self, level, callback) {
	  var command = {};
	  var profile = 0;
	
	  if(level == "off") {
	    profile = 0;
	  } else if(level == "slow_only") {
	    profile = 1;
	  } else if(level == "all") {
	    profile = 2;
	  } else {
	    return callback(new Error("Error: illegal profiling level value " + level));
	  }
	
	  // Set up the profile number
	  command['profile'] = profile;
	
	  self.s.db.executeDbAdminCommand(command, function(err, doc) {
	    if(err == null && doc.ok === 1)
	      return callback(null, level);
	    return err != null ? callback(err, null) : callback(new Error("Error with profile command"), null);
	  });
	}
	
	define.classMethod('setProfilingLevel', {callback: true, promise:true});
	
	/**
	 * Retrive the current profiling information for MongoDB
	 *
	 * @param {Admin~resultCallback} [callback] The command result callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Query the system.profile collection directly.
	 */
	Admin.prototype.profilingInfo = function(callback) {
	  var self = this;
	
	  // Execute using callback
	  if(typeof callback == 'function') return profilingInfo(self, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    profilingInfo(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var profilingInfo = function(self, callback) {
	  try {
	    self.s.topology.cursor("admin.system.profile", { find: 'system.profile', query: {}}, {}).toArray(callback);
	  } catch (err) {
	    return callback(err, null);
	  }
	}
	
	define.classMethod('profilingLevel', {callback: true, promise:true});
	
	/**
	 * Validate an existing collection
	 *
	 * @param {string} collectionName The name of the collection to validate.
	 * @param {object} [options=null] Optional settings.
	 * @param {Admin~resultCallback} [callback] The command result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.validateCollection = function(collectionName, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() : {};
	  options = options || {};
	
	  // Execute using callback
	  if(typeof callback == 'function')
	    return validateCollection(self, collectionName, options, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    validateCollection(self, collectionName, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var validateCollection = function(self, collectionName, options, callback) {
	  var command = {validate: collectionName};
	  var keys = Object.keys(options);
	
	  // Decorate command with extra options
	  for(var i = 0; i < keys.length; i++) {
	    if(options.hasOwnProperty(keys[i])) {
	      command[keys[i]] = options[keys[i]];
	    }
	  }
	
	  self.s.db.command(command, function(err, doc) {
	    if(err != null) return callback(err, null);
	
	    if(doc.ok === 0)
	      return callback(new Error("Error with validate command"), null);
	    if(doc.result != null && doc.result.constructor != String)
	      return callback(new Error("Error with validation data"), null);
	    if(doc.result != null && doc.result.match(/exception|corrupt/) != null)
	      return callback(new Error("Error: invalid collection " + collectionName), null);
	    if(doc.valid != null && !doc.valid)
	      return callback(new Error("Error: invalid collection " + collectionName), null);
	
	    return callback(null, doc);
	  });
	}
	
	define.classMethod('validateCollection', {callback: true, promise:true});
	
	/**
	 * List the available databases
	 *
	 * @param {Admin~resultCallback} [callback] The command result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.listDatabases = function(callback) {
	  var self = this;
	  // Execute using callback
	  if(typeof callback == 'function') return self.s.db.executeDbAdminCommand({listDatabases:1}, {}, callback);
	
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    self.s.db.executeDbAdminCommand({listDatabases:1}, {}, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	}
	
	define.classMethod('listDatabases', {callback: true, promise:true});
	
	/**
	 * Get ReplicaSet status
	 *
	 * @param {Admin~resultCallback} [callback] The command result callback.
	 * @return {Promise} returns Promise if no callback passed
	 */
	Admin.prototype.replSetGetStatus = function(callback) {
	  var self = this;
	  // Execute using callback
	  if(typeof callback == 'function') return replSetGetStatus(self, callback);
	  // Return a Promise
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    replSetGetStatus(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    });
	  });
	};
	
	var replSetGetStatus = function(self, callback) {
	  self.s.db.executeDbAdminCommand({replSetGetStatus:1}, function(err, doc) {
	    if(err == null && doc.ok === 1)
	      return callback(null, doc);
	    if(err) return callback(err, false);
	    callback(toError(doc), false);
	  });
	}
	
	define.classMethod('replSetGetStatus', {callback: true, promise:true});
	
	module.exports = Admin;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var Long = __webpack_require__(3).BSON.Long,
	  Timestamp = __webpack_require__(3).BSON.Timestamp;
	
	// Error codes
	var UNKNOWN_ERROR = 8;
	var INVALID_BSON_ERROR = 22;
	var WRITE_CONCERN_ERROR = 64;
	var MULTIPLE_ERROR = 65;
	
	// Insert types
	var INSERT = 1;
	var UPDATE = 2;
	var REMOVE = 3
	
	
	// Get write concern
	var writeConcern = function(target, col, options) {
	  var writeConcern = {};
	
	  // Collection level write concern
	  if(col.writeConcern && col.writeConcern.w != null) writeConcern.w = col.writeConcern.w;
	  if(col.writeConcern && col.writeConcern.j != null) writeConcern.j = col.writeConcern.j;
	  if(col.writeConcern && col.writeConcern.fsync != null) writeConcern.fsync = col.writeConcern.fsync;
	  if(col.writeConcern && col.writeConcern.wtimeout != null) writeConcern.wtimeout = col.writeConcern.wtimeout;
	
	  // Options level write concern
	  if(options && options.w != null) writeConcern.w = options.w;
	  if(options && options.wtimeout != null) writeConcern.wtimeout = options.wtimeout;
	  if(options && options.j != null) writeConcern.j = options.j;
	  if(options && options.fsync != null) writeConcern.fsync = options.fsync;
	
	  // Return write concern
	  return writeConcern;
	}
	
	/**
	 * Helper function to define properties
	 * @ignore
	 */
	var defineReadOnlyProperty = function(self, name, value) {
	  Object.defineProperty(self, name, {
	      enumerable: true
	    , get: function() {
	      return value;
	    }
	  });
	}
	
	/**
	 * Keeps the state of a unordered batch so we can rewrite the results
	 * correctly after command execution
	 * @ignore
	 */
	var Batch = function(batchType, originalZeroIndex) {
	  this.originalZeroIndex = originalZeroIndex;
	  this.currentIndex = 0;
	  this.originalIndexes = [];
	  this.batchType = batchType;
	  this.operations = [];
	  this.size = 0;
	  this.sizeBytes = 0;
	}
	
	/**
	 * Wraps a legacy operation so we can correctly rewrite it's error
	 * @ignore
	 */
	var LegacyOp = function(batchType, operation, index) {
	  this.batchType = batchType;
	  this.index = index;
	  this.operation = operation;
	}
	
	/**
	 * Create a new BulkWriteResult instance (INTERNAL TYPE, do not instantiate directly)
	 *
	 * @class
	 * @property {boolean} ok Did bulk operation correctly execute
	 * @property {number} nInserted number of inserted documents
	 * @property {number} nUpdated number of documents updated logically
	 * @property {number} nUpserted Number of upserted documents
	 * @property {number} nModified Number of documents updated physically on disk
	 * @property {number} nRemoved Number of removed documents
	 * @return {BulkWriteResult} a BulkWriteResult instance
	 */
	var BulkWriteResult = function(bulkResult) {
	  defineReadOnlyProperty(this, "ok", bulkResult.ok);
	  defineReadOnlyProperty(this, "nInserted", bulkResult.nInserted);
	  defineReadOnlyProperty(this, "nUpserted", bulkResult.nUpserted);
	  defineReadOnlyProperty(this, "nMatched", bulkResult.nMatched);
	  defineReadOnlyProperty(this, "nModified", bulkResult.nModified);
	  defineReadOnlyProperty(this, "nRemoved", bulkResult.nRemoved);
	
	  /**
	   * Return an array of inserted ids
	   *
	   * @return {object[]}
	   */
	  this.getInsertedIds = function() {
	    return bulkResult.insertedIds;
	  }
	
	  /**
	   * Return an array of upserted ids
	   *
	   * @return {object[]}
	   */
	  this.getUpsertedIds = function() {
	    return bulkResult.upserted;
	  }
	
	  /**
	   * Return the upserted id at position x
	   *
	   * @param {number} index the number of the upserted id to return, returns undefined if no result for passed in index
	   * @return {object}
	   */
	  this.getUpsertedIdAt = function(index) {
	    return bulkResult.upserted[index];
	  }
	
	  /**
	   * Return raw internal result
	   *
	   * @return {object}
	   */
	  this.getRawResponse = function() {
	    return bulkResult;
	  }
	
	  /**
	   * Returns true if the bulk operation contains a write error
	   *
	   * @return {boolean}
	   */
	  this.hasWriteErrors = function() {
	    return bulkResult.writeErrors.length > 0;
	  }
	
	  /**
	   * Returns the number of write errors off the bulk operation
	   *
	   * @return {number}
	   */
	  this.getWriteErrorCount = function() {
	    return bulkResult.writeErrors.length;
	  }
	
	  /**
	   * Returns a specific write error object
	   *
	   * @return {WriteError}
	   */
	  this.getWriteErrorAt = function(index) {
	    if(index < bulkResult.writeErrors.length) {
	      return bulkResult.writeErrors[index];
	    }
	    return null;
	  }
	
	  /**
	   * Retrieve all write errors
	   *
	   * @return {object[]}
	   */
	  this.getWriteErrors = function() {
	    return bulkResult.writeErrors;
	  }
	
	  /**
	   * Retrieve lastOp if available
	   *
	   * @return {object}
	   */
	  this.getLastOp = function() {
	    return bulkResult.lastOp;
	  }
	
	  /**
	   * Retrieve the write concern error if any
	   *
	   * @return {WriteConcernError}
	   */
	  this.getWriteConcernError = function() {
	    if(bulkResult.writeConcernErrors.length == 0) {
	      return null;
	    } else if(bulkResult.writeConcernErrors.length == 1) {
	      // Return the error
	      return bulkResult.writeConcernErrors[0];
	    } else {
	
	      // Combine the errors
	      var errmsg = "";
	      for(var i = 0; i < bulkResult.writeConcernErrors.length; i++) {
	        var err = bulkResult.writeConcernErrors[i];
	        errmsg = errmsg + err.errmsg;
	
	        // TODO: Something better
	        if(i == 0) errmsg = errmsg + " and ";
	      }
	
	      return new WriteConcernError({ errmsg : errmsg, code : WRITE_CONCERN_ERROR });
	    }
	  }
	
	  this.toJSON = function() {
	    return bulkResult;
	  }
	
	  this.toString = function() {
	    return "BulkWriteResult(" + this.toJSON(bulkResult) + ")";
	  }
	
	  this.isOk = function() {
	    return bulkResult.ok == 1;
	  }
	}
	
	/**
	 * Create a new WriteConcernError instance (INTERNAL TYPE, do not instantiate directly)
	 *
	 * @class
	 * @property {number} code Write concern error code.
	 * @property {string} errmsg Write concern error message.
	 * @return {WriteConcernError} a WriteConcernError instance
	 */
	var WriteConcernError = function(err) {
	  if(!(this instanceof WriteConcernError)) return new WriteConcernError(err);
	
	  // Define properties
	  defineReadOnlyProperty(this, "code", err.code);
	  defineReadOnlyProperty(this, "errmsg", err.errmsg);
	
	  this.toJSON = function() {
	    return {code: err.code, errmsg: err.errmsg};
	  }
	
	  this.toString = function() {
	    return "WriteConcernError(" + err.errmsg + ")";
	  }
	}
	
	/**
	 * Create a new WriteError instance (INTERNAL TYPE, do not instantiate directly)
	 *
	 * @class
	 * @property {number} code Write concern error code.
	 * @property {number} index Write concern error original bulk operation index.
	 * @property {string} errmsg Write concern error message.
	 * @return {WriteConcernError} a WriteConcernError instance
	 */
	var WriteError = function(err) {
	  if(!(this instanceof WriteError)) return new WriteError(err);
	
	  // Define properties
	  defineReadOnlyProperty(this, "code", err.code);
	  defineReadOnlyProperty(this, "index", err.index);
	  defineReadOnlyProperty(this, "errmsg", err.errmsg);
	
	  //
	  // Define access methods
	  this.getOperation = function() {
	    return err.op;
	  }
	
	  this.toJSON = function() {
	    return {code: err.code, index: err.index, errmsg: err.errmsg, op: err.op};
	  }
	
	  this.toString = function() {
	    return "WriteError(" + JSON.stringify(this.toJSON()) + ")";
	  }
	}
	
	/**
	 * Merges results into shared data structure
	 * @ignore
	 */
	var mergeBatchResults = function(ordered, batch, bulkResult, err, result) {
	  // If we have an error set the result to be the err object
	  if(err) {
	    result = err;
	  } else if(result && result.result) {
	    result = result.result;
	  } else if(result == null) {
	    return;
	  }
	
	  // Do we have a top level error stop processing and return
	  if(result.ok == 0 && bulkResult.ok == 1) {
	    bulkResult.ok = 0;
	
	    var writeError = {
	        index: 0
	      , code: result.code || 0
	      , errmsg: result.message
	      , op: batch.operations[0]
	    };
	
	    bulkResult.writeErrors.push(new WriteError(writeError));
	    return;
	  } else if(result.ok == 0 && bulkResult.ok == 0) {
	    return;
	  }
	
	  // Deal with opTime if available
	  if(result.opTime || result.lastOp) {
	    var opTime = result.lastOp || result.opTime;
	    var lastOpTS = null;
	    var lastOpT = null;
	
	    // We have a time stamp
	    if(opTime && opTime._bsontype == 'Timestamp') {
	      if(bulkResult.lastOp == null) {
	        bulkResult.lastOp = opTime;
	      } else if(opTime.greaterThan(bulkResult.lastOp)) {
	        bulkResult.lastOp = opTime;
	      }
	    } else {
	      // Existing TS
	      if(bulkResult.lastOp) {
	        lastOpTS = typeof bulkResult.lastOp.ts == 'number'
	          ? Long.fromNumber(bulkResult.lastOp.ts) : bulkResult.lastOp.ts;
	        lastOpT = typeof bulkResult.lastOp.t == 'number'
	          ? Long.fromNumber(bulkResult.lastOp.t) : bulkResult.lastOp.t;
	      }
	
	      // Current OpTime TS
	      var opTimeTS = typeof opTime.ts == 'number'
	        ? Long.fromNumber(opTime.ts) : opTime.ts;
	      var opTimeT = typeof opTime.t == 'number'
	        ? Long.fromNumber(opTime.t) : opTime.t;
	
	      // Compare the opTime's
	      if(bulkResult.lastOp == null) {
	        bulkResult.lastOp = opTime;
	      } else if(opTimeTS.greaterThan(lastOpTS)) {
	        bulkResult.lastOp = opTime;
	      } else if(opTimeTS.equals(lastOpTS)) {
	        if(opTimeT.greaterThan(lastOpT)) {
	          bulkResult.lastOp = opTime;
	        }
	      }
	    }
	  }
	
	  // If we have an insert Batch type
	  if(batch.batchType == INSERT && result.n) {
	    bulkResult.nInserted = bulkResult.nInserted + result.n;
	  }
	
	  // If we have an insert Batch type
	  if(batch.batchType == REMOVE && result.n) {
	    bulkResult.nRemoved = bulkResult.nRemoved + result.n;
	  }
	
	  var nUpserted = 0;
	
	  // We have an array of upserted values, we need to rewrite the indexes
	  if(Array.isArray(result.upserted)) {
	    nUpserted = result.upserted.length;
	
	    for(var i = 0; i < result.upserted.length; i++) {
	      bulkResult.upserted.push({
	          index: result.upserted[i].index + batch.originalZeroIndex
	        , _id: result.upserted[i]._id
	      });
	    }
	  } else if(result.upserted) {
	
	    nUpserted = 1;
	
	    bulkResult.upserted.push({
	        index: batch.originalZeroIndex
	      , _id: result.upserted
	    });
	  }
	
	  // If we have an update Batch type
	  if(batch.batchType == UPDATE && result.n) {
	    var nModified = result.nModified;
	    bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
	    bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
	
	    if(typeof nModified == 'number') {
	      bulkResult.nModified = bulkResult.nModified + nModified;
	    } else {
	      bulkResult.nModified = null;
	    }
	  }
	
	  if(Array.isArray(result.writeErrors)) {
	    for(i = 0; i < result.writeErrors.length; i++) {
	
	      writeError = {
	          index: batch.originalZeroIndex + result.writeErrors[i].index
	        , code: result.writeErrors[i].code
	        , errmsg: result.writeErrors[i].errmsg
	        , op: batch.operations[result.writeErrors[i].index]
	      };
	
	      bulkResult.writeErrors.push(new WriteError(writeError));
	    }
	  }
	
	  if(result.writeConcernError) {
	    bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
	  }
	}
	
	//
	// Clone the options
	var cloneOptions = function(options) {
	  var clone = {};
	  var keys = Object.keys(options);
	  for(var i = 0; i < keys.length; i++) {
	    clone[keys[i]] = options[keys[i]];
	  }
	
	  return clone;
	}
	
	// Exports symbols
	exports.BulkWriteResult = BulkWriteResult;
	exports.WriteError = WriteError;
	exports.Batch = Batch;
	exports.LegacyOp = LegacyOp;
	exports.mergeBatchResults = mergeBatchResults;
	exports.cloneOptions = cloneOptions;
	exports.writeConcern = writeConcern;
	exports.INVALID_BSON_ERROR = INVALID_BSON_ERROR;
	exports.WRITE_CONCERN_ERROR = WRITE_CONCERN_ERROR;
	exports.MULTIPLE_ERROR = MULTIPLE_ERROR;
	exports.UNKNOWN_ERROR = UNKNOWN_ERROR;
	exports.INSERT = INSERT;
	exports.UPDATE = UPDATE;
	exports.REMOVE = REMOVE;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var Binary = __webpack_require__(3).BSON.Binary,
	  ObjectID = __webpack_require__(3).BSON.ObjectID;
	
	/**
	 * Class for representing a single chunk in GridFS.
	 *
	 * @class
	 *
	 * @param file {GridStore} The {@link GridStore} object holding this chunk.
	 * @param mongoObject {object} The mongo object representation of this chunk.
	 *
	 * @throws Error when the type of data field for {@link mongoObject} is not
	 *     supported. Currently supported types for data field are instances of
	 *     {@link String}, {@link Array}, {@link Binary} and {@link Binary}
	 *     from the bson module
	 *
	 * @see Chunk#buildMongoObject
	 */
	var Chunk = function(file, mongoObject, writeConcern) {
	  if(!(this instanceof Chunk)) return new Chunk(file, mongoObject);
	
	  this.file = file;
	  var mongoObjectFinal = mongoObject == null ? {} : mongoObject;
	  this.writeConcern = writeConcern || {w:1};
	  this.objectId = mongoObjectFinal._id == null ? new ObjectID() : mongoObjectFinal._id;
	  this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;
	  this.data = new Binary();
	
	  if(typeof mongoObjectFinal.data == "string") {
	    var buffer = new Buffer(mongoObjectFinal.data.length);
	    buffer.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, 'binary');
	    this.data = new Binary(buffer);
	  } else if(Array.isArray(mongoObjectFinal.data)) {
	    buffer = new Buffer(mongoObjectFinal.data.length);
	    var data = mongoObjectFinal.data.join('');
	    buffer.write(data, 0, data.length, 'binary');
	    this.data = new Binary(buffer);
	  } else if(mongoObjectFinal.data && mongoObjectFinal.data._bsontype === 'Binary') {
	    this.data = mongoObjectFinal.data;
	  } else if(!Buffer.isBuffer(mongoObjectFinal.data) && !(mongoObjectFinal.data == null)){
	    throw Error("Illegal chunk format");
	  }
	
	  // Update position
	  this.internalPosition = 0;
	};
	
	/**
	 * Writes a data to this object and advance the read/write head.
	 *
	 * @param data {string} the data to write
	 * @param callback {function(*, GridStore)} This will be called after executing
	 *     this method. The first parameter will contain null and the second one
	 *     will contain a reference to this object.
	 */
	Chunk.prototype.write = function(data, callback) {
	  this.data.write(data, this.internalPosition, data.length, 'binary');
	  this.internalPosition = this.data.length();
	  if(callback != null) return callback(null, this);
	  return this;
	};
	
	/**
	 * Reads data and advances the read/write head.
	 *
	 * @param length {number} The length of data to read.
	 *
	 * @return {string} The data read if the given length will not exceed the end of
	 *     the chunk. Returns an empty String otherwise.
	 */
	Chunk.prototype.read = function(length) {
	  // Default to full read if no index defined
	  length = length == null || length == 0 ? this.length() : length;
	
	  if(this.length() - this.internalPosition + 1 >= length) {
	    var data = this.data.read(this.internalPosition, length);
	    this.internalPosition = this.internalPosition + length;
	    return data;
	  } else {
	    return '';
	  }
	};
	
	Chunk.prototype.readSlice = function(length) {
	  if ((this.length() - this.internalPosition) >= length) {
	    var data = null;
	    if (this.data.buffer != null) { //Pure BSON
	      data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);
	    } else { //Native BSON
	      data = new Buffer(length);
	      length = this.data.readInto(data, this.internalPosition);
	    }
	    this.internalPosition = this.internalPosition + length;
	    return data;
	  } else {
	    return null;
	  }
	};
	
	/**
	 * Checks if the read/write head is at the end.
	 *
	 * @return {boolean} Whether the read/write head has reached the end of this
	 *     chunk.
	 */
	Chunk.prototype.eof = function() {
	  return this.internalPosition == this.length() ? true : false;
	};
	
	/**
	 * Reads one character from the data of this chunk and advances the read/write
	 * head.
	 *
	 * @return {string} a single character data read if the the read/write head is
	 *     not at the end of the chunk. Returns an empty String otherwise.
	 */
	Chunk.prototype.getc = function() {
	  return this.read(1);
	};
	
	/**
	 * Clears the contents of the data in this chunk and resets the read/write head
	 * to the initial position.
	 */
	Chunk.prototype.rewind = function() {
	  this.internalPosition = 0;
	  this.data = new Binary();
	};
	
	/**
	 * Saves this chunk to the database. Also overwrites existing entries having the
	 * same id as this chunk.
	 *
	 * @param callback {function(*, GridStore)} This will be called after executing
	 *     this method. The first parameter will contain null and the second one
	 *     will contain a reference to this object.
	 */
	Chunk.prototype.save = function(options, callback) {
	  var self = this;
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  self.file.chunkCollection(function(err, collection) {
	    if(err) return callback(err);
	
	    // Merge the options
	    var writeOptions = { upsert: true };
	    for(var name in options) writeOptions[name] = options[name];
	    for(name in self.writeConcern) writeOptions[name] = self.writeConcern[name];
	
	    if(self.data.length() > 0) {
	      self.buildMongoObject(function(mongoObject) {
	        var options = {forceServerObjectId:true};
	        for(var name in self.writeConcern) {
	          options[name] = self.writeConcern[name];
	        }
	
	        collection.replaceOne({'_id':self.objectId}, mongoObject, writeOptions, function(err) {
	          callback(err, self);
	        });
	      });
	    } else {
	      callback(null, self);
	    }
	    // });
	  });
	};
	
	/**
	 * Creates a mongoDB object representation of this chunk.
	 *
	 * @param callback {function(Object)} This will be called after executing this
	 *     method. The object will be passed to the first parameter and will have
	 *     the structure:
	 *
	 *        <pre><code>
	 *        {
	 *          '_id' : , // {number} id for this chunk
	 *          'files_id' : , // {number} foreign key to the file collection
	 *          'n' : , // {number} chunk number
	 *          'data' : , // {bson#Binary} the chunk data itself
	 *        }
	 *        </code></pre>
	 *
	 * @see <a href="http://www.mongodb.org/display/DOCS/GridFS+Specification#GridFSSpecification-{{chunks}}">MongoDB GridFS Chunk Object Structure</a>
	 */
	Chunk.prototype.buildMongoObject = function(callback) {
	  var mongoObject = {
	    'files_id': this.file.fileId,
	    'n': this.chunkNumber,
	    'data': this.data};
	  // If we are saving using a specific ObjectId
	  if(this.objectId != null) mongoObject._id = this.objectId;
	
	  callback(mongoObject);
	};
	
	/**
	 * @return {number} the length of the data
	 */
	Chunk.prototype.length = function() {
	  return this.data.length();
	};
	
	/**
	 * The position of the read/write head
	 * @name position
	 * @lends Chunk#
	 * @field
	 */
	Object.defineProperty(Chunk.prototype, "position", { enumerable: true
	  , get: function () {
	      return this.internalPosition;
	    }
	  , set: function(value) {
	      this.internalPosition = value;
	    }
	});
	
	/**
	 * The default chunk size
	 * @constant
	 */
	Chunk.DEFAULT_CHUNK_SIZE = 1024 * 255;
	
	module.exports = Chunk;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	/**
	 * @fileOverview GridFS is a tool for MongoDB to store files to the database.
	 * Because of the restrictions of the object size the database can hold, a
	 * facility to split a file into several chunks is needed. The {@link GridStore}
	 * class offers a simplified api to interact with files while managing the
	 * chunks of split files behind the scenes. More information about GridFS can be
	 * found <a href="http://www.mongodb.org/display/DOCS/GridFS">here</a>.
	 *
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   GridStore = require('mongodb').GridStore,
	 *   ObjectID = require('mongodb').ObjectID,
	 *   test = require('assert');
	 *
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   var gridStore = new GridStore(db, null, "w");
	 *   gridStore.open(function(err, gridStore) {
	 *     gridStore.write("hello world!", function(err, gridStore) {
	 *       gridStore.close(function(err, result) {
	 *
	 *         // Let's read the file using object Id
	 *         GridStore.read(db, result._id, function(err, data) {
	 *           test.equal('hello world!', data);
	 *           db.close();
	 *           test.done();
	 *         });
	 *       });
	 *     });
	 *   });
	 * });
	 */
	var Chunk = __webpack_require__(123),
	  ObjectID = __webpack_require__(3).BSON.ObjectID,
	  ReadPreference = __webpack_require__(16),
	  Buffer = __webpack_require__(153).Buffer,
	  Collection = __webpack_require__(59),
	  fs = __webpack_require__(154),
	  f = __webpack_require__(1).format,
	  util = __webpack_require__(1),
	  Define = __webpack_require__(13),
	  MongoError = __webpack_require__(3).MongoError,
	  inherits = util.inherits,
	  Duplex = __webpack_require__(18).Duplex || __webpack_require__(70).Duplex,
	  shallowClone = __webpack_require__(2).shallowClone;
	
	var REFERENCE_BY_FILENAME = 0,
	  REFERENCE_BY_ID = 1;
	
	/**
	 * Namespace provided by the mongodb-core and node.js
	 * @external Duplex
	 */
	
	/**
	 * Create a new GridStore instance
	 *
	 * Modes
	 *  - **"r"** - read only. This is the default mode.
	 *  - **"w"** - write in truncate mode. Existing data will be overwriten.
	 *
	 * @class
	 * @param {Db} db A database instance to interact with.
	 * @param {object} [id] optional unique id for this file
	 * @param {string} [filename] optional filename for this file, no unique constrain on the field
	 * @param {string} mode set the mode for this file.
	 * @param {object} [options=null] Optional settings.
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.fsync=false] Specify a file sync write concern.
	 * @param {string} [options.root=null] Root collection to use. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.
	 * @param {string} [options.content_type=null] MIME type of the file. Defaults to **{GridStore.DEFAULT_CONTENT_TYPE}**.
	 * @param {number} [options.chunk_size=261120] Size for the chunk. Defaults to **{Chunk.DEFAULT_CHUNK_SIZE}**.
	 * @param {object} [options.metadata=null] Arbitrary data the user wants to store.
	 * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @property {number} chunkSize Get the gridstore chunk size.
	 * @property {number} md5 The md5 checksum for this file.
	 * @property {number} chunkNumber The current chunk number the gridstore has materialized into memory
	 * @return {GridStore} a GridStore instance.
	 * @deprecated Use GridFSBucket API instead
	 */
	var GridStore = function GridStore(db, id, filename, mode, options) {
	  if(!(this instanceof GridStore)) return new GridStore(db, id, filename, mode, options);
	  this.db = db;
	
	  // Handle options
	  if(typeof options === 'undefined') options = {};
	  // Handle mode
	  if(typeof mode === 'undefined') {
	    mode = filename;
	    filename = undefined;
	  } else if(typeof mode == 'object') {
	    options = mode;
	    mode = filename;
	    filename = undefined;
	  }
	
	  if(id && id._bsontype == 'ObjectID') {
	    this.referenceBy = REFERENCE_BY_ID;
	    this.fileId = id;
	    this.filename = filename;
	  } else if(typeof filename == 'undefined') {
	    this.referenceBy = REFERENCE_BY_FILENAME;
	    this.filename = id;
	    if (mode.indexOf('w') != null) {
	      this.fileId = new ObjectID();
	    }
	  } else {
	    this.referenceBy = REFERENCE_BY_ID;
	    this.fileId = id;
	    this.filename = filename;
	  }
	
	  // Set up the rest
	  this.mode = mode == null ? "r" : mode;
	  this.options = options || {};
	
	  // Opened
	  this.isOpen = false;
	
	  // Set the root if overridden
	  this.root = this.options['root'] == null ? GridStore.DEFAULT_ROOT_COLLECTION : this.options['root'];
	  this.position = 0;
	  this.readPreference = this.options.readPreference || db.options.readPreference || ReadPreference.PRIMARY;
	  this.writeConcern = _getWriteConcern(db, this.options);
	  // Set default chunk size
	  this.internalChunkSize = this.options['chunkSize'] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options['chunkSize'];
	
	  // Get the promiseLibrary
	  var promiseLibrary = this.options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(10).Promise;
	  }
	
	  // Set the promiseLibrary
	  this.promiseLibrary = promiseLibrary;
	
	  Object.defineProperty(this, "chunkSize", { enumerable: true
	   , get: function () {
	       return this.internalChunkSize;
	     }
	   , set: function(value) {
	       if(!(this.mode[0] == "w" && this.position == 0 && this.uploadDate == null)) {
	         this.internalChunkSize = this.internalChunkSize;
	       } else {
	         this.internalChunkSize = value;
	       }
	     }
	  });
	
	  Object.defineProperty(this, "md5", { enumerable: true
	   , get: function () {
	       return this.internalMd5;
	     }
	  });
	
	  Object.defineProperty(this, "chunkNumber", { enumerable: true
	   , get: function () {
	       return this.currentChunk && this.currentChunk.chunkNumber ? this.currentChunk.chunkNumber : null;
	     }
	  });
	}
	
	var define = GridStore.define = new Define('Gridstore', GridStore, true);
	
	/**
	 * The callback format for the Gridstore.open method
	 * @callback GridStore~openCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {GridStore} gridStore The GridStore instance if the open method was successful.
	 */
	
	/**
	 * Opens the file from the database and initialize this object. Also creates a
	 * new one if file does not exist.
	 *
	 * @method
	 * @param {GridStore~openCallback} [callback] this will be called after executing this method
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.open = function(callback) {
	  var self = this;
	  if( this.mode != "w" && this.mode != "w+" && this.mode != "r"){
	    throw MongoError.create({message: "Illegal mode " + this.mode, driver:true});
	  }
	
	  // We provided a callback leg
	  if(typeof callback == 'function') return open(self, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    open(self, function(err, store) {
	      if(err) return reject(err);
	      resolve(store);
	    })
	  });
	};
	
	var open = function(self, callback) {
	  // Get the write concern
	  var writeConcern = _getWriteConcern(self.db, self.options);
	
	  // If we are writing we need to ensure we have the right indexes for md5's
	  if((self.mode == "w" || self.mode == "w+")) {
	    // Get files collection
	    var collection = self.collection();
	    // Put index on filename
	    collection.ensureIndex([['filename', 1]], writeConcern, function() {
	      // Get chunk collection
	      var chunkCollection = self.chunkCollection();
	      // Make an unique index for compatibility with mongo-cxx-driver:legacy
	      var chunkIndexOptions = shallowClone(writeConcern);
	      chunkIndexOptions.unique = true;
	      // Ensure index on chunk collection
	      chunkCollection.ensureIndex([['files_id', 1], ['n', 1]], chunkIndexOptions, function() {
	        // Open the connection
	        _open(self, writeConcern, function(err, r) {
	          if(err) return callback(err);
	          self.isOpen = true;
	          callback(err, r);
	        });
	      });
	    });
	  } else {
	    // Open the gridstore
	    _open(self, writeConcern, function(err, r) {
	      if(err) return callback(err);
	      self.isOpen = true;
	      callback(err, r);
	    });
	  }
	}
	
	// Push the definition for open
	define.classMethod('open', {callback: true, promise:true});
	
	/**
	 * Verify if the file is at EOF.
	 *
	 * @method
	 * @return {boolean} true if the read/write head is at the end of this file.
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.eof = function() {
	  return this.position == this.length ? true : false;
	}
	
	define.classMethod('eof', {callback: false, promise:false, returns: [Boolean]});
	
	/**
	 * The callback result format.
	 * @callback GridStore~resultCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {object} result The result from the callback.
	 */
	
	/**
	 * Retrieves a single character from this file.
	 *
	 * @method
	 * @param {GridStore~resultCallback} [callback] this gets called after this method is executed. Passes null to the first parameter and the character read to the second or null to the second if the read/write head is at the end of the file.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.getc = function(callback) {
	  var self = this;
	  // We provided a callback leg
	  if(typeof callback == 'function') return eof(self, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    eof(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	}
	
	var eof = function(self, callback) {
	  if(self.eof()) {
	    callback(null, null);
	  } else if(self.currentChunk.eof()) {
	    nthChunk(self, self.currentChunk.chunkNumber + 1, function(err, chunk) {
	      self.currentChunk = chunk;
	      self.position = self.position + 1;
	      callback(err, self.currentChunk.getc());
	    });
	  } else {
	    self.position = self.position + 1;
	    callback(null, self.currentChunk.getc());
	  }
	}
	
	define.classMethod('getc', {callback: true, promise:true});
	
	/**
	 * Writes a string to the file with a newline character appended at the end if
	 * the given string does not have one.
	 *
	 * @method
	 * @param {string} string the string to write.
	 * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.puts = function(string, callback) {
	  var self = this;
	  var finalString = string.match(/\n$/) == null ? string + "\n" : string;
	  // We provided a callback leg
	  if(typeof callback == 'function') return this.write(finalString, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    self.write(finalString, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	}
	
	define.classMethod('puts', {callback: true, promise:true});
	
	/**
	 * Return a modified Readable stream including a possible transform method.
	 *
	 * @method
	 * @return {GridStoreStream}
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.stream = function() {
	  return new GridStoreStream(this);
	}
	
	define.classMethod('stream', {callback: false, promise:false, returns: [GridStoreStream]});
	
	/**
	 * Writes some data. This method will work properly only if initialized with mode "w" or "w+".
	 *
	 * @method
	 * @param {(string|Buffer)} data the data to write.
	 * @param {boolean} [close] closes this file after writing if set to true.
	 * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.write = function write(data, close, callback) {
	  var self = this;
	  // We provided a callback leg
	  if(typeof callback == 'function') return _writeNormal(this, data, close, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    _writeNormal(self, data, close, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	}
	
	define.classMethod('write', {callback: true, promise:true});
	
	/**
	 * Handles the destroy part of a stream
	 *
	 * @method
	 * @result {null}
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.destroy = function destroy() {
	  // close and do not emit any more events. queued data is not sent.
	  if(!this.writable) return;
	  this.readable = false;
	  if(this.writable) {
	    this.writable = false;
	    this._q.length = 0;
	    this.emit('close');
	  }
	}
	
	define.classMethod('destroy', {callback: false, promise:false});
	
	/**
	 * Stores a file from the file system to the GridFS database.
	 *
	 * @method
	 * @param {(string|Buffer|FileHandle)} file the file to store.
	 * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.writeFile = function (file, callback) {
	  var self = this;
	  // We provided a callback leg
	  if(typeof callback == 'function') return writeFile(self, file, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    writeFile(self, file, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var writeFile = function(self, file, callback) {
	  if (typeof file === 'string') {
	    fs.open(file, 'r', function (err, fd) {
	      if(err) return callback(err);
	      self.writeFile(fd, callback);
	    });
	    return;
	  }
	
	  self.open(function (err, self) {
	    if(err) return callback(err, self);
	
	    fs.fstat(file, function (err, stats) {
	      if(err) return callback(err, self);
	
	      var offset = 0;
	      var index = 0;
	
	      // Write a chunk
	      var writeChunk = function() {
	        // Allocate the buffer
	        var _buffer = new Buffer(self.chunkSize);
	        // Read the file
	        fs.read(file, _buffer, 0, _buffer.length, offset, function(err, bytesRead, data) {
	          if(err) return callback(err, self);
	
	          offset = offset + bytesRead;
	
	          // Create a new chunk for the data
	          var chunk = new Chunk(self, {n:index++}, self.writeConcern);
	          chunk.write(data.slice(0, bytesRead), function(err, chunk) {
	            if(err) return callback(err, self);
	
	            chunk.save({}, function(err) {
	              if(err) return callback(err, self);
	
	              self.position = self.position + bytesRead;
	
	              // Point to current chunk
	              self.currentChunk = chunk;
	
	              if(offset >= stats.size) {
	                fs.close(file);
	                self.close(function(err) {
	                  if(err) return callback(err, self);
	                  return callback(null, self);
	                });
	              } else {
	                return process.nextTick(writeChunk);
	              }
	            });
	          });
	        });
	      }
	
	      // Process the first write
	      process.nextTick(writeChunk);
	    });
	  });
	}
	
	define.classMethod('writeFile', {callback: true, promise:true});
	
	/**
	 * Saves this file to the database. This will overwrite the old entry if it
	 * already exists. This will work properly only if mode was initialized to
	 * "w" or "w+".
	 *
	 * @method
	 * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.close = function(callback) {
	  var self = this;
	  // We provided a callback leg
	  if(typeof callback == 'function') return close(self, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    close(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var close = function(self, callback) {
	  if(self.mode[0] == "w") {
	    // Set up options
	    var options = self.writeConcern;
	
	    if(self.currentChunk != null && self.currentChunk.position > 0) {
	      self.currentChunk.save({}, function(err) {
	        if(err && typeof callback == 'function') return callback(err);
	
	        self.collection(function(err, files) {
	          if(err && typeof callback == 'function') return callback(err);
	
	          // Build the mongo object
	          if(self.uploadDate != null) {
	            buildMongoObject(self, function(err, mongoObject) {
	              if(err) {
	                if(typeof callback == 'function') return callback(err); else throw err;
	              }
	
	              files.save(mongoObject, options, function(err) {
	                if(typeof callback == 'function')
	                  callback(err, mongoObject);
	              });
	            });
	          } else {
	            self.uploadDate = new Date();
	            buildMongoObject(self, function(err, mongoObject) {
	              if(err) {
	                if(typeof callback == 'function') return callback(err); else throw err;
	              }
	
	              files.save(mongoObject, options, function(err) {
	                if(typeof callback == 'function')
	                  callback(err, mongoObject);
	              });
	            });
	          }
	        });
	      });
	    } else {
	      self.collection(function(err, files) {
	        if(err && typeof callback == 'function') return callback(err);
	
	        self.uploadDate = new Date();
	        buildMongoObject(self, function(err, mongoObject) {
	          if(err) {
	            if(typeof callback == 'function') return callback(err); else throw err;
	          }
	
	          files.save(mongoObject, options, function(err) {
	            if(typeof callback == 'function')
	              callback(err, mongoObject);
	          });
	        });
	      });
	    }
	  } else if(self.mode[0] == "r") {
	    if(typeof callback == 'function')
	      callback(null, null);
	  } else {
	    if(typeof callback == 'function')
	      callback(MongoError.create({message: f("Illegal mode %s", self.mode), driver:true}));
	  }
	}
	
	define.classMethod('close', {callback: true, promise:true});
	
	/**
	 * The collection callback format.
	 * @callback GridStore~collectionCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Collection} collection The collection from the command execution.
	 */
	
	/**
	 * Retrieve this file's chunks collection.
	 *
	 * @method
	 * @param {GridStore~collectionCallback} callback the command callback.
	 * @return {Collection}
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.chunkCollection = function(callback) {
	  if(typeof callback == 'function')
	    return this.db.collection((this.root + ".chunks"), callback);
	  return this.db.collection((this.root + ".chunks"));
	};
	
	define.classMethod('chunkCollection', {callback: true, promise:false, returns: [Collection]});
	
	/**
	 * Deletes all the chunks of this file in the database.
	 *
	 * @method
	 * @param {GridStore~resultCallback} [callback] the command callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.unlink = function(callback) {
	  var self = this;
	  // We provided a callback leg
	  if(typeof callback == 'function') return unlink(self, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    unlink(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var unlink = function(self, callback) {
	  deleteChunks(self, function(err) {
	    if(err!==null) {
	      err.message = "at deleteChunks: " + err.message;
	      return callback(err);
	    }
	
	    self.collection(function(err, collection) {
	      if(err!==null) {
	        err.message = "at collection: " + err.message;
	        return callback(err);
	      }
	
	      collection.remove({'_id':self.fileId}, self.writeConcern, function(err) {
	        callback(err, self);
	      });
	    });
	  });
	}
	
	define.classMethod('unlink', {callback: true, promise:true});
	
	/**
	 * Retrieves the file collection associated with this object.
	 *
	 * @method
	 * @param {GridStore~collectionCallback} callback the command callback.
	 * @return {Collection}
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.collection = function(callback) {
	  if(typeof callback == 'function')
	    this.db.collection(this.root + ".files", callback);
	  return this.db.collection(this.root + ".files");
	};
	
	define.classMethod('collection', {callback: true, promise:false, returns: [Collection]});
	
	/**
	 * The readlines callback format.
	 * @callback GridStore~readlinesCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {string[]} strings The array of strings returned.
	 */
	
	/**
	 * Read the entire file as a list of strings splitting by the provided separator.
	 *
	 * @method
	 * @param {string} [separator] The character to be recognized as the newline separator.
	 * @param {GridStore~readlinesCallback} [callback] the command callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.readlines = function(separator, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  separator = args.length ? args.shift() : "\n";
	  separator = separator || "\n";
	
	  // We provided a callback leg
	  if(typeof callback == 'function') return readlines(self, separator, callback);
	
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    readlines(self, separator, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var readlines = function(self, separator, callback) {
	  self.read(function(err, data) {
	    if(err) return callback(err);
	
	    var items = data.toString().split(separator);
	    items = items.length > 0 ? items.splice(0, items.length - 1) : [];
	    for(var i = 0; i < items.length; i++) {
	      items[i] = items[i] + separator;
	    }
	
	    callback(null, items);
	  });
	}
	
	define.classMethod('readlines', {callback: true, promise:true});
	
	/**
	 * Deletes all the chunks of this file in the database if mode was set to "w" or
	 * "w+" and resets the read/write head to the initial position.
	 *
	 * @method
	 * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.rewind = function(callback) {
	  var self = this;
	  // We provided a callback leg
	  if(typeof callback == 'function') return rewind(self, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    rewind(self, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var rewind = function(self, callback) {
	  if(self.currentChunk.chunkNumber != 0) {
	    if(self.mode[0] == "w") {
	      deleteChunks(self, function(err) {
	        if(err) return callback(err);
	        self.currentChunk = new Chunk(self, {'n': 0}, self.writeConcern);
	        self.position = 0;
	        callback(null, self);
	      });
	    } else {
	      self.currentChunk(0, function(err, chunk) {
	        if(err) return callback(err);
	        self.currentChunk = chunk;
	        self.currentChunk.rewind();
	        self.position = 0;
	        callback(null, self);
	      });
	    }
	  } else {
	    self.currentChunk.rewind();
	    self.position = 0;
	    callback(null, self);
	  }
	}
	
	define.classMethod('rewind', {callback: true, promise:true});
	
	/**
	 * The read callback format.
	 * @callback GridStore~readCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {Buffer} data The data read from the GridStore object
	 */
	
	/**
	 * Retrieves the contents of this file and advances the read/write head. Works with Buffers only.
	 *
	 * There are 3 signatures for this method:
	 *
	 * (callback)
	 * (length, callback)
	 * (length, buffer, callback)
	 *
	 * @method
	 * @param {number} [length] the number of characters to read. Reads all the characters from the read/write head to the EOF if not specified.
	 * @param {(string|Buffer)} [buffer] a string to hold temporary data. This is used for storing the string data read so far when recursively calling this method.
	 * @param {GridStore~readCallback} [callback] the command callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.read = function(length, buffer, callback) {
	  var self = this;
	
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  length = args.length ? args.shift() : null;
	  buffer = args.length ? args.shift() : null;
	  // We provided a callback leg
	  if(typeof callback == 'function') return read(self, length, buffer, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    read(self, length, buffer, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	}
	
	var read = function(self, length, buffer, callback) {
	  // The data is a c-terminated string and thus the length - 1
	  var finalLength = length == null ? self.length - self.position : length;
	  var finalBuffer = buffer == null ? new Buffer(finalLength) : buffer;
	  // Add a index to buffer to keep track of writing position or apply current index
	  finalBuffer._index = buffer != null && buffer._index != null ? buffer._index : 0;
	
	  if((self.currentChunk.length() - self.currentChunk.position + finalBuffer._index) >= finalLength) {
	    var slice = self.currentChunk.readSlice(finalLength - finalBuffer._index);
	    // Copy content to final buffer
	    slice.copy(finalBuffer, finalBuffer._index);
	    // Update internal position
	    self.position = self.position + finalBuffer.length;
	    // Check if we don't have a file at all
	    if(finalLength == 0 && finalBuffer.length == 0) return callback(MongoError.create({message: "File does not exist", driver:true}), null);
	    // Else return data
	    return callback(null, finalBuffer);
	  }
	
	  // Read the next chunk
	  slice = self.currentChunk.readSlice(self.currentChunk.length() - self.currentChunk.position);
	  // Copy content to final buffer
	  slice.copy(finalBuffer, finalBuffer._index);
	  // Update index position
	  finalBuffer._index += slice.length;
	
	  // Load next chunk and read more
	  nthChunk(self, self.currentChunk.chunkNumber + 1, function(err, chunk) {
	    if(err) return callback(err);
	
	    if(chunk.length() > 0) {
	      self.currentChunk = chunk;
	      self.read(length, finalBuffer, callback);
	    } else {
	      if(finalBuffer._index > 0) {
	        callback(null, finalBuffer)
	      } else {
	        callback(MongoError.create({message: "no chunks found for file, possibly corrupt", driver:true}), null);
	      }
	    }
	  });
	}
	
	define.classMethod('read', {callback: true, promise:true});
	
	/**
	 * The tell callback format.
	 * @callback GridStore~tellCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {number} position The current read position in the GridStore.
	 */
	
	/**
	 * Retrieves the position of the read/write head of this file.
	 *
	 * @method
	 * @param {number} [length] the number of characters to read. Reads all the characters from the read/write head to the EOF if not specified.
	 * @param {(string|Buffer)} [buffer] a string to hold temporary data. This is used for storing the string data read so far when recursively calling this method.
	 * @param {GridStore~tellCallback} [callback] the command callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.tell = function(callback) {
	  var self = this;
	  // We provided a callback leg
	  if(typeof callback == 'function') return callback(null, this.position);
	  // Return promise
	  return new self.promiseLibrary(function(resolve) {
	    resolve(self.position);
	  });
	};
	
	define.classMethod('tell', {callback: true, promise:true});
	
	/**
	 * The tell callback format.
	 * @callback GridStore~gridStoreCallback
	 * @param {MongoError} error An error instance representing the error during the execution.
	 * @param {GridStore} gridStore The gridStore.
	 */
	
	/**
	 * Moves the read/write head to a new location.
	 *
	 * There are 3 signatures for this method
	 *
	 * Seek Location Modes
	 *  - **GridStore.IO_SEEK_SET**, **(default)** set the position from the start of the file.
	 *  - **GridStore.IO_SEEK_CUR**, set the position from the current position in the file.
	 *  - **GridStore.IO_SEEK_END**, set the position from the end of the file.
	 *
	 * @method
	 * @param {number} [position] the position to seek to
	 * @param {number} [seekLocation] seek mode. Use one of the Seek Location modes.
	 * @param {GridStore~gridStoreCallback} [callback] the command callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.prototype.seek = function(position, seekLocation, callback) {
	  var self = this;
	
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  seekLocation = args.length ? args.shift() : null;
	
	  // We provided a callback leg
	  if(typeof callback == 'function') return seek(self, position, seekLocation, callback);
	  // Return promise
	  return new self.promiseLibrary(function(resolve, reject) {
	    seek(self, position, seekLocation, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	}
	
	var seek = function(self, position, seekLocation, callback) {
	  // Seek only supports read mode
	  if(self.mode != 'r') {
	    return callback(MongoError.create({message: "seek is only supported for mode r", driver:true}))
	  }
	
	  var seekLocationFinal = seekLocation == null ? GridStore.IO_SEEK_SET : seekLocation;
	  var finalPosition = position;
	  var targetPosition = 0;
	
	  // Calculate the position
	  if(seekLocationFinal == GridStore.IO_SEEK_CUR) {
	    targetPosition = self.position + finalPosition;
	  } else if(seekLocationFinal == GridStore.IO_SEEK_END) {
	    targetPosition = self.length + finalPosition;
	  } else {
	    targetPosition = finalPosition;
	  }
	
	  // Get the chunk
	  var newChunkNumber = Math.floor(targetPosition/self.chunkSize);
	  var seekChunk = function() {
	    nthChunk(self, newChunkNumber, function(err, chunk) {
	      if(err) return callback(err, null);
	      if(chunk == null) return callback(new Error('no chunk found'));
	
	      // Set the current chunk
	      self.currentChunk = chunk;
	      self.position = targetPosition;
	      self.currentChunk.position = (self.position % self.chunkSize);
	      callback(err, self);
	    });
	  };
	
	  seekChunk();
	}
	
	define.classMethod('seek', {callback: true, promise:true});
	
	/**
	 * @ignore
	 */
	var _open = function(self, options, callback) {
	  var collection = self.collection();
	  // Create the query
	  var query = self.referenceBy == REFERENCE_BY_ID ? {_id:self.fileId} : {filename:self.filename};
	  query = null == self.fileId && self.filename == null ? null : query;
	  options.readPreference = self.readPreference;
	
	  // Fetch the chunks
	  if(query != null) {
	    collection.findOne(query, options, function(err, doc) {
	      if(err) return error(err);
	
	      // Check if the collection for the files exists otherwise prepare the new one
	      if(doc != null) {
	        self.fileId = doc._id;
	        // Prefer a new filename over the existing one if this is a write
	        self.filename = ((self.mode == 'r') || (self.filename == undefined)) ? doc.filename : self.filename;
	        self.contentType = doc.contentType;
	        self.internalChunkSize = doc.chunkSize;
	        self.uploadDate = doc.uploadDate;
	        self.aliases = doc.aliases;
	        self.length = doc.length;
	        self.metadata = doc.metadata;
	        self.internalMd5 = doc.md5;
	      } else if (self.mode != 'r') {
	        self.fileId = self.fileId == null ? new ObjectID() : self.fileId;
	        self.contentType = GridStore.DEFAULT_CONTENT_TYPE;
	        self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;
	        self.length = 0;
	      } else {
	        self.length = 0;
	        var txtId = self.fileId._bsontype == "ObjectID" ? self.fileId.toHexString() : self.fileId;
	        return error(MongoError.create({message: f("file with id %s not opened for writing", (self.referenceBy == REFERENCE_BY_ID ? txtId : self.filename)), driver:true}), self);
	      }
	
	      // Process the mode of the object
	      if(self.mode == "r") {
	        nthChunk(self, 0, options, function(err, chunk) {
	          if(err) return error(err);
	          self.currentChunk = chunk;
	          self.position = 0;
	          callback(null, self);
	        });
	      } else if(self.mode == "w" && doc) {
	        // Delete any existing chunks
	        deleteChunks(self, options, function(err) {
	          if(err) return error(err);
	          self.currentChunk = new Chunk(self, {'n':0}, self.writeConcern);
	          self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];
	          self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];
	          self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
	          self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
	          self.position = 0;
	          callback(null, self);
	        });
	      } else if(self.mode == "w") {
	        self.currentChunk = new Chunk(self, {'n':0}, self.writeConcern);
	        self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];
	        self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];
	        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
	        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
	        self.position = 0;
	        callback(null, self);
	      } else if(self.mode == "w+") {
	        nthChunk(self, lastChunkNumber(self), options, function(err, chunk) {
	          if(err) return error(err);
	          // Set the current chunk
	          self.currentChunk = chunk == null ? new Chunk(self, {'n':0}, self.writeConcern) : chunk;
	          self.currentChunk.position = self.currentChunk.data.length();
	          self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
	          self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
	          self.position = self.length;
	          callback(null, self);
	        });
	      }
	    });
	  } else {
	    // Write only mode
	    self.fileId = null == self.fileId ? new ObjectID() : self.fileId;
	    self.contentType = GridStore.DEFAULT_CONTENT_TYPE;
	    self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;
	    self.length = 0;
	
	    // No file exists set up write mode
	    if(self.mode == "w") {
	      // Delete any existing chunks
	      deleteChunks(self, options, function(err) {
	        if(err) return error(err);
	        self.currentChunk = new Chunk(self, {'n':0}, self.writeConcern);
	        self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];
	        self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];
	        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
	        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
	        self.position = 0;
	        callback(null, self);
	      });
	    } else if(self.mode == "w+") {
	      nthChunk(self, lastChunkNumber(self), options, function(err, chunk) {
	        if(err) return error(err);
	        // Set the current chunk
	        self.currentChunk = chunk == null ? new Chunk(self, {'n':0}, self.writeConcern) : chunk;
	        self.currentChunk.position = self.currentChunk.data.length();
	        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];
	        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];
	        self.position = self.length;
	        callback(null, self);
	      });
	    }
	  }
	
	  // only pass error to callback once
	  function error (err) {
	    if(error.err) return;
	    callback(error.err = err);
	  }
	};
	
	/**
	 * @ignore
	 */
	var writeBuffer = function(self, buffer, close, callback) {
	  if(typeof close === "function") { callback = close; close = null; }
	  var finalClose = typeof close == 'boolean' ? close : false;
	
	  if(self.mode != "w") {
	    callback(MongoError.create({message: f("file with id %s not opened for writing", (self.referenceBy == REFERENCE_BY_ID ? self.referenceBy : self.filename)), driver:true}), null);
	  } else {
	    if(self.currentChunk.position + buffer.length >= self.chunkSize) {
	      // Write out the current Chunk and then keep writing until we have less data left than a chunkSize left
	      // to a new chunk (recursively)
	      var previousChunkNumber = self.currentChunk.chunkNumber;
	      var leftOverDataSize = self.chunkSize - self.currentChunk.position;
	      var firstChunkData = buffer.slice(0, leftOverDataSize);
	      var leftOverData = buffer.slice(leftOverDataSize);
	      // A list of chunks to write out
	      var chunksToWrite = [self.currentChunk.write(firstChunkData)];
	      // If we have more data left than the chunk size let's keep writing new chunks
	      while(leftOverData.length >= self.chunkSize) {
	        // Create a new chunk and write to it
	        var newChunk = new Chunk(self, {'n': (previousChunkNumber + 1)}, self.writeConcern);
	        firstChunkData = leftOverData.slice(0, self.chunkSize);
	        leftOverData = leftOverData.slice(self.chunkSize);
	        // Update chunk number
	        previousChunkNumber = previousChunkNumber + 1;
	        // Write data
	        newChunk.write(firstChunkData);
	        // Push chunk to save list
	        chunksToWrite.push(newChunk);
	      }
	
	      // Set current chunk with remaining data
	      self.currentChunk = new Chunk(self, {'n': (previousChunkNumber + 1)}, self.writeConcern);
	      // If we have left over data write it
	      if(leftOverData.length > 0) self.currentChunk.write(leftOverData);
	
	      // Update the position for the gridstore
	      self.position = self.position + buffer.length;
	      // Total number of chunks to write
	      var numberOfChunksToWrite = chunksToWrite.length;
	
	      for(var i = 0; i < chunksToWrite.length; i++) {
	        chunksToWrite[i].save({}, function(err) {
	          if(err) return callback(err);
	
	          numberOfChunksToWrite = numberOfChunksToWrite - 1;
	
	          if(numberOfChunksToWrite <= 0) {
	            // We care closing the file before returning
	            if(finalClose) {
	              return self.close(function(err) {
	                callback(err, self);
	              });
	            }
	
	            // Return normally
	            return callback(null, self);
	          }
	        });
	      }
	    } else {
	      // Update the position for the gridstore
	      self.position = self.position + buffer.length;
	      // We have less data than the chunk size just write it and callback
	      self.currentChunk.write(buffer);
	      // We care closing the file before returning
	      if(finalClose) {
	        return self.close(function(err) {
	          callback(err, self);
	        });
	      }
	      // Return normally
	      return callback(null, self);
	    }
	  }
	};
	
	/**
	 * Creates a mongoDB object representation of this object.
	 *
	 *        <pre><code>
	 *        {
	 *          '_id' : , // {number} id for this file
	 *          'filename' : , // {string} name for this file
	 *          'contentType' : , // {string} mime type for this file
	 *          'length' : , // {number} size of this file?
	 *          'chunksize' : , // {number} chunk size used by this file
	 *          'uploadDate' : , // {Date}
	 *          'aliases' : , // {array of string}
	 *          'metadata' : , // {string}
	 *        }
	 *        </code></pre>
	 *
	 * @ignore
	 */
	var buildMongoObject = function(self, callback) {
	  // Calcuate the length
	  var mongoObject = {
	    '_id': self.fileId,
	    'filename': self.filename,
	    'contentType': self.contentType,
	    'length': self.position ? self.position : 0,
	    'chunkSize': self.chunkSize,
	    'uploadDate': self.uploadDate,
	    'aliases': self.aliases,
	    'metadata': self.metadata
	  };
	
	  var md5Command = {filemd5:self.fileId, root:self.root};
	  self.db.command(md5Command, function(err, results) {
	    if(err) return callback(err);
	
	    mongoObject.md5 = results.md5;
	    callback(null, mongoObject);
	  });
	};
	
	/**
	 * Gets the nth chunk of this file.
	 * @ignore
	 */
	var nthChunk = function(self, chunkNumber, options, callback) {
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  options = options || self.writeConcern;
	  options.readPreference = self.readPreference;
	  // Get the nth chunk
	  self.chunkCollection().findOne({'files_id':self.fileId, 'n':chunkNumber}, options, function(err, chunk) {
	    if(err) return callback(err);
	
	    var finalChunk = chunk == null ? {} : chunk;
	    callback(null, new Chunk(self, finalChunk, self.writeConcern));
	  });
	};
	
	/**
	 * @ignore
	 */
	var lastChunkNumber = function(self) {
	  return Math.floor((self.length ? self.length - 1 : 0)/self.chunkSize);
	};
	
	/**
	 * Deletes all the chunks of this file in the database.
	 *
	 * @ignore
	 */
	var deleteChunks = function(self, options, callback) {
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	  }
	
	  options = options || self.writeConcern;
	
	  if(self.fileId != null) {
	    self.chunkCollection().remove({'files_id':self.fileId}, options, function(err) {
	      if(err) return callback(err, false);
	      callback(null, true);
	    });
	  } else {
	    callback(null, true);
	  }
	};
	
	/**
	* The collection to be used for holding the files and chunks collection.
	*
	* @classconstant DEFAULT_ROOT_COLLECTION
	**/
	GridStore.DEFAULT_ROOT_COLLECTION = 'fs';
	
	/**
	* Default file mime type
	*
	* @classconstant DEFAULT_CONTENT_TYPE
	**/
	GridStore.DEFAULT_CONTENT_TYPE = 'binary/octet-stream';
	
	/**
	* Seek mode where the given length is absolute.
	*
	* @classconstant IO_SEEK_SET
	**/
	GridStore.IO_SEEK_SET = 0;
	
	/**
	* Seek mode where the given length is an offset to the current read/write head.
	*
	* @classconstant IO_SEEK_CUR
	**/
	GridStore.IO_SEEK_CUR = 1;
	
	/**
	* Seek mode where the given length is an offset to the end of the file.
	*
	* @classconstant IO_SEEK_END
	**/
	GridStore.IO_SEEK_END = 2;
	
	/**
	 * Checks if a file exists in the database.
	 *
	 * @method
	 * @static
	 * @param {Db} db the database to query.
	 * @param {string} name The name of the file to look for.
	 * @param {string} [rootCollection] The root collection that holds the files and chunks collection. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	 * @param {GridStore~resultCallback} [callback] result from exists.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.exist = function(db, fileIdObject, rootCollection, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  rootCollection = args.length ? args.shift() : null;
	  options = args.length ? args.shift() : {};
	  options = options || {};
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(10).Promise;
	  }
	
	  // We provided a callback leg
	  if(typeof callback == 'function') return exists(db, fileIdObject, rootCollection, options, callback);
	  // Return promise
	  return new promiseLibrary(function(resolve, reject) {
	    exists(db, fileIdObject, rootCollection, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var exists = function(db, fileIdObject, rootCollection, options, callback) {
	  // Establish read preference
	  var readPreference = options.readPreference || ReadPreference.PRIMARY;
	  // Fetch collection
	  var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
	  db.collection(rootCollectionFinal + ".files", function(err, collection) {
	    if(err) return callback(err);
	
	    // Build query
	    var query = (typeof fileIdObject == 'string' || Object.prototype.toString.call(fileIdObject) == '[object RegExp]' )
	      ? {'filename':fileIdObject}
	      : {'_id':fileIdObject};    // Attempt to locate file
	
	    // We have a specific query
	    if(fileIdObject != null
	      && typeof fileIdObject == 'object'
	      && Object.prototype.toString.call(fileIdObject) != '[object RegExp]') {
	      query = fileIdObject;
	    }
	
	    // Check if the entry exists
	    collection.findOne(query, {readPreference:readPreference}, function(err, item) {
	      if(err) return callback(err);
	      callback(null, item == null ? false : true);
	    });
	  });
	}
	
	define.staticMethod('exist', {callback: true, promise:true});
	
	/**
	 * Gets the list of files stored in the GridFS.
	 *
	 * @method
	 * @static
	 * @param {Db} db the database to query.
	 * @param {string} [rootCollection] The root collection that holds the files and chunks collection. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	 * @param {GridStore~resultCallback} [callback] result from exists.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.list = function(db, rootCollection, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  rootCollection = args.length ? args.shift() : null;
	  options = args.length ? args.shift() : {};
	  options = options || {};
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(10).Promise;
	  }
	
	  // We provided a callback leg
	  if(typeof callback == 'function') return list(db, rootCollection, options, callback);
	  // Return promise
	  return new promiseLibrary(function(resolve, reject) {
	    list(db, rootCollection, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var list = function(db, rootCollection, options, callback) {
	  // Ensure we have correct values
	  if(rootCollection != null && typeof rootCollection == 'object') {
	    options = rootCollection;
	    rootCollection = null;
	  }
	
	  // Establish read preference
	  var readPreference = options.readPreference || ReadPreference.PRIMARY;
	  // Check if we are returning by id not filename
	  var byId = options['id'] != null ? options['id'] : false;
	  // Fetch item
	  var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
	  var items = [];
	  db.collection((rootCollectionFinal + ".files"), function(err, collection) {
	    if(err) return callback(err);
	
	    collection.find({}, {readPreference:readPreference}, function(err, cursor) {
	      if(err) return callback(err);
	
	      cursor.each(function(err, item) {
	        if(item != null) {
	          items.push(byId ? item._id : item.filename);
	        } else {
	          callback(err, items);
	        }
	      });
	    });
	  });
	}
	
	define.staticMethod('list', {callback: true, promise:true});
	
	/**
	 * Reads the contents of a file.
	 *
	 * This method has the following signatures
	 *
	 * (db, name, callback)
	 * (db, name, length, callback)
	 * (db, name, length, offset, callback)
	 * (db, name, length, offset, options, callback)
	 *
	 * @method
	 * @static
	 * @param {Db} db the database to query.
	 * @param {string} name The name of the file.
	 * @param {number} [length] The size of data to read.
	 * @param {number} [offset] The offset from the head of the file of which to start reading from.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	 * @param {GridStore~readCallback} [callback] the command callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.read = function(db, name, length, offset, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  length = args.length ? args.shift() : null;
	  offset = args.length ? args.shift() : null;
	  options = args.length ? args.shift() : null;
	  options = options || {};
	
	  // Get the promiseLibrary
	  var promiseLibrary = options ? options.promiseLibrary : null;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(10).Promise;
	  }
	
	  // We provided a callback leg
	  if(typeof callback == 'function') return readStatic(db, name, length, offset, options, callback);
	  // Return promise
	  return new promiseLibrary(function(resolve, reject) {
	    readStatic(db, name, length, offset, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var readStatic = function(db, name, length, offset, options, callback) {
	  new GridStore(db, name, "r", options).open(function(err, gridStore) {
	    if(err) return callback(err);
	    // Make sure we are not reading out of bounds
	    if(offset && offset >= gridStore.length) return callback("offset larger than size of file", null);
	    if(length && length > gridStore.length) return callback("length is larger than the size of the file", null);
	    if(offset && length && (offset + length) > gridStore.length) return callback("offset and length is larger than the size of the file", null);
	
	    if(offset != null) {
	      gridStore.seek(offset, function(err, gridStore) {
	        if(err) return callback(err);
	        gridStore.read(length, callback);
	      });
	    } else {
	      gridStore.read(length, callback);
	    }
	  });
	}
	
	define.staticMethod('read', {callback: true, promise:true});
	
	/**
	 * Read the entire file as a list of strings splitting by the provided separator.
	 *
	 * @method
	 * @static
	 * @param {Db} db the database to query.
	 * @param {(String|object)} name the name of the file.
	 * @param {string} [separator] The character to be recognized as the newline separator.
	 * @param {object} [options=null] Optional settings.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	 * @param {GridStore~readlinesCallback} [callback] the command callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.readlines = function(db, name, separator, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  separator = args.length ? args.shift() : null;
	  options = args.length ? args.shift() : null;
	  options = options || {};
	
	  // Get the promiseLibrary
	  var promiseLibrary = options ? options.promiseLibrary : null;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(10).Promise;
	  }
	
	  // We provided a callback leg
	  if(typeof callback == 'function') return readlinesStatic(db, name, separator, options, callback);
	  // Return promise
	  return new promiseLibrary(function(resolve, reject) {
	    readlinesStatic(db, name, separator, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var readlinesStatic = function(db, name, separator, options, callback) {
	  var finalSeperator = separator == null ? "\n" : separator;
	  new GridStore(db, name, "r", options).open(function(err, gridStore) {
	    if(err) return callback(err);
	    gridStore.readlines(finalSeperator, callback);
	  });
	}
	
	define.staticMethod('readlines', {callback: true, promise:true});
	
	/**
	 * Deletes the chunks and metadata information of a file from GridFS.
	 *
	 * @method
	 * @static
	 * @param {Db} db The database to query.
	 * @param {(string|array)} names The name/names of the files to delete.
	 * @param {object} [options=null] Optional settings.
	 * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	 * @param {GridStore~resultCallback} [callback] the command callback.
	 * @return {Promise} returns Promise if no callback passed
	 * @deprecated Use GridFSBucket API instead
	 */
	GridStore.unlink = function(db, names, options, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  options = args.length ? args.shift() : {};
	  options = options || {};
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(10).Promise;
	  }
	
	  // We provided a callback leg
	  if(typeof callback == 'function') return unlinkStatic(self, db, names, options, callback);
	
	  // Return promise
	  return new promiseLibrary(function(resolve, reject) {
	    unlinkStatic(self, db, names, options, function(err, r) {
	      if(err) return reject(err);
	      resolve(r);
	    })
	  });
	};
	
	var unlinkStatic = function(self, db, names, options, callback) {
	  // Get the write concern
	  var writeConcern = _getWriteConcern(db, options);
	
	  // List of names
	  if(names.constructor == Array) {
	    var tc = 0;
	    for(var i = 0; i < names.length; i++) {
	      ++tc;
	      GridStore.unlink(db, names[i], options, function() {
	        if(--tc == 0) {
	          callback(null, self);
	        }
	      });
	    }
	  } else {
	    new GridStore(db, names, "w", options).open(function(err, gridStore) {
	      if(err) return callback(err);
	      deleteChunks(gridStore, function(err) {
	        if(err) return callback(err);
	        gridStore.collection(function(err, collection) {
	          if(err) return callback(err);
	          collection.remove({'_id':gridStore.fileId}, writeConcern, function(err) {
	            callback(err, self);
	          });
	        });
	      });
	    });
	  }
	}
	
	define.staticMethod('unlink', {callback: true, promise:true});
	
	/**
	 *  @ignore
	 */
	var _writeNormal = function(self, data, close, callback) {
	  // If we have a buffer write it using the writeBuffer method
	  if(Buffer.isBuffer(data)) {
	    return writeBuffer(self, data, close, callback);
	  } else {
	    return writeBuffer(self, new Buffer(data, 'binary'), close, callback);
	  }
	}
	
	/**
	 * @ignore
	 */
	var _setWriteConcernHash = function(options) {
	  var finalOptions = {};
	  if(options.w != null) finalOptions.w = options.w;
	  if(options.journal == true) finalOptions.j = options.journal;
	  if(options.j == true) finalOptions.j = options.j;
	  if(options.fsync == true) finalOptions.fsync = options.fsync;
	  if(options.wtimeout != null) finalOptions.wtimeout = options.wtimeout;
	  return finalOptions;
	}
	
	/**
	 * @ignore
	 */
	var _getWriteConcern = function(self, options) {
	  // Final options
	  var finalOptions = {w:1};
	  options = options || {};
	
	  // Local options verification
	  if(options.w != null || typeof options.j == 'boolean' || typeof options.journal == 'boolean' || typeof options.fsync == 'boolean') {
	    finalOptions = _setWriteConcernHash(options);
	  } else if(options.safe != null && typeof options.safe == 'object') {
	    finalOptions = _setWriteConcernHash(options.safe);
	  } else if(typeof options.safe == "boolean") {
	    finalOptions = {w: (options.safe ? 1 : 0)};
	  } else if(self.options.w != null || typeof self.options.j == 'boolean' || typeof self.options.journal == 'boolean' || typeof self.options.fsync == 'boolean') {
	    finalOptions = _setWriteConcernHash(self.options);
	  } else if(self.safe && (self.safe.w != null || typeof self.safe.j == 'boolean' || typeof self.safe.journal == 'boolean' || typeof self.safe.fsync == 'boolean')) {
	    finalOptions = _setWriteConcernHash(self.safe);
	  } else if(typeof self.safe == "boolean") {
	    finalOptions = {w: (self.safe ? 1 : 0)};
	  }
	
	  // Ensure we don't have an invalid combination of write concerns
	  if(finalOptions.w < 1
	    && (finalOptions.journal == true || finalOptions.j == true || finalOptions.fsync == true)) throw MongoError.create({message: "No acknowledgement using w < 1 cannot be combined with journal:true or fsync:true", driver:true});
	
	  // Return the options
	  return finalOptions;
	}
	
	/**
	 * Create a new GridStoreStream instance (INTERNAL TYPE, do not instantiate directly)
	 *
	 * @class
	 * @extends external:Duplex
	 * @return {GridStoreStream} a GridStoreStream instance.
	 * @deprecated Use GridFSBucket API instead
	 */
	var GridStoreStream = function(gs) {
	  // Initialize the duplex stream
	  Duplex.call(this);
	
	  // Get the gridstore
	  this.gs = gs;
	
	  // End called
	  this.endCalled = false;
	
	  // If we have a seek
	  this.totalBytesToRead = this.gs.length - this.gs.position;
	  this.seekPosition = this.gs.position;
	}
	
	//
	// Inherit duplex
	inherits(GridStoreStream, Duplex);
	
	GridStoreStream.prototype._pipe = GridStoreStream.prototype.pipe;
	
	// Set up override
	GridStoreStream.prototype.pipe = function(destination) {
	  var self = this;
	
	  // Only open gridstore if not already open
	  if(!self.gs.isOpen) {
	    self.gs.open(function(err) {
	      if(err) return self.emit('error', err);
	      self.totalBytesToRead = self.gs.length - self.gs.position;
	      self._pipe.apply(self, [destination]);
	    });
	  } else {
	    self.totalBytesToRead = self.gs.length - self.gs.position;
	    self._pipe.apply(self, [destination]);
	  }
	
	  return destination;
	}
	
	// Called by stream
	GridStoreStream.prototype._read = function() {
	  var self = this;
	
	  var read = function() {
	    // Read data
	    self.gs.read(length, function(err, buffer) {
	      if(err && !self.endCalled) return self.emit('error', err);
	
	      // Stream is closed
	      if(self.endCalled || buffer == null) return self.push(null);
	      // Remove bytes read
	      if(buffer.length <= self.totalBytesToRead) {
	        self.totalBytesToRead = self.totalBytesToRead - buffer.length;
	        self.push(buffer);
	      } else if(buffer.length > self.totalBytesToRead) {
	        self.totalBytesToRead = self.totalBytesToRead - buffer._index;
	        self.push(buffer.slice(0, buffer._index));
	      }
	
	      // Finished reading
	      if(self.totalBytesToRead <= 0) {
	        self.endCalled = true;
	      }
	    });
	  }
	
	  // Set read length
	  var length = self.gs.length < self.gs.chunkSize ? self.gs.length - self.seekPosition : self.gs.chunkSize;
	  if(!self.gs.isOpen) {
	    self.gs.open(function(err) {
	      self.totalBytesToRead = self.gs.length - self.gs.position;
	      if(err) return self.emit('error', err);
	      read();
	    });
	  } else {
	    read();
	  }
	}
	
	GridStoreStream.prototype.destroy = function() {
	  this.pause();
	  this.endCalled = true;
	  this.gs.close();
	  this.emit('end');
	}
	
	GridStoreStream.prototype.write = function(chunk) {
	  var self = this;
	  if(self.endCalled) return self.emit('error', MongoError.create({message: 'attempting to write to stream after end called', driver:true}))
	  // Do we have to open the gridstore
	  if(!self.gs.isOpen) {
	    self.gs.open(function() {
	      self.gs.isOpen = true;
	      self.gs.write(chunk, function() {
	        process.nextTick(function() {
	          self.emit('drain');
	        });
	      });
	    });
	    return false;
	  } else {
	    self.gs.write(chunk, function() {
	      self.emit('drain');
	    });
	    return true;
	  }
	}
	
	GridStoreStream.prototype.end = function(chunk, encoding, callback) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  callback = args.pop();
	  if(typeof callback != 'function') args.push(callback);
	  chunk = args.length ? args.shift() : null;
	  encoding = args.length ? args.shift() : null;
	  self.endCalled = true;
	
	  if(chunk) {
	    self.gs.write(chunk, function() {
	      self.gs.close(function() {
	        if(typeof callback == 'function') callback();
	        self.emit('end')
	      });
	    });
	  }
	
	  self.gs.close(function() {
	    if(typeof callback == 'function') callback();
	    self.emit('end')
	  });
	}
	
	/**
	 * The read() method pulls some data out of the internal buffer and returns it. If there is no data available, then it will return null.
	 * @function external:Duplex#read
	 * @param {number} size Optional argument to specify how much data to read.
	 * @return {(String | Buffer | null)}
	 */
	
	/**
	 * Call this function to cause the stream to return strings of the specified encoding instead of Buffer objects.
	 * @function external:Duplex#setEncoding
	 * @param {string} encoding The encoding to use.
	 * @return {null}
	 */
	
	/**
	 * This method will cause the readable stream to resume emitting data events.
	 * @function external:Duplex#resume
	 * @return {null}
	 */
	
	/**
	 * This method will cause a stream in flowing-mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.
	 * @function external:Duplex#pause
	 * @return {null}
	 */
	
	/**
	 * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.
	 * @function external:Duplex#pipe
	 * @param {Writable} destination The destination for writing data
	 * @param {object} [options] Pipe options
	 * @return {null}
	 */
	
	/**
	 * This method will remove the hooks set up for a previous pipe() call.
	 * @function external:Duplex#unpipe
	 * @param {Writable} [destination] The destination for writing data
	 * @return {null}
	 */
	
	/**
	 * This is useful in certain cases where a stream is being consumed by a parser, which needs to "un-consume" some data that it has optimistically pulled out of the source, so that the stream can be passed on to some other party.
	 * @function external:Duplex#unshift
	 * @param {(Buffer|string)} chunk Chunk of data to unshift onto the read queue.
	 * @return {null}
	 */
	
	/**
	 * Versions of Node prior to v0.10 had streams that did not implement the entire Streams API as it is today. (See "Compatibility" below for more information.)
	 * @function external:Duplex#wrap
	 * @param {Stream} stream An "old style" readable stream.
	 * @return {null}
	 */
	
	/**
	 * This method writes some data to the underlying system, and calls the supplied callback once the data has been fully handled.
	 * @function external:Duplex#write
	 * @param {(string|Buffer)} chunk The data to write
	 * @param {string} encoding The encoding, if chunk is a String
	 * @param {function} callback Callback for when this chunk of data is flushed
	 * @return {boolean}
	 */
	
	/**
	 * Call this method when no more data will be written to the stream. If supplied, the callback is attached as a listener on the finish event.
	 * @function external:Duplex#end
	 * @param {(string|Buffer)} chunk The data to write
	 * @param {string} encoding The encoding, if chunk is a String
	 * @param {function} callback Callback for when this chunk of data is flushed
	 * @return {null}
	 */
	
	/**
	 * GridStoreStream stream data event, fired for each document in the cursor.
	 *
	 * @event GridStoreStream#data
	 * @type {object}
	 */
	
	/**
	 * GridStoreStream stream end event
	 *
	 * @event GridStoreStream#end
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream close event
	 *
	 * @event GridStoreStream#close
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream readable event
	 *
	 * @event GridStoreStream#readable
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream drain event
	 *
	 * @event GridStoreStream#drain
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream finish event
	 *
	 * @event GridStoreStream#finish
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream pipe event
	 *
	 * @event GridStoreStream#pipe
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream unpipe event
	 *
	 * @event GridStoreStream#unpipe
	 * @type {null}
	 */
	
	/**
	 * GridStoreStream stream error event
	 *
	 * @event GridStoreStream#error
	 * @type {null}
	 */
	
	/**
	 * @ignore
	 */
	module.exports = GridStore;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var parse = __webpack_require__(205)
	  , Server = __webpack_require__(60)
	  , Mongos = __webpack_require__(126)
	  , ReplSet = __webpack_require__(127)
	  , EventEmitter = __webpack_require__(6).EventEmitter
	  , inherits = __webpack_require__(1).inherits
	  , Define = __webpack_require__(13)
	  , ReadPreference = __webpack_require__(16)
	  , Logger = __webpack_require__(3).Logger
	  , MongoError = __webpack_require__(3).MongoError
	  , Db = __webpack_require__(82)
	  , f = __webpack_require__(1).format
	  , assign = __webpack_require__(2).assign
	  , shallowClone = __webpack_require__(2).shallowClone
	  , authenticate = __webpack_require__(79);
	
	/**
	 * @fileOverview The **MongoClient** class is a class that allows for making Connections to MongoDB.
	 *
	 * @example
	 * var MongoClient = require('mongodb').MongoClient,
	 *   test = require('assert');
	 * // Connection url
	 * var url = 'mongodb://localhost:27017/test';
	 * // Connect using MongoClient
	 * MongoClient.connect(url, function(err, db) {
	 *   // Get an additional db
	 *   db.close();
	 * });
	 */
	var validOptionNames = ['poolSize', 'ssl', 'sslValidate', 'sslCA', 'sslCert',
	  'sslKey', 'sslPass', 'sslCRL', 'autoReconnect', 'noDelay', 'keepAlive', 'connectTimeoutMS', 'family',
	  'socketTimeoutMS', 'reconnectTries', 'reconnectInterval', 'ha', 'haInterval',
	  'replicaSet', 'secondaryAcceptableLatencyMS', 'acceptableLatencyMS',
	  'connectWithNoPrimary', 'authSource', 'w', 'wtimeout', 'j', 'forceServerObjectId',
	  'serializeFunctions', 'ignoreUndefined', 'raw', 'bufferMaxEntries',
	  'readPreference', 'pkFactory', 'promiseLibrary', 'readConcern', 'maxStalenessSeconds',
	  'loggerLevel', 'logger', 'promoteValues', 'promoteBuffers', 'promoteLongs',
	  'domainsEnabled', 'keepAliveInitialDelay', 'checkServerIdentity', 'validateOptions', 'appname', 'auth'];
	var ignoreOptionNames = ['native_parser'];
	var legacyOptionNames = ['server', 'replset', 'replSet', 'mongos', 'db'];
	
	function validOptions(options) {
	  var _validOptions = validOptionNames.concat(legacyOptionNames);
	
	  for(var name in options) {
	    if(ignoreOptionNames.indexOf(name) != -1) {
	      continue;
	    }
	
	    if(_validOptions.indexOf(name) == -1 && options.validateOptions) {
	      return new MongoError(f('option %s is not supported', name));
	    } else if(_validOptions.indexOf(name) == -1) {
	      console.warn(f('the options [%s] is not supported', name));
	    }
	
	    if(legacyOptionNames.indexOf(name) != -1) {
	      console.warn(f('the server/replset/mongos options are deprecated, '
	      + 'all their options are supported at the top level of the options object [%s]', validOptionNames));
	    }
	  }
	}
	
	/**
	 * Creates a new MongoClient instance
	 * @class
	 * @return {MongoClient} a MongoClient instance.
	 */
	function MongoClient() {
	  if(!(this instanceof MongoClient)) return new MongoClient();
	
	  // Set up event emitter
	  EventEmitter.call(this);
	
	  /**
	   * The callback format for results
	   * @callback MongoClient~connectCallback
	   * @param {MongoError} error An error instance representing the error during the execution.
	   * @param {Db} db The connected database.
	   */
	
	  /**
	   * Connect to MongoDB using a url as documented at
	   *
	   *  docs.mongodb.org/manual/reference/connection-string/
	   *
	   * Note that for replicasets the replicaSet query parameter is required in the 2.0 driver
	   *
	   * @method
	   * @param {string} url The connection URI string
	   * @param {object} [options] Optional settings.
	   * @param {number} [options.poolSize=5] poolSize The maximum size of the individual server pool.
	   * @param {boolean} [options.ssl=false] Enable SSL connection.
	   * @param {Buffer} [options.sslCA=undefined] SSL Certificate store binary buffer
	   * @param {Buffer} [options.sslCRL=undefined] SSL Certificate revocation list binary buffer
	   * @param {Buffer} [options.sslCert=undefined] SSL Certificate binary buffer
	   * @param {Buffer} [options.sslKey=undefined] SSL Key file binary buffer
	   * @param {string} [options.sslPass=undefined] SSL Certificate pass phrase
	   * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	   * @param {boolean} [options.autoReconnect=true] Enable autoReconnect for single server instances
	   * @param {boolean} [options.noDelay=true] TCP Connection no delay
	   * @param {number} [options.family=4] Version of IP stack. Defaults to 4.
	   * @param {boolean} [options.keepAlive=30000] The number of milliseconds to wait before initiating keepAlive on the TCP socket.
	   * @param {number} [options.connectTimeoutMS=30000] TCP Connection timeout setting
	   * @param {number} [options.socketTimeoutMS=360000] TCP Socket timeout setting
	   * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times
	   * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries
	   * @param {boolean} [options.ha=true] Control if high availability monitoring runs for Replicaset or Mongos proxies.
	   * @param {number} [options.haInterval=10000] The High availability period for replicaset inquiry
	   * @param {string} [options.replicaSet=undefined] The Replicaset set name
	   * @param {number} [options.secondaryAcceptableLatencyMS=15] Cutoff latency point in MS for Replicaset member selection
	   * @param {number} [options.acceptableLatencyMS=15] Cutoff latency point in MS for Mongos proxies selection.
	   * @param {boolean} [options.connectWithNoPrimary=false] Sets if the driver should connect even if no primary is available
	   * @param {string} [options.authSource=undefined] Define the database to authenticate against
	   * @param {string} [options.auth.user=undefined] The username for auth
	   * @param {string} [options.auth.password=undefined] The username for auth
	   * @param {(number|string)} [options.w=null] The write concern.
	   * @param {number} [options.wtimeout=null] The write concern timeout.
	   * @param {boolean} [options.j=false] Specify a journal write concern.
	   * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
	   * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	   * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	   * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
	   * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
	   * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
	   * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
	   * @param {number} [options.bufferMaxEntries=-1] Sets a cap on how many operations the driver will buffer up before giving up on getting a working connection, default is -1 which is unlimited.
	   * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	   * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
	   * @param {object} [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
	   * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	   * @param {object} [options.readConcern=null] Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)
	   * @param {string} [options.readConcern.level='local'] Specify a read concern level for the collection operations, one of [local|majority]. (only MongoDB 3.2 or higher supported)
	   * @param {number} [options.maxStalenessSeconds=undefined] The max staleness to secondary reads (values under 10 seconds cannot be guaranteed);
	   * @param {string} [options.appname=undefined] The name of the application that created this MongoClient instance. MongoDB 3.4 and newer will print this value in the server log upon establishing each connection. It is also recorded in the slow query log and profile collections.
	   * @param {string} [options.loggerLevel=undefined] The logging level (error/warn/info/debug)
	   * @param {object} [options.logger=undefined] Custom logger object
	   * @param {object} [options.validateOptions=false] Validate MongoClient passed in options for correctness.
	   * @param {MongoClient~connectCallback} [callback] The command result callback
	   * @return {Promise} returns Promise if no callback passed
	   */
	  this.connect = MongoClient.connect;
	}
	
	/**
	 * @ignore
	 */
	inherits(MongoClient, EventEmitter);
	
	var define = MongoClient.define = new Define('MongoClient', MongoClient, false);
	
	/**
	 * Connect to MongoDB using a url as documented at
	 *
	 *  docs.mongodb.org/manual/reference/connection-string/
	 *
	 * Note that for replicasets the replicaSet query parameter is required in the 2.0 driver
	 *
	 * @method
	 * @static
	 * @param {string} url The connection URI string
	 * @param {object} [options] Optional settings.
	 * @param {number} [options.poolSize=5] poolSize The maximum size of the individual server pool.
	 * @param {boolean} [options.ssl=false] Enable SSL connection.
	 * @param {Buffer} [options.sslCA=undefined] SSL Certificate store binary buffer
	 * @param {Buffer} [options.sslCRL=undefined] SSL Certificate revocation list binary buffer
	 * @param {Buffer} [options.sslCert=undefined] SSL Certificate binary buffer
	 * @param {Buffer} [options.sslKey=undefined] SSL Key file binary buffer
	 * @param {string} [options.sslPass=undefined] SSL Certificate pass phrase
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {boolean} [options.autoReconnect=true] Enable autoReconnect for single server instances
	 * @param {boolean} [options.noDelay=true] TCP Connection no delay
	 * @param {number} [options.family=4] Version of IP stack. Defaults to 4.
	 * @param {boolean} [options.keepAlive=30000] The number of milliseconds to wait before initiating keepAlive on the TCP socket.
	 * @param {number} [options.connectTimeoutMS=30000] TCP Connection timeout setting
	 * @param {number} [options.socketTimeoutMS=360000] TCP Socket timeout setting
	 * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times
	 * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries
	 * @param {boolean} [options.ha=true] Control if high availability monitoring runs for Replicaset or Mongos proxies.
	 * @param {number} [options.haInterval=10000] The High availability period for replicaset inquiry
	 * @param {string} [options.replicaSet=undefined] The Replicaset set name
	 * @param {number} [options.secondaryAcceptableLatencyMS=15] Cutoff latency point in MS for Replicaset member selection
	 * @param {number} [options.acceptableLatencyMS=15] Cutoff latency point in MS for Mongos proxies selection.
	 * @param {boolean} [options.connectWithNoPrimary=false] Sets if the driver should connect even if no primary is available
	 * @param {string} [options.authSource=undefined] Define the database to authenticate against
	 * @param {string} [options.auth.user=undefined] The username for auth
	 * @param {string} [options.auth.password=undefined] The username for auth
	 * @param {(number|string)} [options.w=null] The write concern.
	 * @param {number} [options.wtimeout=null] The write concern timeout.
	 * @param {boolean} [options.j=false] Specify a journal write concern.
	 * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.
	 * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.
	 * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.
	 * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
	 * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
	 * @param {number} [options.bufferMaxEntries=-1] Sets a cap on how many operations the driver will buffer up before giving up on getting a working connection, default is -1 which is unlimited.
	 * @param {(ReadPreference|string)} [options.readPreference=null] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
	 * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
	 * @param {object} [options.pkFactory=null] A primary key factory object for generation of custom _id keys.
	 * @param {object} [options.promiseLibrary=null] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible
	 * @param {object} [options.readConcern=null] Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)
	 * @param {string} [options.readConcern.level='local'] Specify a read concern level for the collection operations, one of [local|majority]. (only MongoDB 3.2 or higher supported)
	 * @param {number} [options.maxStalenessSeconds=undefined] The max staleness to secondary reads (values under 10 seconds cannot be guaranteed);
	 * @param {string} [options.appname=undefined] The name of the application that created this MongoClient instance. MongoDB 3.4 and newer will print this value in the server log upon establishing each connection. It is also recorded in the slow query log and profile collections.
	 * @param {string} [options.loggerLevel=undefined] The logging level (error/warn/info/debug)
	 * @param {object} [options.logger=undefined] Custom logger object
	 * @param {object} [options.validateOptions=false] Validate MongoClient passed in options for correctness.
	 * @param {MongoClient~connectCallback} [callback] The command result callback
	 * @return {Promise} returns Promise if no callback passed
	 */
	MongoClient.connect = function(url, options, callback) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  callback = typeof args[args.length - 1] == 'function' ? args.pop() : null;
	  options = args.length ? args.shift() : null;
	  options = options || {};
	  var self = this;
	
	  // Validate options object
	  var err = validOptions(options);
	
	  // Get the promiseLibrary
	  var promiseLibrary = options.promiseLibrary;
	
	  // No promise library selected fall back
	  if(!promiseLibrary) {
	    promiseLibrary = typeof global.Promise == 'function' ?
	      global.Promise : __webpack_require__(10).Promise;
	  }
	
	  // Return a promise
	  if(typeof callback != 'function') {
	    return new promiseLibrary(function(resolve, reject) {
	      // Did we have a validation error
	      if(err) return reject(err);
	      // Attempt to connect
	      connect(self, url, options, function(err, db) {
	        if(err) return reject(err);
	        resolve(db);
	      });
	    });
	  }
	
	  // Did we have a validation error
	  if(err) return callback(err);
	  // Fallback to callback based connect
	  connect(self, url, options, callback);
	}
	
	define.staticMethod('connect', {callback: true, promise:true});
	
	var mergeOptions = function(target, source, flatten) {
	  for(var name in source) {
	    if(source[name] && typeof source[name] == 'object' && flatten) {
	      target = mergeOptions(target, source[name], flatten);
	    } else {
	      target[name] = source[name];
	    }
	  }
	
	  return target;
	}
	
	var createUnifiedOptions = function(finalOptions, options) {
	  var childOptions = ['mongos', 'server', 'db'
	    , 'replset', 'db_options', 'server_options', 'rs_options', 'mongos_options'];
	  var noMerge = ['readconcern'];
	
	  for(var name in options) {
	    if(noMerge.indexOf(name.toLowerCase()) != -1) {
	      finalOptions[name] = options[name];
	    } else if(childOptions.indexOf(name.toLowerCase()) != -1) {
	      finalOptions = mergeOptions(finalOptions, options[name], false);
	    } else {
	      if(options[name] && typeof options[name] == 'object' && !Buffer.isBuffer(options[name]) && !Array.isArray(options[name])) {
	        finalOptions = mergeOptions(finalOptions, options[name], true);
	      } else {
	        finalOptions[name] = options[name];
	      }
	    }
	  }
	
	  return finalOptions;
	}
	
	function translateOptions(options) {
	  // If we have a readPreference passed in by the db options
	  if(typeof options.readPreference == 'string' || typeof options.read_preference == 'string') {
	    options.readPreference = new ReadPreference(options.readPreference || options.read_preference);
	  }
	
	  // Do we have readPreference tags, add them
	  if(options.readPreference && (options.readPreferenceTags || options.read_preference_tags)) {
	    options.readPreference.tags = options.readPreferenceTags || options.read_preference_tags;
	  }
	
	  // Do we have maxStalenessSeconds
	  if(options.maxStalenessSeconds) {
	    options.readPreference.maxStalenessSeconds = options.maxStalenessSeconds;
	  }
	
	  // Set the socket and connection timeouts
	  if(options.socketTimeoutMS == null) options.socketTimeoutMS = 360000;
	  if(options.connectTimeoutMS == null) options.connectTimeoutMS = 30000;
	
	  // Create server instances
	  return options.servers.map(function(serverObj) {
	    return serverObj.domain_socket ?
	      new Server(serverObj.domain_socket, 27017, options)
	    : new Server(serverObj.host, serverObj.port, options);
	  });
	}
	
	//
	// Collect all events in order from SDAM
	//
	function collectEvents(self, db) {
	  var collectedEvents = [];
	
	  if(self instanceof MongoClient) {
	    var events = ["timeout", "close", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	      'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening',
	      'topologyClosed', 'topologyDescriptionChanged', 'joined', 'left', 'ping', 'ha', 'all', 'fullsetup'];
	    events.forEach(function(event) {
	      db.serverConfig.on(event, function(object1, object2) {
	        collectedEvents.push({
	          event: event, object1: object1, object2: object2
	        });
	      });
	    });
	  }
	
	  return collectedEvents;
	}
	
	//
	// Replay any events due to single server connection switching to Mongos
	//
	function replayEvents(self, events) {
	  for(var i = 0; i < events.length; i++) {
	    self.emit(events[i].event, events[i].object1, events[i].object2);
	  }
	}
	
	function relayEvents(self, db) {
	  if(self instanceof MongoClient) {
	    var events = ["timeout", "close", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	      'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening',
	      'topologyClosed', 'topologyDescriptionChanged', 'joined', 'left', 'ping', 'ha', 'all', 'fullsetup'];
	    events.forEach(function(event) {
	      db.serverConfig.on(event, function(object1, object2) {
	        self.emit(event, object1, object2);
	      });
	    });
	  }
	}
	
	function createReplicaset(self, options, callback) {
	  // Set default options
	  var servers = translateOptions(options);
	  // Create Db instance
	  var db = new Db(options.dbName, new ReplSet(servers, options), options);
	  // Propegate the events to the client
	  relayEvents(self, db);
	  // Open the connection
	  db.open(callback);
	}
	
	function createMongos(self, options, callback) {
	  // Set default options
	  var servers = translateOptions(options);
	  // Create Db instance
	  var db = new Db(options.dbName, new Mongos(servers, options), options)
	  // Propegate the events to the client
	  relayEvents(self, db);
	  // Open the connection
	  db.open(callback);
	}
	
	function createServer(self, options, callback) {
	  // Set default options
	  var servers = translateOptions(options);
	  // Create db instance
	  var db = new Db(options.dbName, servers[0], options);
	  // Propegate the events to the client
	  var collectedEvents = collectEvents(self, db);
	  // Create Db instance
	  db.open(function(err, db) {
	    if(err) return callback(err);
	    // Check if we are really speaking to a mongos
	    var ismaster = db.serverConfig.lastIsMaster();
	
	    // Do we actually have a mongos
	    if(ismaster && ismaster.msg == 'isdbgrid') {
	      // Destroy the current connection
	      db.close();
	      // Create mongos connection instead
	      return createMongos(self, options, callback);
	    }
	
	    // Fire all the events
	    replayEvents(self, collectedEvents);
	    // Propegate the events to the client
	    relayEvents(self, db);
	    // Otherwise callback
	    callback(err, db);
	  });
	}
	
	function connectHandler(options, callback) {
	  return function (err, db) {
	    if(err) {
	      return process.nextTick(function() {
	        try {
	          callback(err, null);
	        } catch (err) {
	          if(db) db.close();
	          throw err
	        }
	      });
	    }
	
	    // No authentication just reconnect
	    if(!options.auth) {
	      return process.nextTick(function() {
	        try {
	          callback(err, db);
	        } catch (err) {
	          if(db) db.close();
	          throw err
	        }
	      })
	    }
	
	    // What db to authenticate against
	    var authentication_db = db;
	    if(options.authSource) {
	      authentication_db = db.db(options.authSource);
	    }
	
	    // Authenticate
	    authenticate(authentication_db, options.user, options.password, options, function(err, success) {
	      if(success){
	        process.nextTick(function() {
	          try {
	            callback(null, db);
	          } catch (err) {
	            if(db) db.close();
	            throw err
	          }
	        });
	      } else {
	        if(db) db.close();
	        process.nextTick(function() {
	          try {
	            callback(err ? err : new Error('Could not authenticate user ' + options.auth[0]), null);
	          } catch (err) {
	            if(db) db.close();
	            throw err
	          }
	        });
	      }
	    });
	  }
	}
	
	/*
	 * Connect using MongoClient
	 */
	var connect = function(self, url, options, callback) {
	  options = options || {};
	  options = shallowClone(options);
	
	  // If callback is null throw an exception
	  if(callback == null) {
	    throw new Error("no callback function provided");
	  }
	
	  // Get a logger for MongoClient
	  var logger = Logger('MongoClient', options);
	
	  // Parse the string
	  var object = parse(url, options);
	  var _finalOptions = createUnifiedOptions({}, object);
	  _finalOptions = mergeOptions(_finalOptions, object, false);
	  _finalOptions = createUnifiedOptions(_finalOptions, options);
	
	  // Check if we have connection and socket timeout set
	  if(_finalOptions.socketTimeoutMS == null) _finalOptions.socketTimeoutMS = 360000;
	  if(_finalOptions.connectTimeoutMS == null) _finalOptions.connectTimeoutMS = 30000;
	
	  if (_finalOptions.db_options && _finalOptions.db_options.auth) {
	    delete _finalOptions.db_options.auth;
	  }
	
	  // Failure modes
	  if(object.servers.length == 0) {
	    throw new Error("connection string must contain at least one seed host");
	  }
	
	  function connectCallback(err, db) {
	    if(err && err.message == 'no mongos proxies found in seed list') {
	      if(logger.isWarn()) {
	        logger.warn(f('seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name'));
	      }
	
	      // Return a more specific error message for MongoClient.connect
	      return callback(new MongoError('seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name'));
	    }
	
	    // Return the error and db instance
	    callback(err, db);
	  }
	
	  // Do we have a replicaset then skip discovery and go straight to connectivity
	  if(_finalOptions.replicaSet || _finalOptions.rs_name) {
	    return createReplicaset(self, _finalOptions, connectHandler(_finalOptions, connectCallback));
	  } else if(object.servers.length > 1) {
	    return createMongos(self, _finalOptions, connectHandler(_finalOptions, connectCallback));
	  } else {
	    return createServer(self, _finalOptions, connectHandler(_finalOptions, connectCallback));
	  }
	}
	
	module.exports = MongoClient


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var EventEmitter = __webpack_require__(6).EventEmitter
	  , inherits = __webpack_require__(1).inherits
	  , f = __webpack_require__(1).format
	  , ServerCapabilities = __webpack_require__(28).ServerCapabilities
	  , MongoError = __webpack_require__(3).MongoError
	  , CMongos = __webpack_require__(3).Mongos
	  , Cursor = __webpack_require__(17)
	  , AggregationCursor = __webpack_require__(27)
	  , CommandCursor = __webpack_require__(23)
	  , Define = __webpack_require__(13)
	  , Server = __webpack_require__(60)
	  , Store = __webpack_require__(28).Store
	  , MAX_JS_INT = __webpack_require__(2).MAX_JS_INT
	  , translateOptions = __webpack_require__(2).translateOptions
	  , filterOptions = __webpack_require__(2).filterOptions
	  , mergeOptions = __webpack_require__(2).mergeOptions
	  , getReadPreference = __webpack_require__(2).getReadPreference
	  , os = __webpack_require__(49);
	
	// Get package.json variable
	var driverVersion = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../package.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).version;
	var nodejsversion = f('Node.js %s, %s', process.version, os.endianness());
	var type = os.type();
	var name = process.platform;
	var architecture = process.arch;
	var release = os.release();
	
	/**
	 * @fileOverview The **Mongos** class is a class that represents a Mongos Proxy topology and is
	 * used to construct connections.
	 *
	 * **Mongos Should not be used, use MongoClient.connect**
	 * @example
	 * var Db = require('mongodb').Db,
	 *   Mongos = require('mongodb').Mongos,
	 *   Server = require('mongodb').Server,
	 *   test = require('assert');
	 * // Connect using Mongos
	 * var server = new Server('localhost', 27017);
	 * var db = new Db('test', new Mongos([server]));
	 * db.open(function(err, db) {
	 *   // Get an additional db
	 *   db.close();
	 * });
	 */
	
	 // Allowed parameters
	 var legalOptionNames = ['ha', 'haInterval', 'acceptableLatencyMS'
	   , 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate'
	   , 'sslCA', 'sslCRL', 'sslCert', 'sslKey', 'sslPass', 'socketOptions', 'bufferMaxEntries'
	   , 'store', 'auto_reconnect', 'autoReconnect', 'emitError'
	   , 'keepAlive', 'noDelay', 'connectTimeoutMS', 'socketTimeoutMS'
	   , 'loggerLevel', 'logger', 'reconnectTries', 'appname', 'domainsEnabled'
	   , 'servername', 'promoteLongs', 'promoteValues', 'promoteBuffers'];
	
	/**
	 * Creates a new Mongos instance
	 * @class
	 * @deprecated
	 * @param {Server[]} servers A seedlist of servers participating in the replicaset.
	 * @param {object} [options=null] Optional settings.
	 * @param {booelan} [options.ha=true] Turn on high availability monitoring.
	 * @param {number} [options.haInterval=5000] Time between each replicaset status check.
	 * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.
	 * @param {number} [options.acceptableLatencyMS=15] Cutoff latency point in MS for MongoS proxy selection
	 * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {object} [options.sslValidate=true] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {array} [options.sslCA=null] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {array} [options.sslCRL=null] Array of revocation certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslCert=null] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslKey=null] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslPass=null] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.
	 * @param {object} [options.socketOptions=null] Socket options
	 * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option.
	 * @param {number} [options.socketOptions.keepAlive=0] TCP KeepAlive on the socket with a X ms delay before start.
	 * @param {number} [options.socketOptions.connectTimeoutMS=0] TCP Connection timeout setting
	 * @param {number} [options.socketOptions.socketTimeoutMS=0] TCP Socket timeout setting
	 * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
	 * @fires Mongos#connect
	 * @fires Mongos#ha
	 * @fires Mongos#joined
	 * @fires Mongos#left
	 * @fires Mongos#fullsetup
	 * @fires Mongos#open
	 * @fires Mongos#close
	 * @fires Mongos#error
	 * @fires Mongos#timeout
	 * @fires Mongos#parseError
	 * @property {string} parserType the parser type used (c++ or js).
	 * @return {Mongos} a Mongos instance.
	 */
	var Mongos = function(servers, options) {
	  if(!(this instanceof Mongos)) return new Mongos(servers, options);
	  options = options || {};
	  var self = this;
	
	  // Filter the options
	  options = filterOptions(options, legalOptionNames);
	
	  // Ensure all the instances are Server
	  for(var i = 0; i < servers.length; i++) {
	    if(!(servers[i] instanceof Server)) {
	      throw MongoError.create({message: "all seed list instances must be of the Server type", driver:true});
	    }
	  }
	
	  // Stored options
	  var storeOptions = {
	      force: false
	    , bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : MAX_JS_INT
	  }
	
	  // Shared global store
	  var store = options.store || new Store(self, storeOptions);
	
	  // Set up event emitter
	  EventEmitter.call(this);
	
	  // Build seed list
	  var seedlist = servers.map(function(x) {
	    return {host: x.host, port: x.port}
	  });
	
	  // Get the reconnect option
	  var reconnect = typeof options.auto_reconnect == 'boolean' ? options.auto_reconnect : true;
	  reconnect = typeof options.autoReconnect == 'boolean' ? options.autoReconnect : reconnect;
	
	  // Clone options
	  var clonedOptions = mergeOptions({}, {
	    disconnectHandler: store,
	    cursorFactory: Cursor,
	    reconnect: reconnect,
	    emitError: typeof options.emitError == 'boolean' ? options.emitError : true,
	    size: typeof options.poolSize == 'number' ? options.poolSize : 5
	  });
	
	  // Translate any SSL options and other connectivity options
	  clonedOptions = translateOptions(clonedOptions, options);
	
	  // Socket options
	  var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0
	    ? options.socketOptions : options;
	
	  // Translate all the options to the mongodb-core ones
	  clonedOptions = translateOptions(clonedOptions, socketOptions);
	  if(typeof clonedOptions.keepAlive == 'number') {
	    clonedOptions.keepAliveInitialDelay = clonedOptions.keepAlive;
	    clonedOptions.keepAlive = clonedOptions.keepAlive > 0;
	  }
	
	  // Build default client information
	  this.clientInfo = {
	    driver: {
	      name: "nodejs",
	      version: driverVersion
	    },
	    os: {
	      type: type,
	      name: name,
	      architecture: architecture,
	      version: release
	    },
	    platform: nodejsversion
	  }
	
	  // Build default client information
	  clonedOptions.clientInfo = this.clientInfo;
	  // Do we have an application specific string
	  if(options.appname) {
	    clonedOptions.clientInfo.application = { name: options.appname };
	  }
	
	  // Create the Mongos
	  var mongos = new CMongos(seedlist, clonedOptions)
	  // Server capabilities
	  var sCapabilities = null;
	
	  // Internal state
	  this.s = {
	    // Create the Mongos
	      mongos: mongos
	    // Server capabilities
	    , sCapabilities: sCapabilities
	    // Debug turned on
	    , debug: clonedOptions.debug
	    // Store option defaults
	    , storeOptions: storeOptions
	    // Cloned options
	    , clonedOptions: clonedOptions
	    // Actual store of callbacks
	    , store: store
	    // Options
	    , options: options
	  }
	}
	
	var define = Mongos.define = new Define('Mongos', Mongos, false);
	
	/**
	 * @ignore
	 */
	inherits(Mongos, EventEmitter);
	
	// Last ismaster
	Object.defineProperty(Mongos.prototype, 'isMasterDoc', {
	  enumerable:true, get: function() { return this.s.mongos.lastIsMaster(); }
	});
	
	Object.defineProperty(Mongos.prototype, 'parserType', {
	  enumerable:true, get: function() {
	    return this.s.mongos.parserType;
	  }
	});
	
	// BSON property
	Object.defineProperty(Mongos.prototype, 'bson', {
	  enumerable: true, get: function() {
	    return this.s.mongos.s.bson;
	  }
	});
	
	Object.defineProperty(Mongos.prototype, 'haInterval', {
	  enumerable:true, get: function() { return this.s.mongos.s.haInterval; }
	});
	
	// Connect
	Mongos.prototype.connect = function(db, _options, callback) {
	  var self = this;
	  if('function' === typeof _options) callback = _options, _options = {};
	  if(_options == null) _options = {};
	  if(!('function' === typeof callback)) callback = null;
	  self.s.options = _options;
	
	  // Update bufferMaxEntries
	  self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries;
	
	  // Error handler
	  var connectErrorHandler = function() {
	    return function(err) {
	      // Remove all event handlers
	      var events = ['timeout', 'error', 'close'];
	      events.forEach(function(e) {
	        self.removeListener(e, connectErrorHandler);
	      });
	
	      self.s.mongos.removeListener('connect', connectErrorHandler);
	
	      // Try to callback
	      try {
	        callback(err);
	      } catch(err) {
	        process.nextTick(function() { throw err; })
	      }
	    }
	  }
	
	  // Actual handler
	  var errorHandler = function(event) {
	    return function(err) {
	      if(event != 'error') {
	        self.emit(event, err);
	      }
	    }
	  }
	
	  // Error handler
	  var reconnectHandler = function() {
	    self.emit('reconnect');
	    self.s.store.execute();
	  }
	
	  // relay the event
	  var relay = function(event) {
	    return function(t, server) {
	      self.emit(event, t, server);
	    }
	  }
	
	  // Connect handler
	  var connectHandler = function() {
	    // Clear out all the current handlers left over
	    var events = ["timeout", "error", "close", 'fullsetup'];
	    events.forEach(function(e) {
	      self.s.mongos.removeAllListeners(e);
	    });
	
	    // Set up listeners
	    self.s.mongos.once('timeout', errorHandler('timeout'));
	    self.s.mongos.once('error', errorHandler('error'));
	    self.s.mongos.once('close', errorHandler('close'));
	
	    // Set up serverConfig listeners
	    self.s.mongos.on('fullsetup', function() { self.emit('fullsetup', self); });
	
	    // Emit open event
	    self.emit('open', null, self);
	
	    // Return correctly
	    try {
	      callback(null, self);
	    } catch(err) {
	      process.nextTick(function() { throw err; })
	    }
	  }
	
	  // Clear out all the current handlers left over
	  var events = ["timeout", "error", "close", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	    'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening',
	    'topologyClosed', 'topologyDescriptionChanged'];
	  events.forEach(function(e) {
	    self.s.mongos.removeAllListeners(e);
	  });
	
	  // Set up SDAM listeners
	  self.s.mongos.on('serverDescriptionChanged', relay('serverDescriptionChanged'));
	  self.s.mongos.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));
	  self.s.mongos.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));
	  self.s.mongos.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));
	  self.s.mongos.on('serverOpening', relay('serverOpening'));
	  self.s.mongos.on('serverClosed', relay('serverClosed'));
	  self.s.mongos.on('topologyOpening', relay('topologyOpening'));
	  self.s.mongos.on('topologyClosed', relay('topologyClosed'));
	  self.s.mongos.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));
	
	  // Set up listeners
	  self.s.mongos.once('timeout', connectErrorHandler('timeout'));
	  self.s.mongos.once('error', connectErrorHandler('error'));
	  self.s.mongos.once('close', connectErrorHandler('close'));
	  self.s.mongos.once('connect', connectHandler);
	  // Join and leave events
	  self.s.mongos.on('joined', relay('joined'));
	  self.s.mongos.on('left', relay('left'));
	
	  // Reconnect server
	  self.s.mongos.on('reconnect', reconnectHandler);
	
	  // Start connection
	  self.s.mongos.connect(_options);
	}
	
	// Server capabilities
	Mongos.prototype.capabilities = function() {
	  if(this.s.sCapabilities) return this.s.sCapabilities;
	  if(this.s.mongos.lastIsMaster() == null) return null;
	  this.s.sCapabilities = new ServerCapabilities(this.s.mongos.lastIsMaster());
	  return this.s.sCapabilities;
	}
	
	define.classMethod('capabilities', {callback: false, promise:false, returns: [ServerCapabilities]});
	
	// Command
	Mongos.prototype.command = function(ns, cmd, options, callback) {
	  this.s.mongos.command(ns, cmd, getReadPreference(options), callback);
	}
	
	define.classMethod('command', {callback: true, promise:false});
	
	// Insert
	Mongos.prototype.insert = function(ns, ops, options, callback) {
	  this.s.mongos.insert(ns, ops, options, function(e, m) {
	    callback(e, m)
	  });
	}
	
	define.classMethod('insert', {callback: true, promise:false});
	
	// Update
	Mongos.prototype.update = function(ns, ops, options, callback) {
	  this.s.mongos.update(ns, ops, options, callback);
	}
	
	define.classMethod('update', {callback: true, promise:false});
	
	// Remove
	Mongos.prototype.remove = function(ns, ops, options, callback) {
	  this.s.mongos.remove(ns, ops, options, callback);
	}
	
	define.classMethod('remove', {callback: true, promise:false});
	
	// Destroyed
	Mongos.prototype.isDestroyed = function() {
	  return this.s.mongos.isDestroyed();
	}
	
	// IsConnected
	Mongos.prototype.isConnected = function() {
	  return this.s.mongos.isConnected();
	}
	
	define.classMethod('isConnected', {callback: false, promise:false, returns: [Boolean]});
	
	// Insert
	Mongos.prototype.cursor = function(ns, cmd, options) {
	  options.disconnectHandler = this.s.store;
	  return this.s.mongos.cursor(ns, cmd, options);
	}
	
	define.classMethod('cursor', {callback: false, promise:false, returns: [Cursor, AggregationCursor, CommandCursor]});
	
	Mongos.prototype.lastIsMaster = function() {
	  return this.s.mongos.lastIsMaster();
	}
	
	/**
	 * Unref all sockets
	 * @method
	 */
	Mongos.prototype.unref = function () {
	  return this.s.mongos.unref();
	}
	
	Mongos.prototype.close = function(forceClosed) {
	  this.s.mongos.destroy({
	    force: typeof forceClosed == 'boolean' ? forceClosed : false,
	  });
	  // We need to wash out all stored processes
	  if(forceClosed == true) {
	    this.s.storeOptions.force = forceClosed;
	    this.s.store.flush();
	  }
	}
	
	define.classMethod('close', {callback: false, promise:false});
	
	Mongos.prototype.auth = function() {
	  var args = Array.prototype.slice.call(arguments, 0);
	  this.s.mongos.auth.apply(this.s.mongos, args);
	}
	
	define.classMethod('auth', {callback: true, promise:false});
	
	Mongos.prototype.logout = function() {
	  var args = Array.prototype.slice.call(arguments, 0);
	  this.s.mongos.logout.apply(this.s.mongos, args);
	}
	
	define.classMethod('logout', {callback: true, promise:false});
	
	/**
	 * All raw connections
	 * @method
	 * @return {array}
	 */
	Mongos.prototype.connections = function() {
	  return this.s.mongos.connections();
	}
	
	define.classMethod('connections', {callback: false, promise:false, returns:[Array]});
	
	/**
	 * A mongos connect event, used to verify that the connection is up and running
	 *
	 * @event Mongos#connect
	 * @type {Mongos}
	 */
	
	/**
	 * The mongos high availability event
	 *
	 * @event Mongos#ha
	 * @type {function}
	 * @param {string} type The stage in the high availability event (start|end)
	 * @param {boolean} data.norepeat This is a repeating high availability process or a single execution only
	 * @param {number} data.id The id for this high availability request
	 * @param {object} data.state An object containing the information about the current replicaset
	 */
	
	/**
	 * A server member left the mongos set
	 *
	 * @event Mongos#left
	 * @type {function}
	 * @param {string} type The type of member that left (primary|secondary|arbiter)
	 * @param {Server} server The server object that left
	 */
	
	/**
	 * A server member joined the mongos set
	 *
	 * @event Mongos#joined
	 * @type {function}
	 * @param {string} type The type of member that joined (primary|secondary|arbiter)
	 * @param {Server} server The server object that joined
	 */
	
	/**
	 * Mongos fullsetup event, emitted when all proxies in the topology have been connected to.
	 *
	 * @event Mongos#fullsetup
	 * @type {Mongos}
	 */
	
	/**
	 * Mongos open event, emitted when mongos can start processing commands.
	 *
	 * @event Mongos#open
	 * @type {Mongos}
	 */
	
	/**
	 * Mongos close event
	 *
	 * @event Mongos#close
	 * @type {object}
	 */
	
	/**
	 * Mongos error event, emitted if there is an error listener.
	 *
	 * @event Mongos#error
	 * @type {MongoError}
	 */
	
	/**
	 * Mongos timeout event
	 *
	 * @event Mongos#timeout
	 * @type {object}
	 */
	
	/**
	 * Mongos parseError event
	 *
	 * @event Mongos#parseError
	 * @type {object}
	 */
	
	module.exports = Mongos;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var EventEmitter = __webpack_require__(6).EventEmitter
	  , inherits = __webpack_require__(1).inherits
	  , f = __webpack_require__(1).format
	  , Server = __webpack_require__(60)
	  , Cursor = __webpack_require__(17)
	  , AggregationCursor = __webpack_require__(27)
	  , CommandCursor = __webpack_require__(23)
	  , ReadPreference = __webpack_require__(16)
	  , MongoError = __webpack_require__(3).MongoError
	  , ServerCapabilities = __webpack_require__(28).ServerCapabilities
	  , Store = __webpack_require__(28).Store
	  , Define = __webpack_require__(13)
	  , CReplSet = __webpack_require__(3).ReplSet
	  , CoreReadPreference = __webpack_require__(3).ReadPreference
	  , MAX_JS_INT = __webpack_require__(2).MAX_JS_INT
	  , translateOptions = __webpack_require__(2).translateOptions
	  , filterOptions = __webpack_require__(2).filterOptions
	  , getReadPreference = __webpack_require__(2).getReadPreference
	  , mergeOptions = __webpack_require__(2).mergeOptions
	  , os = __webpack_require__(49);
	/**
	 * @fileOverview The **ReplSet** class is a class that represents a Replicaset topology and is
	 * used to construct connections.
	 *
	 * **ReplSet Should not be used, use MongoClient.connect**
	 * @example
	 * var Db = require('mongodb').Db,
	 *   ReplSet = require('mongodb').ReplSet,
	 *   Server = require('mongodb').Server,
	 *   test = require('assert');
	 * // Connect using ReplSet
	 * var server = new Server('localhost', 27017);
	 * var db = new Db('test', new ReplSet([server]));
	 * db.open(function(err, db) {
	 *   // Get an additional db
	 *   db.close();
	 * });
	 */
	
	// Allowed parameters
	var legalOptionNames = ['ha', 'haInterval', 'replicaSet', 'rs_name', 'secondaryAcceptableLatencyMS'
	  , 'connectWithNoPrimary', 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate'
	  , 'sslCA', 'sslCert', 'sslCRL', 'sslKey', 'sslPass', 'socketOptions', 'bufferMaxEntries'
	  , 'store', 'auto_reconnect', 'autoReconnect', 'emitError'
	  , 'keepAlive', 'noDelay', 'connectTimeoutMS', 'socketTimeoutMS', 'strategy', 'debug', 'family'
	  , 'loggerLevel', 'logger', 'reconnectTries', 'appname', 'domainsEnabled'
	  , 'servername', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'maxStalenessSeconds'];
	
	// Get package.json variable
	var driverVersion = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../package.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).version;
	var nodejsversion = f('Node.js %s, %s', process.version, os.endianness());
	var type = os.type();
	var name = process.platform;
	var architecture = process.arch;
	var release = os.release();
	
	/**
	 * Creates a new ReplSet instance
	 * @class
	 * @deprecated
	 * @param {Server[]} servers A seedlist of servers participating in the replicaset.
	 * @param {object} [options=null] Optional settings.
	 * @param {boolean} [options.ha=true] Turn on high availability monitoring.
	 * @param {number} [options.haInterval=10000] Time between each replicaset status check.
	 * @param {string} [options.replicaSet] The name of the replicaset to connect to.
	 * @param {number} [options.secondaryAcceptableLatencyMS=15] Sets the range of servers to pick when using NEAREST (lowest ping ms + the latency fence, ex: range of 1 to (1 + 15) ms)
	 * @param {boolean} [options.connectWithNoPrimary=false] Sets if the driver should connect even if no primary is available
	 * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.
	 * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {object} [options.sslValidate=true] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {array} [options.sslCA=null] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {array} [options.sslCRL=null] Array of revocation certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslCert=null] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslKey=null] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {(Buffer|string)} [options.sslPass=null] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)
	 * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.
	 * @param {object} [options.socketOptions=null] Socket options
	 * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option.
	 * @param {number} [options.socketOptions.keepAlive=0] TCP KeepAlive on the socket with a X ms delay before start.
	 * @param {number} [options.socketOptions.connectTimeoutMS=10000] TCP Connection timeout setting
	 * @param {number} [options.socketOptions.socketTimeoutMS=0] TCP Socket timeout setting
	 * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
	 * @param {number} [options.maxStalenessSeconds=undefined] The max staleness to secondary reads (values under 10 seconds cannot be guaranteed);
	 * @fires ReplSet#connect
	 * @fires ReplSet#ha
	 * @fires ReplSet#joined
	 * @fires ReplSet#left
	 * @fires ReplSet#fullsetup
	 * @fires ReplSet#open
	 * @fires ReplSet#close
	 * @fires ReplSet#error
	 * @fires ReplSet#timeout
	 * @fires ReplSet#parseError
	 * @property {string} parserType the parser type used (c++ or js).
	 * @return {ReplSet} a ReplSet instance.
	 */
	var ReplSet = function(servers, options) {
	  if(!(this instanceof ReplSet)) return new ReplSet(servers, options);
	  options = options || {};
	  var self = this;
	  // Set up event emitter
	  EventEmitter.call(this);
	
	  // Filter the options
	  options = filterOptions(options, legalOptionNames);
	
	  // Ensure all the instances are Server
	  for(var i = 0; i < servers.length; i++) {
	    if(!(servers[i] instanceof Server)) {
	      throw MongoError.create({message: "all seed list instances must be of the Server type", driver:true});
	    }
	  }
	
	  // Stored options
	  var storeOptions = {
	      force: false
	    , bufferMaxEntries: typeof options.bufferMaxEntries == 'number' ? options.bufferMaxEntries : MAX_JS_INT
	  }
	
	  // Shared global store
	  var store = options.store || new Store(self, storeOptions);
	
	  // Build seed list
	  var seedlist = servers.map(function(x) {
	    return {host: x.host, port: x.port}
	  });
	
	  // Clone options
	  var clonedOptions = mergeOptions({}, {
	    disconnectHandler: store,
	    cursorFactory: Cursor,
	    reconnect: false,
	    emitError: typeof options.emitError == 'boolean' ? options.emitError : true,
	    size: typeof options.poolSize == 'number' ? options.poolSize : 5
	  });
	
	  // Translate any SSL options and other connectivity options
	  clonedOptions = translateOptions(clonedOptions, options);
	
	  // Socket options
	  var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0
	    ? options.socketOptions : options;
	
	  // Translate all the options to the mongodb-core ones
	  clonedOptions = translateOptions(clonedOptions, socketOptions);
	  if(typeof clonedOptions.keepAlive == 'number') {
	    clonedOptions.keepAliveInitialDelay = clonedOptions.keepAlive;
	    clonedOptions.keepAlive = clonedOptions.keepAlive > 0;
	  }
	
	  // Client info
	  this.clientInfo = {
	    driver: {
	      name: "nodejs",
	      version: driverVersion
	    },
	    os: {
	      type: type,
	      name: name,
	      architecture: architecture,
	      version: release
	    },
	    platform: nodejsversion
	  }
	
	  // Build default client information
	  clonedOptions.clientInfo = this.clientInfo;
	  // Do we have an application specific string
	  if(options.appname) {
	    clonedOptions.clientInfo.application = { name: options.appname };
	  }
	
	  // Create the ReplSet
	  var replset = new CReplSet(seedlist, clonedOptions);
	
	  // Listen to reconnect event
	  replset.on('reconnect', function() {
	    self.emit('reconnect');
	    store.execute();
	  });
	
	  // Internal state
	  this.s = {
	    // Replicaset
	    replset: replset
	    // Server capabilities
	    , sCapabilities: null
	    // Debug tag
	    , tag: options.tag
	    // Store options
	    , storeOptions: storeOptions
	    // Cloned options
	    , clonedOptions: clonedOptions
	    // Store
	    , store: store
	    // Options
	    , options: options
	  }
	
	  // Debug
	  if(clonedOptions.debug) {
	    // Last ismaster
	    Object.defineProperty(this, 'replset', {
	      enumerable:true, get: function() { return replset; }
	    });
	  }
	}
	
	/**
	 * @ignore
	 */
	inherits(ReplSet, EventEmitter);
	
	// Last ismaster
	Object.defineProperty(ReplSet.prototype, 'isMasterDoc', {
	  enumerable:true, get: function() { return this.s.replset.lastIsMaster(); }
	});
	
	Object.defineProperty(ReplSet.prototype, 'parserType', {
	  enumerable:true, get: function() {
	    return this.s.replset.parserType;
	  }
	});
	
	// BSON property
	Object.defineProperty(ReplSet.prototype, 'bson', {
	  enumerable: true, get: function() {
	    return this.s.replset.s.bson;
	  }
	});
	
	Object.defineProperty(ReplSet.prototype, 'haInterval', {
	  enumerable:true, get: function() { return this.s.replset.s.haInterval; }
	});
	
	var define = ReplSet.define = new Define('ReplSet', ReplSet, false);
	
	// Ensure the right read Preference object
	var translateReadPreference = function(options) {
	  if(typeof options.readPreference == 'string') {
	    options.readPreference = new CoreReadPreference(options.readPreference);
	  } else if(options.readPreference instanceof ReadPreference) {
	    options.readPreference = new CoreReadPreference(options.readPreference.mode
	      , options.readPreference.tags, {maxStalenessSeconds: options.readPreference.maxStalenessSeconds});
	  }
	
	  return options;
	}
	
	// Connect method
	ReplSet.prototype.connect = function(db, _options, callback) {
	  var self = this;
	  if('function' === typeof _options) callback = _options, _options = {};
	  if(_options == null) _options = {};
	  if(!('function' === typeof callback)) callback = null;
	  self.s.options = _options;
	
	  // Update bufferMaxEntries
	  self.s.storeOptions.bufferMaxEntries = db.bufferMaxEntries;
	
	  // Actual handler
	  var errorHandler = function(event) {
	    return function(err) {
	      if(event != 'error') {
	        self.emit(event, err);
	      }
	    }
	  }
	
	  // Clear out all the current handlers left over
	  var events = ["timeout", "error", "close", 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted',
	    'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening',
	    'topologyClosed', 'topologyDescriptionChanged', 'joined', 'left', 'ping', 'ha'];
	  events.forEach(function(e) {
	    self.s.replset.removeAllListeners(e);
	  });
	
	  // relay the event
	  var relay = function(event) {
	    return function(t, server) {
	      self.emit(event, t, server);
	    }
	  }
	
	  // Replset events relay
	  var replsetRelay = function(event) {
	    return function(t, server) {
	      self.emit(event, t, server.lastIsMaster(), server);
	    }
	  }
	
	  // Relay ha
	  var relayHa = function(t, state) {
	    self.emit('ha', t, state);
	
	    if(t == 'start') {
	      self.emit('ha_connect', t, state);
	    } else if(t == 'end') {
	      self.emit('ha_ismaster', t, state);
	    }
	  }
	
	  // Set up serverConfig listeners
	  self.s.replset.on('joined', replsetRelay('joined'));
	  self.s.replset.on('left', relay('left'));
	  self.s.replset.on('ping', relay('ping'));
	  self.s.replset.on('ha', relayHa);
	
	  // Set up SDAM listeners
	  self.s.replset.on('serverDescriptionChanged', relay('serverDescriptionChanged'));
	  self.s.replset.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));
	  self.s.replset.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));
	  self.s.replset.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));
	  self.s.replset.on('serverOpening', relay('serverOpening'));
	  self.s.replset.on('serverClosed', relay('serverClosed'));
	  self.s.replset.on('topologyOpening', relay('topologyOpening'));
	  self.s.replset.on('topologyClosed', relay('topologyClosed'));
	  self.s.replset.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));
	
	  self.s.replset.on('fullsetup', function() {
	    self.emit('fullsetup', self, self);
	  });
	
	  self.s.replset.on('all', function() {
	    self.emit('all', null, self);
	  });
	
	  // Connect handler
	  var connectHandler = function() {
	    // Set up listeners
	    self.s.replset.once('timeout', errorHandler('timeout'));
	    self.s.replset.once('error', errorHandler('error'));
	    self.s.replset.once('close', errorHandler('close'));
	
	    // Emit open event
	    self.emit('open', null, self);
	
	    // Return correctly
	    try {
	      callback(null, self);
	    } catch(err) {
	      process.nextTick(function() { throw err; })
	    }
	  }
	
	  // Error handler
	  var connectErrorHandler = function() {
	    return function(err) {
	      ['timeout', 'error', 'close'].forEach(function(e) {
	        self.s.replset.removeListener(e, connectErrorHandler);
	      });
	
	      self.s.replset.removeListener('connect', connectErrorHandler);
	      // Destroy the replset
	      self.s.replset.destroy();
	
	      // Try to callback
	      try {
	        callback(err);
	      } catch(err) {
	        if(!self.s.replset.isConnected())
	          process.nextTick(function() { throw err; })
	      }
	    }
	  }
	
	  // Set up listeners
	  self.s.replset.once('timeout', connectErrorHandler('timeout'));
	  self.s.replset.once('error', connectErrorHandler('error'));
	  self.s.replset.once('close', connectErrorHandler('close'));
	  self.s.replset.once('connect', connectHandler);
	
	  // Start connection
	  self.s.replset.connect(_options);
	}
	
	// Server capabilities
	ReplSet.prototype.capabilities = function() {
	  if(this.s.sCapabilities) return this.s.sCapabilities;
	  if(this.s.replset.lastIsMaster() == null) return null;
	  this.s.sCapabilities = new ServerCapabilities(this.s.replset.lastIsMaster());
	  return this.s.sCapabilities;
	}
	
	define.classMethod('capabilities', {callback: false, promise:false, returns: [ServerCapabilities]});
	
	// Command
	ReplSet.prototype.command = function(ns, cmd, options, callback) {
	  this.s.replset.command(ns, cmd, getReadPreference(options), callback);
	}
	
	define.classMethod('command', {callback: true, promise:false});
	
	// Insert
	ReplSet.prototype.insert = function(ns, ops, options, callback) {
	  this.s.replset.insert(ns, ops, options, callback);
	}
	
	define.classMethod('insert', {callback: true, promise:false});
	
	// Update
	ReplSet.prototype.update = function(ns, ops, options, callback) {
	  this.s.replset.update(ns, ops, options, callback);
	}
	
	define.classMethod('update', {callback: true, promise:false});
	
	// Remove
	ReplSet.prototype.remove = function(ns, ops, options, callback) {
	  this.s.replset.remove(ns, ops, options, callback);
	}
	
	define.classMethod('remove', {callback: true, promise:false});
	
	// Destroyed
	ReplSet.prototype.isDestroyed = function() {
	  return this.s.replset.isDestroyed();
	}
	
	// IsConnected
	ReplSet.prototype.isConnected = function(options) {
	  options = options || {};
	
	  // If we passed in a readPreference, translate to
	  // a CoreReadPreference instance
	  if(options.readPreference) {
	    options.readPreference = translateReadPreference(options.readPreference);
	  }
	
	  return this.s.replset.isConnected(options);
	}
	
	define.classMethod('isConnected', {callback: false, promise:false, returns: [Boolean]});
	
	// Insert
	ReplSet.prototype.cursor = function(ns, cmd, options) {
	  options = translateReadPreference(options);
	  options.disconnectHandler = this.s.store;
	  return this.s.replset.cursor(ns, cmd, options);
	}
	
	define.classMethod('cursor', {callback: false, promise:false, returns: [Cursor, AggregationCursor, CommandCursor]});
	
	ReplSet.prototype.lastIsMaster = function() {
	  return this.s.replset.lastIsMaster();
	}
	
	/**
	 * Unref all sockets
	 * @method
	 */
	ReplSet.prototype.unref = function() {
	  return this.s.replset.unref();
	}
	
	ReplSet.prototype.close = function(forceClosed) {
	  var self = this;
	  // Call destroy on the topology
	  this.s.replset.destroy({
	    force: typeof forceClosed == 'boolean' ? forceClosed : false,
	  });
	  // We need to wash out all stored processes
	  if(forceClosed == true) {
	    this.s.storeOptions.force = forceClosed;
	    this.s.store.flush();
	  }
	
	  var events = ['timeout', 'error', 'close', 'joined', 'left'];
	  events.forEach(function(e) {
	    self.removeAllListeners(e);
	  });
	}
	
	define.classMethod('close', {callback: false, promise:false});
	
	ReplSet.prototype.auth = function() {
	  var args = Array.prototype.slice.call(arguments, 0);
	  this.s.replset.auth.apply(this.s.replset, args);
	}
	
	define.classMethod('auth', {callback: true, promise:false});
	
	ReplSet.prototype.logout = function() {
	  var args = Array.prototype.slice.call(arguments, 0);
	  this.s.replset.logout.apply(this.s.replset, args);
	}
	
	define.classMethod('logout', {callback: true, promise:false});
	
	/**
	 * All raw connections
	 * @method
	 * @return {array}
	 */
	ReplSet.prototype.connections = function() {
	  return this.s.replset.connections();
	}
	
	define.classMethod('connections', {callback: false, promise:false, returns:[Array]});
	
	/**
	 * A replset connect event, used to verify that the connection is up and running
	 *
	 * @event ReplSet#connect
	 * @type {ReplSet}
	 */
	
	/**
	 * The replset high availability event
	 *
	 * @event ReplSet#ha
	 * @type {function}
	 * @param {string} type The stage in the high availability event (start|end)
	 * @param {boolean} data.norepeat This is a repeating high availability process or a single execution only
	 * @param {number} data.id The id for this high availability request
	 * @param {object} data.state An object containing the information about the current replicaset
	 */
	
	/**
	 * A server member left the replicaset
	 *
	 * @event ReplSet#left
	 * @type {function}
	 * @param {string} type The type of member that left (primary|secondary|arbiter)
	 * @param {Server} server The server object that left
	 */
	
	/**
	 * A server member joined the replicaset
	 *
	 * @event ReplSet#joined
	 * @type {function}
	 * @param {string} type The type of member that joined (primary|secondary|arbiter)
	 * @param {Server} server The server object that joined
	 */
	
	/**
	 * ReplSet open event, emitted when replicaset can start processing commands.
	 *
	 * @event ReplSet#open
	 * @type {Replset}
	 */
	
	/**
	 * ReplSet fullsetup event, emitted when all servers in the topology have been connected to.
	 *
	 * @event ReplSet#fullsetup
	 * @type {Replset}
	 */
	
	/**
	 * ReplSet close event
	 *
	 * @event ReplSet#close
	 * @type {object}
	 */
	
	/**
	 * ReplSet error event, emitted if there is an error listener.
	 *
	 * @event ReplSet#error
	 * @type {MongoError}
	 */
	
	/**
	 * ReplSet timeout event
	 *
	 * @event ReplSet#timeout
	 * @type {object}
	 */
	
	/**
	 * ReplSet parseError event
	 *
	 * @event ReplSet#parseError
	 * @type {object}
	 */
	
	module.exports = ReplSet;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	var map = {
		"./collection": 130,
		"./drivers/node-mongodb-native/collection": 89
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 128;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies
	 */
	
	var AggregationCursor = __webpack_require__(210);
	var PromiseProvider = __webpack_require__(14);
	var Query = __webpack_require__(94);
	var eachAsync = __webpack_require__(144);
	var util = __webpack_require__(1);
	var utils = __webpack_require__(4);
	var read = Query.prototype.read;
	
	/**
	 * Aggregate constructor used for building aggregation pipelines.
	 *
	 * ####Example:
	 *
	 *     new Aggregate();
	 *     new Aggregate({ $project: { a: 1, b: 1 } });
	 *     new Aggregate({ $project: { a: 1, b: 1 } }, { $skip: 5 });
	 *     new Aggregate([{ $project: { a: 1, b: 1 } }, { $skip: 5 }]);
	 *
	 * Returned when calling Model.aggregate().
	 *
	 * ####Example:
	 *
	 *     Model
	 *     .aggregate({ $match: { age: { $gte: 21 }}})
	 *     .unwind('tags')
	 *     .exec(callback)
	 *
	 * ####Note:
	 *
	 * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).
	 * - Requires MongoDB >= 2.1
	 * - Mongoose does **not** cast pipeline stages. `new Aggregate({ $match: { _id: '00000000000000000000000a' } });` will not work unless `_id` is a string in the database. Use `new Aggregate({ $match: { _id: mongoose.Types.ObjectId('00000000000000000000000a') } });` instead.
	 *
	 * @see MongoDB http://docs.mongodb.org/manual/applications/aggregation/
	 * @see driver http://mongodb.github.com/node-mongodb-native/api-generated/collection.html#aggregate
	 * @param {Object|Array} [ops] aggregation operator(s) or operator array
	 * @api public
	 */
	
	function Aggregate() {
	  this._pipeline = [];
	  this._model = undefined;
	  this.options = {};
	
	  if (arguments.length === 1 && util.isArray(arguments[0])) {
	    this.append.apply(this, arguments[0]);
	  } else {
	    this.append.apply(this, arguments);
	  }
	}
	
	/**
	 * Binds this aggregate to a model.
	 *
	 * @param {Model} model the model to which the aggregate is to be bound
	 * @return {Aggregate}
	 * @api public
	 */
	
	Aggregate.prototype.model = function(model) {
	  this._model = model;
	  if (model.schema != null) {
	    if (this.options.readPreference == null &&
	        model.schema.options.read != null) {
	      this.options.readPreference = model.schema.options.read;
	    }
	    if (this.options.collation == null &&
	        model.schema.options.collation != null) {
	      this.options.collation = model.schema.options.collation;
	    }
	  }
	  return this;
	};
	
	/**
	 * Appends new operators to this aggregate pipeline
	 *
	 * ####Examples:
	 *
	 *     aggregate.append({ $project: { field: 1 }}, { $limit: 2 });
	 *
	 *     // or pass an array
	 *     var pipeline = [{ $match: { daw: 'Logic Audio X' }} ];
	 *     aggregate.append(pipeline);
	 *
	 * @param {Object} ops operator(s) to append
	 * @return {Aggregate}
	 * @api public
	 */
	
	Aggregate.prototype.append = function() {
	  var args = (arguments.length === 1 && util.isArray(arguments[0]))
	      ? arguments[0]
	      : utils.args(arguments);
	
	  if (!args.every(isOperator)) {
	    throw new Error('Arguments must be aggregate pipeline operators');
	  }
	
	  this._pipeline = this._pipeline.concat(args);
	
	  return this;
	};
	
	/**
	 * Appends a new $project operator to this aggregate pipeline.
	 *
	 * Mongoose query [selection syntax](#query_Query-select) is also supported.
	 *
	 * ####Examples:
	 *
	 *     // include a, include b, exclude _id
	 *     aggregate.project("a b -_id");
	 *
	 *     // or you may use object notation, useful when
	 *     // you have keys already prefixed with a "-"
	 *     aggregate.project({a: 1, b: 1, _id: 0});
	 *
	 *     // reshaping documents
	 *     aggregate.project({
	 *         newField: '$b.nested'
	 *       , plusTen: { $add: ['$val', 10]}
	 *       , sub: {
	 *            name: '$a'
	 *         }
	 *     })
	 *
	 *     // etc
	 *     aggregate.project({ salary_k: { $divide: [ "$salary", 1000 ] } });
	 *
	 * @param {Object|String} arg field specification
	 * @see projection http://docs.mongodb.org/manual/reference/aggregation/project/
	 * @return {Aggregate}
	 * @api public
	 */
	
	Aggregate.prototype.project = function(arg) {
	  var fields = {};
	
	  if (typeof arg === 'object' && !util.isArray(arg)) {
	    Object.keys(arg).forEach(function(field) {
	      fields[field] = arg[field];
	    });
	  } else if (arguments.length === 1 && typeof arg === 'string') {
	    arg.split(/\s+/).forEach(function(field) {
	      if (!field) {
	        return;
	      }
	      var include = field[0] === '-' ? 0 : 1;
	      if (include === 0) {
	        field = field.substring(1);
	      }
	      fields[field] = include;
	    });
	  } else {
	    throw new Error('Invalid project() argument. Must be string or object');
	  }
	
	  return this.append({$project: fields});
	};
	
	/**
	 * Appends a new custom $group operator to this aggregate pipeline.
	 *
	 * ####Examples:
	 *
	 *     aggregate.group({ _id: "$department" });
	 *
	 * @see $group http://docs.mongodb.org/manual/reference/aggregation/group/
	 * @method group
	 * @memberOf Aggregate
	 * @param {Object} arg $group operator contents
	 * @return {Aggregate}
	 * @api public
	 */
	
	/**
	 * Appends a new custom $match operator to this aggregate pipeline.
	 *
	 * ####Examples:
	 *
	 *     aggregate.match({ department: { $in: [ "sales", "engineering" ] } });
	 *
	 * @see $match http://docs.mongodb.org/manual/reference/aggregation/match/
	 * @method match
	 * @memberOf Aggregate
	 * @param {Object} arg $match operator contents
	 * @return {Aggregate}
	 * @api public
	 */
	
	/**
	 * Appends a new $skip operator to this aggregate pipeline.
	 *
	 * ####Examples:
	 *
	 *     aggregate.skip(10);
	 *
	 * @see $skip http://docs.mongodb.org/manual/reference/aggregation/skip/
	 * @method skip
	 * @memberOf Aggregate
	 * @param {Number} num number of records to skip before next stage
	 * @return {Aggregate}
	 * @api public
	 */
	
	/**
	 * Appends a new $limit operator to this aggregate pipeline.
	 *
	 * ####Examples:
	 *
	 *     aggregate.limit(10);
	 *
	 * @see $limit http://docs.mongodb.org/manual/reference/aggregation/limit/
	 * @method limit
	 * @memberOf Aggregate
	 * @param {Number} num maximum number of records to pass to the next stage
	 * @return {Aggregate}
	 * @api public
	 */
	
	/**
	 * Appends a new $geoNear operator to this aggregate pipeline.
	 *
	 * ####NOTE:
	 *
	 * **MUST** be used as the first operator in the pipeline.
	 *
	 * ####Examples:
	 *
	 *     aggregate.near({
	 *       near: [40.724, -73.997],
	 *       distanceField: "dist.calculated", // required
	 *       maxDistance: 0.008,
	 *       query: { type: "public" },
	 *       includeLocs: "dist.location",
	 *       uniqueDocs: true,
	 *       num: 5
	 *     });
	 *
	 * @see $geoNear http://docs.mongodb.org/manual/reference/aggregation/geoNear/
	 * @method near
	 * @memberOf Aggregate
	 * @param {Object} parameters
	 * @return {Aggregate}
	 * @api public
	 */
	
	Aggregate.prototype.near = function(arg) {
	  var op = {};
	  op.$geoNear = arg;
	  return this.append(op);
	};
	
	/*!
	 * define methods
	 */
	
	'group match skip limit out'.split(' ').forEach(function($operator) {
	  Aggregate.prototype[$operator] = function(arg) {
	    var op = {};
	    op['$' + $operator] = arg;
	    return this.append(op);
	  };
	});
	
	/**
	 * Appends new custom $unwind operator(s) to this aggregate pipeline.
	 *
	 * Note that the `$unwind` operator requires the path name to start with '$'.
	 * Mongoose will prepend '$' if the specified field doesn't start '$'.
	 *
	 * ####Examples:
	 *
	 *     aggregate.unwind("tags");
	 *     aggregate.unwind("a", "b", "c");
	 *
	 * @see $unwind http://docs.mongodb.org/manual/reference/aggregation/unwind/
	 * @param {String} fields the field(s) to unwind
	 * @return {Aggregate}
	 * @api public
	 */
	
	Aggregate.prototype.unwind = function() {
	  var args = utils.args(arguments);
	
	  var res = [];
	  for (var i = 0; i < args.length; ++i) {
	    var arg = args[i];
	    if (arg && typeof arg === 'object') {
	      res.push({ $unwind: arg });
	    } else if (typeof arg === 'string') {
	      res.push({
	        $unwind: (arg && arg.charAt(0) === '$') ? arg : '$' + arg
	      });
	    } else {
	      throw new Error('Invalid arg "' + arg + '" to unwind(), ' +
	        'must be string or object');
	    }
	  }
	
	  return this.append.apply(this, res);
	};
	
	/**
	 * Appends new custom $lookup operator(s) to this aggregate pipeline.
	 *
	 * ####Examples:
	 *
	 *     aggregate.lookup({ from: 'users', localField: 'userId', foreignField: '_id', as: 'users' });
	 *
	 * @see $lookup https://docs.mongodb.org/manual/reference/operator/aggregation/lookup/#pipe._S_lookup
	 * @param {Object} options to $lookup as described in the above link
	 * @return {Aggregate}
	 * @api public
	 */
	
	Aggregate.prototype.lookup = function(options) {
	  return this.append({$lookup: options});
	};
	
	/**
	 * Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.
	 *
	 * Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if `{ allowDiskUse: true }` is specified.
	 *
	 * #### Examples:
	 *      // Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: 'Calculus', prerequisite: 'Trigonometry'}` and `{ _id: 0, name: 'Trigonometry', prerequisite: 'Algebra' }`
	 *      aggregate.graphLookup({ from: 'courses', startWith: '$prerequisite', connectFromField: 'prerequisite', connectToField: 'name', as: 'prerequisites', maxDepth: 3 }) // this will recursively search the 'courses' collection up to 3 prerequisites
	 *
	 * @see $graphLookup https://docs.mongodb.com/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup
	 * @param {Object} options to $graphLookup as described in the above link
	 * @return {Aggregate}
	 * @api public
	 */
	
	Aggregate.prototype.graphLookup = function(options) {
	  var cloneOptions = {};
	  if (options) {
	    if (!utils.isObject(options)) {
	      throw new TypeError('Invalid graphLookup() argument. Must be an object.');
	    }
	
	    utils.mergeClone(cloneOptions, options);
	    var startWith = cloneOptions.startWith;
	
	    if (startWith && typeof startWith === 'string') {
	      cloneOptions.startWith = cloneOptions.startWith.charAt(0) === '$' ?
	        cloneOptions.startWith :
	        '$' + cloneOptions.startWith;
	    }
	
	  }
	  return this.append({ $graphLookup: cloneOptions });
	};
	
	/**
	 * Appepnds new custom $sample operator(s) to this aggregate pipeline.
	 *
	 * ####Examples:
	 *
	 *     aggregate.sample(3); // Add a pipeline that picks 3 random documents
	 *
	 * @see $sample https://docs.mongodb.org/manual/reference/operator/aggregation/sample/#pipe._S_sample
	 * @param {Number} size number of random documents to pick
	 * @return {Aggregate}
	 * @api public
	 */
	
	Aggregate.prototype.sample = function(size) {
	  return this.append({$sample: {size: size}});
	};
	
	/**
	 * Appends a new $sort operator to this aggregate pipeline.
	 *
	 * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.
	 *
	 * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.
	 *
	 * ####Examples:
	 *
	 *     // these are equivalent
	 *     aggregate.sort({ field: 'asc', test: -1 });
	 *     aggregate.sort('field -test');
	 *
	 * @see $sort http://docs.mongodb.org/manual/reference/aggregation/sort/
	 * @param {Object|String} arg
	 * @return {Aggregate} this
	 * @api public
	 */
	
	Aggregate.prototype.sort = function(arg) {
	  // TODO refactor to reuse the query builder logic
	
	  var sort = {};
	
	  if (arg.constructor.name === 'Object') {
	    var desc = ['desc', 'descending', -1];
	    Object.keys(arg).forEach(function(field) {
	      // If sorting by text score, skip coercing into 1/-1
	      if (arg[field] instanceof Object && arg[field].$meta) {
	        sort[field] = arg[field];
	        return;
	      }
	      sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;
	    });
	  } else if (arguments.length === 1 && typeof arg === 'string') {
	    arg.split(/\s+/).forEach(function(field) {
	      if (!field) {
	        return;
	      }
	      var ascend = field[0] === '-' ? -1 : 1;
	      if (ascend === -1) {
	        field = field.substring(1);
	      }
	      sort[field] = ascend;
	    });
	  } else {
	    throw new TypeError('Invalid sort() argument. Must be a string or object.');
	  }
	
	  return this.append({$sort: sort});
	};
	
	/**
	 * Sets the readPreference option for the aggregation query.
	 *
	 * ####Example:
	 *
	 *     Model.aggregate(..).read('primaryPreferred').exec(callback)
	 *
	 * @param {String} pref one of the listed preference options or their aliases
	 * @param {Array} [tags] optional tags for this query
	 * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
	 * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences
	 */
	
	Aggregate.prototype.read = function(pref, tags) {
	  if (!this.options) {
	    this.options = {};
	  }
	  read.call(this, pref, tags);
	  return this;
	};
	
	/**
	 * Execute the aggregation with explain
	 *
	 * ####Example:
	 *
	 *     Model.aggregate(..).explain(callback)
	 *
	 * @param {Function} callback
	 * @return {Promise}
	 */
	
	Aggregate.prototype.explain = function(callback) {
	  var _this = this;
	  var Promise = PromiseProvider.get();
	  return new Promise.ES6(function(resolve, reject) {
	    if (!_this._pipeline.length) {
	      var err = new Error('Aggregate has empty pipeline');
	      if (callback) {
	        callback(err);
	      }
	      reject(err);
	      return;
	    }
	
	    prepareDiscriminatorPipeline(_this);
	
	    _this._model
	        .collection
	        .aggregate(_this._pipeline, _this.options || {})
	        .explain(function(error, result) {
	          if (error) {
	            if (callback) {
	              callback(error);
	            }
	            reject(error);
	            return;
	          }
	
	          if (callback) {
	            callback(null, result);
	          }
	          resolve(result);
	        });
	  });
	};
	
	/**
	 * Sets the allowDiskUse option for the aggregation query (ignored for < 2.6.0)
	 *
	 * ####Example:
	 *
	 *     Model.aggregate(..).allowDiskUse(true).exec(callback)
	 *
	 * @param {Boolean} value Should tell server it can use hard drive to store data during aggregation.
	 * @param {Array} [tags] optional tags for this query
	 * @see mongodb http://docs.mongodb.org/manual/reference/command/aggregate/
	 */
	
	Aggregate.prototype.allowDiskUse = function(value) {
	  if (!this.options) {
	    this.options = {};
	  }
	  this.options.allowDiskUse = value;
	  return this;
	};
	
	/**
	 * Sets the cursor option option for the aggregation query (ignored for < 2.6.0).
	 * Note the different syntax below: .exec() returns a cursor object, and no callback
	 * is necessary.
	 *
	 * ####Example:
	 *
	 *     var cursor = Model.aggregate(..).cursor({ batchSize: 1000 }).exec();
	 *     cursor.each(function(error, doc) {
	 *       // use doc
	 *     });
	 *
	 * @param {Object} options
	 * @param {Number} options.batchSize set the cursor batch size
	 * @param {Boolean} [options.useMongooseAggCursor] use experimental mongoose-specific aggregation cursor (for `eachAsync()` and other query cursor semantics)
	 * @see mongodb http://mongodb.github.io/node-mongodb-native/2.0/api/AggregationCursor.html
	 */
	
	Aggregate.prototype.cursor = function(options) {
	  if (!this.options) {
	    this.options = {};
	  }
	  this.options.cursor = options || {};
	  return this;
	};
	
	/**
	 * Adds a [cursor flag](http://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag)
	 *
	 * ####Example:
	 *
	 *     Model.aggregate(..).addCursorFlag('noCursorTimeout', true).exec();
	 *
	 * @param {String} flag
	 * @param {Boolean} value
	 * @see mongodb http://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag
	 */
	
	Aggregate.prototype.addCursorFlag = function(flag, value) {
	  if (!this.options) {
	    this.options = {};
	  }
	  this.options[flag] = value;
	  return this;
	};
	
	/**
	 * Adds a collation
	 *
	 * ####Example:
	 *
	 *     Model.aggregate(..).collation({ locale: 'en_US', strength: 1 }).exec();
	 *
	 * @param {Object} collation options
	 * @param {Boolean} value
	 * @see mongodb http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#aggregate
	 */
	
	Aggregate.prototype.collation = function(collation) {
	  if (!this.options) {
	    this.options = {};
	  }
	  this.options.collation = collation;
	  return this;
	};
	
	/**
	 * Combines multiple aggregation pipelines.
	 *
	 * ####Example:
	 *     Model.aggregate(...)
	 *      .facet({
	 *        books: [{ groupBy: '$author' }],
	 *        price: [{ $bucketAuto: { groupBy: '$price', buckets: 2 } }]
	 *      })
	 *      .exec();
	 *
	 *     // Output: { books: [...], price: [{...}, {...}] }
	 *
	 * @param {Object} facet options
	 * @return {Aggregate} this
	 * @see $facet https://docs.mongodb.com/v3.4/reference/operator/aggregation/facet/
	 * @api public
	 */
	
	Aggregate.prototype.facet = function(options) {
	  return this.append({$facet: options});
	};
	
	/**
	 * Executes the aggregate pipeline on the currently bound Model.
	 *
	 * ####Example:
	 *
	 *     aggregate.exec(callback);
	 *
	 *     // Because a promise is returned, the `callback` is optional.
	 *     var promise = aggregate.exec();
	 *     promise.then(..);
	 *
	 * @see Promise #promise_Promise
	 * @param {Function} [callback]
	 * @return {Promise}
	 * @api public
	 */
	
	Aggregate.prototype.exec = function(callback) {
	  if (!this._model) {
	    throw new Error('Aggregate not bound to any Model');
	  }
	  var _this = this;
	  var Promise = PromiseProvider.get();
	  var options = utils.clone(this.options);
	
	  if (options && options.cursor) {
	    if (options.cursor.async) {
	      delete options.cursor.async;
	      return new Promise.ES6(function(resolve) {
	        if (!_this._model.collection.buffer) {
	          process.nextTick(function() {
	            var cursor = _this._model.collection.
	              aggregate(_this._pipeline, options || {});
	            decorateCursor(cursor);
	            resolve(cursor);
	            callback && callback(null, cursor);
	          });
	          return;
	        }
	        _this._model.collection.emitter.once('queue', function() {
	          var cursor = _this._model.collection.
	            aggregate(_this._pipeline, options || {});
	          decorateCursor(cursor);
	          resolve(cursor);
	          callback && callback(null, cursor);
	        });
	      });
	    } else if (options.cursor.useMongooseAggCursor) {
	      delete options.cursor.useMongooseAggCursor;
	      return new AggregationCursor(this);
	    }
	    var cursor = this._model.collection.
	      aggregate(this._pipeline, this.options || {});
	    decorateCursor(cursor);
	    return cursor;
	  }
	
	  return new Promise.ES6(function(resolve, reject) {
	    if (!_this._pipeline.length) {
	      var err = new Error('Aggregate has empty pipeline');
	      if (callback) {
	        callback(err);
	      }
	      reject(err);
	      return;
	    }
	
	    prepareDiscriminatorPipeline(_this);
	
	    _this._model
	        .collection
	        .aggregate(_this._pipeline, _this.options || {}, function(error, result) {
	          if (error) {
	            if (callback) {
	              callback(error);
	            }
	            reject(error);
	            return;
	          }
	
	          if (callback) {
	            callback(null, result);
	          }
	          resolve(result);
	        });
	  });
	};
	
	/*!
	 * Add `eachAsync()` to aggregation cursors
	 */
	
	function decorateCursor(cursor) {
	  cursor.eachAsync = function(fn, opts, callback) {
	    if (typeof opts === 'function') {
	      callback = opts;
	      opts = {};
	    }
	    opts = opts || {};
	
	    return eachAsync(function(cb) { return cursor.next(cb); }, fn, opts, callback);
	  };
	}
	
	/**
	 * Provides promise for aggregate.
	 *
	 * ####Example:
	 *
	 *     Model.aggregate(..).then(successCallback, errorCallback);
	 *
	 * @see Promise #promise_Promise
	 * @param {Function} [resolve] successCallback
	 * @param {Function} [reject]  errorCallback
	 * @return {Promise}
	 */
	Aggregate.prototype.then = function(resolve, reject) {
	  return this.exec().then(resolve, reject);
	};
	
	/*!
	 * Helpers
	 */
	
	/**
	 * Checks whether an object is likely a pipeline operator
	 *
	 * @param {Object} obj object to check
	 * @return {Boolean}
	 * @api private
	 */
	
	function isOperator(obj) {
	  var k;
	
	  if (typeof obj !== 'object') {
	    return false;
	  }
	
	  k = Object.keys(obj);
	
	  return k.length === 1 && k
	          .some(function(key) {
	            return key[0] === '$';
	          });
	}
	
	/*!
	 * Adds the appropriate `$match` pipeline step to the top of an aggregate's
	 * pipeline, should it's model is a non-root discriminator type. This is
	 * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.
	 *
	 * @param {Aggregate} aggregate Aggregate to prepare
	 */
	
	function prepareDiscriminatorPipeline(aggregate) {
	  var schema = aggregate._model.schema,
	      discriminatorMapping = schema && schema.discriminatorMapping;
	
	  if (discriminatorMapping && !discriminatorMapping.isRoot) {
	    var originalPipeline = aggregate._pipeline,
	        discriminatorKey = discriminatorMapping.key,
	        discriminatorValue = discriminatorMapping.value;
	
	    // If the first pipeline stage is a match and it doesn't specify a `__t`
	    // key, add the discriminator key to it. This allows for potential
	    // aggregation query optimizations not to be disturbed by this feature.
	    if (originalPipeline[0] && originalPipeline[0].$match && !originalPipeline[0].$match[discriminatorKey]) {
	      originalPipeline[0].$match[discriminatorKey] = discriminatorValue;
	      // `originalPipeline` is a ref, so there's no need for
	      // aggregate._pipeline = originalPipeline
	    } else if (originalPipeline[0] && originalPipeline[0].$geoNear) {
	      originalPipeline[0].$geoNear.query =
	          originalPipeline[0].$geoNear.query || {};
	      originalPipeline[0].$geoNear.query[discriminatorKey] = discriminatorValue;
	    } else {
	      var match = {};
	      match[discriminatorKey] = discriminatorValue;
	      aggregate._pipeline = [{$match: match}].concat(originalPipeline);
	    }
	  }
	}
	
	
	/*!
	 * Exports
	 */
	
	module.exports = Aggregate;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var EventEmitter = __webpack_require__(6).EventEmitter;
	var STATES = __webpack_require__(61);
	
	/**
	 * Abstract Collection constructor
	 *
	 * This is the base class that drivers inherit from and implement.
	 *
	 * @param {String} name name of the collection
	 * @param {Connection} conn A MongooseConnection instance
	 * @param {Object} opts optional collection options
	 * @api public
	 */
	
	function Collection(name, conn, opts) {
	  if (opts === void 0) {
	    opts = {};
	  }
	  if (opts.capped === void 0) {
	    opts.capped = {};
	  }
	
	  opts.bufferCommands = undefined === opts.bufferCommands
	      ? true
	      : opts.bufferCommands;
	
	  if (typeof opts.capped === 'number') {
	    opts.capped = {size: opts.capped};
	  }
	
	  this.opts = opts;
	  this.name = name;
	  this.collectionName = name;
	  this.conn = conn;
	  this.queue = [];
	  this.buffer = this.opts.bufferCommands;
	  this.emitter = new EventEmitter();
	
	  if (STATES.connected === this.conn.readyState) {
	    this.onOpen();
	  }
	}
	
	/**
	 * The collection name
	 *
	 * @api public
	 * @property name
	 */
	
	Collection.prototype.name;
	
	/**
	 * The collection name
	 *
	 * @api public
	 * @property collectionName
	 */
	
	Collection.prototype.collectionName;
	
	/**
	 * The Connection instance
	 *
	 * @api public
	 * @property conn
	 */
	
	Collection.prototype.conn;
	
	/**
	 * Called when the database connects
	 *
	 * @api private
	 */
	
	Collection.prototype.onOpen = function() {
	  this.buffer = false;
	  this.doQueue();
	};
	
	/**
	 * Called when the database disconnects
	 *
	 * @api private
	 */
	
	Collection.prototype.onClose = function(force) {
	  if (this.opts.bufferCommands && !force) {
	    this.buffer = true;
	  }
	};
	
	/**
	 * Queues a method for later execution when its
	 * database connection opens.
	 *
	 * @param {String} name name of the method to queue
	 * @param {Array} args arguments to pass to the method when executed
	 * @api private
	 */
	
	Collection.prototype.addQueue = function(name, args) {
	  this.queue.push([name, args]);
	  return this;
	};
	
	/**
	 * Executes all queued methods and clears the queue.
	 *
	 * @api private
	 */
	
	Collection.prototype.doQueue = function() {
	  for (var i = 0, l = this.queue.length; i < l; i++) {
	    if (typeof this.queue[i][0] === 'function') {
	      this.queue[i][0].apply(this, this.queue[i][1]);
	    } else {
	      this[this.queue[i][0]].apply(this, this.queue[i][1]);
	    }
	  }
	  this.queue = [];
	  var _this = this;
	  process.nextTick(function() {
	    _this.emitter.emit('queue');
	  });
	  return this;
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.ensureIndex = function() {
	  throw new Error('Collection#ensureIndex unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.createIndex = function() {
	  throw new Error('Collection#ensureIndex unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.findAndModify = function() {
	  throw new Error('Collection#findAndModify unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.findOne = function() {
	  throw new Error('Collection#findOne unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.find = function() {
	  throw new Error('Collection#find unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.insert = function() {
	  throw new Error('Collection#insert unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.save = function() {
	  throw new Error('Collection#save unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.update = function() {
	  throw new Error('Collection#update unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.getIndexes = function() {
	  throw new Error('Collection#getIndexes unimplemented by driver');
	};
	
	/**
	 * Abstract method that drivers must implement.
	 */
	
	Collection.prototype.mapReduce = function() {
	  throw new Error('Collection#mapReduce unimplemented by driver');
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = Collection;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var utils = __webpack_require__(4);
	var EventEmitter = __webpack_require__(6).EventEmitter;
	var driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native';
	var Schema = __webpack_require__(45);
	var Collection = __webpack_require__(128)(driver + '/collection');
	var STATES = __webpack_require__(61);
	var MongooseError = __webpack_require__(5);
	var muri = __webpack_require__(251);
	var PromiseProvider = __webpack_require__(14);
	var mongodb = __webpack_require__(22);
	var util = __webpack_require__(1);
	
	/*!
	 * Protocol prefix regexp.
	 *
	 * @api private
	 */
	
	var rgxProtocol = /^(?:.)+:\/\//;
	
	/*!
	 * A list of authentication mechanisms that don't require a password for authentication.
	 * This is used by the authMechanismDoesNotRequirePassword method.
	 *
	 * @api private
	 */
	var authMechanismsWhichDontRequirePassword = [
	  'MONGODB-X509'
	];
	
	/**
	 * Connection constructor
	 *
	 * For practical reasons, a Connection equals a Db.
	 *
	 * @param {Mongoose} base a mongoose instance
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `connecting`: Emitted when `connection.{open,openSet}()` is executed on this connection.
	 * @event `connected`: Emitted when this connection successfully connects to the db. May be emitted _multiple_ times in `reconnected` scenarios.
	 * @event `open`: Emitted after we `connected` and `onOpen` is executed on all of this connections models.
	 * @event `disconnecting`: Emitted when `connection.close()` was executed.
	 * @event `disconnected`: Emitted after getting disconnected from the db.
	 * @event `close`: Emitted after we `disconnected` and `onClose` executed on all of this connections models.
	 * @event `reconnected`: Emitted after we `connected` and subsequently `disconnected`, followed by successfully another successfull connection.
	 * @event `error`: Emitted when an error occurs on this connection.
	 * @event `fullsetup`: Emitted in a replica-set scenario, when primary and at least one seconaries specified in the connection string are connected.
	 * @event `all`: Emitted in a replica-set scenario, when all nodes specified in the connection string are connected.
	 * @api public
	 */
	
	function Connection(base) {
	  this.base = base;
	  this.collections = {};
	  this.models = {};
	  this.config = {autoIndex: true};
	  this.replica = false;
	  this.hosts = null;
	  this.host = null;
	  this.port = null;
	  this.user = null;
	  this.pass = null;
	  this.name = null;
	  this.options = null;
	  this.otherDbs = [];
	  this.states = STATES;
	  this._readyState = STATES.disconnected;
	  this._closeCalled = false;
	  this._hasOpened = false;
	}
	
	/*!
	 * Inherit from EventEmitter
	 */
	
	Connection.prototype.__proto__ = EventEmitter.prototype;
	
	/**
	 * Connection ready state
	 *
	 * - 0 = disconnected
	 * - 1 = connected
	 * - 2 = connecting
	 * - 3 = disconnecting
	 *
	 * Each state change emits its associated event name.
	 *
	 * ####Example
	 *
	 *     conn.on('connected', callback);
	 *     conn.on('disconnected', callback);
	 *
	 * @property readyState
	 * @api public
	 */
	
	Object.defineProperty(Connection.prototype, 'readyState', {
	  get: function() {
	    return this._readyState;
	  },
	  set: function(val) {
	    if (!(val in STATES)) {
	      throw new Error('Invalid connection state: ' + val);
	    }
	
	    if (this._readyState !== val) {
	      this._readyState = val;
	      // loop over the otherDbs on this connection and change their state
	      for (var i = 0; i < this.otherDbs.length; i++) {
	        this.otherDbs[i].readyState = val;
	      }
	
	      if (STATES.connected === val) {
	        this._hasOpened = true;
	      }
	
	      this.emit(STATES[val]);
	    }
	  }
	});
	
	/**
	 * A hash of the collections associated with this connection
	 *
	 * @property collections
	 */
	
	Connection.prototype.collections;
	
	/**
	 * The mongodb.Db instance, set when the connection is opened
	 *
	 * @property db
	 */
	
	Connection.prototype.db;
	
	/**
	 * A hash of the global options that are associated with this connection
	 *
	 * @property config
	 */
	
	Connection.prototype.config;
	
	/*!
	 * ignore
	 */
	
	Connection.prototype._handleOpenArgs = function(host, database, port, options, callback) {
	  var err;
	
	  var parsed;
	
	  if (typeof database === 'string') {
	    switch (arguments.length) {
	      case 2:
	        port = 27017;
	        break;
	      case 3:
	        switch (typeof port) {
	          case 'function':
	            callback = port;
	            port = 27017;
	            break;
	          case 'object':
	            options = port;
	            port = 27017;
	            break;
	        }
	        break;
	      case 4:
	        if (typeof options === 'function') {
	          callback = options;
	          options = {};
	        }
	    }
	  } else {
	    switch (typeof database) {
	      case 'function':
	        callback = database;
	        database = undefined;
	        break;
	      case 'object':
	        options = database;
	        database = undefined;
	        callback = port;
	        break;
	    }
	
	    if (!rgxProtocol.test(host)) {
	      host = 'mongodb://' + host;
	    }
	
	    try {
	      parsed = muri(host);
	    } catch (error) {
	      this.error(error, callback);
	      throw error;
	    }
	
	    database = parsed.db;
	    host = parsed.hosts[0].host || parsed.hosts[0].ipc;
	    port = parsed.hosts[0].port || 27017;
	  }
	
	  this.options = this.parseOptions(options, parsed && parsed.options);
	
	  // make sure we can open
	  if (STATES.disconnected !== this.readyState) {
	    err = new Error('Trying to open unclosed connection.');
	    err.state = this.readyState;
	    this.error(err, callback);
	    throw err;
	  }
	
	  if (!host) {
	    err = new Error('Missing hostname.');
	    this.error(err, callback);
	    throw err;
	  }
	
	  if (!database) {
	    err = new Error('Missing database name.');
	    this.error(err, callback);
	    throw err;
	  }
	
	  // authentication
	  if (this.optionsProvideAuthenticationData(options)) {
	    this.user = options.user;
	    this.pass = options.pass;
	  } else if (parsed && parsed.auth) {
	    this.user = parsed.auth.user;
	    this.pass = parsed.auth.pass;
	
	    // Check hostname for user/pass
	  } else if (/@/.test(host) && /:/.test(host.split('@')[0])) {
	    host = host.split('@');
	    if (host.length > 2) {
	      err = new Error('Username and password must be URI encoded if they ' +
	        'contain "@", see http://bit.ly/2nRYRyq');
	      throw err;
	    }
	    var auth = host.shift().split(':');
	    if (auth.length > 2) {
	      err = new Error('Username and password must be URI encoded if they ' +
	        'contain ":", see http://bit.ly/2nRYRyq');
	      throw err;
	    }
	    host = host.pop();
	    this.user = auth[0];
	    this.pass = auth[1];
	  } else {
	    this.user = this.pass = undefined;
	  }
	
	  // global configuration options
	  if (options && options.config) {
	    this.config.autoIndex = options.config.autoIndex !== false;
	  }
	
	  this.name = database;
	  this.host = host;
	  this.port = port;
	
	  return callback;
	};
	
	/**
	 * Opens the connection to MongoDB.
	 *
	 * `options` is a hash with the following possible properties:
	 *
	 *     config  - passed to the connection config instance
	 *     db      - passed to the connection db instance
	 *     server  - passed to the connection server instance(s)
	 *     replset - passed to the connection ReplSet instance
	 *     user    - username for authentication
	 *     pass    - password for authentication
	 *     auth    - options for authentication (see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate)
	 *
	 * ####Notes:
	 *
	 * Mongoose forces the db option `forceServerObjectId` false and cannot be overridden.
	 * Mongoose defaults the server `auto_reconnect` options to true which can be overridden.
	 * See the node-mongodb-native driver instance for options that it understands.
	 *
	 * _Options passed take precedence over options included in connection strings._
	 *
	 * @param {String} connection_string mongodb://uri or the host to which you are connecting
	 * @param {String} [database] database name
	 * @param {Number} [port] database port
	 * @param {Object} [options] options
	 * @param {Function} [callback]
	 * @see node-mongodb-native https://github.com/mongodb/node-mongodb-native
	 * @see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate
	 * @api public
	 */
	
	Connection.prototype.open = util.deprecate(function() {
	  var Promise = PromiseProvider.get();
	  var callback;
	
	  try {
	    callback = this._handleOpenArgs.apply(this, arguments);
	  } catch (error) {
	    return new Promise.ES6(function(resolve, reject) {
	      reject(error);
	    });
	  }
	
	  var _this = this;
	  var promise = new Promise.ES6(function(resolve, reject) {
	    _this._open(true, function(error) {
	      callback && callback(error);
	      if (error) {
	        // Error can be on same tick re: christkv/mongodb-core#157
	        setImmediate(function() {
	          reject(error);
	          if (!callback && !promise.$hasHandler) {
	            _this.emit('error', error);
	          }
	        });
	        return;
	      }
	      resolve();
	    });
	  });
	
	  // Monkey-patch `.then()` so if the promise is handled, we don't emit an
	  // `error` event.
	  var _then = promise.then;
	  promise.then = function(resolve, reject) {
	    promise.$hasHandler = true;
	    return _then.call(promise, resolve, reject);
	  };
	
	  return promise;
	}, '`open()` is deprecated in mongoose >= 4.11.0, use `openUri()` instead, or set the `useMongoClient` option if using `connect()` or `createConnection()`. See http://mongoosejs.com/docs/connections.html#use-mongo-client');
	
	/*!
	 * ignore
	 */
	
	Connection.prototype._openWithoutPromise = function() {
	  var callback;
	
	  try {
	    callback = this._handleOpenArgs.apply(this, arguments);
	  } catch (error) {
	    // No need to do anything
	  }
	
	  var _this = this;
	  this._open(true, function(error) {
	    callback && callback(error);
	    if (error && !callback) {
	      // Error can be on same tick re: christkv/mongodb-core#157
	      setImmediate(function() {
	        _this.emit('error', error);
	      });
	      return;
	    }
	  });
	};
	
	/**
	 * Helper for `dropCollection()`. Will delete the given collection, including
	 * all documents and indexes.
	 *
	 * @param {string} collection The collection to delete
	 * @param {Function} [callback]
	 * @return {Promise}
	 * @api public
	 */
	
	Connection.prototype.dropCollection = _wrapConnHelper(function dropCollection(collection, cb) {
	  this.db.dropCollection(collection, cb);
	});
	
	/**
	 * Helper for `dropDatabase()`. Deletes the given database, including all
	 * collections, documents, and indexes.
	 *
	 * @param {Function} [callback]
	 * @return {Promise}
	 * @api public
	 */
	
	Connection.prototype.dropDatabase = _wrapConnHelper(function dropDatabase(cb) {
	  this.db.dropDatabase(cb);
	});
	
	/*!
	 * ignore
	 */
	
	function _wrapConnHelper(fn) {
	  return function() {
	    var _this = this;
	    var Promise = PromiseProvider.get();
	    var argsWithoutCb = Array.prototype.slice.call(arguments, 0, fn.length - 1);
	    var cb = arguments[arguments.length - 1];
	    var promise = new Promise.ES6(function(resolve, reject) {
	      if (_this.readyState !== STATES.connected) {
	        _this.on('open', function() {
	          fn.apply(_this, argsWithoutCb.concat([function(error) {
	            if (error) {
	              reject(error);
	            } else {
	              resolve();
	            }
	          }]));
	        });
	      } else {
	        fn.apply(_this, argsWithoutCb.concat([function(error) {
	          if (error) {
	            reject(error);
	          } else {
	            resolve();
	          }
	        }]));
	      }
	    });
	    if (cb) {
	      promise.
	        then(function() { cb(); }, function(error) { cb(error); });
	    }
	    return promise;
	  };
	}
	
	/*!
	 * ignore
	 */
	
	Connection.prototype._handleOpenSetArgs = function(uris, database, options, callback) {
	  if (!rgxProtocol.test(uris)) {
	    uris = 'mongodb://' + uris;
	  }
	
	  switch (arguments.length) {
	    case 3:
	      switch (typeof database) {
	        case 'string':
	          this.name = database;
	          break;
	        case 'object':
	          callback = options;
	          options = database;
	          database = null;
	          break;
	      }
	
	      if (typeof options === 'function') {
	        callback = options;
	        options = {};
	      }
	      break;
	    case 2:
	      switch (typeof database) {
	        case 'string':
	          this.name = database;
	          break;
	        case 'function':
	          callback = database;
	          database = null;
	          break;
	        case 'object':
	          options = database;
	          database = null;
	          break;
	      }
	  }
	
	  if (typeof database === 'string') {
	    this.name = database;
	  }
	
	  var parsed;
	  try {
	    parsed = muri(uris);
	  } catch (err) {
	    this.error(err, callback);
	    throw err;
	  }
	
	  if (!this.name) {
	    this.name = parsed.db;
	  }
	
	  this.hosts = parsed.hosts;
	  this.options = this.parseOptions(options, parsed && parsed.options);
	  this.replica = true;
	
	  if (!this.name) {
	    var err = new Error('No database name provided for replica set');
	    this.error(err, callback);
	    throw err;
	  }
	
	  // authentication
	  if (this.optionsProvideAuthenticationData(options)) {
	    this.user = options.user;
	    this.pass = options.pass;
	  } else if (parsed && parsed.auth) {
	    this.user = parsed.auth.user;
	    this.pass = parsed.auth.pass;
	  } else {
	    this.user = this.pass = undefined;
	  }
	
	  // global configuration options
	  if (options && options.config) {
	    this.config.autoIndex = options.config.autoIndex !== false;
	  }
	
	  return callback;
	};
	
	/*!
	 * ignore
	 */
	
	Connection.prototype._openSetWithoutPromise = function(uris, database, options, callback) {
	  try {
	    callback = this._handleOpenSetArgs.apply(this, arguments);
	  } catch (err) {
	    // Nothing to do, `_handleOpenSetArgs` calls callback if error occurred
	    return;
	  }
	
	  var _this = this;
	  var emitted = false;
	  this._open(true, function(error) {
	    callback && callback(error);
	    if (error) {
	      if (!callback && !emitted) {
	        emitted = true;
	        _this.emit('error', error);
	      }
	      return;
	    }
	  });
	};
	
	/**
	 * Opens the connection to a replica set.
	 *
	 * ####Example:
	 *
	 *     var db = mongoose.createConnection();
	 *     db.openSet("mongodb://user:pwd@localhost:27020,localhost:27021,localhost:27012/mydb");
	 *
	 * The database name and/or auth need only be included in one URI.
	 * The `options` is a hash which is passed to the internal driver connection object.
	 *
	 * Valid `options`
	 *
	 *     db      - passed to the connection db instance
	 *     server  - passed to the connection server instance(s)
	 *     replset - passed to the connection ReplSetServer instance
	 *     user    - username for authentication
	 *     pass    - password for authentication
	 *     auth    - options for authentication (see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate)
	 *     mongos  - Boolean - if true, enables High Availability support for mongos
	 *
	 * _Options passed take precedence over options included in connection strings._
	 *
	 * ####Notes:
	 *
	 * _If connecting to multiple mongos servers, set the `mongos` option to true._
	 *
	 *     conn.open('mongodb://mongosA:27501,mongosB:27501', { mongos: true }, cb);
	 *
	 * Mongoose forces the db option `forceServerObjectId` false and cannot be overridden.
	 * Mongoose defaults the server `auto_reconnect` options to true which can be overridden.
	 * See the node-mongodb-native driver instance for options that it understands.
	 *
	 * _Options passed take precedence over options included in connection strings._
	 *
	 * @param {String} uris MongoDB connection string
	 * @param {String} [database] database name if not included in `uris`
	 * @param {Object} [options] passed to the internal driver
	 * @param {Function} [callback]
	 * @see node-mongodb-native https://github.com/mongodb/node-mongodb-native
	 * @see http://mongodb.github.com/node-mongodb-native/api-generated/db.html#authenticate
	 * @api public
	 */
	
	Connection.prototype.openSet = util.deprecate(function(uris, database, options, callback) {
	  var Promise = PromiseProvider.get();
	
	  try {
	    callback = this._handleOpenSetArgs.apply(this, arguments);
	  } catch (err) {
	    return new Promise.ES6(function(resolve, reject) {
	      reject(err);
	    });
	  }
	
	  var _this = this;
	  var emitted = false;
	  var promise = new Promise.ES6(function(resolve, reject) {
	    _this._open(true, function(error) {
	      callback && callback(error);
	      if (error) {
	        reject(error);
	        if (!callback && !promise.$hasHandler && !emitted) {
	          emitted = true;
	          _this.emit('error', error);
	        }
	        return;
	      }
	      resolve();
	    });
	  });
	
	  // Monkey-patch `.then()` so if the promise is handled, we don't emit an
	  // `error` event.
	  var _then = promise.then;
	  promise.then = function(resolve, reject) {
	    promise.$hasHandler = true;
	    return _then.call(promise, resolve, reject);
	  };
	
	  return promise;
	}, '`openSet()` is deprecated in mongoose >= 4.11.0, use `openUri()` instead, or set the `useMongoClient` option if using `connect()` or `createConnection()`. See http://mongoosejs.com/docs/connections.html#use-mongo-client');
	
	/**
	 * error
	 *
	 * Graceful error handling, passes error to callback
	 * if available, else emits error on the connection.
	 *
	 * @param {Error} err
	 * @param {Function} callback optional
	 * @api private
	 */
	
	Connection.prototype.error = function(err, callback) {
	  if (callback) {
	    return callback(err);
	  }
	  this.emit('error', err);
	};
	
	/**
	 * Handles opening the connection with the appropriate method based on connection type.
	 *
	 * @param {Function} callback
	 * @api private
	 */
	
	Connection.prototype._open = function(emit, callback) {
	  this.readyState = STATES.connecting;
	  this._closeCalled = false;
	
	  var _this = this;
	
	  var method = this.replica
	      ? 'doOpenSet'
	      : 'doOpen';
	
	  // open connection
	  this[method](function(err) {
	    if (err) {
	      _this.readyState = STATES.disconnected;
	      if (_this._hasOpened) {
	        if (callback) {
	          callback(err);
	        }
	      } else {
	        _this.error(err, emit && callback);
	      }
	      return;
	    }
	
	    _this.onOpen(callback);
	  });
	};
	
	/**
	 * Called when the connection is opened
	 *
	 * @api private
	 */
	
	Connection.prototype.onOpen = function(callback) {
	  var _this = this;
	
	  function open(err, isAuth) {
	    if (err) {
	      _this.readyState = isAuth ? STATES.unauthorized : STATES.disconnected;
	      _this.error(err, callback);
	      return;
	    }
	
	    _this.readyState = STATES.connected;
	
	    // avoid having the collection subscribe to our event emitter
	    // to prevent 0.3 warning
	    for (var i in _this.collections) {
	      if (utils.object.hasOwnProperty(_this.collections, i)) {
	        _this.collections[i].onOpen();
	      }
	    }
	
	    callback && callback();
	    _this.emit('open');
	  }
	
	  // re-authenticate if we're not already connected #3871
	  if (this._readyState !== STATES.connected && this.shouldAuthenticate()) {
	    _this.db.authenticate(_this.user, _this.pass, _this.options.auth, function(err) {
	      open(err, true);
	    });
	  } else {
	    open();
	  }
	};
	
	/**
	 * Opens the connection with a URI using `MongoClient.connect()`.
	 *
	 * @param {String} uri The URI to connect with.
	 * @param {Object} [options] Passed on to http://mongodb.github.io/node-mongodb-native/2.2/api/MongoClient.html#connect
	 * @param {Function} [callback]
	 * @returns {Connection} this
	 * @api private
	 */
	
	Connection.prototype.openUri = function(uri, options, callback) {
	  this.readyState = STATES.connecting;
	  this._closeCalled = false;
	
	  try {
	    var parsed = muri(uri);
	    this.name = parsed.db;
	    this.host = parsed.hosts[0].host || parsed.hosts[0].ipc;
	    this.port = parsed.hosts[0].port || 27017;
	    if (parsed.auth) {
	      this.user = parsed.auth.user;
	      this.pass = parsed.auth.pass;
	    }
	  } catch (error) {
	    this.error(error, callback);
	    throw error;
	  }
	
	  if (typeof options === 'function') {
	    callback = options;
	    options = null;
	  }
	
	  var Promise = PromiseProvider.get();
	  var _this = this;
	
	  if (options) {
	    options = utils.clone(options, { retainKeyOrder: true });
	    delete options.useMongoClient;
	    if (options.config && options.config.autoIndex != null) {
	      this.config.autoIndex = options.config.autoIndex !== false;
	      delete options.config;
	    }
	
	    // Backwards compat
	    if (options.user || options.pass) {
	      options.auth = options.auth || {};
	      options.auth.user = options.user;
	      options.auth.password = options.pass;
	      delete options.user;
	      delete options.pass;
	      this.user = options.auth.user;
	      this.pass = options.auth.password;
	    }
	  }
	
	  this._connectionOptions = options;
	
	  var promise = new Promise.ES6(function(resolve, reject) {
	    mongodb.MongoClient.connect(uri, options, function(error, db) {
	      if (error) {
	        _this.readyState = STATES.disconnected;
	        if (_this.listeners('error').length) {
	          _this.emit('error', error);
	        }
	        callback && callback(error);
	        return reject(error);
	      }
	      // Backwards compat for mongoose 4.x
	      db.on('reconnect', function() {
	        _this.readyState = STATES.connected;
	        _this.emit('reconnected');
	      });
	      db.s.topology.on('reconnectFailed', function() {
	        _this.emit('reconnectFailed');
	      });
	      db.s.topology.on('close', function() {
	        // Implicitly emits 'disconnected'
	        _this.readyState = STATES.disconnected;
	      });
	      db.on('timeout', function() {
	        _this.emit('timeout');
	      });
	
	      _this.db = db;
	      _this.readyState = STATES.connected;
	
	      for (var i in _this.collections) {
	        if (utils.object.hasOwnProperty(_this.collections, i)) {
	          _this.collections[i].onOpen();
	        }
	      }
	
	      callback && callback(null, _this);
	      delete _this.then;
	      delete _this.catch;
	      resolve(_this);
	      _this.emit('open');
	    });
	  });
	
	  this.then = function(resolve, reject) {
	    return promise.then(resolve, reject);
	  };
	  this.catch = function(reject) {
	    return promise.catch(reject);
	  };
	
	  return this;
	};
	
	/**
	 * Closes the connection
	 *
	 * @param {Boolean} [force] optional
	 * @param {Function} [callback] optional
	 * @return {Connection} self
	 * @api public
	 */
	
	Connection.prototype.close = function(force, callback) {
	  var _this = this;
	  var Promise = PromiseProvider.get();
	
	  if (typeof force === 'function') {
	    callback = force;
	    force = false;
	  }
	
	  this.$wasForceClosed = !!force;
	
	  return new Promise.ES6(function(resolve, reject) {
	    _this._close(force, function(error) {
	      callback && callback(error);
	      if (error) {
	        reject(error);
	        return;
	      }
	      resolve();
	    });
	  });
	};
	
	/**
	 * Handles closing the connection
	 *
	 * @param {Boolean} force
	 * @param {Function} callback
	 * @api private
	 */
	Connection.prototype._close = function(force, callback) {
	  var _this = this;
	  this._closeCalled = true;
	
	  switch (this.readyState) {
	    case 0: // disconnected
	      callback && callback();
	      break;
	
	    case 1: // connected
	    case 4: // unauthorized
	      this.readyState = STATES.disconnecting;
	      this.doClose(force, function(err) {
	        if (err) {
	          _this.error(err, callback);
	        } else {
	          _this.onClose(force);
	          callback && callback();
	        }
	      });
	      break;
	
	    case 2: // connecting
	      this.once('open', function() {
	        _this.close(callback);
	      });
	      break;
	
	    case 3: // disconnecting
	      if (!callback) {
	        break;
	      }
	      this.once('close', function() {
	        callback();
	      });
	      break;
	  }
	
	  return this;
	};
	
	/**
	 * Called when the connection closes
	 *
	 * @api private
	 */
	
	Connection.prototype.onClose = function(force) {
	  this.readyState = STATES.disconnected;
	
	  // avoid having the collection subscribe to our event emitter
	  // to prevent 0.3 warning
	  for (var i in this.collections) {
	    if (utils.object.hasOwnProperty(this.collections, i)) {
	      this.collections[i].onClose(force);
	    }
	  }
	
	  this.emit('close', force);
	};
	
	/**
	 * Retrieves a collection, creating it if not cached.
	 *
	 * Not typically needed by applications. Just talk to your collection through your model.
	 *
	 * @param {String} name of the collection
	 * @param {Object} [options] optional collection options
	 * @return {Collection} collection instance
	 * @api public
	 */
	
	Connection.prototype.collection = function(name, options) {
	  options = options ? utils.clone(options, { retainKeyOrder: true }) : {};
	  options.$wasForceClosed = this.$wasForceClosed;
	  if (!(name in this.collections)) {
	    this.collections[name] = new Collection(name, this, options);
	  }
	  return this.collections[name];
	};
	
	/**
	 * Defines or retrieves a model.
	 *
	 *     var mongoose = require('mongoose');
	 *     var db = mongoose.createConnection(..);
	 *     db.model('Venue', new Schema(..));
	 *     var Ticket = db.model('Ticket', new Schema(..));
	 *     var Venue = db.model('Venue');
	 *
	 * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the [utils.toCollectionName](#utils_exports.toCollectionName) method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._
	 *
	 * ####Example:
	 *
	 *     var schema = new Schema({ name: String }, { collection: 'actor' });
	 *
	 *     // or
	 *
	 *     schema.set('collection', 'actor');
	 *
	 *     // or
	 *
	 *     var collectionName = 'actor'
	 *     var M = conn.model('Actor', schema, collectionName)
	 *
	 * @param {String} name the model name
	 * @param {Schema} [schema] a schema. necessary when defining a model
	 * @param {String} [collection] name of mongodb collection (optional) if not given it will be induced from model name
	 * @see Mongoose#model #index_Mongoose-model
	 * @return {Model} The compiled model
	 * @api public
	 */
	
	Connection.prototype.model = function(name, schema, collection) {
	  // collection name discovery
	  if (typeof schema === 'string') {
	    collection = schema;
	    schema = false;
	  }
	
	  if (utils.isObject(schema) && !schema.instanceOfSchema) {
	    schema = new Schema(schema);
	  }
	  if (schema && !schema.instanceOfSchema) {
	    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +
	      'schema or a POJO');
	  }
	
	  if (this.models[name] && !collection) {
	    // model exists but we are not subclassing with custom collection
	    if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {
	      throw new MongooseError.OverwriteModelError(name);
	    }
	    return this.models[name];
	  }
	
	  var opts = {cache: false, connection: this};
	  var model;
	
	  if (schema && schema.instanceOfSchema) {
	    // compile a model
	    model = this.base.model(name, schema, collection, opts);
	
	    // only the first model with this name is cached to allow
	    // for one-offs with custom collection names etc.
	    if (!this.models[name]) {
	      this.models[name] = model;
	    }
	
	    model.init();
	    return model;
	  }
	
	  if (this.models[name] && collection) {
	    // subclassing current model with alternate collection
	    model = this.models[name];
	    schema = model.prototype.schema;
	    var sub = model.__subclass(this, schema, collection);
	    // do not cache the sub model
	    return sub;
	  }
	
	  // lookup model in mongoose module
	  model = this.base.models[name];
	
	  if (!model) {
	    throw new MongooseError.MissingSchemaError(name);
	  }
	
	  if (this === model.prototype.db
	      && (!collection || collection === model.collection.name)) {
	    // model already uses this connection.
	
	    // only the first model with this name is cached to allow
	    // for one-offs with custom collection names etc.
	    if (!this.models[name]) {
	      this.models[name] = model;
	    }
	
	    return model;
	  }
	  this.models[name] = model.__subclass(this, schema, collection);
	  return this.models[name];
	};
	
	/**
	 * Returns an array of model names created on this connection.
	 * @api public
	 * @return {Array}
	 */
	
	Connection.prototype.modelNames = function() {
	  return Object.keys(this.models);
	};
	
	/**
	 * @brief Returns if the connection requires authentication after it is opened. Generally if a
	 * username and password are both provided than authentication is needed, but in some cases a
	 * password is not required.
	 * @api private
	 * @return {Boolean} true if the connection should be authenticated after it is opened, otherwise false.
	 */
	Connection.prototype.shouldAuthenticate = function() {
	  return (this.user !== null && this.user !== void 0) &&
	      ((this.pass !== null || this.pass !== void 0) || this.authMechanismDoesNotRequirePassword());
	};
	
	/**
	 * @brief Returns a boolean value that specifies if the current authentication mechanism needs a
	 * password to authenticate according to the auth objects passed into the open/openSet methods.
	 * @api private
	 * @return {Boolean} true if the authentication mechanism specified in the options object requires
	 *  a password, otherwise false.
	 */
	Connection.prototype.authMechanismDoesNotRequirePassword = function() {
	  if (this.options && this.options.auth) {
	    return authMechanismsWhichDontRequirePassword.indexOf(this.options.auth.authMechanism) >= 0;
	  }
	  return true;
	};
	
	/**
	 * @brief Returns a boolean value that specifies if the provided objects object provides enough
	 * data to authenticate with. Generally this is true if the username and password are both specified
	 * but in some authentication methods, a password is not required for authentication so only a username
	 * is required.
	 * @param {Object} [options] the options object passed into the open/openSet methods.
	 * @api private
	 * @return {Boolean} true if the provided options object provides enough data to authenticate with,
	 *   otherwise false.
	 */
	Connection.prototype.optionsProvideAuthenticationData = function(options) {
	  return (options) &&
	      (options.user) &&
	      ((options.pass) || this.authMechanismDoesNotRequirePassword());
	};
	
	/*!
	 * Module exports.
	 */
	
	Connection.STATES = STATES;
	module.exports = Connection;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/* eslint-env browser */
	
	/*!
	 * Module dependencies.
	 */
	var Document = __webpack_require__(8);
	var BrowserDocument = __webpack_require__(209);
	
	var isBrowser = false;
	
	/**
	 * Returns the Document constructor for the current context
	 *
	 * @api private
	 */
	module.exports = function() {
	  if (isBrowser) {
	    return BrowserDocument;
	  }
	  return Document;
	};
	
	/*!
	 * ignore
	 */
	module.exports.setBrowser = function(flag) {
	  isBrowser = flag;
	};


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * ignore
	 */
	
	module.exports = __webpack_require__(62);


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module requirements
	 */
	
	var MongooseError = __webpack_require__(5);
	var utils = __webpack_require__(4);
	
	/**
	 * Document Validation Error
	 *
	 * @api private
	 * @param {Document} instance
	 * @inherits MongooseError
	 */
	
	function ValidationError(instance) {
	  this.errors = {};
	  this._message = '';
	  if (instance && instance.constructor.name === 'model') {
	    this._message = instance.constructor.modelName + ' validation failed';
	    MongooseError.call(this, this._message);
	  } else {
	    this._message = 'Validation failed';
	    MongooseError.call(this, this._message);
	  }
	  this.name = 'ValidationError';
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	  if (instance) {
	    instance.errors = this.errors;
	  }
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	ValidationError.prototype = Object.create(MongooseError.prototype);
	ValidationError.prototype.constructor = MongooseError;
	
	/**
	 * Console.log helper
	 */
	
	ValidationError.prototype.toString = function() {
	  return this.name + ': ' + _generateMessage(this);
	};
	
	/*!
	 * inspect helper
	 */
	
	ValidationError.prototype.inspect = function() {
	  return utils.assign(new Error(this.message), this);
	};
	
	/*!
	 * Helper for JSON.stringify
	 */
	
	ValidationError.prototype.toJSON = function() {
	  return utils.assign({}, this, { message: this.message });
	};
	
	/*!
	 * add message
	 */
	
	ValidationError.prototype.addError = function(path, error) {
	  this.errors[path] = error;
	  this.message = this._message + ': ' + _generateMessage(this);
	};
	
	/*!
	 * ignore
	 */
	
	function _generateMessage(err) {
	  var keys = Object.keys(err.errors || {});
	  var len = keys.length;
	  var msgs = [];
	  var key;
	
	  for (var i = 0; i < len; ++i) {
	    key = keys[i];
	    if (err === err.errors[key]) {
	      continue;
	    }
	    msgs.push(key + ': ' + err.errors[key].message);
	  }
	
	  return msgs.join(', ');
	}
	
	/*!
	 * Module exports
	 */
	
	module.exports = exports = ValidationError;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Dependencies
	 */
	
	var StateMachine = __webpack_require__(242);
	var ActiveRoster = StateMachine.ctor('require', 'modify', 'init', 'default', 'ignore');
	
	module.exports = exports = InternalCache;
	
	function InternalCache() {
	  this.strictMode = undefined;
	  this.selected = undefined;
	  this.shardval = undefined;
	  this.saveError = undefined;
	  this.validationError = undefined;
	  this.adhocPaths = undefined;
	  this.removing = undefined;
	  this.inserting = undefined;
	  this.version = undefined;
	  this.getters = {};
	  this._id = undefined;
	  this.populate = undefined; // what we want to populate in this doc
	  this.populated = undefined;// the _ids that have been populated
	  this.wasPopulated = false; // if this doc was the result of a population
	  this.scope = undefined;
	  this.activePaths = new ActiveRoster;
	  this.pathsToScopes = {};
	
	  // embedded docs
	  this.ownerDocument = undefined;
	  this.fullPath = undefined;
	}


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var utils = __webpack_require__(4);
	
	var SchemaType = __webpack_require__(12);
	
	/**
	 * Boolean SchemaType constructor.
	 *
	 * @param {String} path
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function SchemaBoolean(path, options) {
	  SchemaType.call(this, path, options, 'Boolean');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	SchemaBoolean.schemaName = 'Boolean';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaBoolean.prototype = Object.create(SchemaType.prototype);
	SchemaBoolean.prototype.constructor = SchemaBoolean;
	
	/**
	 * Check if the given value satisfies a required validator. For a boolean
	 * to satisfy a required validator, it must be strictly equal to true or to
	 * false.
	 *
	 * @param {Any} value
	 * @return {Boolean}
	 * @api public
	 */
	
	SchemaBoolean.prototype.checkRequired = function(value) {
	  return value === true || value === false;
	};
	
	/**
	 * Casts to boolean
	 *
	 * @param {Object} value
	 * @api private
	 */
	
	SchemaBoolean.prototype.cast = function(value) {
	  if (value === null) {
	    return value;
	  }
	  if (value === '0') {
	    return false;
	  }
	  if (value === 'true') {
	    return true;
	  }
	  if (value === 'false') {
	    return false;
	  }
	  return !!value;
	};
	
	SchemaBoolean.$conditionalHandlers =
	    utils.options(SchemaType.prototype.$conditionalHandlers, {});
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} val
	 * @api private
	 */
	
	SchemaBoolean.prototype.castForQuery = function($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = SchemaBoolean.$conditionalHandlers[$conditional];
	
	    if (handler) {
	      return handler.call(this, val);
	    }
	
	    return this._castForQuery(val);
	  }
	
	  return this._castForQuery($conditional);
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaBoolean;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var handleBitwiseOperator = __webpack_require__(140);
	var utils = __webpack_require__(4);
	
	var MongooseBuffer = __webpack_require__(31).Buffer;
	var SchemaType = __webpack_require__(12);
	
	var Binary = MongooseBuffer.Binary;
	var CastError = SchemaType.CastError;
	var Document;
	
	/**
	 * Buffer SchemaType constructor
	 *
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function SchemaBuffer(key, options) {
	  SchemaType.call(this, key, options, 'Buffer');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	SchemaBuffer.schemaName = 'Buffer';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaBuffer.prototype = Object.create(SchemaType.prototype);
	SchemaBuffer.prototype.constructor = SchemaBuffer;
	
	/**
	 * Check if the given value satisfies a required validator. To satisfy a
	 * required validator, a buffer must not be null or undefined and have
	 * non-zero length.
	 *
	 * @param {Any} value
	 * @param {Document} doc
	 * @return {Boolean}
	 * @api public
	 */
	
	SchemaBuffer.prototype.checkRequired = function(value, doc) {
	  if (SchemaType._isRef(this, value, doc, true)) {
	    return !!value;
	  }
	  return !!(value && value.length);
	};
	
	/**
	 * Casts contents
	 *
	 * @param {Object} value
	 * @param {Document} doc document that triggers the casting
	 * @param {Boolean} init
	 * @api private
	 */
	
	SchemaBuffer.prototype.cast = function(value, doc, init) {
	  var ret;
	  if (SchemaType._isRef(this, value, doc, init)) {
	    // wait! we may need to cast this to a document
	
	    if (value === null || value === undefined) {
	      return value;
	    }
	
	    // lazy load
	    Document || (Document = __webpack_require__(8));
	
	    if (value instanceof Document) {
	      value.$__.wasPopulated = true;
	      return value;
	    }
	
	    // setting a populated path
	    if (Buffer.isBuffer(value)) {
	      return value;
	    } else if (!utils.isObject(value)) {
	      throw new CastError('buffer', value, this.path);
	    }
	
	    // Handle the case where user directly sets a populated
	    // path to a plain object; cast to the Model used in
	    // the population query.
	    var path = doc.$__fullPath(this.path);
	    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
	    var pop = owner.populated(path, true);
	    ret = new pop.options.model(value);
	    ret.$__.wasPopulated = true;
	    return ret;
	  }
	
	  // documents
	  if (value && value._id) {
	    value = value._id;
	  }
	
	  if (value && value.isMongooseBuffer) {
	    return value;
	  }
	
	  if (Buffer.isBuffer(value)) {
	    if (!value || !value.isMongooseBuffer) {
	      value = new MongooseBuffer(value, [this.path, doc]);
	    }
	
	    return value;
	  } else if (value instanceof Binary) {
	    ret = new MongooseBuffer(value.value(true), [this.path, doc]);
	    if (typeof value.sub_type !== 'number') {
	      throw new CastError('buffer', value, this.path);
	    }
	    ret._subtype = value.sub_type;
	    return ret;
	  }
	
	  if (value === null) {
	    return value;
	  }
	
	  var type = typeof value;
	  if (type === 'string' || type === 'number' || Array.isArray(value)) {
	    if (type === 'number') {
	      value = [value];
	    }
	    ret = new MongooseBuffer(value, [this.path, doc]);
	    return ret;
	  }
	
	  throw new CastError('buffer', value, this.path);
	};
	
	/*!
	 * ignore
	 */
	function handleSingle(val) {
	  return this.castForQuery(val);
	}
	
	SchemaBuffer.prototype.$conditionalHandlers =
	    utils.options(SchemaType.prototype.$conditionalHandlers, {
	      $bitsAllClear: handleBitwiseOperator,
	      $bitsAnyClear: handleBitwiseOperator,
	      $bitsAllSet: handleBitwiseOperator,
	      $bitsAnySet: handleBitwiseOperator,
	      $gt: handleSingle,
	      $gte: handleSingle,
	      $lt: handleSingle,
	      $lte: handleSingle
	    });
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [value]
	 * @api private
	 */
	
	SchemaBuffer.prototype.castForQuery = function($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	    if (!handler) {
	      throw new Error('Can\'t use ' + $conditional + ' with Buffer.');
	    }
	    return handler.call(this, val);
	  }
	  val = $conditional;
	  var casted = this._castForQuery(val);
	  return casted ? casted.toObject({ transform: false, virtuals: false }) : casted;
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaBuffer;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module requirements.
	 */
	
	var MongooseError = __webpack_require__(5);
	var utils = __webpack_require__(4);
	
	var SchemaType = __webpack_require__(12);
	
	var CastError = SchemaType.CastError;
	
	/**
	 * Date SchemaType constructor.
	 *
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function SchemaDate(key, options) {
	  SchemaType.call(this, key, options, 'Date');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	SchemaDate.schemaName = 'Date';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaDate.prototype = Object.create(SchemaType.prototype);
	SchemaDate.prototype.constructor = SchemaDate;
	
	/**
	 * Declares a TTL index (rounded to the nearest second) for _Date_ types only.
	 *
	 * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.
	 * This index type is only compatible with Date types.
	 *
	 * ####Example:
	 *
	 *     // expire in 24 hours
	 *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});
	 *
	 * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:
	 *
	 * ####Example:
	 *
	 *     // expire in 24 hours
	 *     new Schema({ createdAt: { type: Date, expires: '24h' }});
	 *
	 *     // expire in 1.5 hours
	 *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});
	 *
	 *     // expire in 7 days
	 *     var schema = new Schema({ createdAt: Date });
	 *     schema.path('createdAt').expires('7d');
	 *
	 * @param {Number|String} when
	 * @added 3.0.0
	 * @return {SchemaType} this
	 * @api public
	 */
	
	SchemaDate.prototype.expires = function(when) {
	  if (!this._index || this._index.constructor.name !== 'Object') {
	    this._index = {};
	  }
	
	  this._index.expires = when;
	  utils.expires(this._index);
	  return this;
	};
	
	/**
	 * Check if the given value satisfies a required validator. To satisfy
	 * a required validator, the given value must be an instance of `Date`.
	 *
	 * @param {Any} value
	 * @param {Document} doc
	 * @return {Boolean}
	 * @api public
	 */
	
	SchemaDate.prototype.checkRequired = function(value) {
	  return value instanceof Date;
	};
	
	/**
	 * Sets a minimum date validator.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ d: { type: Date, min: Date('1970-01-01') })
	 *     var M = db.model('M', s)
	 *     var m = new M({ d: Date('1969-12-31') })
	 *     m.save(function (err) {
	 *       console.error(err) // validator error
	 *       m.d = Date('2014-12-08');
	 *       m.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MIN} token which will be replaced with the invalid value
	 *     var min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];
	 *     var schema = new Schema({ d: { type: Date, min: min })
	 *     var M = mongoose.model('M', schema);
	 *     var s= new M({ d: Date('1969-12-31') });
	 *     s.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).
	 *     })
	 *
	 * @param {Date} value minimum date
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaDate.prototype.min = function(value, message) {
	  if (this.minValidator) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator !== this.minValidator;
	    }, this);
	  }
	
	  if (value) {
	    var msg = message || MongooseError.messages.Date.min;
	    msg = msg.replace(/{MIN}/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));
	    var _this = this;
	    this.validators.push({
	      validator: this.minValidator = function(val) {
	        var min = (value === Date.now ? value() : _this.cast(value));
	        return val === null || val.valueOf() >= min.valueOf();
	      },
	      message: msg,
	      type: 'min',
	      min: value
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Sets a maximum date validator.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ d: { type: Date, max: Date('2014-01-01') })
	 *     var M = db.model('M', s)
	 *     var m = new M({ d: Date('2014-12-08') })
	 *     m.save(function (err) {
	 *       console.error(err) // validator error
	 *       m.d = Date('2013-12-31');
	 *       m.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MAX} token which will be replaced with the invalid value
	 *     var max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];
	 *     var schema = new Schema({ d: { type: Date, max: max })
	 *     var M = mongoose.model('M', schema);
	 *     var s= new M({ d: Date('2014-12-08') });
	 *     s.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).
	 *     })
	 *
	 * @param {Date} maximum date
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaDate.prototype.max = function(value, message) {
	  if (this.maxValidator) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator !== this.maxValidator;
	    }, this);
	  }
	
	  if (value) {
	    var msg = message || MongooseError.messages.Date.max;
	    msg = msg.replace(/{MAX}/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));
	    var _this = this;
	    this.validators.push({
	      validator: this.maxValidator = function(val) {
	        var max = (value === Date.now ? value() : _this.cast(value));
	        return val === null || val.valueOf() <= max.valueOf();
	      },
	      message: msg,
	      type: 'max',
	      max: value
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Casts to date
	 *
	 * @param {Object} value to cast
	 * @api private
	 */
	
	SchemaDate.prototype.cast = function(value) {
	  // If null or undefined
	  if (value === null || value === void 0 || value === '') {
	    return null;
	  }
	
	  if (value instanceof Date) {
	    if (isNaN(value.valueOf())) {
	      throw new CastError('date', value, this.path);
	    }
	
	    return value;
	  }
	
	  var date;
	
	  if (typeof value === 'boolean') {
	    throw new CastError('date', value, this.path);
	  }
	
	  if (value instanceof Number || typeof value === 'number'
	      || String(value) == Number(value)) {
	    // support for timestamps
	    date = new Date(Number(value));
	  } else if (value.valueOf) {
	    // support for moment.js
	    date = new Date(value.valueOf());
	  }
	
	  if (!isNaN(date.valueOf())) {
	    return date;
	  }
	
	  throw new CastError('date', value, this.path);
	};
	
	/*!
	 * Date Query casting.
	 *
	 * @api private
	 */
	
	function handleSingle(val) {
	  return this.cast(val);
	}
	
	SchemaDate.prototype.$conditionalHandlers =
	    utils.options(SchemaType.prototype.$conditionalHandlers, {
	      $gt: handleSingle,
	      $gte: handleSingle,
	      $lt: handleSingle,
	      $lte: handleSingle
	    });
	
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [value]
	 * @api private
	 */
	
	SchemaDate.prototype.castForQuery = function($conditional, val) {
	  var handler;
	
	  if (arguments.length !== 2) {
	    return this._castForQuery($conditional);
	  }
	
	  handler = this.$conditionalHandlers[$conditional];
	
	  if (!handler) {
	    throw new Error('Can\'t use ' + $conditional + ' with Date.');
	  }
	
	  return handler.call(this, val);
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaDate;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	
	/*!
	 * Module exports.
	 */
	
	exports.String = __webpack_require__(143);
	
	exports.Number = __webpack_require__(96);
	
	exports.Boolean = __webpack_require__(136);
	
	exports.DocumentArray = __webpack_require__(232);
	
	exports.Embedded = __webpack_require__(233);
	
	exports.Array = __webpack_require__(95);
	
	exports.Buffer = __webpack_require__(137);
	
	exports.Date = __webpack_require__(138);
	
	exports.ObjectId = __webpack_require__(97);
	
	exports.Mixed = __webpack_require__(64);
	
	exports.Decimal128 = exports.Decimal = __webpack_require__(231);
	
	// alias
	
	exports.Oid = exports.ObjectId;
	exports.Object = exports.Mixed;
	exports.Bool = exports.Boolean;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module requirements.
	 */
	
	var CastError = __webpack_require__(44);
	
	/*!
	 * ignore
	 */
	
	function handleBitwiseOperator(val) {
	  var _this = this;
	  if (Array.isArray(val)) {
	    return val.map(function(v) {
	      return _castNumber(_this.path, v);
	    });
	  } else if (Buffer.isBuffer(val)) {
	    return val;
	  }
	  // Assume trying to cast to number
	  return _castNumber(_this.path, val);
	}
	
	/*!
	 * ignore
	 */
	
	function _castNumber(path, num) {
	  var v = Number(num);
	  if (isNaN(v)) {
	    throw new CastError('number', num, path);
	  }
	  return v;
	}
	
	module.exports = handleBitwiseOperator;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module requirements.
	 */
	
	var castArraysOfNumbers = __webpack_require__(65).castArraysOfNumbers;
	var castToNumber = __webpack_require__(65).castToNumber;
	
	/*!
	 * ignore
	 */
	
	exports.cast$geoIntersects = cast$geoIntersects;
	exports.cast$near = cast$near;
	exports.cast$within = cast$within;
	
	function cast$near(val) {
	  var SchemaArray = __webpack_require__(95);
	
	  if (Array.isArray(val)) {
	    castArraysOfNumbers(val, this);
	    return val;
	  }
	
	  _castMinMaxDistance(this, val);
	
	  if (val && val.$geometry) {
	    return cast$geometry(val, this);
	  }
	
	  return SchemaArray.prototype.castForQuery.call(this, val);
	}
	
	function cast$geometry(val, self) {
	  switch (val.$geometry.type) {
	    case 'Polygon':
	    case 'LineString':
	    case 'Point':
	      castArraysOfNumbers(val.$geometry.coordinates, self);
	      break;
	    default:
	      // ignore unknowns
	      break;
	  }
	
	  _castMinMaxDistance(this, val);
	
	  return val;
	}
	
	function cast$within(val) {
	  _castMinMaxDistance(this, val);
	
	  if (val.$box || val.$polygon) {
	    var type = val.$box ? '$box' : '$polygon';
	    val[type].forEach(function(arr) {
	      if (!Array.isArray(arr)) {
	        var msg = 'Invalid $within $box argument. '
	            + 'Expected an array, received ' + arr;
	        throw new TypeError(msg);
	      }
	      arr.forEach(function(v, i) {
	        arr[i] = castToNumber.call(this, v);
	      });
	    });
	  } else if (val.$center || val.$centerSphere) {
	    type = val.$center ? '$center' : '$centerSphere';
	    val[type].forEach(function(item, i) {
	      if (Array.isArray(item)) {
	        item.forEach(function(v, j) {
	          item[j] = castToNumber.call(this, v);
	        });
	      } else {
	        val[type][i] = castToNumber.call(this, item);
	      }
	    });
	  } else if (val.$geometry) {
	    cast$geometry(val, this);
	  }
	
	  return val;
	}
	
	function cast$geoIntersects(val) {
	  var geo = val.$geometry;
	  if (!geo) {
	    return;
	  }
	
	  cast$geometry(val, this);
	  return val;
	}
	
	function _castMinMaxDistance(self, val) {
	  if (val.$maxDistance) {
	    val.$maxDistance = castToNumber.call(self, val.$maxDistance);
	  }
	  if (val.$minDistance) {
	    val.$minDistance = castToNumber.call(self, val.$minDistance);
	  }
	}


/***/ }),
/* 142 */
/***/ (function(module, exports) {

	'use strict';
	
	/*!
	 * ignore
	 */
	
	module.exports = function(val) {
	  if (typeof val !== 'number' && typeof val !== 'string') {
	    throw new Error('$type parameter must be number or string');
	  }
	
	  return val;
	};


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var SchemaType = __webpack_require__(12);
	var CastError = SchemaType.CastError;
	var MongooseError = __webpack_require__(5);
	var utils = __webpack_require__(4);
	var Document;
	
	/**
	 * String SchemaType constructor.
	 *
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function SchemaString(key, options) {
	  this.enumValues = [];
	  this.regExp = null;
	  SchemaType.call(this, key, options, 'String');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	SchemaString.schemaName = 'String';
	
	/*!
	 * Inherits from SchemaType.
	 */
	SchemaString.prototype = Object.create(SchemaType.prototype);
	SchemaString.prototype.constructor = SchemaString;
	
	/**
	 * Adds an enum validator
	 *
	 * ####Example:
	 *
	 *     var states = ['opening', 'open', 'closing', 'closed']
	 *     var s = new Schema({ state: { type: String, enum: states }})
	 *     var M = db.model('M', s)
	 *     var m = new M({ state: 'invalid' })
	 *     m.save(function (err) {
	 *       console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.
	 *       m.state = 'open'
	 *       m.save(callback) // success
	 *     })
	 *
	 *     // or with custom error messages
	 *     var enum = {
	 *       values: ['opening', 'open', 'closing', 'closed'],
	 *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'
	 *     }
	 *     var s = new Schema({ state: { type: String, enum: enum })
	 *     var M = db.model('M', s)
	 *     var m = new M({ state: 'invalid' })
	 *     m.save(function (err) {
	 *       console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`
	 *       m.state = 'open'
	 *       m.save(callback) // success
	 *     })
	 *
	 * @param {String|Object} [args...] enumeration values
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaString.prototype.enum = function() {
	  if (this.enumValidator) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator !== this.enumValidator;
	    }, this);
	    this.enumValidator = false;
	  }
	
	  if (arguments[0] === void 0 || arguments[0] === false) {
	    return this;
	  }
	
	  var values;
	  var errorMessage;
	
	  if (utils.isObject(arguments[0])) {
	    values = arguments[0].values;
	    errorMessage = arguments[0].message;
	  } else {
	    values = arguments;
	    errorMessage = MongooseError.messages.String.enum;
	  }
	
	  for (var i = 0; i < values.length; i++) {
	    if (undefined !== values[i]) {
	      this.enumValues.push(this.cast(values[i]));
	    }
	  }
	
	  var vals = this.enumValues;
	  this.enumValidator = function(v) {
	    return undefined === v || ~vals.indexOf(v);
	  };
	  this.validators.push({
	    validator: this.enumValidator,
	    message: errorMessage,
	    type: 'enum',
	    enumValues: vals
	  });
	
	  return this;
	};
	
	/**
	 * Adds a lowercase setter.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ email: { type: String, lowercase: true }})
	 *     var M = db.model('M', s);
	 *     var m = new M({ email: 'SomeEmail@example.COM' });
	 *     console.log(m.email) // someemail@example.com
	 *
	 * @api public
	 * @return {SchemaType} this
	 */
	
	SchemaString.prototype.lowercase = function(shouldApply) {
	  if (arguments.length > 0 && !shouldApply) {
	    return this;
	  }
	  return this.set(function(v, self) {
	    if (typeof v !== 'string') {
	      v = self.cast(v);
	    }
	    if (v) {
	      return v.toLowerCase();
	    }
	    return v;
	  });
	};
	
	/**
	 * Adds an uppercase setter.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ caps: { type: String, uppercase: true }})
	 *     var M = db.model('M', s);
	 *     var m = new M({ caps: 'an example' });
	 *     console.log(m.caps) // AN EXAMPLE
	 *
	 * @api public
	 * @return {SchemaType} this
	 */
	
	SchemaString.prototype.uppercase = function(shouldApply) {
	  if (arguments.length > 0 && !shouldApply) {
	    return this;
	  }
	  return this.set(function(v, self) {
	    if (typeof v !== 'string') {
	      v = self.cast(v);
	    }
	    if (v) {
	      return v.toUpperCase();
	    }
	    return v;
	  });
	};
	
	/**
	 * Adds a trim setter.
	 *
	 * The string value will be trimmed when set.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ name: { type: String, trim: true }})
	 *     var M = db.model('M', s)
	 *     var string = ' some name '
	 *     console.log(string.length) // 11
	 *     var m = new M({ name: string })
	 *     console.log(m.name.length) // 9
	 *
	 * @api public
	 * @return {SchemaType} this
	 */
	
	SchemaString.prototype.trim = function(shouldTrim) {
	  if (arguments.length > 0 && !shouldTrim) {
	    return this;
	  }
	  return this.set(function(v, self) {
	    if (typeof v !== 'string') {
	      v = self.cast(v);
	    }
	    if (v) {
	      return v.trim();
	    }
	    return v;
	  });
	};
	
	/**
	 * Sets a minimum length validator.
	 *
	 * ####Example:
	 *
	 *     var schema = new Schema({ postalCode: { type: String, minlength: 5 })
	 *     var Address = db.model('Address', schema)
	 *     var address = new Address({ postalCode: '9512' })
	 *     address.save(function (err) {
	 *       console.error(err) // validator error
	 *       address.postalCode = '95125';
	 *       address.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MINLENGTH} token which will be replaced with the minimum allowed length
	 *     var minlength = [5, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).'];
	 *     var schema = new Schema({ postalCode: { type: String, minlength: minlength })
	 *     var Address = mongoose.model('Address', schema);
	 *     var address = new Address({ postalCode: '9512' });
	 *     address.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).
	 *     })
	 *
	 * @param {Number} value minimum string length
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaString.prototype.minlength = function(value, message) {
	  if (this.minlengthValidator) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator !== this.minlengthValidator;
	    }, this);
	  }
	
	  if (value !== null && value !== undefined) {
	    var msg = message || MongooseError.messages.String.minlength;
	    msg = msg.replace(/{MINLENGTH}/, value);
	    this.validators.push({
	      validator: this.minlengthValidator = function(v) {
	        return v === null || v.length >= value;
	      },
	      message: msg,
	      type: 'minlength',
	      minlength: value
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Sets a maximum length validator.
	 *
	 * ####Example:
	 *
	 *     var schema = new Schema({ postalCode: { type: String, maxlength: 9 })
	 *     var Address = db.model('Address', schema)
	 *     var address = new Address({ postalCode: '9512512345' })
	 *     address.save(function (err) {
	 *       console.error(err) // validator error
	 *       address.postalCode = '95125';
	 *       address.save() // success
	 *     })
	 *
	 *     // custom error messages
	 *     // We can also use the special {MAXLENGTH} token which will be replaced with the maximum allowed length
	 *     var maxlength = [9, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];
	 *     var schema = new Schema({ postalCode: { type: String, maxlength: maxlength })
	 *     var Address = mongoose.model('Address', schema);
	 *     var address = new Address({ postalCode: '9512512345' });
	 *     address.validate(function (err) {
	 *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (9).
	 *     })
	 *
	 * @param {Number} value maximum string length
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaString.prototype.maxlength = function(value, message) {
	  if (this.maxlengthValidator) {
	    this.validators = this.validators.filter(function(v) {
	      return v.validator !== this.maxlengthValidator;
	    }, this);
	  }
	
	  if (value !== null && value !== undefined) {
	    var msg = message || MongooseError.messages.String.maxlength;
	    msg = msg.replace(/{MAXLENGTH}/, value);
	    this.validators.push({
	      validator: this.maxlengthValidator = function(v) {
	        return v === null || v.length <= value;
	      },
	      message: msg,
	      type: 'maxlength',
	      maxlength: value
	    });
	  }
	
	  return this;
	};
	
	/**
	 * Sets a regexp validator.
	 *
	 * Any value that does not pass `regExp`.test(val) will fail validation.
	 *
	 * ####Example:
	 *
	 *     var s = new Schema({ name: { type: String, match: /^a/ }})
	 *     var M = db.model('M', s)
	 *     var m = new M({ name: 'I am invalid' })
	 *     m.validate(function (err) {
	 *       console.error(String(err)) // "ValidationError: Path `name` is invalid (I am invalid)."
	 *       m.name = 'apples'
	 *       m.validate(function (err) {
	 *         assert.ok(err) // success
	 *       })
	 *     })
	 *
	 *     // using a custom error message
	 *     var match = [ /\.html$/, "That file doesn't end in .html ({VALUE})" ];
	 *     var s = new Schema({ file: { type: String, match: match }})
	 *     var M = db.model('M', s);
	 *     var m = new M({ file: 'invalid' });
	 *     m.validate(function (err) {
	 *       console.log(String(err)) // "ValidationError: That file doesn't end in .html (invalid)"
	 *     })
	 *
	 * Empty strings, `undefined`, and `null` values always pass the match validator. If you require these values, enable the `required` validator also.
	 *
	 *     var s = new Schema({ name: { type: String, match: /^a/, required: true }})
	 *
	 * @param {RegExp} regExp regular expression to test against
	 * @param {String} [message] optional custom error message
	 * @return {SchemaType} this
	 * @see Customized Error Messages #error_messages_MongooseError-messages
	 * @api public
	 */
	
	SchemaString.prototype.match = function match(regExp, message) {
	  // yes, we allow multiple match validators
	
	  var msg = message || MongooseError.messages.String.match;
	
	  var matchValidator = function(v) {
	    if (!regExp) {
	      return false;
	    }
	
	    var ret = ((v != null && v !== '')
	        ? regExp.test(v)
	        : true);
	    return ret;
	  };
	
	  this.validators.push({
	    validator: matchValidator,
	    message: msg,
	    type: 'regexp',
	    regexp: regExp
	  });
	  return this;
	};
	
	/**
	 * Check if the given value satisfies the `required` validator. The value is
	 * considered valid if it is a string (that is, not `null` or `undefined`) and
	 * has positive length. The `required` validator **will** fail for empty
	 * strings.
	 *
	 * @param {Any} value
	 * @param {Document} doc
	 * @return {Boolean}
	 * @api public
	 */
	
	SchemaString.prototype.checkRequired = function checkRequired(value, doc) {
	  if (SchemaType._isRef(this, value, doc, true)) {
	    return !!value;
	  }
	  return (value instanceof String || typeof value === 'string') && value.length;
	};
	
	/**
	 * Casts to String
	 *
	 * @api private
	 */
	
	SchemaString.prototype.cast = function(value, doc, init) {
	  if (SchemaType._isRef(this, value, doc, init)) {
	    // wait! we may need to cast this to a document
	
	    if (value === null || value === undefined) {
	      return value;
	    }
	
	    // lazy load
	    Document || (Document = __webpack_require__(8));
	
	    if (value instanceof Document) {
	      value.$__.wasPopulated = true;
	      return value;
	    }
	
	    // setting a populated path
	    if (typeof value === 'string') {
	      return value;
	    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {
	      throw new CastError('string', value, this.path);
	    }
	
	    // Handle the case where user directly sets a populated
	    // path to a plain object; cast to the Model used in
	    // the population query.
	    var path = doc.$__fullPath(this.path);
	    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
	    var pop = owner.populated(path, true);
	    var ret = new pop.options.model(value);
	    ret.$__.wasPopulated = true;
	    return ret;
	  }
	
	  // If null or undefined
	  if (value === null || value === undefined) {
	    return value;
	  }
	
	  if (typeof value !== 'undefined') {
	    // handle documents being passed
	    if (value._id && typeof value._id === 'string') {
	      return value._id;
	    }
	
	    // Re: gh-647 and gh-3030, we're ok with casting using `toString()`
	    // **unless** its the default Object.toString, because "[object Object]"
	    // doesn't really qualify as useful data
	    if (value.toString && value.toString !== Object.prototype.toString) {
	      return value.toString();
	    }
	  }
	
	  throw new CastError('string', value, this.path);
	};
	
	/*!
	 * ignore
	 */
	
	function handleSingle(val) {
	  return this.castForQuery(val);
	}
	
	function handleArray(val) {
	  var _this = this;
	  if (!Array.isArray(val)) {
	    return [this.castForQuery(val)];
	  }
	  return val.map(function(m) {
	    return _this.castForQuery(m);
	  });
	}
	
	SchemaString.prototype.$conditionalHandlers =
	    utils.options(SchemaType.prototype.$conditionalHandlers, {
	      $all: handleArray,
	      $gt: handleSingle,
	      $gte: handleSingle,
	      $lt: handleSingle,
	      $lte: handleSingle,
	      $options: handleSingle,
	      $regex: handleSingle,
	      $not: handleSingle
	    });
	
	/**
	 * Casts contents for queries.
	 *
	 * @param {String} $conditional
	 * @param {any} [val]
	 * @api private
	 */
	
	SchemaString.prototype.castForQuery = function($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	    if (!handler) {
	      throw new Error('Can\'t use ' + $conditional + ' with String.');
	    }
	    return handler.call(this, val);
	  }
	  val = $conditional;
	  if (Object.prototype.toString.call(val) === '[object RegExp]') {
	    return val;
	  }
	
	  return this._castForQuery(val);
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = SchemaString;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/*!
	 * Module dependencies.
	 */
	
	var PromiseProvider = __webpack_require__(14);
	var async = __webpack_require__(267);
	
	/**
	 * Execute `fn` for every document in the cursor. If `fn` returns a promise,
	 * will wait for the promise to resolve before iterating on to the next one.
	 * Returns a promise that resolves when done.
	 *
	 * @param {Function} next the thunk to call to get the next document
	 * @param {Function} fn
	 * @param {Object} options
	 * @param {Function} [callback] executed when all docs have been processed
	 * @return {Promise}
	 * @api public
	 * @method eachAsync
	 */
	
	module.exports = function eachAsync(next, fn, options, callback) {
	  var Promise = PromiseProvider.get();
	  var parallel = options.parallel || 1;
	
	  var handleNextResult = function(doc, callback) {
	    var promise = fn(doc);
	    if (promise && typeof promise.then === 'function') {
	      promise.then(
	        function() { callback(null); },
	        function(error) { callback(error); });
	    } else {
	      callback(null);
	    }
	  };
	
	  var iterate = function(callback) {
	    var drained = false;
	    var nextQueue = async.queue(function(task, cb) {
	      if (drained) return cb();
	      next(function(err, doc) {
	        if (err) return cb(err);
	        if (!doc) drained = true;
	        cb(null, doc);
	      });
	    }, 1);
	
	    var getAndRun = function(cb) {
	      nextQueue.push({}, function(err, doc) {
	        if (err) return cb(err);
	        if (!doc) return cb();
	        handleNextResult(doc, function(err) {
	          if (err) return cb(err);
	          // Make sure to clear the stack re: gh-4697
	          setTimeout(function() {
	            getAndRun(cb);
	          }, 0);
	        });
	      });
	    };
	
	    async.times(parallel, function(n, cb) {
	      getAndRun(cb);
	    }, callback);
	  };
	
	  return new Promise.ES6(function(resolve, reject) {
	    iterate(function(error) {
	      if (error) {
	        callback && callback(error);
	        return reject(error);
	      }
	      callback && callback(null);
	      return resolve();
	    });
	  });
	};


/***/ }),
/* 145 */
/***/ (function(module, exports) {

	'use strict';
	
	/*!
	 * ignore
	 */
	
	module.exports = function cleanModifiedSubpaths(doc, path) {
	  var _modifiedPaths = Object.keys(doc.$__.activePaths.states.modify);
	  var _numModifiedPaths = _modifiedPaths.length;
	  var deleted = 0;
	  for (var j = 0; j < _numModifiedPaths; ++j) {
	    if (_modifiedPaths[j].indexOf(path + '.') === 0) {
	      delete doc.$__.activePaths.states.modify[_modifiedPaths[j]];
	      ++deleted;
	    }
	  }
	  return deleted;
	};


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var StrictModeError = __webpack_require__(93);
	var utils = __webpack_require__(4);
	
	/*!
	 * Casts an update op based on the given schema
	 *
	 * @param {Schema} schema
	 * @param {Object} obj
	 * @param {Object} options
	 * @param {Boolean} [options.overwrite] defaults to false
	 * @param {Boolean|String} [options.strict] defaults to true
	 * @param {Query} context passed to setters
	 * @return {Boolean} true iff the update is non-empty
	 */
	
	module.exports = function castUpdate(schema, obj, options, context) {
	  if (!obj) {
	    return undefined;
	  }
	
	  var ops = Object.keys(obj);
	  var i = ops.length;
	  var ret = {};
	  var hasKeys;
	  var val;
	  var hasDollarKey = false;
	  var overwrite = options.overwrite;
	
	  while (i--) {
	    var op = ops[i];
	    // if overwrite is set, don't do any of the special $set stuff
	    if (op[0] !== '$' && !overwrite) {
	      // fix up $set sugar
	      if (!ret.$set) {
	        if (obj.$set) {
	          ret.$set = obj.$set;
	        } else {
	          ret.$set = {};
	        }
	      }
	      ret.$set[op] = obj[op];
	      ops.splice(i, 1);
	      if (!~ops.indexOf('$set')) ops.push('$set');
	    } else if (op === '$set') {
	      if (!ret.$set) {
	        ret[op] = obj[op];
	      }
	    } else {
	      ret[op] = obj[op];
	    }
	  }
	
	  // cast each value
	  i = ops.length;
	
	  // if we get passed {} for the update, we still need to respect that when it
	  // is an overwrite scenario
	  if (overwrite) {
	    hasKeys = true;
	  }
	
	  while (i--) {
	    op = ops[i];
	    val = ret[op];
	    hasDollarKey = hasDollarKey || op.charAt(0) === '$';
	    if (val &&
	        typeof val === 'object' &&
	        (!overwrite || hasDollarKey)) {
	      hasKeys |= walkUpdatePath(schema, val, op, options.strict, context);
	    } else if (overwrite && ret && typeof ret === 'object') {
	      // if we are just using overwrite, cast the query and then we will
	      // *always* return the value, even if it is an empty object. We need to
	      // set hasKeys above because we need to account for the case where the
	      // user passes {} and wants to clobber the whole document
	      // Also, _walkUpdatePath expects an operation, so give it $set since that
	      // is basically what we're doing
	      walkUpdatePath(schema, ret, '$set', options.strict, context);
	    } else {
	      var msg = 'Invalid atomic update value for ' + op + '. '
	          + 'Expected an object, received ' + typeof val;
	      throw new Error(msg);
	    }
	  }
	
	  return hasKeys && ret;
	};
	
	/*!
	 * Walk each path of obj and cast its values
	 * according to its schema.
	 *
	 * @param {Schema} schema
	 * @param {Object} obj - part of a query
	 * @param {String} op - the atomic operator ($pull, $set, etc)
	 * @param {Boolean|String} strict
	 * @param {Query} context
	 * @param {String} pref - path prefix (internal only)
	 * @return {Bool} true if this path has keys to update
	 * @api private
	 */
	
	function walkUpdatePath(schema, obj, op, strict, context, pref) {
	  var prefix = pref ? pref + '.' : '',
	      keys = Object.keys(obj),
	      i = keys.length,
	      hasKeys = false,
	      schematype,
	      key,
	      val;
	
	  var useNestedStrict = schema.options.useNestedStrict;
	
	  while (i--) {
	    key = keys[i];
	    val = obj[key];
	
	    if (val && val.constructor.name === 'Object') {
	      // watch for embedded doc schemas
	      schematype = schema._getSchema(prefix + key);
	      if (schematype && schematype.caster && op in castOps) {
	        // embedded doc schema
	        hasKeys = true;
	
	        if ('$each' in val) {
	          obj[key] = {
	            $each: castUpdateVal(schematype, val.$each, op, context)
	          };
	
	          if (val.$slice != null) {
	            obj[key].$slice = val.$slice | 0;
	          }
	
	          if (val.$sort) {
	            obj[key].$sort = val.$sort;
	          }
	
	          if (!!val.$position || val.$position === 0) {
	            obj[key].$position = val.$position;
	          }
	        } else {
	          obj[key] = castUpdateVal(schematype, val, op, context);
	        }
	      } else if (op === '$currentDate') {
	        // $currentDate can take an object
	        obj[key] = castUpdateVal(schematype, val, op, context);
	        hasKeys = true;
	      } else if (op in castOps && schematype) {
	        obj[key] = castUpdateVal(schematype, val, op, context);
	        hasKeys = true;
	      } else {
	        var pathToCheck = (prefix + key);
	        var v = schema._getPathType(pathToCheck);
	        var _strict = strict;
	        if (useNestedStrict &&
	            v &&
	            v.schema &&
	            'strict' in v.schema.options) {
	          _strict = v.schema.options.strict;
	        }
	
	        if (v.pathType === 'undefined') {
	          if (_strict === 'throw') {
	            throw new StrictModeError(pathToCheck);
	          } else if (_strict) {
	            delete obj[key];
	            continue;
	          }
	        }
	
	        // gh-2314
	        // we should be able to set a schema-less field
	        // to an empty object literal
	        hasKeys |= walkUpdatePath(schema, val, op, strict, context, prefix + key) ||
	          (utils.isObject(val) && Object.keys(val).length === 0);
	      }
	    } else {
	      var checkPath = (key === '$each' || key === '$or' || key === '$and') ?
	        pref : prefix + key;
	      schematype = schema._getSchema(checkPath);
	
	      var pathDetails = schema._getPathType(checkPath);
	      var isStrict = strict;
	      if (useNestedStrict &&
	          pathDetails &&
	          pathDetails.schema &&
	          'strict' in pathDetails.schema.options) {
	        isStrict = pathDetails.schema.options.strict;
	      }
	
	      var skip = isStrict &&
	          !schematype &&
	          !/real|nested/.test(pathDetails.pathType);
	
	      if (skip) {
	        if (isStrict === 'throw') {
	          throw new StrictModeError(prefix + key);
	        } else {
	          delete obj[key];
	        }
	      } else {
	        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking
	        // improving this.
	        if (op === '$rename') {
	          hasKeys = true;
	          continue;
	        }
	
	        hasKeys = true;
	        obj[key] = castUpdateVal(schematype, val, op, key, context);
	      }
	    }
	  }
	  return hasKeys;
	}
	
	/*!
	 * These operators should be cast to numbers instead
	 * of their path schema type.
	 */
	
	var numberOps = {
	  $pop: 1,
	  $unset: 1,
	  $inc: 1
	};
	
	/*!
	 * These operators require casting docs
	 * to real Documents for Update operations.
	 */
	
	var castOps = {
	  $push: 1,
	  $pushAll: 1,
	  $addToSet: 1,
	  $set: 1,
	  $setOnInsert: 1
	};
	
	/*!
	 * ignore
	 */
	
	var overwriteOps = {
	  $set: 1,
	  $setOnInsert: 1
	};
	
	/*!
	 * Casts `val` according to `schema` and atomic `op`.
	 *
	 * @param {SchemaType} schema
	 * @param {Object} val
	 * @param {String} op - the atomic operator ($pull, $set, etc)
	 * @param {String} $conditional
	 * @param {Query} context
	 * @api private
	 */
	
	function castUpdateVal(schema, val, op, $conditional, context) {
	  if (!schema) {
	    // non-existing schema path
	    return op in numberOps
	        ? Number(val)
	        : val;
	  }
	
	  var cond = schema.caster && op in castOps &&
	      (utils.isObject(val) || Array.isArray(val));
	  if (cond) {
	    // Cast values for ops that add data to MongoDB.
	    // Ensures embedded documents get ObjectIds etc.
	    var tmp = schema.cast(val);
	    if (Array.isArray(val)) {
	      val = tmp;
	    } else if (Array.isArray(tmp)) {
	      val = tmp[0];
	    } else {
	      val = tmp;
	    }
	    return val;
	  }
	
	  if (op in numberOps) {
	    if (op === '$inc') {
	      return schema.castForQueryWrapper({ val: val, context: context });
	    }
	    return Number(val);
	  }
	  if (op === '$currentDate') {
	    if (typeof val === 'object') {
	      return {$type: val.$type};
	    }
	    return Boolean(val);
	  }
	
	  if (/^\$/.test($conditional)) {
	    return schema.castForQueryWrapper({
	      $conditional: $conditional,
	      val: val,
	      context: context
	    });
	  }
	
	  if (overwriteOps[op]) {
	    return schema.castForQueryWrapper({
	      val: val,
	      context: context,
	      $skipQueryCastForUpdate: val != null && schema.$isMongooseArray
	    });
	  }
	
	  return schema.castForQueryWrapper({ val: val, context: context });
	}


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	var Document = __webpack_require__(8);
	var PromiseProvider = __webpack_require__(14);
	
	module.exports = Subdocument;
	
	/**
	 * Subdocument constructor.
	 *
	 * @inherits Document
	 * @api private
	 */
	
	function Subdocument(value, fields, parent, skipId, options) {
	  this.$isSingleNested = true;
	  Document.call(this, value, fields, skipId, options);
	}
	
	Subdocument.prototype = Object.create(Document.prototype);
	
	Subdocument.prototype.toBSON = function() {
	  return this.toObject({
	    transform: false,
	    virtuals: false,
	    _skipDepopulateTopLevel: true,
	    depopulate: true,
	    flattenDecimals: false
	  });
	};
	
	/**
	 * Used as a stub for [hooks.js](https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3)
	 *
	 * ####NOTE:
	 *
	 * _This is a no-op. Does not actually save the doc to the db._
	 *
	 * @param {Function} [fn]
	 * @return {Promise} resolved Promise
	 * @api private
	 */
	
	Subdocument.prototype.save = function(fn) {
	  var Promise = PromiseProvider.get();
	  return new Promise.ES6(function(resolve) {
	    fn && fn();
	    resolve();
	  });
	};
	
	Subdocument.prototype.$isValid = function(path) {
	  if (this.$parent && this.$basePath) {
	    return this.$parent.$isValid([this.$basePath, path].join('.'));
	  }
	  return Document.prototype.$isValid.call(this, path);
	};
	
	Subdocument.prototype.markModified = function(path) {
	  Document.prototype.markModified.call(this, path);
	  if (this.$parent && this.$basePath) {
	    if (this.$parent.isDirectModified(this.$basePath)) {
	      return;
	    }
	    this.$parent.markModified([this.$basePath, path].join('.'), this);
	  }
	};
	
	Subdocument.prototype.$markValid = function(path) {
	  Document.prototype.$markValid.call(this, path);
	  if (this.$parent && this.$basePath) {
	    this.$parent.$markValid([this.$basePath, path].join('.'));
	  }
	};
	
	Subdocument.prototype.invalidate = function(path, err, val) {
	  // Hack: array subdocuments' validationError is equal to the owner doc's,
	  // so validating an array subdoc gives the top-level doc back. Temporary
	  // workaround for #5208 so we don't have circular errors.
	  if (err !== this.ownerDocument().$__.validationError) {
	    Document.prototype.invalidate.call(this, path, err, val);
	  }
	
	  if (this.$parent && this.$basePath) {
	    this.$parent.invalidate([this.$basePath, path].join('.'), err, val);
	  } else if (err.kind === 'cast' || err.name === 'CastError') {
	    throw err;
	  }
	};
	
	/**
	 * Returns the top level document of this sub-document.
	 *
	 * @return {Document}
	 */
	
	Subdocument.prototype.ownerDocument = function() {
	  if (this.$__.ownerDocument) {
	    return this.$__.ownerDocument;
	  }
	
	  var parent = this.$parent;
	  if (!parent) {
	    return this;
	  }
	
	  while (parent.$parent || parent.__parent) {
	    parent = parent.$parent || parent.__parent;
	  }
	  this.$__.ownerDocument = parent;
	  return this.$__.ownerDocument;
	};
	
	/**
	 * Returns this sub-documents parent document.
	 *
	 * @api public
	 */
	
	Subdocument.prototype.parent = function() {
	  return this.$parent;
	};
	
	/**
	 * Null-out this subdoc
	 *
	 * @param {Object} [options]
	 * @param {Function} [callback] optional callback for compatibility with Document.prototype.remove
	 */
	
	Subdocument.prototype.remove = function(options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = null;
	  }
	
	  registerRemoveListener(this);
	
	  // If removing entire doc, no need to remove subdoc
	  if (!options || !options.noop) {
	    this.$parent.set(this.$basePath, null);
	  }
	
	  if (typeof callback === 'function') {
	    callback(null);
	  }
	};
	
	/*!
	 * ignore
	 */
	
	Subdocument.prototype.populate = function() {
	  throw new Error('Mongoose does not support calling populate() on nested ' +
	    'docs. Instead of `doc.nested.populate("path")`, use ' +
	    '`doc.populate("nested.path")`');
	};
	
	/*!
	 * Registers remove event listeners for triggering
	 * on subdocuments.
	 *
	 * @param {EmbeddedDocument} sub
	 * @api private
	 */
	
	function registerRemoveListener(sub) {
	  var owner = sub.ownerDocument();
	
	  function emitRemove() {
	    owner.removeListener('save', emitRemove);
	    owner.removeListener('remove', emitRemove);
	    sub.emit('remove', sub);
	    sub.constructor.emit('remove', sub);
	    owner = sub = null;
	  }
	
	  owner.on('save', emitRemove);
	  owner.on('remove', emitRemove);
	}


/***/ }),
/* 148 */
/***/ (function(module, exports) {

	'use strict';
	
	exports.isNode = 'undefined' != typeof process
	           && 'object' == typeof module
	           && 'object' == typeof global
	           && 'function' == typeof Buffer
	           && process.argv
	
	exports.isMongo = !exports.isNode
	           && 'function' == typeof printjson
	           && 'function' == typeof ObjectId
	           && 'function' == typeof rs
	           && 'function' == typeof sh;
	
	exports.isBrowser = !exports.isNode
	                 && !exports.isMongo
	                 && 'undefined' != typeof window;
	
	exports.type = exports.isNode ? 'node'
	  : exports.isMongo ? 'mongo'
	  : exports.isBrowser ? 'browser'
	  : 'unknown'


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/*!
	 * Module dependencies.
	 */
	
	var RegExpClone = __webpack_require__(150)
	
	/**
	 * Clones objects
	 *
	 * @param {Object} obj the object to clone
	 * @param {Object} options
	 * @return {Object} the cloned object
	 * @api private
	 */
	
	var clone = exports.clone = function clone (obj, options) {
	  if (obj === undefined || obj === null)
	    return obj;
	
	  if (Array.isArray(obj))
	    return exports.cloneArray(obj, options);
	
	  if (obj.constructor) {
	    if (/ObjectI[dD]$/.test(obj.constructor.name)) {
	      return 'function' == typeof obj.clone
	        ? obj.clone()
	        : new obj.constructor(obj.id);
	    }
	
	    if ('ReadPreference' === obj._type && obj.isValid && obj.toObject) {
	      return 'function' == typeof obj.clone
	        ? obj.clone()
	        : new obj.constructor(obj.mode, clone(obj.tags, options));
	    }
	
	    if ('Binary' == obj._bsontype && obj.buffer && obj.value) {
	      return 'function' == typeof obj.clone
	        ? obj.clone()
	        : new obj.constructor(obj.value(true), obj.sub_type);
	    }
	
	    if ('Date' === obj.constructor.name || 'Function' === obj.constructor.name)
	      return new obj.constructor(+obj);
	
	    if ('RegExp' === obj.constructor.name)
	      return RegExpClone(obj);
	
	    if ('Buffer' === obj.constructor.name)
	      return exports.cloneBuffer(obj);
	  }
	
	  if (isObject(obj))
	    return exports.cloneObject(obj, options);
	
	  if (obj.valueOf)
	    return obj.valueOf();
	};
	
	/*!
	 * ignore
	 */
	
	var cloneObject = exports.cloneObject = function cloneObject (obj, options) {
	  var retainKeyOrder = options && options.retainKeyOrder
	    , minimize = options && options.minimize
	    , ret = {}
	    , hasKeys
	    , keys
	    , val
	    , k
	    , i
	
	  if (retainKeyOrder) {
	    for (k in obj) {
	      val = clone(obj[k], options);
	
	      if (!minimize || ('undefined' !== typeof val)) {
	        hasKeys || (hasKeys = true);
	        ret[k] = val;
	      }
	    }
	  } else {
	    // faster
	
	    keys = Object.keys(obj);
	    i = keys.length;
	
	    while (i--) {
	      k = keys[i];
	      val = clone(obj[k], options);
	
	      if (!minimize || ('undefined' !== typeof val)) {
	        if (!hasKeys) hasKeys = true;
	        ret[k] = val;
	      }
	    }
	  }
	
	  return minimize
	    ? hasKeys && ret
	    : ret;
	};
	
	var cloneArray = exports.cloneArray = function cloneArray (arr, options) {
	  var ret = [];
	  for (var i = 0, l = arr.length; i < l; i++)
	    ret.push(clone(arr[i], options));
	  return ret;
	};
	
	/**
	 * process.nextTick helper.
	 *
	 * Wraps the given `callback` in a try/catch. If an error is
	 * caught it will be thrown on nextTick.
	 *
	 * node-mongodb-native had a habit of state corruption when
	 * an error was immediately thrown from within a collection
	 * method (find, update, etc) callback.
	 *
	 * @param {Function} [callback]
	 * @api private
	 */
	
	var tick = exports.tick = function tick (callback) {
	  if ('function' !== typeof callback) return;
	  return function () {
	    // callbacks should always be fired on the next
	    // turn of the event loop. A side benefit is
	    // errors thrown from executing the callback
	    // will not cause drivers state to be corrupted
	    // which has historically been a problem.
	    var args = arguments;
	    soon(function(){
	      callback.apply(this, args);
	    });
	  }
	}
	
	/**
	 * Merges `from` into `to` without overwriting existing properties.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 * @api private
	 */
	
	var merge = exports.merge = function merge (to, from) {
	  var keys = Object.keys(from)
	    , i = keys.length
	    , key
	
	  while (i--) {
	    key = keys[i];
	    if ('undefined' === typeof to[key]) {
	      to[key] = from[key];
	    } else {
	      if (exports.isObject(from[key])) {
	        merge(to[key], from[key]);
	      } else {
	        to[key] = from[key];
	      }
	    }
	  }
	}
	
	/**
	 * Same as merge but clones the assigned values.
	 *
	 * @param {Object} to
	 * @param {Object} from
	 * @api private
	 */
	
	var mergeClone = exports.mergeClone = function mergeClone (to, from) {
	  var keys = Object.keys(from)
	    , i = keys.length
	    , key
	
	  while (i--) {
	    key = keys[i];
	    if ('undefined' === typeof to[key]) {
	      // make sure to retain key order here because of a bug handling the $each
	      // operator in mongodb 2.4.4
	      to[key] = clone(from[key], { retainKeyOrder : 1});
	    } else {
	      if (exports.isObject(from[key])) {
	        mergeClone(to[key], from[key]);
	      } else {
	        // make sure to retain key order here because of a bug handling the
	        // $each operator in mongodb 2.4.4
	        to[key] = clone(from[key], { retainKeyOrder : 1});
	      }
	    }
	  }
	}
	
	/**
	 * Read pref helper (mongo 2.2 drivers support this)
	 *
	 * Allows using aliases instead of full preference names:
	 *
	 *     p   primary
	 *     pp  primaryPreferred
	 *     s   secondary
	 *     sp  secondaryPreferred
	 *     n   nearest
	 *
	 * @param {String} pref
	 */
	
	exports.readPref = function readPref (pref) {
	  switch (pref) {
	    case 'p':
	      pref = 'primary';
	      break;
	    case 'pp':
	      pref = 'primaryPreferred';
	      break;
	    case 's':
	      pref = 'secondary';
	      break;
	    case 'sp':
	      pref = 'secondaryPreferred';
	      break;
	    case 'n':
	      pref = 'nearest';
	      break;
	  }
	
	  return pref;
	}
	
	/**
	 * Object.prototype.toString.call helper
	 */
	
	var _toString = Object.prototype.toString;
	var toString = exports.toString = function (arg) {
	  return _toString.call(arg);
	}
	
	/**
	 * Determines if `arg` is an object.
	 *
	 * @param {Object|Array|String|Function|RegExp|any} arg
	 * @return {Boolean}
	 */
	
	var isObject = exports.isObject = function (arg) {
	  return '[object Object]' == exports.toString(arg);
	}
	
	/**
	 * Determines if `arg` is an array.
	 *
	 * @param {Object}
	 * @return {Boolean}
	 * @see nodejs utils
	 */
	
	var isArray = exports.isArray = function (arg) {
	  return Array.isArray(arg) ||
	    'object' == typeof arg && '[object Array]' == exports.toString(arg);
	}
	
	/**
	 * Object.keys helper
	 */
	
	exports.keys = Object.keys || function (obj) {
	  var keys = [];
	  for (var k in obj) if (obj.hasOwnProperty(k)) {
	    keys.push(k);
	  }
	  return keys;
	}
	
	/**
	 * Basic Object.create polyfill.
	 * Only one argument is supported.
	 *
	 * Based on https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create
	 */
	
	exports.create = 'function' == typeof Object.create
	  ? Object.create
	  : create;
	
	function create (proto) {
	  if (arguments.length > 1) {
	    throw new Error("Adding properties is not supported")
	  }
	
	  function F () {}
	  F.prototype = proto;
	  return new F;
	}
	
	/**
	 * inheritance
	 */
	
	exports.inherits = function (ctor, superCtor) {
	  ctor.prototype = exports.create(superCtor.prototype);
	  ctor.prototype.constructor = ctor;
	}
	
	/**
	 * nextTick helper
	 * compat with node 0.10 which behaves differently than previous versions
	 */
	
	var soon = exports.soon = 'function' == typeof setImmediate
	  ? setImmediate
	  : process.nextTick;
	
	/**
	 * Clones the contents of a buffer.
	 *
	 * @param {Buffer} buff
	 * @return {Buffer}
	 */
	
	exports.cloneBuffer = function (buff) {
	  var dupe = new Buffer(buff.length);
	  buff.copy(dupe, 0, 0, buff.length);
	  return dupe;
	};
	
	/**
	 * Check if this object is an arguments object
	 *
	 * @param {Any} v
	 * @return {Boolean}
	 */
	
	exports.isArgumentsObject = function(v) {
	  return Object.prototype.toString.call(v) === '[object Arguments]';
	};


/***/ }),
/* 150 */
/***/ (function(module, exports) {

	
	var toString = Object.prototype.toString;
	
	function isRegExp (o) {
	  return 'object' == typeof o
	      && '[object RegExp]' == toString.call(o);
	}
	
	module.exports = exports = function (regexp) {
	  if (!isRegExp(regexp)) {
	    throw new TypeError('Not a RegExp');
	  }
	
	  var flags = [];
	  if (regexp.global) flags.push('g');
	  if (regexp.multiline) flags.push('m');
	  if (regexp.ignoreCase) flags.push('i');
	  return new RegExp(regexp.source, flags.join(''));
	}
	


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	var assert = __webpack_require__(152),
	  require_optional = __webpack_require__(20),
	  nestedTest = __webpack_require__(106);
	
	describe('Require Optional', function() {
	  describe('top level require', function() {
	    it('should correctly require co library', function() {
	      var promise = require_optional('es6-promise');
	      assert.ok(promise);
	    });
	
	    it('should fail to require es6-promise library', function() {
	      try {
	        require_optional('co');
	      } catch(e) {
	        assert.equal('OPTIONAL_MODULE_NOT_FOUND', e.code);
	        return;
	      }
	
	      assert.ok(false);
	    });
	
	    it('should ignore optional library not defined', function() {
	      assert.equal(undefined, require_optional('es6-promise2'));
	    });
	  });
	
	  describe('internal module file require', function() {
	    it('should correctly require co library', function() {
	      var Long = require_optional('bson/lib/bson/long.js');
	      assert.ok(Long);
	    });
	  });
	
	  describe('top level resolve', function() {
	    it('should correctly use exists method', function() {
	      assert.equal(false, require_optional.exists('co'));
	      assert.equal(true, require_optional.exists('es6-promise'));
	      assert.equal(true, require_optional.exists('bson/lib/bson/long.js'));
	      assert.equal(false, require_optional.exists('es6-promise2'));
	    });
	  });
	
	  describe('require_optional inside dependencies', function() {
	    it('should correctly walk up module call stack searching for peerOptionalDependencies', function() {
	      assert.ok(nestedTest.findPackage('bson'))
	    });
	    it('should return null when a package is defined in top-level package.json but not installed', function() {
	      assert.equal(null, nestedTest.findPackage('es6-promise2'))
	    });
	    it('should error when searching for an optional dependency that is not defined in any ancestor package.json', function() {
	      try {
	        nestedTest.findPackage('bison')
	      } catch (err) {
	        assert.equal(err.message, 'no optional dependency [bison] defined in peerOptionalDependencies in any package.json')
	      }
	    })
	  });
	});


/***/ }),
/* 152 */
/***/ (function(module, exports) {

	module.exports = require("assert");

/***/ }),
/* 153 */
/***/ (function(module, exports) {

	module.exports = require("buffer");

/***/ }),
/* 154 */
/***/ (function(module, exports) {

	module.exports = require("fs");

/***/ }),
/* 155 */
/***/ (function(module, exports) {

	module.exports = require("querystring");

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = eachOfLimit;
	
	var _eachOfLimit2 = __webpack_require__(110);
	
	var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name eachOfLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.eachOf]{@link module:Collections.eachOf}
	 * @alias forEachOfLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A function to apply to each
	 * item in `coll`. The `key` is the item's key, or index in the case of an
	 * array. The iteratee is passed a `callback(err)` which must be called once it
	 * has completed. If no error has occurred, the callback should be run without
	 * arguments or with an explicit `null` argument. Invoked with
	 * (item, key, callback).
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 */
	function eachOfLimit(coll, limit, iteratee, callback) {
	  (0, _eachOfLimit3.default)(limit)(coll, iteratee, callback);
	}
	module.exports = exports['default'];

/***/ }),
/* 157 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	// A temporary value used to identify if the loop should be broken.
	// See #1064, #1293
	exports.default = {};
	module.exports = exports["default"];

/***/ }),
/* 158 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = doLimit;
	function doLimit(fn, limit) {
	    return function (iterable, iteratee, callback) {
	        return fn(iterable, limit, iteratee, callback);
	    };
	}
	module.exports = exports["default"];

/***/ }),
/* 159 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	exports.default = function (coll) {
	    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
	};
	
	var iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;
	
	module.exports = exports['default'];

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = iterator;
	
	var _isArrayLike = __webpack_require__(51);
	
	var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
	
	var _getIterator = __webpack_require__(159);
	
	var _getIterator2 = _interopRequireDefault(_getIterator);
	
	var _keys = __webpack_require__(192);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createArrayIterator(coll) {
	    var i = -1;
	    var len = coll.length;
	    return function next() {
	        return ++i < len ? { value: coll[i], key: i } : null;
	    };
	}
	
	function createES2015Iterator(iterator) {
	    var i = -1;
	    return function next() {
	        var item = iterator.next();
	        if (item.done) return null;
	        i++;
	        return { value: item.value, key: i };
	    };
	}
	
	function createObjectIterator(obj) {
	    var okeys = (0, _keys2.default)(obj);
	    var i = -1;
	    var len = okeys.length;
	    return function next() {
	        var key = okeys[++i];
	        return i < len ? { value: obj[key], key: key } : null;
	    };
	}
	
	function iterator(coll) {
	    if ((0, _isArrayLike2.default)(coll)) {
	        return createArrayIterator(coll);
	    }
	
	    var iterator = (0, _getIterator2.default)(coll);
	    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
	}
	module.exports = exports['default'];

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = rest;
	
	var _overRest2 = __webpack_require__(184);
	
	var _overRest3 = _interopRequireDefault(_overRest2);
	
	var _identity = __webpack_require__(185);
	
	var _identity2 = _interopRequireDefault(_identity);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Lodash rest function without function.toString()
	// remappings
	function rest(func, start) {
	    return (0, _overRest3.default)(func, start, _identity2.default);
	}
	module.exports = exports['default'];

/***/ }),
/* 162 */
/***/ (function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = _withoutIndex;
	function _withoutIndex(iteratee) {
	    return function (value, index, callback) {
	        return iteratee(value, callback);
	    };
	}
	module.exports = exports["default"];

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = parallelLimit;
	
	var _eachOfLimit = __webpack_require__(110);
	
	var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
	
	var _parallel = __webpack_require__(113);
	
	var _parallel2 = _interopRequireDefault(_parallel);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name parallelLimit
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.parallel]{@link module:ControlFlow.parallel}
	 * @category Control Flow
	 * @param {Array|Collection} tasks - A collection containing functions to run.
	 * Each function is passed a `callback(err, result)` which it must call on
	 * completion with an error `err` (which can be `null`) and an optional `result`
	 * value.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} [callback] - An optional callback to run once all the
	 * functions have completed successfully. This function gets a results array
	 * (or object) containing all the result arguments passed to the task callbacks.
	 * Invoked with (err, results).
	 */
	function parallelLimit(tasks, limit, callback) {
	  (0, _parallel2.default)((0, _eachOfLimit2.default)(limit), tasks, callback);
	}
	module.exports = exports['default'];

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict"
	
	var writeIEEE754 = __webpack_require__(21).writeIEEE754,
		readIEEE754 = __webpack_require__(21).readIEEE754,
	  Map = __webpack_require__(71),
		Long = __webpack_require__(26),
	  Double = __webpack_require__(36),
	  Timestamp = __webpack_require__(42),
	  ObjectID = __webpack_require__(39),
	  BSONRegExp = __webpack_require__(40),
	  Symbol = __webpack_require__(41),
		Int32 = __webpack_require__(50),
	  Code = __webpack_require__(33),
		Decimal128 = __webpack_require__(35),
	  MinKey = __webpack_require__(38),
	  MaxKey = __webpack_require__(37),
	  DBRef = __webpack_require__(34),
	  Binary = __webpack_require__(32);
	
	// Parts of the parser
	var deserialize = __webpack_require__(166),
		serializer = __webpack_require__(167),
		calculateObjectSize = __webpack_require__(165);
	
	/**
	 * @ignore
	 * @api private
	 */
	// Max Size
	var MAXSIZE = (1024*1024*17);
	// Max Document Buffer size
	var buffer = new Buffer(MAXSIZE);
	
	var BSON = function() {
	}
	
	/**
	 * Serialize a Javascript object.
	 *
	 * @param {Object} object the Javascript object to serialize.
	 * @param {Boolean} [options.checkKeys] the serializer will check if keys are valid.
	 * @param {Boolean} [options.serializeFunctions=false] serialize the javascript functions **(default:false)**.
	 * @param {Boolean} [options.ignoreUndefined=true] ignore undefined fields **(default:true)**.
	 * @return {Buffer} returns the Buffer object containing the serialized object.
	 * @api public
	 */
	BSON.prototype.serialize = function serialize(object, options) {
		options = options || {};
		// Unpack the options
		var checkKeys = typeof options.checkKeys == 'boolean'
			? options.checkKeys : false;
		var serializeFunctions = typeof options.serializeFunctions == 'boolean'
			? options.serializeFunctions : false;
		var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
			? options.ignoreUndefined : true;
	
		// Attempt to serialize
		var serializationIndex = serializer(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, []);
		// Create the final buffer
		var finishedBuffer = new Buffer(serializationIndex);
		// Copy into the finished buffer
		buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length);
		// Return the buffer
		return finishedBuffer;
	}
	
	/**
	 * Serialize a Javascript object using a predefined Buffer and index into the buffer, useful when pre-allocating the space for serialization.
	 *
	 * @param {Object} object the Javascript object to serialize.
	 * @param {Buffer} buffer the Buffer you pre-allocated to store the serialized BSON object.
	 * @param {Boolean} [options.checkKeys] the serializer will check if keys are valid.
	 * @param {Boolean} [options.serializeFunctions=false] serialize the javascript functions **(default:false)**.
	 * @param {Boolean} [options.ignoreUndefined=true] ignore undefined fields **(default:true)**.
	 * @param {Number} [options.index] the index in the buffer where we wish to start serializing into.
	 * @return {Number} returns the index pointing to the last written byte in the buffer.
	 * @api public
	 */
	BSON.prototype.serializeWithBufferAndIndex = function(object, finalBuffer, options) {
		options = options || {};
		// Unpack the options
		var checkKeys = typeof options.checkKeys == 'boolean'
			? options.checkKeys : false;
		var serializeFunctions = typeof options.serializeFunctions == 'boolean'
			? options.serializeFunctions : false;
		var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
			? options.ignoreUndefined : true;
		var startIndex = typeof options.index == 'number'
			? options.index : 0;
	
		// Attempt to serialize
		var serializationIndex = serializer(buffer, object, checkKeys, startIndex || 0, 0, serializeFunctions, ignoreUndefined);
		buffer.copy(finalBuffer, startIndex, 0, serializationIndex);
	
		// Return the index
		return serializationIndex - 1;
	}
	
	/**
	 * Deserialize data as BSON.
	 *
	 * @param {Buffer} buffer the buffer containing the serialized set of BSON documents.
	 * @param {Object} [options.evalFunctions=false] evaluate functions in the BSON document scoped to the object deserialized.
	 * @param {Object} [options.cacheFunctions=false] cache evaluated functions for reuse.
	 * @param {Object} [options.cacheFunctionsCrc32=false] use a crc32 code for caching, otherwise use the string of the function.
	 * @param {Object} [options.promoteLongs=true] when deserializing a Long will fit it into a Number if it's smaller than 53 bits
	 * @param {Object} [options.promoteBuffers=false] when deserializing a Binary will return it as a node.js Buffer instance.
	 * @param {Object} [options.promoteValues=false] when deserializing will promote BSON values to their Node.js closest equivalent types.
	 * @param {Object} [options.fieldsAsRaw=null] allow to specify if there what fields we wish to return as unserialized raw buffer.
	 * @param {Object} [options.bsonRegExp=false] return BSON regular expressions as BSONRegExp instances.
	 * @return {Object} returns the deserialized Javascript Object.
	 * @api public
	 */
	BSON.prototype.deserialize = function(buffer, options) {
	  return deserialize(buffer, options);
	}
	
	/**
	 * Calculate the bson size for a passed in Javascript object.
	 *
	 * @param {Object} object the Javascript object to calculate the BSON byte size for.
	 * @param {Boolean} [options.serializeFunctions=false] serialize the javascript functions **(default:false)**.
	 * @param {Boolean} [options.ignoreUndefined=true] ignore undefined fields **(default:true)**.
	 * @return {Number} returns the number of bytes the BSON object will take up.
	 * @api public
	 */
	BSON.prototype.calculateObjectSize = function(object, options) {
		options = options || {};
	
		var serializeFunctions = typeof options.serializeFunctions == 'boolean'
			? options.serializeFunctions : false;
		var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
			? options.ignoreUndefined : true;
	
	  return calculateObjectSize(object, serializeFunctions, ignoreUndefined);
	}
	
	/**
	 * Deserialize stream data as BSON documents.
	 *
	 * @param {Buffer} data the buffer containing the serialized set of BSON documents.
	 * @param {Number} startIndex the start index in the data Buffer where the deserialization is to start.
	 * @param {Number} numberOfDocuments number of documents to deserialize.
	 * @param {Array} documents an array where to store the deserialized documents.
	 * @param {Number} docStartIndex the index in the documents array from where to start inserting documents.
	 * @param {Object} [options] additional options used for the deserialization.
	 * @param {Object} [options.evalFunctions=false] evaluate functions in the BSON document scoped to the object deserialized.
	 * @param {Object} [options.cacheFunctions=false] cache evaluated functions for reuse.
	 * @param {Object} [options.cacheFunctionsCrc32=false] use a crc32 code for caching, otherwise use the string of the function.
	 * @param {Object} [options.promoteLongs=true] when deserializing a Long will fit it into a Number if it's smaller than 53 bits
	 * @param {Object} [options.promoteBuffers=false] when deserializing a Binary will return it as a node.js Buffer instance.
	 * @param {Object} [options.promoteValues=false] when deserializing will promote BSON values to their Node.js closest equivalent types.
	 * @param {Object} [options.fieldsAsRaw=null] allow to specify if there what fields we wish to return as unserialized raw buffer.
	 * @param {Object} [options.bsonRegExp=false] return BSON regular expressions as BSONRegExp instances.
	 * @return {Number} returns the next index in the buffer after deserialization **x** numbers of documents.
	 * @api public
	 */
	BSON.prototype.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
	  options = options != null ? options : {};
	  var index = startIndex;
	  // Loop over all documents
	  for(var i = 0; i < numberOfDocuments; i++) {
	    // Find size of the document
	    var size = data[index] | data[index + 1] << 8 | data[index + 2] << 16 | data[index + 3] << 24;
	    // Update options with index
	    options['index'] = index;
	    // Parse the document at this point
	    documents[docStartIndex + i] = this.deserialize(data, options);
	    // Adjust index by the document size
	    index = index + size;
	  }
	
	  // Return object containing end index of parsing and list of documents
	  return index;
	}
	
	/**
	 * @ignore
	 * @api private
	 */
	// BSON MAX VALUES
	BSON.BSON_INT32_MAX = 0x7FFFFFFF;
	BSON.BSON_INT32_MIN = -0x80000000;
	
	BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
	BSON.BSON_INT64_MIN = -Math.pow(2, 63);
	
	// JS MAX PRECISE VALUES
	BSON.JS_INT_MAX = 0x20000000000000;  // Any integer up to 2^53 can be precisely represented by a double.
	BSON.JS_INT_MIN = -0x20000000000000;  // Any integer down to -2^53 can be precisely represented by a double.
	
	// Internal long versions
	var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000);  // Any integer up to 2^53 can be precisely represented by a double.
	var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000);  // Any integer down to -2^53 can be precisely represented by a double.
	
	/**
	 * Number BSON Type
	 *
	 * @classconstant BSON_DATA_NUMBER
	 **/
	BSON.BSON_DATA_NUMBER = 1;
	/**
	 * String BSON Type
	 *
	 * @classconstant BSON_DATA_STRING
	 **/
	BSON.BSON_DATA_STRING = 2;
	/**
	 * Object BSON Type
	 *
	 * @classconstant BSON_DATA_OBJECT
	 **/
	BSON.BSON_DATA_OBJECT = 3;
	/**
	 * Array BSON Type
	 *
	 * @classconstant BSON_DATA_ARRAY
	 **/
	BSON.BSON_DATA_ARRAY = 4;
	/**
	 * Binary BSON Type
	 *
	 * @classconstant BSON_DATA_BINARY
	 **/
	BSON.BSON_DATA_BINARY = 5;
	/**
	 * ObjectID BSON Type
	 *
	 * @classconstant BSON_DATA_OID
	 **/
	BSON.BSON_DATA_OID = 7;
	/**
	 * Boolean BSON Type
	 *
	 * @classconstant BSON_DATA_BOOLEAN
	 **/
	BSON.BSON_DATA_BOOLEAN = 8;
	/**
	 * Date BSON Type
	 *
	 * @classconstant BSON_DATA_DATE
	 **/
	BSON.BSON_DATA_DATE = 9;
	/**
	 * null BSON Type
	 *
	 * @classconstant BSON_DATA_NULL
	 **/
	BSON.BSON_DATA_NULL = 10;
	/**
	 * RegExp BSON Type
	 *
	 * @classconstant BSON_DATA_REGEXP
	 **/
	BSON.BSON_DATA_REGEXP = 11;
	/**
	 * Code BSON Type
	 *
	 * @classconstant BSON_DATA_CODE
	 **/
	BSON.BSON_DATA_CODE = 13;
	/**
	 * Symbol BSON Type
	 *
	 * @classconstant BSON_DATA_SYMBOL
	 **/
	BSON.BSON_DATA_SYMBOL = 14;
	/**
	 * Code with Scope BSON Type
	 *
	 * @classconstant BSON_DATA_CODE_W_SCOPE
	 **/
	BSON.BSON_DATA_CODE_W_SCOPE = 15;
	/**
	 * 32 bit Integer BSON Type
	 *
	 * @classconstant BSON_DATA_INT
	 **/
	BSON.BSON_DATA_INT = 16;
	/**
	 * Timestamp BSON Type
	 *
	 * @classconstant BSON_DATA_TIMESTAMP
	 **/
	BSON.BSON_DATA_TIMESTAMP = 17;
	/**
	 * Long BSON Type
	 *
	 * @classconstant BSON_DATA_LONG
	 **/
	BSON.BSON_DATA_LONG = 18;
	/**
	 * MinKey BSON Type
	 *
	 * @classconstant BSON_DATA_MIN_KEY
	 **/
	BSON.BSON_DATA_MIN_KEY = 0xff;
	/**
	 * MaxKey BSON Type
	 *
	 * @classconstant BSON_DATA_MAX_KEY
	 **/
	BSON.BSON_DATA_MAX_KEY = 0x7f;
	
	/**
	 * Binary Default Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_DEFAULT
	 **/
	BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
	/**
	 * Binary Function Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_FUNCTION
	 **/
	BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
	/**
	 * Binary Byte Array Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY
	 **/
	BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
	/**
	 * Binary UUID Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_UUID
	 **/
	BSON.BSON_BINARY_SUBTYPE_UUID = 3;
	/**
	 * Binary MD5 Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_MD5
	 **/
	BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
	/**
	 * Binary User Defined Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED
	 **/
	BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
	
	// Return BSON
	module.exports = BSON;
	module.exports.Code = Code;
	module.exports.Map = Map;
	module.exports.Symbol = Symbol;
	module.exports.BSON = BSON;
	module.exports.DBRef = DBRef;
	module.exports.Binary = Binary;
	module.exports.ObjectID = ObjectID;
	module.exports.Long = Long;
	module.exports.Timestamp = Timestamp;
	module.exports.Double = Double;
	module.exports.Int32 = Int32;
	module.exports.MinKey = MinKey;
	module.exports.MaxKey = MaxKey;
	module.exports.BSONRegExp = BSONRegExp;
	module.exports.Decimal128 = Decimal128;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict"
	
	var writeIEEE754 = __webpack_require__(21).writeIEEE754
		, readIEEE754 = __webpack_require__(21).readIEEE754
		, Long = __webpack_require__(26).Long
	  , Double = __webpack_require__(36).Double
	  , Timestamp = __webpack_require__(42).Timestamp
	  , ObjectID = __webpack_require__(39).ObjectID
	  , Symbol = __webpack_require__(41).Symbol
	  , BSONRegExp = __webpack_require__(40).BSONRegExp
	  , Code = __webpack_require__(33).Code
		, Decimal128 = __webpack_require__(35)
	  , MinKey = __webpack_require__(38).MinKey
	  , MaxKey = __webpack_require__(37).MaxKey
	  , DBRef = __webpack_require__(34).DBRef
	  , Binary = __webpack_require__(32).Binary;
	
	// To ensure that 0.4 of node works correctly
	var isDate = function isDate(d) {
	  return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';
	}
	
	var calculateObjectSize = function calculateObjectSize(object, serializeFunctions, ignoreUndefined) {
	  var totalLength = (4 + 1);
	
	  if(Array.isArray(object)) {
	    for(var i = 0; i < object.length; i++) {
	      totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined)
	    }
	  } else {
			// If we have toBSON defined, override the current object
			if(object.toBSON) {
				object = object.toBSON();
			}
	
			// Calculate size
	    for(var key in object) {
	      totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined)
	    }
	  }
	
	  return totalLength;
	}
	
	/**
	 * @ignore
	 * @api private
	 */
	function calculateElement(name, value, serializeFunctions, isArray, ignoreUndefined) {
		// If we have toBSON defined, override the current object
	  if(value && value.toBSON){
	    value = value.toBSON();
	  }
	
	  switch(typeof value) {
	    case 'string':
	      return 1 + Buffer.byteLength(name, 'utf8') + 1 + 4 + Buffer.byteLength(value, 'utf8') + 1;
	    case 'number':
	      if(Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
	        if(value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) { // 32 bit
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (4 + 1);
	        } else {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (8 + 1);
	        }
	      } else {  // 64 bit
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (8 + 1);
	      }
	    case 'undefined':
	      if(isArray || !ignoreUndefined) return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (1);
	      return 0;
	    case 'boolean':
	      return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (1 + 1);
	    case 'object':
	      if(value == null || value instanceof MinKey || value instanceof MaxKey || value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (1);
	      } else if(value instanceof ObjectID || value['_bsontype'] == 'ObjectID') {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (12 + 1);
	      } else if(value instanceof Date || isDate(value)) {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (8 + 1);
	      } else if(typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (1 + 4 + 1) + value.length;
	      } else if(value instanceof Long || value instanceof Double || value instanceof Timestamp
	          || value['_bsontype'] == 'Long' || value['_bsontype'] == 'Double' || value['_bsontype'] == 'Timestamp') {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (8 + 1);
				} else if(value instanceof Decimal128 || value['_bsontype'] == 'Decimal128') {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (16 + 1);
	      } else if(value instanceof Code || value['_bsontype'] == 'Code') {
	        // Calculate size depending on the availability of a scope
	        if(value.scope != null && Object.keys(value.scope).length > 0) {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + 1 + 4 + 4 + Buffer.byteLength(value.code.toString(), 'utf8') + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
	        } else {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + 1 + 4 + Buffer.byteLength(value.code.toString(), 'utf8') + 1;
	        }
	      } else if(value instanceof Binary || value['_bsontype'] == 'Binary') {
	        // Check what kind of subtype we have
	        if(value.sub_type == Binary.SUBTYPE_BYTE_ARRAY) {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (value.position + 1 + 4 + 1 + 4);
	        } else {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + (value.position + 1 + 4 + 1);
	        }
	      } else if(value instanceof Symbol || value['_bsontype'] == 'Symbol') {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + Buffer.byteLength(value.value, 'utf8') + 4 + 1 + 1;
	      } else if(value instanceof DBRef || value['_bsontype'] == 'DBRef') {
	        // Set up correct object for serialization
	        var ordered_values = {
	            '$ref': value.namespace
	          , '$id' : value.oid
	        };
	
	        // Add db reference if it exists
	        if(null != value.db) {
	          ordered_values['$db'] = value.db;
	        }
	
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + 1 + calculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
	      } else if(value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]') {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + 1 + Buffer.byteLength(value.source, 'utf8') + 1
	            + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1
	      } else if(value instanceof BSONRegExp || value['_bsontype'] == 'BSONRegExp') {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + 1 + Buffer.byteLength(value.pattern, 'utf8') + 1
	            + Buffer.byteLength(value.options, 'utf8') + 1
	      } else {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + calculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
	      }
	    case 'function':
	      // WTF for 0.4.X where typeof /someregexp/ === 'function'
	      if(value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]' || String.call(value) == '[object RegExp]') {
	        return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + 1 + Buffer.byteLength(value.source, 'utf8') + 1
	          + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1
	      } else {
	        if(serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + 1 + 4 + 4 + Buffer.byteLength(value.toString(), 'utf8') + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
	        } else if(serializeFunctions) {
	          return (name != null ? (Buffer.byteLength(name, 'utf8') + 1) : 0) + 1 + 4 + Buffer.byteLength(value.toString(), 'utf8') + 1;
	        }
	      }
	  }
	
	  return 0;
	}
	
	var BSON = {};
	
	// BSON MAX VALUES
	BSON.BSON_INT32_MAX = 0x7FFFFFFF;
	BSON.BSON_INT32_MIN = -0x80000000;
	
	// JS MAX PRECISE VALUES
	BSON.JS_INT_MAX = 0x20000000000000;  // Any integer up to 2^53 can be precisely represented by a double.
	BSON.JS_INT_MIN = -0x20000000000000;  // Any integer down to -2^53 can be precisely represented by a double.
	
	module.exports = calculateObjectSize;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict"
	
	var readIEEE754 = __webpack_require__(21).readIEEE754,
		f = __webpack_require__(1).format,
		Long = __webpack_require__(26).Long,
	  Double = __webpack_require__(36).Double,
	  Timestamp = __webpack_require__(42).Timestamp,
	  ObjectID = __webpack_require__(39).ObjectID,
	  Symbol = __webpack_require__(41).Symbol,
	  Code = __webpack_require__(33).Code,
	  MinKey = __webpack_require__(38).MinKey,
	  MaxKey = __webpack_require__(37).MaxKey,
		Decimal128 = __webpack_require__(35),
		Int32 = __webpack_require__(50),
	  DBRef = __webpack_require__(34).DBRef,
	  BSONRegExp = __webpack_require__(40).BSONRegExp,
	  Binary = __webpack_require__(32).Binary;
	
	var deserialize = function(buffer, options, isArray) {
		options = options == null ? {} : options;
		var index = options && options.index ? options.index : 0;
		// Read the document size
	  var size = buffer[index] | buffer[index+1] << 8 | buffer[index+2] << 16 | buffer[index+3] << 24;
	
		// Ensure buffer is valid size
	  if(size < 5 || buffer.length < size || (size + index) > buffer.length) {
			throw new Error("corrupt bson message");
		}
	
		// Illegal end value
		if(buffer[index + size - 1] != 0) {
			throw new Error("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
		}
	
		// Start deserializtion
		return deserializeObject(buffer, index, options, isArray);
	}
	
	var deserializeObject = function(buffer, index, options, isArray) {
		var evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];
	  var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];
	  var cacheFunctionsCrc32 = options['cacheFunctionsCrc32'] == null ? false : options['cacheFunctionsCrc32'];
		var fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];
	
		// Return raw bson buffer instead of parsing it
		var raw = options['raw'] == null ? false : options['raw'];
	
		// Return BSONRegExp objects instead of native regular expressions
	  var bsonRegExp = typeof options['bsonRegExp'] == 'boolean' ? options['bsonRegExp'] : false;
	
		// Controls the promotion of values vs wrapper classes
		var promoteBuffers = options['promoteBuffers'] == null ? false : options['promoteBuffers'];
		var promoteLongs = options['promoteLongs'] == null ? true : options['promoteLongs'];
		var promoteValues = options['promoteValues'] == null ? true : options['promoteValues'];
	
		// Set the start index
		var startIndex = index;
	
	  // Validate that we have at least 4 bytes of buffer
	  if(buffer.length < 5) throw new Error("corrupt bson message < 5 bytes long");
	
		// Read the document size
	  var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	
		// Ensure buffer is valid size
	  if(size < 5 || size > buffer.length) throw new Error("corrupt bson message");
	
	  // Create holding object
	  var object = isArray ? [] : {};
		// Used for arrays to skip having to perform utf8 decoding
		var arrayIndex = 0;
	
	  // While we have more left data left keep parsing
	  while(true) {
	    // Read the type
	    var elementType = buffer[index++];
	    // If we get a zero it's the last byte, exit
	    if(elementType == 0) {
				break;
			}
	
			// Get the start search index
			var i = index;
			// Locate the end of the c string
			while(buffer[i] !== 0x00 && i < buffer.length) {
				i++
			}
	
			// If are at the end of the buffer there is a problem with the document
			if(i >= buffer.length) throw new Error("Bad BSON Document: illegal CString")
			var name = isArray ? arrayIndex++ : buffer.toString('utf8', index, i);
	
			index = i + 1;
	
			if(elementType == BSON.BSON_DATA_STRING) {
	      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
				if(stringSize <= 0 || stringSize > (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error("bad string length in bson");
	      object[name] = buffer.toString('utf8', index, index + stringSize - 1);
	      index = index + stringSize;
			} else if(elementType == BSON.BSON_DATA_OID) {
				var oid = new Buffer(12);
				buffer.copy(oid, 0, index, index + 12);
	      object[name] = new ObjectID(oid);
	      index = index + 12;
			} else if(elementType == BSON.BSON_DATA_INT && promoteValues == false) {
				object[name] = new Int32(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24);
			} else if(elementType == BSON.BSON_DATA_INT) {
	      object[name] = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
			} else if(elementType == BSON.BSON_DATA_NUMBER && promoteValues == false) {
				object[name] = new Double(buffer.readDoubleLE(index));
				index = index + 8;
			} else if(elementType == BSON.BSON_DATA_NUMBER) {
				object[name] = buffer.readDoubleLE(index);
	      index = index + 8;
			} else if(elementType == BSON.BSON_DATA_DATE) {
	      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	      object[name] = new Date(new Long(lowBits, highBits).toNumber());
			} else if(elementType == BSON.BSON_DATA_BOOLEAN) {
				if(buffer[index] != 0 && buffer[index] != 1) throw new Error('illegal boolean type value');
	      object[name] = buffer[index++] == 1;
			} else if(elementType == BSON.BSON_DATA_OBJECT) {
				var _index = index;
	      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
				if(objectSize <= 0 || objectSize > (buffer.length - index)) throw new Error("bad embedded document length in bson");
	
				// We have a raw value
				if(raw) {
		      object[name] = buffer.slice(index, index + objectSize);
				} else {
		      object[name] = deserializeObject(buffer, _index, options, false);
				}
	
	      index = index + objectSize;
			} else if(elementType == BSON.BSON_DATA_ARRAY) {
				var _index = index;
	      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
				var arrayOptions = options;
	
				// Stop index
				var stopIndex = index + objectSize;
	
				// All elements of array to be returned as raw bson
				if(fieldsAsRaw && fieldsAsRaw[name]) {
					arrayOptions = {};
					for(var n in options) arrayOptions[n] = options[n];
					arrayOptions['raw'] = true;
				}
	
	      object[name] = deserializeObject(buffer, _index, arrayOptions, true);
	      index = index + objectSize;
	
				if(buffer[index - 1] != 0) throw new Error('invalid array terminator byte');
				if(index != stopIndex) throw new Error('corrupted array bson');
			} else if(elementType == BSON.BSON_DATA_UNDEFINED) {
	      object[name] = undefined;
			} else if(elementType == BSON.BSON_DATA_NULL) {
				object[name] = null;
			} else if(elementType == BSON.BSON_DATA_LONG) {
	      // Unpack the low and high bits
	      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	      var long = new Long(lowBits, highBits);
	      // Promote the long if possible
	      if(promoteLongs && promoteValues == true) {
	        object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
	      } else {
	        object[name] = long;
	      }
			} else if(elementType == BSON.BSON_DATA_DECIMAL128) {
				// Buffer to contain the decimal bytes
				var bytes = new Buffer(16);
				// Copy the next 16 bytes into the bytes buffer
				buffer.copy(bytes, 0, index, index + 16);
				// Update index
				index = index + 16;
				// Assign the new Decimal128 value
				var decimal128 = new Decimal128(bytes);
				// If we have an alternative mapper use that
				object[name] = decimal128.toObject ? decimal128.toObject() : decimal128;
			} else if(elementType == BSON.BSON_DATA_BINARY) {
	      var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
				var totalBinarySize = binarySize;
	      var subType = buffer[index++];
	
				// Did we have a negative binary size, throw
				if(binarySize < 0) throw new Error('Negative binary type element size found');
	
				// Is the length longer than the document
				if(binarySize > buffer.length) throw new Error('Binary type size larger than document size');
	
				// Decode as raw Buffer object if options specifies it
	      if(buffer['slice'] != null) {
	        // If we have subtype 2 skip the 4 bytes for the size
	        if(subType == Binary.SUBTYPE_BYTE_ARRAY) {
	          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
						if(binarySize < 0) throw new Error('Negative binary type element size found for subtype 0x02');
						if(binarySize > (totalBinarySize - 4)) throw new Error('Binary type with subtype 0x02 contains to long binary size');
						if(binarySize < (totalBinarySize - 4)) throw new Error('Binary type with subtype 0x02 contains to short binary size');
	        }
	
	        if(promoteBuffers && promoteValues) {
	          object[name] = buffer.slice(index, index + binarySize);
	        } else {
	          object[name] = new Binary(buffer.slice(index, index + binarySize), subType);
	        }
	      } else {
	        var _buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);
	        // If we have subtype 2 skip the 4 bytes for the size
	        if(subType == Binary.SUBTYPE_BYTE_ARRAY) {
	          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
						if(binarySize < 0) throw new Error('Negative binary type element size found for subtype 0x02');
						if(binarySize > (totalBinarySize - 4)) throw new Error('Binary type with subtype 0x02 contains to long binary size');
						if(binarySize < (totalBinarySize - 4)) throw new Error('Binary type with subtype 0x02 contains to short binary size');
	        }
	
	        // Copy the data
	        for(var i = 0; i < binarySize; i++) {
	          _buffer[i] = buffer[index + i];
	        }
	
	        if(promoteBuffers && promoteValues) {
	          object[name] = _buffer;
	        } else {
	          object[name] = new Binary(_buffer, subType);
	        }
	      }
	
	      // Update the index
	      index = index + binarySize;
			} else if(elementType == BSON.BSON_DATA_REGEXP && bsonRegExp == false) {
				// Get the start search index
				var i = index;
				// Locate the end of the c string
				while(buffer[i] !== 0x00 && i < buffer.length) {
					i++
				}
				// If are at the end of the buffer there is a problem with the document
				if(i >= buffer.length) throw new Error("Bad BSON Document: illegal CString")
				// Return the C string
				var source = buffer.toString('utf8', index, i);
	      // Create the regexp
				index = i + 1;
	
				// Get the start search index
				var i = index;
				// Locate the end of the c string
				while(buffer[i] !== 0x00 && i < buffer.length) {
					i++
				}
				// If are at the end of the buffer there is a problem with the document
				if(i >= buffer.length) throw new Error("Bad BSON Document: illegal CString")
				// Return the C string
				var regExpOptions = buffer.toString('utf8', index, i);
				index = i + 1;
	
	      // For each option add the corresponding one for javascript
	      var optionsArray = new Array(regExpOptions.length);
	
	      // Parse options
	      for(var i = 0; i < regExpOptions.length; i++) {
	        switch(regExpOptions[i]) {
	          case 'm':
	            optionsArray[i] = 'm';
	            break;
	          case 's':
	            optionsArray[i] = 'g';
	            break;
	          case 'i':
	            optionsArray[i] = 'i';
	            break;
	        }
	      }
	
	      object[name] = new RegExp(source, optionsArray.join(''));
	    } else if(elementType == BSON.BSON_DATA_REGEXP && bsonRegExp == true) {
				// Get the start search index
				var i = index;
				// Locate the end of the c string
				while(buffer[i] !== 0x00 && i < buffer.length) {
					i++
				}
				// If are at the end of the buffer there is a problem with the document
				if(i >= buffer.length) throw new Error("Bad BSON Document: illegal CString")
				// Return the C string
				var source = buffer.toString('utf8', index, i);
	      index = i + 1;
	
				// Get the start search index
				var i = index;
				// Locate the end of the c string
				while(buffer[i] !== 0x00 && i < buffer.length) {
					i++
				}
				// If are at the end of the buffer there is a problem with the document
				if(i >= buffer.length) throw new Error("Bad BSON Document: illegal CString")
				// Return the C string
				var regExpOptions = buffer.toString('utf8', index, i);
	      index = i + 1;
	
	      // Set the object
	      object[name] = new BSONRegExp(source, regExpOptions);
			} else if(elementType == BSON.BSON_DATA_SYMBOL) {
	      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
				if(stringSize <= 0 || stringSize > (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error("bad string length in bson");
	      object[name] = new Symbol(buffer.toString('utf8', index, index + stringSize - 1));
	      index = index + stringSize;
			} else if(elementType == BSON.BSON_DATA_TIMESTAMP) {
	      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	      object[name] = new Timestamp(lowBits, highBits);
			} else if(elementType == BSON.BSON_DATA_MIN_KEY) {
	      object[name] = new MinKey();
			} else if(elementType == BSON.BSON_DATA_MAX_KEY) {
	      object[name] = new MaxKey();
			} else if(elementType == BSON.BSON_DATA_CODE) {
	      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
				if(stringSize <= 0 || stringSize > (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error("bad string length in bson");
	      var functionString = buffer.toString('utf8', index, index + stringSize - 1);
	
	      // If we are evaluating the functions
	      if(evalFunctions) {
	        var value = null;
	        // If we have cache enabled let's look for the md5 of the function in the cache
	        if(cacheFunctions) {
	          var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
	          // Got to do this to avoid V8 deoptimizing the call due to finding eval
	          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
	        } else {
	          object[name] = isolateEval(functionString);
	        }
	      } else {
	        object[name]  = new Code(functionString);
	      }
	
	      // Update parse index position
	      index = index + stringSize;
			} else if(elementType == BSON.BSON_DATA_CODE_W_SCOPE) {
	      var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
	
				// Element cannot be shorter than totalSize + stringSize + documentSize + terminator
				if(totalSize < (4 + 4 + 4 + 1)) {
					throw new Error("code_w_scope total size shorter minimum expected length");
				}
	
				// Get the code string size
	      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
				// Check if we have a valid string
				if(stringSize <= 0 || stringSize > (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error("bad string length in bson");
	
	      // Javascript function
	      var functionString = buffer.toString('utf8', index, index + stringSize - 1);
	      // Update parse index position
	      index = index + stringSize;
	      // Parse the element
				var _index = index;
	      // Decode the size of the object document
	      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
	      // Decode the scope object
	      var scopeObject = deserializeObject(buffer, _index, options, false);
	      // Adjust the index
	      index = index + objectSize;
	
				// Check if field length is to short
				if(totalSize < (4 + 4 + objectSize + stringSize)) {
					throw new Error('code_w_scope total size is to short, truncating scope');
				}
	
				// Check if totalSize field is to long
				if(totalSize > (4 + 4 + objectSize + stringSize)) {
					throw new Error('code_w_scope total size is to long, clips outer document');
				}
	
	      // If we are evaluating the functions
	      if(evalFunctions) {
	        // Contains the value we are going to set
	        var value = null;
	        // If we have cache enabled let's look for the md5 of the function in the cache
	        if(cacheFunctions) {
	          var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
	          // Got to do this to avoid V8 deoptimizing the call due to finding eval
	          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
	        } else {
	          object[name] = isolateEval(functionString);
	        }
	
	        object[name].scope = scopeObject;
	      } else {
	        object[name]  = new Code(functionString, scopeObject);
	      }
			} else if(elementType == BSON.BSON_DATA_DBPOINTER) {
				// Get the code string size
	      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
				// Check if we have a valid string
				if(stringSize <= 0 || stringSize > (buffer.length - index) || buffer[index + stringSize - 1] != 0) throw new Error("bad string length in bson");
				// Namespace
	      var namespace = buffer.toString('utf8', index, index + stringSize - 1);
				// Update parse index position
	      index = index + stringSize;
	
				// Read the oid
				var oidBuffer = new Buffer(12);
				buffer.copy(oidBuffer, 0, index, index + 12);
	      var oid = new ObjectID(oidBuffer);
	
				// Update the index
				index = index + 12;
	
				// Split the namespace
				var parts = namespace.split('.');
				var db = parts.shift();
				var collection = parts.join('.');
				// Upgrade to DBRef type
				object[name] = new DBRef(collection, oid, db);
	    } else {
				throw new Error("Detected unknown BSON type " + elementType.toString(16) + " for fieldname \"" + name + "\", are you using the latest BSON parser");
			}
	  }
	
		// Check if the deserialization was against a valid array/object
		if(size != (index - startIndex)) {
			if(isArray) throw new Error('corrupt array bson');
			throw new Error('corrupt object bson');
		}
	
	  // Check if we have a db ref object
	  if(object['$id'] != null) object = new DBRef(object['$ref'], object['$id'], object['$db']);
	  return object;
	}
	
	/**
	 * Ensure eval is isolated.
	 *
	 * @ignore
	 * @api private
	 */
	var isolateEvalWithHash = function(functionCache, hash, functionString, object) {
	  // Contains the value we are going to set
	  var value = null;
	
	  // Check for cache hit, eval if missing and return cached function
	  if(functionCache[hash] == null) {
	    eval("value = " + functionString);
	    functionCache[hash] = value;
	  }
	  // Set the object
	  return functionCache[hash].bind(object);
	}
	
	/**
	 * Ensure eval is isolated.
	 *
	 * @ignore
	 * @api private
	 */
	var isolateEval = function(functionString) {
	  // Contains the value we are going to set
	  var value = null;
	  // Eval the function
	  eval("value = " + functionString);
	  return value;
	}
	
	var BSON = {};
	
	/**
	 * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5
	 *
	 * @ignore
	 * @api private
	 */
	var functionCache = BSON.functionCache = {};
	
	/**
	 * Number BSON Type
	 *
	 * @classconstant BSON_DATA_NUMBER
	 **/
	BSON.BSON_DATA_NUMBER = 1;
	/**
	 * String BSON Type
	 *
	 * @classconstant BSON_DATA_STRING
	 **/
	BSON.BSON_DATA_STRING = 2;
	/**
	 * Object BSON Type
	 *
	 * @classconstant BSON_DATA_OBJECT
	 **/
	BSON.BSON_DATA_OBJECT = 3;
	/**
	 * Array BSON Type
	 *
	 * @classconstant BSON_DATA_ARRAY
	 **/
	BSON.BSON_DATA_ARRAY = 4;
	/**
	 * Binary BSON Type
	 *
	 * @classconstant BSON_DATA_BINARY
	 **/
	BSON.BSON_DATA_BINARY = 5;
	/**
	 * Binary BSON Type
	 *
	 * @classconstant BSON_DATA_UNDEFINED
	 **/
	BSON.BSON_DATA_UNDEFINED = 6;
	/**
	 * ObjectID BSON Type
	 *
	 * @classconstant BSON_DATA_OID
	 **/
	BSON.BSON_DATA_OID = 7;
	/**
	 * Boolean BSON Type
	 *
	 * @classconstant BSON_DATA_BOOLEAN
	 **/
	BSON.BSON_DATA_BOOLEAN = 8;
	/**
	 * Date BSON Type
	 *
	 * @classconstant BSON_DATA_DATE
	 **/
	BSON.BSON_DATA_DATE = 9;
	/**
	 * null BSON Type
	 *
	 * @classconstant BSON_DATA_NULL
	 **/
	BSON.BSON_DATA_NULL = 10;
	/**
	 * RegExp BSON Type
	 *
	 * @classconstant BSON_DATA_REGEXP
	 **/
	BSON.BSON_DATA_REGEXP = 11;
	/**
	 * Code BSON Type
	 *
	 * @classconstant BSON_DATA_DBPOINTER
	 **/
	BSON.BSON_DATA_DBPOINTER = 12;
	/**
	 * Code BSON Type
	 *
	 * @classconstant BSON_DATA_CODE
	 **/
	BSON.BSON_DATA_CODE = 13;
	/**
	 * Symbol BSON Type
	 *
	 * @classconstant BSON_DATA_SYMBOL
	 **/
	BSON.BSON_DATA_SYMBOL = 14;
	/**
	 * Code with Scope BSON Type
	 *
	 * @classconstant BSON_DATA_CODE_W_SCOPE
	 **/
	BSON.BSON_DATA_CODE_W_SCOPE = 15;
	/**
	 * 32 bit Integer BSON Type
	 *
	 * @classconstant BSON_DATA_INT
	 **/
	BSON.BSON_DATA_INT = 16;
	/**
	 * Timestamp BSON Type
	 *
	 * @classconstant BSON_DATA_TIMESTAMP
	 **/
	BSON.BSON_DATA_TIMESTAMP = 17;
	/**
	 * Long BSON Type
	 *
	 * @classconstant BSON_DATA_LONG
	 **/
	BSON.BSON_DATA_LONG = 18;
	/**
	 * Long BSON Type
	 *
	 * @classconstant BSON_DATA_DECIMAL128
	 **/
	BSON.BSON_DATA_DECIMAL128 = 19;
	/**
	 * MinKey BSON Type
	 *
	 * @classconstant BSON_DATA_MIN_KEY
	 **/
	BSON.BSON_DATA_MIN_KEY = 0xff;
	/**
	 * MaxKey BSON Type
	 *
	 * @classconstant BSON_DATA_MAX_KEY
	 **/
	BSON.BSON_DATA_MAX_KEY = 0x7f;
	
	/**
	 * Binary Default Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_DEFAULT
	 **/
	BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
	/**
	 * Binary Function Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_FUNCTION
	 **/
	BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
	/**
	 * Binary Byte Array Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY
	 **/
	BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
	/**
	 * Binary UUID Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_UUID
	 **/
	BSON.BSON_BINARY_SUBTYPE_UUID = 3;
	/**
	 * Binary MD5 Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_MD5
	 **/
	BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
	/**
	 * Binary User Defined Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED
	 **/
	BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
	
	// BSON MAX VALUES
	BSON.BSON_INT32_MAX = 0x7FFFFFFF;
	BSON.BSON_INT32_MIN = -0x80000000;
	
	BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
	BSON.BSON_INT64_MIN = -Math.pow(2, 63);
	
	// JS MAX PRECISE VALUES
	BSON.JS_INT_MAX = 0x20000000000000;  // Any integer up to 2^53 can be precisely represented by a double.
	BSON.JS_INT_MIN = -0x20000000000000;  // Any integer down to -2^53 can be precisely represented by a double.
	
	// Internal long versions
	var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000);  // Any integer up to 2^53 can be precisely represented by a double.
	var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000);  // Any integer down to -2^53 can be precisely represented by a double.
	
	module.exports = deserialize


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict"
	
	var writeIEEE754 = __webpack_require__(21).writeIEEE754,
	  readIEEE754 = __webpack_require__(21).readIEEE754,
	  Long = __webpack_require__(26).Long,
	  Map = __webpack_require__(71),
	  Double = __webpack_require__(36).Double,
	  Timestamp = __webpack_require__(42).Timestamp,
	  ObjectID = __webpack_require__(39).ObjectID,
	  Symbol = __webpack_require__(41).Symbol,
	  Code = __webpack_require__(33).Code,
	  BSONRegExp = __webpack_require__(40).BSONRegExp,
	  Int32 = __webpack_require__(50).Int32,
	  MinKey = __webpack_require__(38).MinKey,
	  MaxKey = __webpack_require__(37).MaxKey,
	  Decimal128 = __webpack_require__(35),
	  DBRef = __webpack_require__(34).DBRef,
	  Binary = __webpack_require__(32).Binary;
	
	try {
	  var _Buffer = Uint8Array;
	} catch(e) {
	  var _Buffer = Buffer;
	}
	
	var regexp = /\x00/
	
	// To ensure that 0.4 of node works correctly
	var isDate = function isDate(d) {
	  return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';
	}
	
	var isRegExp = function isRegExp(d) {
	  return Object.prototype.toString.call(d) === '[object RegExp]';
	}
	
	var serializeString = function(buffer, key, value, index, isArray) {
	  // Encode String type
	  buffer[index++] = BSON.BSON_DATA_STRING;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	  // Encode the name
	  index = index + numberOfWrittenBytes + 1;
	  buffer[index - 1] = 0;
	  // Write the string
	  var size = buffer.write(value, index + 4, 'utf8');
	  // Write the size of the string to buffer
	  buffer[index + 3] = (size + 1 >> 24) & 0xff;
	  buffer[index + 2] = (size + 1 >> 16) & 0xff;
	  buffer[index + 1] = (size + 1 >> 8) & 0xff;
	  buffer[index] = size + 1 & 0xff;
	  // Update index
	  index = index + 4 + size;
	  // Write zero
	  buffer[index++] = 0;
	  return index;
	}
	
	var serializeNumber = function(buffer, key, value, index, isArray) {
	  // We have an integer value
	  if(Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
	    // If the value fits in 32 bits encode as int, if it fits in a double
	    // encode it as a double, otherwise long
	    if(value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) {
	      // Set int type 32 bits or less
	      buffer[index++] = BSON.BSON_DATA_INT;
	      // Number of written bytes
	      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	      // Encode the name
	      index = index + numberOfWrittenBytes;
	      buffer[index++] = 0;
	      // Write the int value
	      buffer[index++] = value & 0xff;
	      buffer[index++] = (value >> 8) & 0xff;
	      buffer[index++] = (value >> 16) & 0xff;
	      buffer[index++] = (value >> 24) & 0xff;
	    } else if(value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
	      // Encode as double
	      buffer[index++] = BSON.BSON_DATA_NUMBER;
	      // Number of written bytes
	      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	      // Encode the name
	      index = index + numberOfWrittenBytes;
	      buffer[index++] = 0;
	      // Write float
	      writeIEEE754(buffer, value, index, 'little', 52, 8);
	      // Ajust index
	      index = index + 8;
	    } else {
	      // Set long type
	      buffer[index++] = BSON.BSON_DATA_LONG;
	      // Number of written bytes
	      var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	      // Encode the name
	      index = index + numberOfWrittenBytes;
	      buffer[index++] = 0;
	      var longVal = Long.fromNumber(value);
	      var lowBits = longVal.getLowBits();
	      var highBits = longVal.getHighBits();
	      // Encode low bits
	      buffer[index++] = lowBits & 0xff;
	      buffer[index++] = (lowBits >> 8) & 0xff;
	      buffer[index++] = (lowBits >> 16) & 0xff;
	      buffer[index++] = (lowBits >> 24) & 0xff;
	      // Encode high bits
	      buffer[index++] = highBits & 0xff;
	      buffer[index++] = (highBits >> 8) & 0xff;
	      buffer[index++] = (highBits >> 16) & 0xff;
	      buffer[index++] = (highBits >> 24) & 0xff;
	    }
	  } else {
	    // Encode as double
	    buffer[index++] = BSON.BSON_DATA_NUMBER;
	    // Number of written bytes
	    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	    // Encode the name
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    // Write float
	    writeIEEE754(buffer, value, index, 'little', 52, 8);
	    // Ajust index
	    index = index + 8;
	  }
	
	  return index;
	}
	
	var serializeNull = function(buffer, key, value, index, isArray) {
	  // Set long type
	  buffer[index++] = BSON.BSON_DATA_NULL;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  return index;
	}
	
	var serializeBoolean = function(buffer, key, value, index, isArray) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_BOOLEAN;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Encode the boolean value
	  buffer[index++] = value ? 1 : 0;
	  return index;
	}
	
	var serializeDate = function(buffer, key, value, index, isArray) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_DATE;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	
	  // Write the date
	  var dateInMilis = Long.fromNumber(value.getTime());
	  var lowBits = dateInMilis.getLowBits();
	  var highBits = dateInMilis.getHighBits();
	  // Encode low bits
	  buffer[index++] = lowBits & 0xff;
	  buffer[index++] = (lowBits >> 8) & 0xff;
	  buffer[index++] = (lowBits >> 16) & 0xff;
	  buffer[index++] = (lowBits >> 24) & 0xff;
	  // Encode high bits
	  buffer[index++] = highBits & 0xff;
	  buffer[index++] = (highBits >> 8) & 0xff;
	  buffer[index++] = (highBits >> 16) & 0xff;
	  buffer[index++] = (highBits >> 24) & 0xff;
	  return index;
	}
	
	var serializeRegExp = function(buffer, key, value, index, isArray) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_REGEXP;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  if (value.source && value.source.match(regexp) != null) {
	    throw Error("value " + value.source + " must not contain null bytes");
	  }
	  // Adjust the index
	  index = index + buffer.write(value.source, index, 'utf8');
	  // Write zero
	  buffer[index++] = 0x00;
	  // Write the parameters
	  if(value.global) buffer[index++] = 0x73; // s
	  if(value.ignoreCase) buffer[index++] = 0x69; // i
	  if(value.multiline) buffer[index++] = 0x6d; // m
	  // Add ending zero
	  buffer[index++] = 0x00;
	  return index;
	}
	
	var serializeBSONRegExp = function(buffer, key, value, index, isArray) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_REGEXP;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	
	  // Check the pattern for 0 bytes
	  if (value.pattern.match(regexp) != null) {
	    // The BSON spec doesn't allow keys with null bytes because keys are
	    // null-terminated.
	    throw Error("pattern " + value.pattern + " must not contain null bytes");
	  }
	
	  // Adjust the index
	  index = index + buffer.write(value.pattern, index, 'utf8');
	  // Write zero
	  buffer[index++] = 0x00;
	  // Write the options
	  index = index + buffer.write(value.options.split('').sort().join(''), index, 'utf8');
	  // Add ending zero
	  buffer[index++] = 0x00;
	  return index;
	}
	
	var serializeMinMax = function(buffer, key, value, index, isArray) {
	  // Write the type of either min or max key
	  if(value === null) {
	    buffer[index++] = BSON.BSON_DATA_NULL;
	  } else if(value instanceof MinKey) {
	    buffer[index++] = BSON.BSON_DATA_MIN_KEY;
	  } else {
	    buffer[index++] = BSON.BSON_DATA_MAX_KEY;
	  }
	
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  return index;
	}
	
	var serializeObjectId = function(buffer, key, value, index, isArray) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_OID;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	
	  // Write the objectId into the shared buffer
	  if(typeof value.id == 'string') {
	    buffer.write(value.id, index, 'binary')
	  } else if(value.id && value.id.copy){
	    value.id.copy(buffer, index, 0, 12);
	  } else {
	    throw new Error('object [' + JSON.stringify(value) + "] is not a valid ObjectId");
	  }
	
	  // Ajust index
	  return index + 12;
	}
	
	var serializeBuffer = function(buffer, key, value, index, isArray) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_BINARY;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Get size of the buffer (current write point)
	  var size = value.length;
	  // Write the size of the string to buffer
	  buffer[index++] = size & 0xff;
	  buffer[index++] = (size >> 8) & 0xff;
	  buffer[index++] = (size >> 16) & 0xff;
	  buffer[index++] = (size >> 24) & 0xff;
	  // Write the default subtype
	  buffer[index++] = BSON.BSON_BINARY_SUBTYPE_DEFAULT;
	  // Copy the content form the binary field to the buffer
	  value.copy(buffer, index, 0, size);
	  // Adjust the index
	  index = index + size;
	  return index;
	}
	
	var serializeObject = function(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) {
	  for(var i = 0; i < path.length; i++) {
	    if(path[i] === value) throw new Error('cyclic dependency detected');
	  }
	
	  // Push value to stack
	  path.push(value);
	  // Write the type
	  buffer[index++] = Array.isArray(value) ? BSON.BSON_DATA_ARRAY : BSON.BSON_DATA_OBJECT;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  var endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
	  // Pop stack
	  path.pop();
	  // Write size
	  var size = endIndex - index;
	  return endIndex;
	}
	
	var serializeDecimal128 = function(buffer, key, value, index, isArray) {
	  buffer[index++] = BSON.BSON_DATA_DECIMAL128;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Write the data from the value
	  value.bytes.copy(buffer, index, 0, 16);
	  return index + 16;
	}
	
	var serializeLong = function(buffer, key, value, index, isArray) {
	  // Write the type
	  buffer[index++] = value._bsontype == 'Long' ? BSON.BSON_DATA_LONG : BSON.BSON_DATA_TIMESTAMP;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Write the date
	  var lowBits = value.getLowBits();
	  var highBits = value.getHighBits();
	  // Encode low bits
	  buffer[index++] = lowBits & 0xff;
	  buffer[index++] = (lowBits >> 8) & 0xff;
	  buffer[index++] = (lowBits >> 16) & 0xff;
	  buffer[index++] = (lowBits >> 24) & 0xff;
	  // Encode high bits
	  buffer[index++] = highBits & 0xff;
	  buffer[index++] = (highBits >> 8) & 0xff;
	  buffer[index++] = (highBits >> 16) & 0xff;
	  buffer[index++] = (highBits >> 24) & 0xff;
	  return index;
	}
	
	var serializeInt32 = function(buffer, key, value, index, isArray) {
	  // Set int type 32 bits or less
	  buffer[index++] = BSON.BSON_DATA_INT;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Write the int value
	  buffer[index++] = value & 0xff;
	  buffer[index++] = (value >> 8) & 0xff;
	  buffer[index++] = (value >> 16) & 0xff;
	  buffer[index++] = (value >> 24) & 0xff;
	  return index;
	}
	
	var serializeDouble = function(buffer, key, value, index, isArray) {
	  // Encode as double
	  buffer[index++] = BSON.BSON_DATA_NUMBER;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Write float
	  writeIEEE754(buffer, value, index, 'little', 52, 8);
	  // Ajust index
	  index = index + 8;
	  return index;
	}
	
	var serializeFunction = function(buffer, key, value, index, checkKeys, depth, isArray) {
	  buffer[index++] = BSON.BSON_DATA_CODE;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Function string
	  var functionString = value.toString();
	  // Write the string
	  var size = buffer.write(functionString, index + 4, 'utf8') + 1;
	  // Write the size of the string to buffer
	  buffer[index] = size & 0xff;
	  buffer[index + 1] = (size >> 8) & 0xff;
	  buffer[index + 2] = (size >> 16) & 0xff;
	  buffer[index + 3] = (size >> 24) & 0xff;
	  // Update index
	  index = index + 4 + size - 1;
	  // Write zero
	  buffer[index++] = 0;
	  return index;
	}
	
	var serializeCode = function(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {
	  if(value.scope && typeof value.scope == 'object') {
	    // Write the type
	    buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;
	    // Number of written bytes
	    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	    // Encode the name
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	
	    // Starting index
	    var startIndex = index;
	
	    // Serialize the function
	    // Get the function string
	    var functionString = typeof value.code == 'string' ? value.code : value.code.toString();
	    // Index adjustment
	    index = index + 4;
	    // Write string into buffer
	    var codeSize = buffer.write(functionString, index + 4, 'utf8') + 1;
	    // Write the size of the string to buffer
	    buffer[index] = codeSize & 0xff;
	    buffer[index + 1] = (codeSize >> 8) & 0xff;
	    buffer[index + 2] = (codeSize >> 16) & 0xff;
	    buffer[index + 3] = (codeSize >> 24) & 0xff;
	    // Write end 0
	    buffer[index + 4 + codeSize - 1] = 0;
	    // Write the
	    index = index + codeSize + 4;
	
	    //
	    // Serialize the scope value
	    var endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined)
	    index = endIndex - 1;
	
	    // Writ the total
	    var totalSize = endIndex - startIndex;
	
	    // Write the total size of the object
	    buffer[startIndex++] = totalSize & 0xff;
	    buffer[startIndex++] = (totalSize >> 8) & 0xff;
	    buffer[startIndex++] = (totalSize >> 16) & 0xff;
	    buffer[startIndex++] = (totalSize >> 24) & 0xff;
	    // Write trailing zero
	    buffer[index++] = 0;
	  } else {
	    buffer[index++] = BSON.BSON_DATA_CODE;
	    // Number of written bytes
	    var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	    // Encode the name
	    index = index + numberOfWrittenBytes;
	    buffer[index++] = 0;
	    // Function string
	    var functionString = value.code.toString();
	    // Write the string
	    var size = buffer.write(functionString, index + 4, 'utf8') + 1;
	    // Write the size of the string to buffer
	    buffer[index] = size & 0xff;
	    buffer[index + 1] = (size >> 8) & 0xff;
	    buffer[index + 2] = (size >> 16) & 0xff;
	    buffer[index + 3] = (size >> 24) & 0xff;
	    // Update index
	    index = index + 4 + size - 1;
	    // Write zero
	    buffer[index++] = 0;
	  }
	
	  return index;
	}
	
	var serializeBinary = function(buffer, key, value, index, isArray) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_BINARY;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Extract the buffer
	  var data = value.value(true);
	  // Calculate size
	  var size = value.position;
	  // Add the deprecated 02 type 4 bytes of size to total
	  if(value.sub_type == Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;
	  // Write the size of the string to buffer
	  buffer[index++] = size & 0xff;
	  buffer[index++] = (size >> 8) & 0xff;
	  buffer[index++] = (size >> 16) & 0xff;
	  buffer[index++] = (size >> 24) & 0xff;
	  // Write the subtype to the buffer
	  buffer[index++] = value.sub_type;
	
	  // If we have binary type 2 the 4 first bytes are the size
	  if(value.sub_type == Binary.SUBTYPE_BYTE_ARRAY) {
	    size = size - 4;
	    buffer[index++] = size & 0xff;
	    buffer[index++] = (size >> 8) & 0xff;
	    buffer[index++] = (size >> 16) & 0xff;
	    buffer[index++] = (size >> 24) & 0xff;
	  }
	
	  // Write the data to the object
	  data.copy(buffer, index, 0, value.position);
	  // Adjust the index
	  index = index + value.position;
	  return index;
	}
	
	var serializeSymbol = function(buffer, key, value, index, isArray) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_SYMBOL;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	  // Write the string
	  var size = buffer.write(value.value, index + 4, 'utf8') + 1;
	  // Write the size of the string to buffer
	  buffer[index] = size & 0xff;
	  buffer[index + 1] = (size >> 8) & 0xff;
	  buffer[index + 2] = (size >> 16) & 0xff;
	  buffer[index + 3] = (size >> 24) & 0xff;
	  // Update index
	  index = index + 4 + size - 1;
	  // Write zero
	  buffer[index++] = 0x00;
	  return index;
	}
	
	var serializeDBRef = function(buffer, key, value, index, depth, serializeFunctions, isArray) {
	  // Write the type
	  buffer[index++] = BSON.BSON_DATA_OBJECT;
	  // Number of written bytes
	  var numberOfWrittenBytes = !isArray ? buffer.write(key, index, 'utf8') : buffer.write(key, index, 'ascii');
	
	  // Encode the name
	  index = index + numberOfWrittenBytes;
	  buffer[index++] = 0;
	
	  var startIndex = index;
	  var endIndex;
	
	  // Serialize object
	  if(null != value.db) {
	    endIndex = serializeInto(buffer, {
	        '$ref': value.namespace
	      , '$id' : value.oid
	      , '$db' : value.db
	    }, false, index, depth + 1, serializeFunctions);
	  } else {
	    endIndex = serializeInto(buffer, {
	        '$ref': value.namespace
	      , '$id' : value.oid
	    }, false, index, depth + 1, serializeFunctions);
	  }
	
	  // Calculate object size
	  var size = endIndex - startIndex;
	  // Write the size
	  buffer[startIndex++] = size & 0xff;
	  buffer[startIndex++] = (size >> 8) & 0xff;
	  buffer[startIndex++] = (size >> 16) & 0xff;
	  buffer[startIndex++] = (size >> 24) & 0xff;
	  // Set index
	  return endIndex;
	}
	
	var serializeInto = function serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
	  startingIndex = startingIndex || 0;
	  path = path || [];
	
	  // Push the object to the path
	  path.push(object);
	
	  // Start place to serialize into
	  var index = startingIndex + 4;
	  var self = this;
	
	  // Special case isArray
	  if(Array.isArray(object)) {
	    // Get object keys
	    for(var i = 0; i < object.length; i++) {
	      var key = "" + i;
	      var value = object[i];
	
	      // Is there an override value
	      if(value && value.toBSON) {
	        if(typeof value.toBSON != 'function') throw new Error("toBSON is not a function");
	        value = value.toBSON();
	      }
	
	      var type = typeof value;
	      if(type == 'string') {
	        index = serializeString(buffer, key, value, index, true);
	      } else if(type == 'number') {
	        index = serializeNumber(buffer, key, value, index, true);
	      } else if(type == 'boolean') {
	        index = serializeBoolean(buffer, key, value, index, true);
	      } else if(value instanceof Date || isDate(value)) {
	        index = serializeDate(buffer, key, value, index, true);
	      } else if(value === undefined) {
	        index = serializeNull(buffer, key, value, index, true);
	      } else if(value === null) {
	        index = serializeNull(buffer, key, value, index, true);
	      } else if(value['_bsontype'] == 'ObjectID') {
	        index = serializeObjectId(buffer, key, value, index, true);
	      } else if(Buffer.isBuffer(value)) {
	        index = serializeBuffer(buffer, key, value, index, true);
	      } else if(value instanceof RegExp || isRegExp(value)) {
	        index = serializeRegExp(buffer, key, value, index, true);
	      } else if(type == 'object' && value['_bsontype'] == null) {
	        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path);
	      } else if(type == 'object' && value['_bsontype'] == 'Decimal128') {
	        index = serializeDecimal128(buffer, key, value, index, true);
	      } else if(value['_bsontype'] == 'Long' || value['_bsontype'] == 'Timestamp') {
	        index = serializeLong(buffer, key, value, index, true);
	      } else if(value['_bsontype'] == 'Double') {
	        index = serializeDouble(buffer, key, value, index, true);
	      } else if(typeof value == 'function' && serializeFunctions) {
	        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions, true);
	      } else if(value['_bsontype'] == 'Code') {
	        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true);
	      } else if(value['_bsontype'] == 'Binary') {
	        index = serializeBinary(buffer, key, value, index, true);
	      } else if(value['_bsontype'] == 'Symbol') {
	        index = serializeSymbol(buffer, key, value, index, true);
	      } else if(value['_bsontype'] == 'DBRef') {
	        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, true);
	      } else if(value['_bsontype'] == 'BSONRegExp') {
	        index = serializeBSONRegExp(buffer, key, value, index, true);
	      } else if(value['_bsontype'] == 'Int32') {
	        index = serializeInt32(buffer, key, value, index, true);
	      } else if(value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
	        index = serializeMinMax(buffer, key, value, index, true);
	      }
	    }
	  } else if(object instanceof Map) {
	    var iterator = object.entries();
	    var done = false;
	
	    while(!done) {
	      // Unpack the next entry
	      var entry = iterator.next();
	      done = entry.done;
	      // Are we done, then skip and terminate
	      if(done) continue;
	
	      // Get the entry values
	      var key = entry.value[0];
	      var value = entry.value[1];
	
	      // Check the type of the value
	      var type = typeof value;
	
	      // Check the key and throw error if it's illegal
	      if(key != '$db' && key != '$ref' && key != '$id') {
	        if (key.match(regexp) != null) {
	          // The BSON spec doesn't allow keys with null bytes because keys are
	          // null-terminated.
	          throw Error("key " + key + " must not contain null bytes");
	        }
	
	        if (checkKeys) {
	          if('$' == key[0]) {
	            throw Error("key " + key + " must not start with '$'");
	          } else if (!!~key.indexOf('.')) {
	            throw Error("key " + key + " must not contain '.'");
	          }
	        }
	      }
	
	      if(type == 'string') {
	        index = serializeString(buffer, key, value, index);
	      } else if(type == 'number') {
	        index = serializeNumber(buffer, key, value, index);
	      } else if(type == 'boolean') {
	        index = serializeBoolean(buffer, key, value, index);
	      } else if(value instanceof Date || isDate(value)) {
	        index = serializeDate(buffer, key, value, index);
	      } else if(value === undefined && ignoreUndefined == true) {
	      } else if(value === null || value === undefined) {
	        index = serializeNull(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'ObjectID') {
	        index = serializeObjectId(buffer, key, value, index);
	      } else if(Buffer.isBuffer(value)) {
	        index = serializeBuffer(buffer, key, value, index);
	      } else if(value instanceof RegExp || isRegExp(value)) {
	        index = serializeRegExp(buffer, key, value, index);
	      } else if(type == 'object' && value['_bsontype'] == null) {
	        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
	      } else if(type == 'object' && value['_bsontype'] == 'Decimal128') {
	        index = serializeDecimal128(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Long' || value['_bsontype'] == 'Timestamp') {
	        index = serializeLong(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Double') {
	        index = serializeDouble(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Code') {
	        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
	      } else if(typeof value == 'function' && serializeFunctions) {
	        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
	      } else if(value['_bsontype'] == 'Binary') {
	        index = serializeBinary(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Symbol') {
	        index = serializeSymbol(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'DBRef') {
	        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
	      } else if(value['_bsontype'] == 'BSONRegExp') {
	        index = serializeBSONRegExp(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Int32') {
	        index = serializeInt32(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
	        index = serializeMinMax(buffer, key, value, index);
	      }
	    }
	  } else {
	    // Did we provide a custom serialization method
	    if(object.toBSON) {
	      if(typeof object.toBSON != 'function') throw new Error("toBSON is not a function");
	      object = object.toBSON();
	      if(object != null && typeof object != 'object') throw new Error("toBSON function did not return an object");
	    }
	
	    // Iterate over all the keys
	    for(var key in object) {
	      var value = object[key];
	      // Is there an override value
	      if(value && value.toBSON) {
	        if(typeof value.toBSON != 'function') throw new Error("toBSON is not a function");
	        value = value.toBSON();
	      }
	
	      // Check the type of the value
	      var type = typeof value;
	
	      // Check the key and throw error if it's illegal
	      if(key != '$db' && key != '$ref' && key != '$id') {
	        if (key.match(regexp) != null) {
	          // The BSON spec doesn't allow keys with null bytes because keys are
	          // null-terminated.
	          throw Error("key " + key + " must not contain null bytes");
	        }
	
	        if (checkKeys) {
	          if('$' == key[0]) {
	            throw Error("key " + key + " must not start with '$'");
	          } else if (!!~key.indexOf('.')) {
	            throw Error("key " + key + " must not contain '.'");
	          }
	        }
	      }
	
	      if(type == 'string') {
	        index = serializeString(buffer, key, value, index);
	      } else if(type == 'number') {
	        index = serializeNumber(buffer, key, value, index);
	      } else if(type == 'boolean') {
	        index = serializeBoolean(buffer, key, value, index);
	      } else if(value instanceof Date || isDate(value)) {
	        index = serializeDate(buffer, key, value, index);
	      } else if(value === undefined && ignoreUndefined == true) {
	      } else if(value === null || value === undefined) {
	        index = serializeNull(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'ObjectID') {
	        index = serializeObjectId(buffer, key, value, index);
	      } else if(Buffer.isBuffer(value)) {
	        index = serializeBuffer(buffer, key, value, index);
	      } else if(value instanceof RegExp || isRegExp(value)) {
	        index = serializeRegExp(buffer, key, value, index);
	      } else if(type == 'object' && value['_bsontype'] == null) {
	        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
	      } else if(type == 'object' && value['_bsontype'] == 'Decimal128') {
	        index = serializeDecimal128(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Long' || value['_bsontype'] == 'Timestamp') {
	        index = serializeLong(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Double') {
	        index = serializeDouble(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Code') {
	        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
	      } else if(typeof value == 'function' && serializeFunctions) {
	        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
	      } else if(value['_bsontype'] == 'Binary') {
	        index = serializeBinary(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Symbol') {
	        index = serializeSymbol(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'DBRef') {
	        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
	      } else if(value['_bsontype'] == 'BSONRegExp') {
	        index = serializeBSONRegExp(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'Int32') {
	        index = serializeInt32(buffer, key, value, index);
	      } else if(value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
	        index = serializeMinMax(buffer, key, value, index);
	      }
	    }
	  }
	
	  // Remove the path
	  path.pop();
	
	  // Final padding byte for object
	  buffer[index++] = 0x00;
	
	  // Final size
	  var size = index - startingIndex;
	  // Write the size of the object
	  buffer[startingIndex++] = size & 0xff;
	  buffer[startingIndex++] = (size >> 8) & 0xff;
	  buffer[startingIndex++] = (size >> 16) & 0xff;
	  buffer[startingIndex++] = (size >> 24) & 0xff;
	  return index;
	}
	
	var BSON = {};
	
	/**
	 * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5
	 *
	 * @ignore
	 * @api private
	 */
	var functionCache = BSON.functionCache = {};
	
	/**
	 * Number BSON Type
	 *
	 * @classconstant BSON_DATA_NUMBER
	 **/
	BSON.BSON_DATA_NUMBER = 1;
	/**
	 * String BSON Type
	 *
	 * @classconstant BSON_DATA_STRING
	 **/
	BSON.BSON_DATA_STRING = 2;
	/**
	 * Object BSON Type
	 *
	 * @classconstant BSON_DATA_OBJECT
	 **/
	BSON.BSON_DATA_OBJECT = 3;
	/**
	 * Array BSON Type
	 *
	 * @classconstant BSON_DATA_ARRAY
	 **/
	BSON.BSON_DATA_ARRAY = 4;
	/**
	 * Binary BSON Type
	 *
	 * @classconstant BSON_DATA_BINARY
	 **/
	BSON.BSON_DATA_BINARY = 5;
	/**
	 * ObjectID BSON Type, deprecated
	 *
	 * @classconstant BSON_DATA_UNDEFINED
	 **/
	BSON.BSON_DATA_UNDEFINED = 6;
	/**
	 * ObjectID BSON Type
	 *
	 * @classconstant BSON_DATA_OID
	 **/
	BSON.BSON_DATA_OID = 7;
	/**
	 * Boolean BSON Type
	 *
	 * @classconstant BSON_DATA_BOOLEAN
	 **/
	BSON.BSON_DATA_BOOLEAN = 8;
	/**
	 * Date BSON Type
	 *
	 * @classconstant BSON_DATA_DATE
	 **/
	BSON.BSON_DATA_DATE = 9;
	/**
	 * null BSON Type
	 *
	 * @classconstant BSON_DATA_NULL
	 **/
	BSON.BSON_DATA_NULL = 10;
	/**
	 * RegExp BSON Type
	 *
	 * @classconstant BSON_DATA_REGEXP
	 **/
	BSON.BSON_DATA_REGEXP = 11;
	/**
	 * Code BSON Type
	 *
	 * @classconstant BSON_DATA_CODE
	 **/
	BSON.BSON_DATA_CODE = 13;
	/**
	 * Symbol BSON Type
	 *
	 * @classconstant BSON_DATA_SYMBOL
	 **/
	BSON.BSON_DATA_SYMBOL = 14;
	/**
	 * Code with Scope BSON Type
	 *
	 * @classconstant BSON_DATA_CODE_W_SCOPE
	 **/
	BSON.BSON_DATA_CODE_W_SCOPE = 15;
	/**
	 * 32 bit Integer BSON Type
	 *
	 * @classconstant BSON_DATA_INT
	 **/
	BSON.BSON_DATA_INT = 16;
	/**
	 * Timestamp BSON Type
	 *
	 * @classconstant BSON_DATA_TIMESTAMP
	 **/
	BSON.BSON_DATA_TIMESTAMP = 17;
	/**
	 * Long BSON Type
	 *
	 * @classconstant BSON_DATA_LONG
	 **/
	BSON.BSON_DATA_LONG = 18;
	/**
	 * Long BSON Type
	 *
	 * @classconstant BSON_DATA_DECIMAL128
	 **/
	BSON.BSON_DATA_DECIMAL128 = 19;
	/**
	 * MinKey BSON Type
	 *
	 * @classconstant BSON_DATA_MIN_KEY
	 **/
	BSON.BSON_DATA_MIN_KEY = 0xff;
	/**
	 * MaxKey BSON Type
	 *
	 * @classconstant BSON_DATA_MAX_KEY
	 **/
	BSON.BSON_DATA_MAX_KEY = 0x7f;
	/**
	 * Binary Default Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_DEFAULT
	 **/
	BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
	/**
	 * Binary Function Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_FUNCTION
	 **/
	BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
	/**
	 * Binary Byte Array Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY
	 **/
	BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
	/**
	 * Binary UUID Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_UUID
	 **/
	BSON.BSON_BINARY_SUBTYPE_UUID = 3;
	/**
	 * Binary MD5 Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_MD5
	 **/
	BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
	/**
	 * Binary User Defined Type
	 *
	 * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED
	 **/
	BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
	
	// BSON MAX VALUES
	BSON.BSON_INT32_MAX = 0x7FFFFFFF;
	BSON.BSON_INT32_MIN = -0x80000000;
	
	BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
	BSON.BSON_INT64_MIN = -Math.pow(2, 63);
	
	// JS MAX PRECISE VALUES
	BSON.JS_INT_MAX = 0x20000000000000;  // Any integer up to 2^53 can be precisely represented by a double.
	BSON.JS_INT_MIN = -0x20000000000000;  // Any integer down to -2^53 can be precisely represented by a double.
	
	// Internal long versions
	var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000);  // Any integer up to 2^53 can be precisely represented by a double.
	var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000);  // Any integer down to -2^53 can be precisely represented by a double.
	
	module.exports = serializeInto;


/***/ }),
/* 168 */
/***/ (function(module, exports) {

	// TODO Add in pre and post skipping options
	module.exports = {
	  /**
	   *  Declares a new hook to which you can add pres and posts
	   *  @param {String} name of the function
	   *  @param {Function} the method
	   *  @param {Function} the error handler callback
	   */
	  $hook: function (name, fn, errorCb) {
	    if (arguments.length === 1 && typeof name === 'object') {
	      for (var k in name) { // `name` is a hash of hookName->hookFn
	        this.$hook(k, name[k]);
	      }
	      return;
	    }
	
	    var proto = this.prototype || this
	      , pres = proto._pres = proto._pres || {}
	      , posts = proto._posts = proto._posts || {};
	    pres[name] = pres[name] || [];
	    posts[name] = posts[name] || [];
	
	    proto[name] = function () {
	      var self = this
	        , hookArgs // arguments eventually passed to the hook - are mutable
	        , lastArg = arguments[arguments.length-1]
	        , pres = this._pres[name]
	        , posts = this._posts[name]
	        , _total = pres.length
	        , _current = -1
	        , _asyncsLeft = proto[name].numAsyncPres
	        , _asyncsDone = function(err) {
	            if (err) {
	              return handleError(err);
	            }
	            --_asyncsLeft || _done.apply(self, hookArgs);
	          }
	        , handleError = function(err) {
	            if ('function' == typeof lastArg)
	              return lastArg(err);
	            if (errorCb) return errorCb.call(self, err);
	            throw err;
	          }
	        , _next = function () {
	            if (arguments[0] instanceof Error) {
	              return handleError(arguments[0]);
	            }
	            var _args = Array.prototype.slice.call(arguments)
	              , currPre
	              , preArgs;
	            if (_args.length && !(arguments[0] == null && typeof lastArg === 'function'))
	              hookArgs = _args;
	            if (++_current < _total) {
	              currPre = pres[_current]
	              if (currPre.isAsync && currPre.length < 2)
	                throw new Error("Your pre must have next and done arguments -- e.g., function (next, done, ...)");
	              if (currPre.length < 1)
	                throw new Error("Your pre must have a next argument -- e.g., function (next, ...)");
	              preArgs = (currPre.isAsync
	                          ? [once(_next), once(_asyncsDone)]
	                          : [once(_next)]).concat(hookArgs);
	              return currPre.apply(self, preArgs);
	            } else if (!_asyncsLeft) {
	              return _done.apply(self, hookArgs);
	            }
	          }
	        , _done = function () {
	            var args_ = Array.prototype.slice.call(arguments)
	              , ret, total_, current_, next_, done_, postArgs;
	
	            if (_current === _total) {
	              
	              next_ = function () {
	                if (arguments[0] instanceof Error) {
	                  return handleError(arguments[0]);
	                }
	                var args_ = Array.prototype.slice.call(arguments, 1)
	                  , currPost
	                  , postArgs;
	                if (args_.length) hookArgs = args_;
	                if (++current_ < total_) {
	                  currPost = posts[current_]
	                  if (currPost.length < 1)
	                    throw new Error("Your post must have a next argument -- e.g., function (next, ...)");
	                  postArgs = [once(next_)].concat(hookArgs);
	                  return currPost.apply(self, postArgs);
	                } else if (typeof lastArg === 'function'){
	                  // All post handlers are done, call original callback function
	                  return lastArg.apply(self, arguments);
	                }
	              };
	
	              // We are assuming that if the last argument provided to the wrapped function is a function, it was expecting
	              // a callback.  We trap that callback and wait to call it until all post handlers have finished.
	              if(typeof lastArg === 'function'){
	                args_[args_.length - 1] = once(next_);
	              }
	
	              total_ = posts.length;
	              current_ = -1;
	              ret = fn.apply(self, args_); // Execute wrapped function, post handlers come afterward
	
	              if (total_ && typeof lastArg !== 'function') return next_();  // no callback provided, execute next_() manually
	              return ret;
	            }
	          };
	
	      return _next.apply(this, arguments);
	    };
	    
	    proto[name].numAsyncPres = 0;
	
	    return this;
	  },
	
	  pre: function (name, isAsync, fn, errorCb) {
	    if ('boolean' !== typeof arguments[1]) {
	      errorCb = fn;
	      fn = isAsync;
	      isAsync = false;
	    }
	    var proto = this.prototype || this
	      , pres = proto._pres = proto._pres || {};
	
	    this._lazySetupHooks(proto, name, errorCb);
	
	    if (fn.isAsync = isAsync) {
	      proto[name].numAsyncPres++;
	    }
	
	    (pres[name] = pres[name] || []).push(fn);
	    return this;
	  },
	  post: function (name, isAsync, fn) {
	    if (arguments.length === 2) {
	      fn = isAsync;
	      isAsync = false;
	    }
	    var proto = this.prototype || this
	      , posts = proto._posts = proto._posts || {};
	    
	    this._lazySetupHooks(proto, name);
	    (posts[name] = posts[name] || []).push(fn);
	    return this;
	  },
	  removePre: function (name, fnToRemove) {
	    var proto = this.prototype || this
	      , pres = proto._pres || (proto._pres || {});
	    if (!pres[name]) return this;
	    if (arguments.length === 1) {
	      // Remove all pre callbacks for hook `name`
	      pres[name].length = 0;
	    } else {
	      pres[name] = pres[name].filter( function (currFn) {
	        return currFn !== fnToRemove;
	      });
	    }
	    return this;
	  },
	  removePost: function (name, fnToRemove) {
	    var proto = this.prototype || this
	      , posts = proto._posts || (proto._posts || {});
	    if (!posts[name]) return this;
	    if (arguments.length === 1) {
	      // Remove all post callbacks for hook `name`
	      posts[name].length = 0;
	    } else {
	      posts[name] = posts[name].filter( function (currFn) {
	        return currFn !== fnToRemove;
	      });
	    }
	    return this;
	  },
	  
	  _lazySetupHooks: function (proto, methodName, errorCb) {
	    if ('undefined' === typeof proto[methodName].numAsyncPres) {
	      this.$hook(methodName, proto[methodName], errorCb);
	    }
	  }
	};
	
	function once (fn, scope) {
	  return function fnWrapper () {
	    if (fnWrapper.hookCalled) return;
	    fnWrapper.hookCalled = true;
	    fn.apply(scope, arguments);
	  };
	}


/***/ }),
/* 169 */
/***/ (function(module, exports) {

	'use strict';
	
	function Kareem() {
	  this._pres = {};
	  this._posts = {};
	}
	
	Kareem.prototype.execPre = function(name, context, args, callback) {
	  if (arguments.length === 3) {
	    callback = args;
	    args = [];
	  }
	  var pres = this._pres[name] || [];
	  var numPres = pres.length;
	  var numAsyncPres = pres.numAsync || 0;
	  var currentPre = 0;
	  var asyncPresLeft = numAsyncPres;
	  var done = false;
	  var $args = args;
	
	  if (!numPres) {
	    return process.nextTick(function() {
	      callback(null);
	    });
	  }
	
	  var next = function() {
	    if (currentPre >= numPres) {
	      return;
	    }
	    var pre = pres[currentPre];
	
	    if (pre.isAsync) {
	      pre.fn.call(
	        context,
	        function(error) {
	          if (error) {
	            if (done) {
	              return;
	            }
	            done = true;
	            return callback(error);
	          }
	
	          ++currentPre;
	          next.apply(context, arguments);
	        },
	        function(error) {
	          if (error) {
	            if (done) {
	              return;
	            }
	            done = true;
	            return callback(error);
	          }
	
	          if (--numAsyncPres === 0) {
	            return callback(null);
	          }
	        });
	    } else if (pre.fn.length > 0) {
	      var args = [function(error) {
	        if (error) {
	          if (done) {
	            return;
	          }
	          done = true;
	          return callback(error);
	        }
	
	        if (++currentPre >= numPres) {
	          if (asyncPresLeft > 0) {
	            // Leave parallel hooks to run
	            return;
	          } else {
	            return callback(null);
	          }
	        }
	
	        next.apply(context, arguments);
	      }];
	      var _args = arguments.length >= 2 ? arguments : [null].concat($args);
	      for (var i = 1; i < _args.length; ++i) {
	        args.push(_args[i]);
	      }
	      pre.fn.apply(context, args);
	    } else {
	      pre.fn.call(context);
	      if (++currentPre >= numPres) {
	        if (asyncPresLeft > 0) {
	          // Leave parallel hooks to run
	          return;
	        } else {
	          return process.nextTick(function() {
	            callback(null);
	          });
	        }
	      }
	      next();
	    }
	  };
	
	  next.apply(null, [null].concat(args));
	};
	
	Kareem.prototype.execPreSync = function(name, context) {
	  var pres = this._pres[name] || [];
	  var numPres = pres.length;
	
	  for (var i = 0; i < numPres; ++i) {
	    pres[i].fn.call(context);
	  }
	};
	
	Kareem.prototype.execPost = function(name, context, args, options, callback) {
	  if (arguments.length < 5) {
	    callback = options;
	    options = null;
	  }
	  var posts = this._posts[name] || [];
	  var numPosts = posts.length;
	  var currentPost = 0;
	
	  var firstError = null;
	  if (options && options.error) {
	    firstError = options.error;
	  }
	
	  if (!numPosts) {
	    return process.nextTick(function() {
	      callback.apply(null, [firstError].concat(args));
	    });
	  }
	
	  var next = function() {
	    var post = posts[currentPost];
	    var numArgs = 0;
	    var argLength = args.length;
	    var newArgs = [];
	    for (var i = 0; i < argLength; ++i) {
	      numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;
	      if (!args[i] || !args[i]._kareemIgnore) {
	        newArgs.push(args[i]);
	      }
	    }
	
	    if (firstError) {
	      if (post.length === numArgs + 2) {
	        post.apply(context, [firstError].concat(newArgs).concat(function(error) {
	          if (error) {
	            firstError = error;
	          }
	          if (++currentPost >= numPosts) {
	            return callback.call(null, firstError);
	          }
	          next();
	        }));
	      } else {
	        if (++currentPost >= numPosts) {
	          return callback.call(null, firstError);
	        }
	        next();
	      }
	    } else {
	      if (post.length === numArgs + 2) {
	        // Skip error handlers if no error
	        if (++currentPost >= numPosts) {
	          return callback.apply(null, [null].concat(args));
	        }
	        return next();
	      }
	      if (post.length === numArgs + 1) {
	        post.apply(context, newArgs.concat(function(error) {
	          if (error) {
	            firstError = error;
	            return next();
	          }
	
	          if (++currentPost >= numPosts) {
	            return callback.apply(null, [null].concat(args));
	          }
	
	          next();
	        }));
	      } else {
	        post.apply(context, newArgs);
	
	        if (++currentPost >= numPosts) {
	          return callback.apply(null, [null].concat(args));
	        }
	
	        next();
	      }
	    }
	  };
	
	  next();
	};
	
	Kareem.prototype.execPostSync = function(name, context) {
	  var posts = this._posts[name] || [];
	  var numPosts = posts.length;
	
	  for (var i = 0; i < numPosts; ++i) {
	    posts[i].call(context);
	  }
	};
	
	function _handleWrapError(instance, error, name, context, args, options, callback) {
	  if (options.useErrorHandlers) {
	    var _options = { error: error };
	    return instance.execPost(name, context, args, _options, function(error) {
	      return typeof callback === 'function' && callback(error);
	    });
	  } else {
	    return typeof callback === 'function' ?
	      callback(error) :
	      undefined;
	  }
	}
	
	Kareem.prototype.wrap = function(name, fn, context, args, options) {
	  var lastArg = (args.length > 0 ? args[args.length - 1] : null);
	  var argsWithoutCb = typeof lastArg === 'function' ?
	    args.slice(0, args.length - 1) :
	    args;
	  var _this = this;
	
	  var useLegacyPost;
	  if (typeof options === 'object') {
	    useLegacyPost = options && options.useLegacyPost;
	  } else {
	    useLegacyPost = options;
	  }
	  options = options || {};
	
	  this.execPre(name, context, args, function(error) {
	    if (error) {
	      var numCallbackParams = options.numCallbackParams || 0;
	      var nulls = [];
	      for (var i = 0; i < numCallbackParams; ++i) {
	        nulls.push(null);
	      }
	      return _handleWrapError(_this, error, name, context, nulls,
	        options, lastArg);
	    }
	
	    var end = (typeof lastArg === 'function' ? args.length - 1 : args.length);
	
	    fn.apply(context, args.slice(0, end).concat(function() {
	      var args = arguments;
	      var argsWithoutError = Array.prototype.slice.call(arguments, 1);
	      if (options.nullResultByDefault && argsWithoutError.length === 0) {
	        argsWithoutError.push(null);
	      }
	      if (arguments[0]) {
	        // Assume error
	        return _handleWrapError(_this, arguments[0], name, context,
	          argsWithoutError, options, lastArg);
	      } else {
	        if (useLegacyPost && typeof lastArg === 'function') {
	          lastArg.apply(context, arguments);
	        }
	
	        _this.execPost(name, context, argsWithoutError, function() {
	          if (arguments[0]) {
	            return typeof lastArg === 'function' ?
	              lastArg(arguments[0]) :
	              undefined;
	          }
	
	          return typeof lastArg === 'function' && !useLegacyPost ?
	            lastArg.apply(context, arguments) :
	            undefined;
	        });
	      }
	    }));
	  });
	};
	
	Kareem.prototype.createWrapper = function(name, fn, context, options) {
	  var _this = this;
	  return function() {
	    var args = Array.prototype.slice.call(arguments);
	    _this.wrap(name, fn, context, args, options);
	  };
	};
	
	Kareem.prototype.pre = function(name, isAsync, fn, error) {
	  if (typeof arguments[1] !== 'boolean') {
	    error = fn;
	    fn = isAsync;
	    isAsync = false;
	  }
	
	  this._pres[name] = this._pres[name] || [];
	  var pres = this._pres[name];
	
	  if (isAsync) {
	    pres.numAsync = pres.numAsync || 0;
	    ++pres.numAsync;
	  }
	
	  pres.push({ fn: fn, isAsync: isAsync });
	
	  return this;
	};
	
	Kareem.prototype.post = function(name, fn) {
	  (this._posts[name] = this._posts[name] || []).push(fn);
	  return this;
	};
	
	Kareem.prototype.clone = function() {
	  var n = new Kareem();
	  for (var key in this._pres) {
	    if (!this._pres.hasOwnProperty(key)) {
	      continue;
	    }
	    n._pres[key] = this._pres[key].slice();
	    n._pres[key].numAsync = this._pres[key].numAsync;
	  }
	  for (var key in this._posts) {
	    if (!this._posts.hasOwnProperty(key)) {
	      continue;
	    }
	    n._posts[key] = this._posts[key].slice();
	  }
	
	  return n;
	};
	
	Kareem.prototype.merge = function(other) {
	  var ret = this.clone();
	  for (var key in other._pres) {
	    if (!other._pres.hasOwnProperty(key)) {
	      continue;
	    }
	    ret._pres[key] = (ret._pres[key] || []).concat(other._pres[key].slice());
	    ret._pres[key].numAsync += other._pres[key].numAsync;
	  }
	  for (var key in other._posts) {
	    if (!other._posts.hasOwnProperty(key)) {
	      continue;
	    }
	    ret._posts[key] = (ret._posts[key] || []).concat(other._posts[key].slice());
	  }
	
	  return ret;
	};
	
	module.exports = Kareem;


/***/ }),
/* 170 */
/***/ (function(module, exports) {

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}
	
	module.exports = apply;


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	var baseTimes = __webpack_require__(175),
	    isArguments = __webpack_require__(186),
	    isArray = __webpack_require__(187),
	    isBuffer = __webpack_require__(188),
	    isIndex = __webpack_require__(178),
	    isTypedArray = __webpack_require__(191);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;
	
	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = arrayLikeKeys;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(72),
	    isObjectLike = __webpack_require__(73);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';
	
	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}
	
	module.exports = baseIsArguments;


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(72),
	    isLength = __webpack_require__(118),
	    isObjectLike = __webpack_require__(73);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;
	
	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}
	
	module.exports = baseIsTypedArray;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	var isPrototype = __webpack_require__(179),
	    nativeKeys = __webpack_require__(180);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = baseKeys;


/***/ }),
/* 175 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);
	
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}
	
	module.exports = baseTimes;


/***/ }),
/* 176 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}
	
	module.exports = baseUnary;


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(115);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];
	
	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}
	
	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}
	
	module.exports = getRawTag;


/***/ }),
/* 178 */
/***/ (function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}
	
	module.exports = isIndex;


/***/ }),
/* 179 */
/***/ (function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
	
	  return value === proto;
	}
	
	module.exports = isPrototype;


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(183);
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);
	
	module.exports = nativeKeys;


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(116);
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;
	
	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());
	
	module.exports = nodeUtil;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(47)(module)))

/***/ }),
/* 182 */
/***/ (function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;
	
	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}
	
	module.exports = objectToString;


/***/ }),
/* 183 */
/***/ (function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	module.exports = overArg;


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(170);
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;
	
	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);
	
	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}
	
	module.exports = overRest;


/***/ }),
/* 185 */
/***/ (function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}
	
	module.exports = identity;


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsArguments = __webpack_require__(172),
	    isObjectLike = __webpack_require__(73);
	
	/** Used for built-in method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;
	
	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};
	
	module.exports = isArguments;


/***/ }),
/* 187 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	module.exports = isArray;


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(117),
	    stubFalse = __webpack_require__(193);
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
	
	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;
	
	module.exports = isBuffer;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(47)(module)))

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(72),
	    isObject = __webpack_require__(190);
	
	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	
	module.exports = isFunction;


/***/ }),
/* 190 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}
	
	module.exports = isObject;


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsTypedArray = __webpack_require__(173),
	    baseUnary = __webpack_require__(176),
	    nodeUtil = __webpack_require__(181);
	
	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	module.exports = isTypedArray;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(171),
	    baseKeys = __webpack_require__(174),
	    isArrayLike = __webpack_require__(51);
	
	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	
	module.exports = keys;


/***/ }),
/* 193 */
/***/ (function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}
	
	module.exports = stubFalse;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var inherits = __webpack_require__(1).inherits,
	  EventEmitter = __webpack_require__(6).EventEmitter,
	  Connection = __webpack_require__(120),
	  MongoError = __webpack_require__(7),
	  Logger = __webpack_require__(19),
	  f = __webpack_require__(1).format,
	  Query = __webpack_require__(9).Query,
	  CommandResult = __webpack_require__(119),
	  assign = __webpack_require__(58).assign;
	
	var MongoCR = __webpack_require__(53)
	  , X509 = __webpack_require__(56)
	  , Plain = __webpack_require__(54)
	  , GSSAPI = __webpack_require__(52)
	  , SSPI = __webpack_require__(75)
	  , ScramSHA1 = __webpack_require__(55);
	
	var DISCONNECTED = 'disconnected';
	var CONNECTING = 'connecting';
	var CONNECTED = 'connected';
	var DESTROYING = 'destroying';
	var DESTROYED = 'destroyed';
	
	var _id = 0;
	
	/**
	 * Creates a new Pool instance
	 * @class
	 * @param {string} options.host The server host
	 * @param {number} options.port The server port
	 * @param {number} [options.size=1] Max server connection pool size
	 * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection
	 * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times
	 * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries
	 * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled
	 * @param {number} [options.keepAliveInitialDelay=300000] Initial delay before TCP keep alive enabled
	 * @param {boolean} [options.noDelay=true] TCP Connection no delay
	 * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting
	 * @param {number} [options.socketTimeout=360000] TCP Socket timeout setting
	 * @param {number} [options.monitoringSocketTimeout=30000] TCP Socket timeout setting for replicaset monitoring socket
	 * @param {boolean} [options.ssl=false] Use SSL for connection
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {Buffer} [options.ca] SSL Certificate store binary buffer
	 * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer
	 * @param {Buffer} [options.cert] SSL Certificate binary buffer
	 * @param {Buffer} [options.key] SSL Key file binary buffer
	 * @param {string} [options.passPhrase] SSL Certificate pass phrase
	 * @param {boolean} [options.rejectUnauthorized=false] Reject unauthorized server certificates
	 * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
	 * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
	 * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
	 * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
	 * @fires Pool#connect
	 * @fires Pool#close
	 * @fires Pool#error
	 * @fires Pool#timeout
	 * @fires Pool#parseError
	 * @return {Pool} A cursor instance
	 */
	var Pool = function(options) {
	  // Add event listener
	  EventEmitter.call(this);
	  // Add the options
	  this.options = assign({
	    // Host and port settings
	    host: 'localhost',
	    port: 27017,
	    // Pool default max size
	    size: 5,
	    // socket settings
	    connectionTimeout: 30000,
	    socketTimeout: 360000,
	    keepAlive: true,
	    keepAliveInitialDelay: 300000,
	    noDelay: true,
	    // SSL Settings
	    ssl: false, checkServerIdentity: true,
	    ca: null, crl: null, cert: null, key: null, passPhrase: null,
	    rejectUnauthorized: false,
	    promoteLongs: true,
	    promoteValues: true,
	    promoteBuffers: false,
	    // Reconnection options
	    reconnect: true,
	    reconnectInterval: 1000,
	    reconnectTries: 30,
	    // Enable domains
	    domainsEnabled: false
	  }, options);
	
	  // console.log("=================================== pool options")
	  // console.dir(this.options)
	
	  // Identification information
	  this.id = _id++;
	  // Current reconnect retries
	  this.retriesLeft = this.options.reconnectTries;
	  this.reconnectId = null;
	  // No bson parser passed in
	  if(!options.bson || (options.bson
	    && (typeof options.bson.serialize != 'function'
	    || typeof options.bson.deserialize != 'function'))) {
	      throw new Error("must pass in valid bson parser");
	  }
	
	  // Logger instance
	  this.logger = Logger('Pool', options);
	  // Pool state
	  this.state = DISCONNECTED;
	  // Connections
	  this.availableConnections = [];
	  this.inUseConnections = [];
	  this.connectingConnections = [];
	  // Currently executing
	  this.executing = false;
	  // Operation work queue
	  this.queue = [];
	
	  // All the authProviders
	  this.authProviders = options.authProviders || {
	      'mongocr': new MongoCR(options.bson), 'x509': new X509(options.bson)
	    , 'plain': new Plain(options.bson), 'gssapi': new GSSAPI(options.bson)
	    , 'sspi': new SSPI(options.bson), 'scram-sha-1': new ScramSHA1(options.bson)
	  }
	
	  // Contains the reconnect connection
	  this.reconnectConnection = null;
	
	  // Are we currently authenticating
	  this.authenticating = false;
	  this.loggingout = false;
	  this.nonAuthenticatedConnections = [];
	  this.authenticatingTimestamp = null;
	  // Number of consecutive timeouts caught
	  this.numberOfConsecutiveTimeouts = 0;
	  // Current pool Index
	  this.connectionIndex = 0;
	}
	
	inherits(Pool, EventEmitter);
	
	Object.defineProperty(Pool.prototype, 'size', {
	  enumerable:true,
	  get: function() { return this.options.size; }
	});
	
	Object.defineProperty(Pool.prototype, 'connectionTimeout', {
	  enumerable:true,
	  get: function() { return this.options.connectionTimeout; }
	});
	
	Object.defineProperty(Pool.prototype, 'socketTimeout', {
	  enumerable:true,
	  get: function() { return this.options.socketTimeout; }
	});
	
	function stateTransition(self, newState) {
	  var legalTransitions = {
	    'disconnected': [CONNECTING, DESTROYING, DISCONNECTED],
	    'connecting': [CONNECTING, DESTROYING, CONNECTED, DISCONNECTED],
	    'connected': [CONNECTED, DISCONNECTED, DESTROYING],
	    'destroying': [DESTROYING, DESTROYED],
	    'destroyed': [DESTROYED]
	  }
	
	  // Get current state
	  var legalStates = legalTransitions[self.state];
	  if(legalStates && legalStates.indexOf(newState) != -1) {
	    self.state = newState;
	  } else {
	    self.logger.error(f('Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]'
	      , self.id, self.state, newState, legalStates));
	  }
	}
	
	function authenticate(pool, auth, connection, cb) {
	  if(auth[0] === undefined) return cb(null);
	  // We need to authenticate the server
	  var mechanism = auth[0];
	  var db = auth[1];
	  // Validate if the mechanism exists
	  if(!pool.authProviders[mechanism]) {
	    throw new MongoError(f('authMechanism %s not supported', mechanism));
	  }
	
	  // Get the provider
	  var provider = pool.authProviders[mechanism];
	
	  // Authenticate using the provided mechanism
	  provider.auth.apply(provider, [write(pool), [connection], db].concat(auth.slice(2)).concat([cb]));
	}
	
	// The write function used by the authentication mechanism (bypasses external)
	function write(self) {
	  return function(connection, command, callback) {
	    // Get the raw buffer
	    // Ensure we stop auth if pool was destroyed
	    if(self.state == DESTROYED || self.state == DESTROYING) {
	      return callback(new MongoError('pool destroyed'));
	    }
	
	    // Set the connection workItem callback
	    connection.workItems.push({
	      cb: callback, command: true, requestId: command.requestId
	    });
	
	    // Write the buffer out to the connection
	    connection.write(command.toBin());
	  };
	}
	
	
	function reauthenticate(pool, connection, cb) {
	  // Authenticate
	  function authenticateAgainstProvider(pool, connection, providers, cb) {
	    // Finished re-authenticating against providers
	    if(providers.length == 0) return cb();
	    // Get the provider name
	    var provider = pool.authProviders[providers.pop()];
	
	    // Auth provider
	    provider.reauthenticate(write(pool), [connection], function(err) {
	      // We got an error return immediately
	      if(err) return cb(err);
	      // Continue authenticating the connection
	      authenticateAgainstProvider(pool, connection, providers, cb);
	    });
	  }
	
	  // Start re-authenticating process
	  authenticateAgainstProvider(pool, connection, Object.keys(pool.authProviders), cb);
	}
	
	function connectionFailureHandler(self, event) {
	  return function(err) {
	    // console.log("========== connectionFailureHandler :: " + event)
	    // console.dir(err)
	
	    if (this._connectionFailHandled) return;
	    this._connectionFailHandled = true;
	    // Destroy the connection
	    this.destroy();
	
	    // Remove the connection
	    removeConnection(self, this);
	
	    // Flush all work Items on this connection
	    while(this.workItems.length > 0) {
	      var workItem = this.workItems.shift();
	      // if(workItem.cb) workItem.cb(err);
	      if(workItem.cb) workItem.cb(err);
	    }
	
	    // Did we catch a timeout, increment the numberOfConsecutiveTimeouts
	    if(event == 'timeout') {
	      self.numberOfConsecutiveTimeouts = self.numberOfConsecutiveTimeouts + 1;
	
	      // Have we timed out more than reconnectTries in a row ?
	      // Force close the pool as we are trying to connect to tcp sink hole
	      if(self.numberOfConsecutiveTimeouts > self.options.reconnectTries) {
	        self.numberOfConsecutiveTimeouts = 0;
	        // Destroy all connections and pool
	        self.destroy(true);
	        // Emit close event
	        return self.emit('close', self);
	      }
	    }
	
	    // No more socket available propegate the event
	    if(self.socketCount() == 0) {
	      if(self.state != DESTROYED && self.state != DESTROYING) {
	        stateTransition(self, DISCONNECTED);
	      }
	
	      // Do not emit error events, they are always close events
	      // do not trigger the low level error handler in node
	      event = event == 'error' ? 'close' : event;
	      self.emit(event, err);
	    }
	
	    // Start reconnection attempts
	    if(!self.reconnectId && self.options.reconnect) {
	      self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);
	    }
	  };
	}
	
	function attemptReconnect(self) {
	  return function() {
	    // console.log("========================= attemptReconnect")
	    self.emit('attemptReconnect', self);
	    if(self.state == DESTROYED || self.state == DESTROYING) return;
	
	    // We are connected do not try again
	    if(self.isConnected()) {
	      self.reconnectId = null;
	      return;
	    }
	
	    // If we have failure schedule a retry
	    function _connectionFailureHandler(self, event) {
	      return function() {
	    // console.log("========== _connectionFailureHandler :: " + event)
	        if (this._connectionFailHandled) return;
	        this._connectionFailHandled = true;
	        // Destroy the connection
	        this.destroy();
	        // Count down the number of reconnects
	        self.retriesLeft = self.retriesLeft - 1;
	        // How many retries are left
	        if(self.retriesLeft == 0) {
	          // Destroy the instance
	          self.destroy();
	          // Emit close event
	          self.emit('reconnectFailed'
	            , new MongoError(f('failed to reconnect after %s attempts with interval %s ms', self.options.reconnectTries, self.options.reconnectInterval)));
	        } else {
	          self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);
	        }
	      }
	    }
	
	    // Got a connect handler
	    function _connectHandler(self) {
	      return function() {
	        // Assign
	        var connection = this;
	
	        // Pool destroyed stop the connection
	        if(self.state == DESTROYED || self.state == DESTROYING) {
	          return connection.destroy();
	        }
	
	        // Clear out all handlers
	        handlers.forEach(function(event) {
	          connection.removeAllListeners(event);
	        });
	
	        // Reset reconnect id
	        self.reconnectId = null;
	
	        // Apply pool connection handlers
	        connection.on('error', connectionFailureHandler(self, 'error'));
	        connection.on('close', connectionFailureHandler(self, 'close'));
	        connection.on('timeout', connectionFailureHandler(self, 'timeout'));
	        connection.on('parseError', connectionFailureHandler(self, 'parseError'));
	
	        // Apply any auth to the connection
	        reauthenticate(self, this, function() {
	          // Reset retries
	          self.retriesLeft = self.options.reconnectTries;
	          // Push to available connections
	          self.availableConnections.push(connection);
	          // Set the reconnectConnection to null
	          self.reconnectConnection = null;
	          // Emit reconnect event
	          self.emit('reconnect', self);
	          // Trigger execute to start everything up again
	          _execute(self)();
	        });
	      }
	    }
	
	    // Create a connection
	    self.reconnectConnection = new Connection(messageHandler(self), self.options);
	    // Add handlers
	    self.reconnectConnection.on('close', _connectionFailureHandler(self, 'close'));
	    self.reconnectConnection.on('error', _connectionFailureHandler(self, 'error'));
	    self.reconnectConnection.on('timeout', _connectionFailureHandler(self, 'timeout'));
	    self.reconnectConnection.on('parseError', _connectionFailureHandler(self, 'parseError'));
	    // On connection
	    self.reconnectConnection.on('connect', _connectHandler(self));
	    // Attempt connection
	    self.reconnectConnection.connect();
	  }
	}
	
	function moveConnectionBetween(connection, from, to) {
	  var index = from.indexOf(connection);
	  // Move the connection from connecting to available
	  if(index != -1) {
	    from.splice(index, 1);
	    to.push(connection);
	  }
	}
	
	function messageHandler(self) {
	  return function(message, connection) {
	    // workItem to execute
	    var workItem = null;
	
	    // Locate the workItem
	    for(var i = 0; i < connection.workItems.length; i++) {
	      if(connection.workItems[i].requestId == message.responseTo) {
	        // Get the callback
	        workItem = connection.workItems[i];
	        // Remove from list of workItems
	        connection.workItems.splice(i, 1);
	      }
	    }
	
	
	    // Reset timeout counter
	    self.numberOfConsecutiveTimeouts = 0;
	
	    // Reset the connection timeout if we modified it for
	    // this operation
	    if(workItem.socketTimeout) {
	      connection.resetSocketTimeout();
	    }
	
	    // Log if debug enabled
	    if(self.logger.isDebug()) {
	      self.logger.debug(f('message [%s] received from %s:%s'
	        , message.raw.toString('hex'), self.options.host, self.options.port));
	    }
	
	    // Authenticate any straggler connections
	    function authenticateStragglers(self, connection, callback) {
	      // Get any non authenticated connections
	      var connections = self.nonAuthenticatedConnections.slice(0);
	      var nonAuthenticatedConnections = self.nonAuthenticatedConnections;
	      self.nonAuthenticatedConnections = [];
	
	      // Establish if the connection need to be authenticated
	      // Add to authentication list if
	      // 1. we were in an authentication process when the operation was executed
	      // 2. our current authentication timestamp is from the workItem one, meaning an auth has happened
	      if(connection.workItems.length == 1 && (connection.workItems[0].authenticating == true
	        || (typeof connection.workItems[0].authenticatingTimestamp == 'number'
	            && connection.workItems[0].authenticatingTimestamp != self.authenticatingTimestamp))) {
	        // Add connection to the list
	        connections.push(connection);
	      }
	
	      // No connections need to be re-authenticated
	      if(connections.length == 0) {
	        // Release the connection back to the pool
	        moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);
	        // Finish
	        return callback();
	      }
	
	      // Apply re-authentication to all connections before releasing back to pool
	      var connectionCount = connections.length;
	      // Authenticate all connections
	      for(var i = 0; i < connectionCount; i++) {
	        reauthenticate(self, connections[i], function() {
	          connectionCount = connectionCount - 1;
	
	          if(connectionCount == 0) {
	            // Put non authenticated connections in available connections
	            self.availableConnections = self.availableConnections.concat(nonAuthenticatedConnections);
	            // Release the connection back to the pool
	            moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);
	            // Return
	            callback();
	          }
	        });
	      }
	    }
	
	    function handleOperationCallback(self, cb, err, result) {
	      // No domain enabled
	      if(!self.options.domainsEnabled) {
	        return process.nextTick(function() {
	          return cb(err, result);
	        });
	      }
	
	      // Domain enabled just call the callback
	      cb(err, result);
	    }
	
	    authenticateStragglers(self, connection, function() {
	      // Keep executing, ensure current message handler does not stop execution
	      if(!self.executing) {
	        process.nextTick(function() {
	          _execute(self)();
	        });
	      }
	
	      // Time to dispatch the message if we have a callback
	      if(!workItem.immediateRelease) {
	        try {
	          // Parse the message according to the provided options
	          message.parse(workItem);
	        } catch(err) {
	          return handleOperationCallback(self, workItem.cb, MongoError.create(err));
	        }
	
	        // Establish if we have an error
	        if(workItem.command && message.documents[0] && (message.documents[0].ok == 0 || message.documents[0]['$err']
	        || message.documents[0]['errmsg'] || message.documents[0]['code'])) {
	          return handleOperationCallback(self, workItem.cb, MongoError.create(message.documents[0]));
	        }
	
	        // Add the connection details
	        message.hashedName = connection.hashedName;
	
	        // Return the documents
	        handleOperationCallback(self, workItem.cb, null, new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message));
	      }
	    });
	  }
	}
	
	/**
	 * Return the total socket count in the pool.
	 * @method
	 * @return {Number} The number of socket available.
	 */
	Pool.prototype.socketCount = function() {
	  return this.availableConnections.length
	    + this.inUseConnections.length;
	    // + this.connectingConnections.length;
	}
	
	/**
	 * Return all pool connections
	 * @method
	 * @return {Connection[]} The pool connections
	 */
	Pool.prototype.allConnections = function() {
	  return this.availableConnections
	    .concat(this.inUseConnections)
	    .concat(this.connectingConnections);
	}
	
	/**
	 * Get a pool connection (round-robin)
	 * @method
	 * @return {Connection}
	 */
	Pool.prototype.get = function() {
	  return this.allConnections()[0];
	}
	
	/**
	 * Is the pool connected
	 * @method
	 * @return {boolean}
	 */
	Pool.prototype.isConnected = function() {
	  // We are in a destroyed state
	  if(this.state == DESTROYED || this.state == DESTROYING) {
	    return false;
	  }
	
	  // Get connections
	  var connections = this.availableConnections
	    .concat(this.inUseConnections);
	
	  // Check if we have any connected connections
	  for(var i = 0; i < connections.length; i++) {
	    if(connections[i].isConnected()) return true;
	  }
	
	  // Might be authenticating, but we are still connected
	  if(connections.length == 0 && this.authenticating) {
	    return true
	  }
	
	  // Not connected
	  return false;
	}
	
	/**
	 * Was the pool destroyed
	 * @method
	 * @return {boolean}
	 */
	Pool.prototype.isDestroyed = function() {
	  return this.state == DESTROYED || this.state == DESTROYING;
	}
	
	/**
	 * Is the pool in a disconnected state
	 * @method
	 * @return {boolean}
	 */
	Pool.prototype.isDisconnected = function() {
	  return this.state == DISCONNECTED;
	}
	
	/**
	 * Connect pool
	 * @method
	 */
	Pool.prototype.connect = function() {
	  if(this.state != DISCONNECTED) {
	    throw new MongoError('connection in unlawful state ' + this.state);
	  }
	
	  var self = this;
	  // Transition to connecting state
	  stateTransition(this, CONNECTING);
	  // Create an array of the arguments
	  var args = Array.prototype.slice.call(arguments, 0);
	  // Create a connection
	  var connection = new Connection(messageHandler(self), this.options);
	  // Add to list of connections
	  this.connectingConnections.push(connection);
	  // Add listeners to the connection
	  connection.once('connect', function(connection) {
	    if(self.state == DESTROYED || self.state == DESTROYING) return self.destroy();
	
	    // If we are in a topology, delegate the auth to it
	    // This is to avoid issues where we would auth against an
	    // arbiter
	    if(self.options.inTopology) {
	      // Set connected mode
	      stateTransition(self, CONNECTED);
	
	      // Move the active connection
	      moveConnectionBetween(connection, self.connectingConnections, self.availableConnections);
	
	      // Emit the connect event
	      return self.emit('connect', self);
	    }
	
	    // Apply any store credentials
	    reauthenticate(self, connection, function(err) {
	      if(self.state == DESTROYED || self.state == DESTROYING) return self.destroy();
	
	      // We have an error emit it
	      if(err) {
	        // Destroy the pool
	        self.destroy();
	        // Emit the error
	        return self.emit('error', err);
	      }
	
	      // Authenticate
	      authenticate(self, args, connection, function(err) {
	        if(self.state == DESTROYED || self.state == DESTROYING) return self.destroy();
	
	        // We have an error emit it
	        if(err) {
	          // Destroy the pool
	          self.destroy();
	          // Emit the error
	          return self.emit('error', err);
	        }
	        // Set connected mode
	        stateTransition(self, CONNECTED);
	
	        // Move the active connection
	        moveConnectionBetween(connection, self.connectingConnections, self.availableConnections);
	
	        // Emit the connect event
	        self.emit('connect', self);
	      });
	    });
	  });
	
	  // Add error handlers
	  connection.once('error', connectionFailureHandler(this, 'error'));
	  connection.once('close', connectionFailureHandler(this, 'close'));
	  connection.once('timeout', connectionFailureHandler(this, 'timeout'));
	  connection.once('parseError', connectionFailureHandler(this, 'parseError'));
	
	  try {
	    connection.connect();
	  } catch(err) {
	    // SSL or something threw on connect
	    process.nextTick(function() {
	      self.emit('error', err);
	    });
	  }
	}
	
	/**
	 * Authenticate using a specified mechanism
	 * @method
	 * @param {string} mechanism The Auth mechanism we are invoking
	 * @param {string} db The db we are invoking the mechanism against
	 * @param {...object} param Parameters for the specific mechanism
	 * @param {authResultCallback} callback A callback function
	 */
	Pool.prototype.auth = function(mechanism) {
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 0);
	  var callback = args.pop();
	
	  // If we don't have the mechanism fail
	  if(self.authProviders[mechanism] == null && mechanism != 'default') {
	    throw new MongoError(f("auth provider %s does not exist", mechanism));
	  }
	
	  // Signal that we are authenticating a new set of credentials
	  this.authenticating = true;
	  this.authenticatingTimestamp = new Date().getTime();
	
	  // Authenticate all live connections
	  function authenticateLiveConnections(self, args, cb) {
	    // Get the current viable connections
	    var connections = self.allConnections();
	    // Allow nothing else to use the connections while we authenticate them
	    self.availableConnections = [];
	
	    var connectionsCount = connections.length;
	    var error = null;
	    // No connections available, return
	    if(connectionsCount == 0) {
	      self.authenticating = false;
	      return callback(null);
	    }
	
	    // Authenticate the connections
	    for(var i = 0; i < connections.length; i++) {
	      authenticate(self, args, connections[i], function(err) {
	        connectionsCount = connectionsCount - 1;
	
	        // Store the error
	        if(err) error = err;
	
	        // Processed all connections
	        if(connectionsCount == 0) {
	          // Auth finished
	          self.authenticating = false;
	          // Add the connections back to available connections
	          self.availableConnections = self.availableConnections.concat(connections);
	          // We had an error, return it
	          if(error) {
	            // Log the error
	            if(self.logger.isError()) {
	              self.logger.error(f('[%s] failed to authenticate against server %s:%s'
	                , self.id, self.options.host, self.options.port));
	            }
	
	            return cb(error);
	          }
	          cb(null);
	        }
	      });
	    }
	  }
	
	  // Wait for a logout in process to happen
	  function waitForLogout(self, cb) {
	    if(!self.loggingout) return cb();
	    setTimeout(function() {
	      waitForLogout(self, cb);
	    }, 1)
	  }
	
	  // Wait for loggout to finish
	  waitForLogout(self, function() {
	    // Authenticate all live connections
	    authenticateLiveConnections(self, args, function(err) {
	      // Credentials correctly stored in auth provider if successful
	      // Any new connections will now reauthenticate correctly
	      self.authenticating = false;
	      // Return after authentication connections
	      callback(err);
	    });
	  });
	}
	
	/**
	 * Logout all users against a database
	 * @method
	 * @param {string} dbName The database name
	 * @param {authResultCallback} callback A callback function
	 */
	Pool.prototype.logout = function(dbName, callback) {
	  var self = this;
	  if(typeof dbName != 'string') {
	    throw new MongoError('logout method requires a db name as first argument');
	  }
	
	  if(typeof callback != 'function') {
	    throw new MongoError('logout method requires a callback');
	  }
	
	  // Indicate logout in process
	  this.loggingout = true;
	
	  // Get all relevant connections
	  var connections = self.availableConnections.concat(self.inUseConnections);
	  var count = connections.length;
	  // Store any error
	  var error = null;
	
	  // Send logout command over all the connections
	  for(var i = 0; i < connections.length; i++) {
	    write(self)(connections[i], new Query(this.options.bson
	      , f('%s.$cmd', dbName)
	      , {logout:1}, {numberToSkip: 0, numberToReturn: 1}), function(err) {
	      count = count - 1;
	      if(err) error = err;
	
	      if(count == 0) {
	        self.loggingout = false;
	        callback(error);
	      }
	    });
	  }
	}
	
	/**
	 * Unref the pool
	 * @method
	 */
	Pool.prototype.unref = function() {
	  // Get all the known connections
	  var connections = this.availableConnections
	    .concat(this.inUseConnections)
	    .concat(this.connectingConnections);
	  connections.forEach(function(c) {
	    c.unref();
	  });
	}
	
	// Events
	var events = ['error', 'close', 'timeout', 'parseError', 'connect'];
	
	// Destroy the connections
	function destroy(self, connections) {
	  // Destroy all connections
	  connections.forEach(function(c) {
	    // Remove all listeners
	    for(var i = 0; i < events.length; i++) {
	      c.removeAllListeners(events[i]);
	    }
	    // Destroy connection
	    c.destroy();
	  });
	
	  // Zero out all connections
	  self.inUseConnections = [];
	  self.availableConnections = [];
	  self.nonAuthenticatedConnections = [];
	  self.connectingConnections = [];
	
	  // Set state to destroyed
	  stateTransition(self, DESTROYED);
	}
	
	/**
	 * Destroy pool
	 * @method
	 */
	Pool.prototype.destroy = function(force) {
	  var self = this;
	  // Do not try again if the pool is already dead
	  if(this.state == DESTROYED || self.state == DESTROYING) return;
	  // Set state to destroyed
	  stateTransition(this, DESTROYING);
	
	  // Are we force closing
	  if(force) {
	    // Get all the known connections
	    var connections = self.availableConnections
	      .concat(self.inUseConnections)
	      .concat(self.nonAuthenticatedConnections)
	      .concat(self.connectingConnections);
	
	    // Flush any remaining work items with
	    // an error
	    while(self.queue.length > 0) {
	      var workItem = self.queue.shift();
	      if(typeof workItem.cb == 'function') {
	        workItem.cb(null, err);
	      }
	    }
	
	    // Destroy the topology
	    return destroy(self, connections);
	  }
	
	  // Clear out the reconnect if set
	  if (this.reconnectId) {
	    clearTimeout(this.reconnectId);
	  }
	
	  // If we have a reconnect connection running, close
	  // immediately
	  if (this.reconnectConnection) {
	    this.reconnectConnection.destroy();
	  }
	
	  // Wait for the operations to drain before we close the pool
	  function checkStatus() {
	    flushMonitoringOperations(self.queue);
	
	    if(self.queue.length == 0) {
	      // Get all the known connections
	      var connections = self.availableConnections
	        .concat(self.inUseConnections)
	        .concat(self.nonAuthenticatedConnections)
	        .concat(self.connectingConnections);
	
	      // Check if we have any in flight operations
	      for(var i = 0; i < connections.length; i++) {
	        // There is an operation still in flight, reschedule a
	        // check waiting for it to drain
	        if(connections[i].workItems.length > 0) {
	          return setTimeout(checkStatus, 1);
	        }
	      }
	
	      destroy(self, connections);
	    // } else if (self.queue.length > 0 && !this.reconnectId) {
	
	    } else {
	      // Ensure we empty the queue
	      _execute(self)();
	      // Set timeout
	      setTimeout(checkStatus, 1);
	    }
	  }
	
	  // Initiate drain of operations
	  checkStatus();
	}
	
	/**
	 * Write a message to MongoDB
	 * @method
	 * @return {Connection}
	 */
	Pool.prototype.write = function(commands, options, cb) {
	  var self = this;
	  // Ensure we have a callback
	  if(typeof options == 'function') {
	    cb = options;
	  }
	
	  // Always have options
	  options = options || {};
	
	  // Pool was destroyed error out
	  if(this.state == DESTROYED || this.state == DESTROYING) {
	    // Callback with an error
	    if(cb) {
	      try {
	        cb(new MongoError('pool destroyed'));
	      } catch(err) {
	        process.nextTick(function() {
	          throw err;
	        });
	      }
	    }
	
	    return;
	  }
	
	  if(this.options.domainsEnabled
	    && process.domain && typeof cb === "function") {
	    // if we have a domain bind to it
	    var oldCb = cb;
	    cb = process.domain.bind(function() {
	      // v8 - argumentsToArray one-liner
	      var args = new Array(arguments.length); for(var i = 0; i < arguments.length; i++) { args[i] = arguments[i]; }
	      // bounce off event loop so domain switch takes place
	      process.nextTick(function() {
	        oldCb.apply(null, args);
	      });
	    });
	  }
	
	  // Do we have an operation
	  var operation = {
	    cb: cb, raw: false, promoteLongs: true, promoteValues: true, promoteBuffers: false, fullResult: false
	  };
	
	  var buffer = null
	
	  if(Array.isArray(commands)) {
	    buffer = [];
	
	    for(var i = 0; i < commands.length; i++) {
	      buffer.push(commands[i].toBin());
	    }
	
	    // Get the requestId
	    operation.requestId = commands[commands.length - 1].requestId;
	  } else {
	    operation.requestId = commands.requestId;
	    buffer = commands.toBin();
	  }
	
	  // Set the buffers
	  operation.buffer = buffer;
	
	  // Set the options for the parsing
	  operation.promoteLongs = typeof options.promoteLongs == 'boolean' ? options.promoteLongs : true;
	  operation.promoteValues = typeof options.promoteValues == 'boolean' ? options.promoteValues : true;
	  operation.promoteBuffers = typeof options.promoteBuffers == 'boolean' ? options.promoteBuffers : false;
	  operation.raw = typeof options.raw == 'boolean' ? options.raw : false;
	  operation.immediateRelease = typeof options.immediateRelease == 'boolean' ? options.immediateRelease : false;
	  operation.documentsReturnedIn = options.documentsReturnedIn;
	  operation.command = typeof options.command == 'boolean' ? options.command : false;
	  operation.fullResult = typeof options.fullResult == 'boolean' ? options.fullResult : false;
	  operation.noResponse = typeof options.noResponse == 'boolean' ? options.noResponse : false;
	  // operation.requestId = options.requestId;
	
	  // Optional per operation socketTimeout
	  operation.socketTimeout = options.socketTimeout;
	  operation.monitoring = options.monitoring;
	  // Custom socket Timeout
	  if(options.socketTimeout) {
	    operation.socketTimeout = options.socketTimeout;
	  }
	
	  // We need to have a callback function unless the message returns no response
	  if(!(typeof cb == 'function') && !options.noResponse) {
	    throw new MongoError('write method must provide a callback');
	  }
	
	  // If we have a monitoring operation schedule as the very first operation
	  // Otherwise add to back of queue
	  if(options.monitoring) {
	    this.queue.unshift(operation);
	  } else {
	    this.queue.push(operation);
	  }
	
	  // Attempt to execute the operation
	  if(!self.executing) {
	    process.nextTick(function() {
	      _execute(self)();
	    });
	  }
	}
	
	// Remove connection method
	function remove(connection, connections) {
	  for(var i = 0; i < connections.length; i++) {
	    if(connections[i] === connection) {
	      connections.splice(i, 1);
	      return true;
	    }
	  }
	}
	
	function removeConnection(self, connection) {
	  if(remove(connection, self.availableConnections)) return;
	  if(remove(connection, self.inUseConnections)) return;
	  if(remove(connection, self.connectingConnections)) return;
	  if(remove(connection, self.nonAuthenticatedConnections)) return;
	}
	
	// All event handlers
	var handlers = ["close", "message", "error", "timeout", "parseError", "connect"];
	
	function _createConnection(self) {
	  if(self.state == DESTROYED || self.state == DESTROYING) {
	    return;
	  }
	  var connection = new Connection(messageHandler(self), self.options);
	
	  // Push the connection
	  self.connectingConnections.push(connection);
	
	  // Handle any errors
	  var tempErrorHandler = function(_connection) {
	    return function() {
	      // Destroy the connection
	      _connection.destroy();
	      // Remove the connection from the connectingConnections list
	      removeConnection(self, _connection);
	      // Start reconnection attempts
	      if(!self.reconnectId && self.options.reconnect) {
	        self.reconnectId = setTimeout(attemptReconnect(self), self.options.reconnectInterval);
	      }
	    }
	  }
	
	  // Handle successful connection
	  var tempConnectHandler = function(_connection) {
	    return function() {
	      // Destroyed state return
	      if(self.state == DESTROYED || self.state == DESTROYING) {
	        // Remove the connection from the list
	        removeConnection(self, _connection);
	        return _connection.destroy();
	      }
	
	      // Destroy all event emitters
	      handlers.forEach(function(e) {
	        _connection.removeAllListeners(e);
	      });
	
	      // Add the final handlers
	      _connection.once('close', connectionFailureHandler(self, 'close'));
	      _connection.once('error', connectionFailureHandler(self, 'error'));
	      _connection.once('timeout', connectionFailureHandler(self, 'timeout'));
	      _connection.once('parseError', connectionFailureHandler(self, 'parseError'));
	
	      // Signal
	      reauthenticate(self, _connection, function(err) {
	        if(self.state == DESTROYED || self.state == DESTROYING) {
	          return _connection.destroy();
	        }
	        // Remove the connection from the connectingConnections list
	        removeConnection(self, _connection);
	
	        // Handle error
	        if(err) {
	          return _connection.destroy();
	        }
	
	        // If we are c at the moment
	        // Do not automatially put in available connections
	        // As we need to apply the credentials first
	        if(self.authenticating) {
	          self.nonAuthenticatedConnections.push(_connection);
	        } else {
	          // Push to available
	          self.availableConnections.push(_connection);
	          // Execute any work waiting
	          _execute(self)();
	        }
	      });
	    }
	  }
	
	  // Add all handlers
	  connection.once('close', tempErrorHandler(connection));
	  connection.once('error', tempErrorHandler(connection));
	  connection.once('timeout', tempErrorHandler(connection));
	  connection.once('parseError', tempErrorHandler(connection));
	  connection.once('connect', tempConnectHandler(connection));
	
	  // Start connection
	  connection.connect();
	}
	
	function flushMonitoringOperations(queue) {
	  for(var i = 0; i < queue.length; i++) {
	    if(queue[i].monitoring) {
	      var workItem = queue[i];
	      queue.splice(i, 1);
	      workItem.cb(new MongoError({ message: 'no connection available for monitoring', driver:true }));
	    }
	  }
	}
	
	function _execute(self) {
	  return function() {
	    if(self.state == DESTROYED) return;
	    // Already executing, skip
	    if(self.executing) return;
	    // Set pool as executing
	    self.executing = true;
	
	    // Wait for auth to clear before continuing
	    function waitForAuth(cb) {
	      if(!self.authenticating) return cb();
	      // Wait for a milisecond and try again
	      setTimeout(function() {
	        waitForAuth(cb);
	      }, 1);
	    }
	
	    // Block on any auth in process
	    waitForAuth(function() {
	      // New pool connections are in progress, wait them to finish
	      // before executing any more operation to ensure distribution of
	      // operations
	      if(self.connectingConnections.length > 0) {
	        return;
	      }
	
	      // As long as we have available connections
	      while(true) {
	        // Total availble connections
	        var totalConnections = self.availableConnections.length
	          + self.connectingConnections.length
	          + self.inUseConnections.length;
	
	        // No available connections available, flush any monitoring ops
	        if(self.availableConnections.length == 0) {
	          // Flush any monitoring operations
	          flushMonitoringOperations(self.queue);
	          break;
	        }
	
	        // No queue break
	        if(self.queue.length == 0) {
	          break;
	        }
	
	        // Get a connection
	        var connection = null;
	
	        // Locate all connections that have no work
	        var connections = [];
	        // Get a list of all connections
	        for(var i = 0; i < self.availableConnections.length; i++) {
	          if(self.availableConnections[i].workItems.length == 0) {
	            connections.push(self.availableConnections[i]);
	          }
	        }
	
	        // No connection found that has no work on it, just pick one for pipelining
	        if(connections.length == 0) {
	          connection = self.availableConnections[self.connectionIndex++ % self.availableConnections.length];
	        } else {
	          connection = connections[self.connectionIndex++ % connections.length];
	        }
	
	        // Is the connection connected
	        if(connection.isConnected()) {
	          // Get the next work item
	          var workItem = self.queue.shift();
	
	          // If we are monitoring we need to use a connection that is not
	          // running another operation to avoid socket timeout changes
	          // affecting an existing operation
	          if (workItem.monitoring) {
	            var foundValidConnection = false;
	
	            for (var i = 0; i < self.availableConnections.length; i++) {
	              // If the connection is connected
	              // And there are no pending workItems on it
	              // Then we can safely use it for monitoring.
	              if(self.availableConnections[i].isConnected()
	                && self.availableConnections[i].workItems.length == 0) {
	                  foundValidConnection = true;
	                  connection = self.availableConnections[i];
	                  break;
	                }
	            }
	
	            // No safe connection found, attempt to grow the connections
	            // if possible and break from the loop
	            if(!foundValidConnection) {
	              // Put workItem back on the queue
	              self.queue.unshift(workItem);
	
	              // Attempt to grow the pool if it's not yet maxsize
	              if(totalConnections < self.options.size
	                && self.queue.length > 0) {
	                // Create a new connection
	                _createConnection(self);
	              }
	
	              // Re-execute the operation
	              setTimeout(function() {
	                _execute(self)();
	              }, 10);
	
	              break;
	            }
	          }
	
	          // Don't execute operation until we have a full pool
	          if(totalConnections < self.options.size) {
	            // Connection has work items, then put it back on the queue
	            // and create a new connection
	            if(connection.workItems.length > 0) {
	              // Lets put the workItem back on the list
	              self.queue.unshift(workItem);
	              // Create a new connection
	              _createConnection(self);
	              // Break from the loop
	              break;
	            }
	          }
	
	          // Get actual binary commands
	          var buffer = workItem.buffer;
	
	          // Set current status of authentication process
	          workItem.authenticating = self.authenticating;
	          workItem.authenticatingTimestamp = self.authenticatingTimestamp;
	
	          // If we are monitoring take the connection of the availableConnections
	          if (workItem.monitoring) {
	            moveConnectionBetween(connection, self.availableConnections, self.inUseConnections);
	          }
	
	          // Track the executing commands on the mongo server
	          // as long as there is an expected response
	          if (! workItem.noResponse) {
	            connection.workItems.push(workItem);
	          }
	
	          // We have a custom socketTimeout
	          if(!workItem.immediateRelease && typeof workItem.socketTimeout == 'number') {
	            connection.setSocketTimeout(workItem.socketTimeout);
	          }
	
	          // Capture if write was successful
	          var writeSuccessful = true;
	
	          // Put operation on the wire
	          if(Array.isArray(buffer)) {
	            for(var i = 0; i < buffer.length; i++) {
	              writeSuccessful = connection.write(buffer[i])
	            }
	          } else {
	            writeSuccessful = connection.write(buffer);
	          }
	
	          if(writeSuccessful && workItem.immediateRelease && self.authenticating) {
	            self.nonAuthenticatedConnections.push(connection);
	          } else if(writeSuccessful === false) {
	            // If write not successful put back on queue
	            self.queue.unshift(workItem);
	            // Remove the disconnected connection
	            removeConnection(self, connection);
	            // Flush any monitoring operations in the queue, failing fast
	            flushMonitoringOperations(self.queue);
	          }
	        } else {
	          // Remove the disconnected connection
	          removeConnection(self, connection);
	          // Flush any monitoring operations in the queue, failing fast
	          flushMonitoringOperations(self.queue);
	        }
	      }
	    });
	
	    self.executing = false;
	  }
	}
	
	// Make execution loop available for testing
	Pool._execute = _execute;
	
	/**
	 * A server connect event, used to verify that the connection is up and running
	 *
	 * @event Pool#connect
	 * @type {Pool}
	 */
	
	/**
	 * A server reconnect event, used to verify that pool reconnected.
	 *
	 * @event Pool#reconnect
	 * @type {Pool}
	 */
	
	/**
	 * The server connection closed, all pool connections closed
	 *
	 * @event Pool#close
	 * @type {Pool}
	 */
	
	/**
	 * The server connection caused an error, all pool connections closed
	 *
	 * @event Pool#error
	 * @type {Pool}
	 */
	
	/**
	 * The server connection timed out, all pool connections closed
	 *
	 * @event Pool#timeout
	 * @type {Pool}
	 */
	
	/**
	 * The driver experienced an invalid message, all pool connections closed
	 *
	 * @event Pool#parseError
	 * @type {Pool}
	 */
	
	/**
	 * The driver attempted to reconnect
	 *
	 * @event Pool#attemptReconnect
	 * @type {Pool}
	 */
	
	/**
	 * The driver exhausted all reconnect attempts
	 *
	 * @event Pool#reconnectFailed
	 * @type {Pool}
	 */
	
	module.exports = Pool;


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict"
	
	var inherits = __webpack_require__(1).inherits,
	  f = __webpack_require__(1).format,
	  EventEmitter = __webpack_require__(6).EventEmitter,
	  BasicCursor = __webpack_require__(57),
	  Logger = __webpack_require__(19),
	  retrieveBSON = __webpack_require__(11).retrieveBSON,
	  MongoError = __webpack_require__(7),
	  Server = __webpack_require__(76),
	  assign = __webpack_require__(58).assign,
	  clone = __webpack_require__(15).clone,
	  sdam = __webpack_require__(15),
	  diff = __webpack_require__(15).diff,
	  cloneOptions = __webpack_require__(15).cloneOptions,
	  createClientInfo = __webpack_require__(15).createClientInfo;
	
	var BSON = retrieveBSON();
	
	/**
	 * @fileOverview The **Mongos** class is a class that represents a Mongos Proxy topology and is
	 * used to construct connections.
	 *
	 * @example
	 * var Mongos = require('mongodb-core').Mongos
	 *   , ReadPreference = require('mongodb-core').ReadPreference
	 *   , assert = require('assert');
	 *
	 * var server = new Mongos([{host: 'localhost', port: 30000}]);
	 * // Wait for the connection event
	 * server.on('connect', function(server) {
	 *   server.destroy();
	 * });
	 *
	 * // Start connecting
	 * server.connect();
	 */
	
	var MongoCR = __webpack_require__(53)
	  , X509 = __webpack_require__(56)
	  , Plain = __webpack_require__(54)
	  , GSSAPI = __webpack_require__(52)
	  , SSPI = __webpack_require__(75)
	  , ScramSHA1 = __webpack_require__(55);
	
	//
	// States
	var DISCONNECTED = 'disconnected';
	var CONNECTING = 'connecting';
	var CONNECTED = 'connected';
	var UNREFERENCED = 'unreferenced';
	var DESTROYED = 'destroyed';
	
	function stateTransition(self, newState) {
	  var legalTransitions = {
	    'disconnected': [CONNECTING, DESTROYED, DISCONNECTED],
	    'connecting': [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],
	    'connected': [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],
	    'unreferenced': [UNREFERENCED, DESTROYED],
	    'destroyed': [DESTROYED]
	  }
	
	  // Get current state
	  var legalStates = legalTransitions[self.state];
	  if(legalStates && legalStates.indexOf(newState) != -1) {
	    self.state = newState;
	  } else {
	    self.logger.error(f('Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]'
	      , self.id, self.state, newState, legalStates));
	  }
	}
	
	//
	// ReplSet instance id
	var id = 1;
	var handlers = ['connect', 'close', 'error', 'timeout', 'parseError'];
	
	/**
	 * Creates a new Mongos instance
	 * @class
	 * @param {array} seedlist A list of seeds for the replicaset
	 * @param {number} [options.haInterval=5000] The High availability period for replicaset inquiry
	 * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors
	 * @param {number} [options.size=5] Server connection pool size
	 * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled
	 * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled
	 * @param {number} [options.localThresholdMS=15] Cutoff latency point in MS for MongoS proxy selection
	 * @param {boolean} [options.noDelay=true] TCP Connection no delay
	 * @param {number} [options.connectionTimeout=1000] TCP Connection timeout setting
	 * @param {number} [options.socketTimeout=0] TCP Socket timeout setting
	 * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed
	 * @param {boolean} [options.ssl=false] Use SSL for connection
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {Buffer} [options.ca] SSL Certificate store binary buffer
	 * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer
	 * @param {Buffer} [options.cert] SSL Certificate binary buffer
	 * @param {Buffer} [options.key] SSL Key file binary buffer
	 * @param {string} [options.passphrase] SSL Certificate pass phrase
	 * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.
	 * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates
	 * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
	 * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
	 * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
	 * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
	 * @return {Mongos} A cursor instance
	 * @fires Mongos#connect
	 * @fires Mongos#reconnect
	 * @fires Mongos#joined
	 * @fires Mongos#left
	 * @fires Mongos#failed
	 * @fires Mongos#fullsetup
	 * @fires Mongos#all
	 * @fires Mongos#serverHeartbeatStarted
	 * @fires Mongos#serverHeartbeatSucceeded
	 * @fires Mongos#serverHeartbeatFailed
	 * @fires Mongos#topologyOpening
	 * @fires Mongos#topologyClosed
	 * @fires Mongos#topologyDescriptionChanged
	 * @property {string} type the topology type.
	 * @property {string} parserType the parser type used (c++ or js).
	 */
	var Mongos = function(seedlist, options) {
	  options = options || {};
	
	  // Get replSet Id
	  this.id = id++;
	
	  // Internal state
	  this.s = {
	    options: assign({}, options),
	    // BSON instance
	    bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128,
	      BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey,
	      BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),
	    // Factory overrides
	    Cursor: options.cursorFactory || BasicCursor,
	    // Logger instance
	    logger: Logger('Mongos', options),
	    // Seedlist
	    seedlist: seedlist,
	    // Ha interval
	    haInterval: options.haInterval ? options.haInterval : 10000,
	    // Disconnect handler
	    disconnectHandler: options.disconnectHandler,
	    // Server selection index
	    index: 0,
	    // Connect function options passed in
	    connectOptions: {},
	    // Are we running in debug mode
	    debug: typeof options.debug == 'boolean' ? options.debug : false,
	    // localThresholdMS
	    localThresholdMS: options.localThresholdMS || 15,
	    // Client info
	    clientInfo: createClientInfo(options),
	    // Authentication context
	    authenticationContexts: [],
	  }
	
	  // Set the client info
	  this.s.options.clientInfo = createClientInfo(options);
	
	  // Log info warning if the socketTimeout < haInterval as it will cause
	  // a lot of recycled connections to happen.
	  if(this.s.logger.isWarn()
	    && this.s.options.socketTimeout != 0
	    && this.s.options.socketTimeout < this.s.haInterval) {
	      this.s.logger.warn(f('warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts'
	        , this.s.options.socketTimeout, this.s.haInterval));
	  }
	
	  // All the authProviders
	  this.authProviders = options.authProviders || {
	      'mongocr': new MongoCR(this.s.bson), 'x509': new X509(this.s.bson)
	    , 'plain': new Plain(this.s.bson), 'gssapi': new GSSAPI(this.s.bson)
	    , 'sspi': new SSPI(this.s.bson), 'scram-sha-1': new ScramSHA1(this.s.bson)
	  }
	
	  // Disconnected state
	  this.state = DISCONNECTED;
	
	  // Current proxies we are connecting to
	  this.connectingProxies = [];
	  // Currently connected proxies
	  this.connectedProxies = [];
	  // Disconnected proxies
	  this.disconnectedProxies = [];
	  // Are we authenticating
	  this.authenticating = false;
	  // Index of proxy to run operations against
	  this.index = 0;
	  // High availability timeout id
	  this.haTimeoutId = null;
	  // Last ismaster
	  this.ismaster = null;
	
	  // Description of the Replicaset
	  this.topologyDescription = {
	    "topologyType": "Unknown", "servers": []
	  };
	
	  // Add event listener
	  EventEmitter.call(this);
	}
	
	inherits(Mongos, EventEmitter);
	
	Object.defineProperty(Mongos.prototype, 'type', {
	  enumerable:true, get: function() { return 'mongos'; }
	});
	
	Object.defineProperty(Mongos.prototype, 'parserType', {
	  enumerable:true, get: function() {
	    return BSON.native ? "c++" : "js";
	  }
	});
	
	/**
	 * Emit event if it exists
	 * @method
	 */
	function emitSDAMEvent(self, event, description) {
	  if(self.listeners(event).length > 0) {
	    self.emit(event, description);
	  }
	}
	
	/**
	 * Initiate server connect
	 * @method
	 * @param {array} [options.auth=null] Array of auth options to apply on connect
	 */
	Mongos.prototype.connect = function(options) {
	  var self = this;
	  // Add any connect level options to the internal state
	  this.s.connectOptions = options || {};
	  // Set connecting state
	  stateTransition(this, CONNECTING);
	  // Create server instances
	  var servers = this.s.seedlist.map(function(x) {
	    return new Server(assign({}, self.s.options, x, {
	      authProviders: self.authProviders, reconnect:false, monitoring:false, inTopology: true
	    }, {
	      clientInfo: clone(self.s.clientInfo)
	    }));
	  });
	
	  servers.forEach(function(server) {
	    server.on('serverDescriptionChanged', function(event) { self.emit('serverDescriptionChanged', event); });
	  });
	
	  // Emit the topology opening event
	  emitSDAMEvent(this, 'topologyOpening', { topologyId: this.id });
	
	  // Start all server connections
	  connectProxies(self, servers);
	}
	
	function handleEvent(self) {
	  return function() {
	    if(self.state == DESTROYED) return;
	    // Move to list of disconnectedProxies
	    moveServerFrom(self.connectedProxies, self.disconnectedProxies, this);
	    // Emit the initial topology
	    emitTopologyDescriptionChanged(self);
	    // Emit the left signal
	    self.emit('left', 'mongos', this);
	    // Emit the sdam event
	    self.emit('serverClosed', {
	      topologyId: self.id,
	      address: this.name
	    });
	  }
	}
	
	function handleInitialConnectEvent(self, event) {
	  return function() {
	    var _this = this;
	
	    // Destroy the instance
	    if(self.state == DESTROYED) {
	      // Emit the initial topology
	      emitTopologyDescriptionChanged(self);
	      // Move from connectingProxies
	      moveServerFrom(self.connectingProxies, self.disconnectedProxies, this);
	      return this.destroy();
	    }
	
	    // Check the type of server
	    if(event == 'connect') {
	      // Do we have authentication contexts that need to be applied
	      applyAuthenticationContexts(self, _this, function() {
	        // Get last known ismaster
	        self.ismaster = _this.lastIsMaster();
	
	        // Is this not a proxy, remove t
	        if(self.ismaster.msg == 'isdbgrid') {
	          // Add to the connectd list
	          for(var i = 0; i < self.connectedProxies.length; i++) {
	            if(self.connectedProxies[i].name == _this.name) {
	              // Move from connectingProxies
	              moveServerFrom(self.connectingProxies, self.disconnectedProxies, _this);
	              // Emit the initial topology
	              emitTopologyDescriptionChanged(self);
	              _this.destroy();
	              return self.emit('failed', _this);
	            }
	          }
	
	          // Remove the handlers
	          for(i = 0; i < handlers.length; i++) {
	            _this.removeAllListeners(handlers[i]);
	          }
	
	          // Add stable state handlers
	          _this.on('error', handleEvent(self, 'error'));
	          _this.on('close', handleEvent(self, 'close'));
	          _this.on('timeout', handleEvent(self, 'timeout'));
	          _this.on('parseError', handleEvent(self, 'parseError'));
	
	          // Move from connecting proxies connected
	          moveServerFrom(self.connectingProxies, self.connectedProxies, _this);
	          // Emit the joined event
	          self.emit('joined', 'mongos', _this);
	        } else {
	
	          // Print warning if we did not find a mongos proxy
	          if(self.s.logger.isWarn()) {
	            var message = 'expected mongos proxy, but found replicaset member mongod for server %s';
	            // We have a standalone server
	            if(!self.ismaster.hosts) {
	              message = 'expected mongos proxy, but found standalone mongod for server %s';
	            }
	
	            self.s.logger.warn(f(message, _this.name));
	          }
	
	          // This is not a mongos proxy, remove it completely
	          removeProxyFrom(self.connectingProxies, _this);
	          // Emit the left event
	          self.emit('left', 'server', _this);
	          // Emit failed event
	          self.emit('failed', _this);
	        }
	      });
	    } else {
	      moveServerFrom(self.connectingProxies, self.disconnectedProxies, this);
	      // Emit the left event
	      self.emit('left', 'mongos', this);
	      // Emit failed event
	      self.emit('failed', this);
	    }
	
	    // Emit the initial topology
	    emitTopologyDescriptionChanged(self);
	
	    // Trigger topologyMonitor
	    if(self.connectingProxies.length == 0) {
	      // Emit connected if we are connected
	      if(self.connectedProxies.length > 0) {
	        // Set the state to connected
	        stateTransition(self, CONNECTED);
	        // Emit the connect event
	        self.emit('connect', self);
	        self.emit('fullsetup', self);
	        self.emit('all', self);
	      } else if(self.disconnectedProxies.length == 0) {
	        // Print warning if we did not find a mongos proxy
	        if(self.s.logger.isWarn()) {
	          self.s.logger.warn(f('no mongos proxies found in seed list, did you mean to connect to a replicaset'));
	        }
	
	        // Emit the error that no proxies were found
	        return self.emit('error', new MongoError('no mongos proxies found in seed list'));
	      }
	
	      // Topology monitor
	      topologyMonitor(self, {firstConnect:true});
	    }
	  };
	}
	
	function connectProxies(self, servers) {
	  // Update connectingProxies
	  self.connectingProxies = self.connectingProxies.concat(servers);
	
	  // Index used to interleaf the server connects, avoiding
	  // runtime issues on io constrained vm's
	  var timeoutInterval = 0;
	
	  function connect(server, timeoutInterval) {
	    setTimeout(function() {
	      // Emit opening server event
	      self.emit('serverOpening', {
	        topologyId: self.id,
	        address: server.name
	      });
	
	      // Emit the initial topology
	      emitTopologyDescriptionChanged(self);
	
	      // Add event handlers
	      server.once('close', handleInitialConnectEvent(self, 'close'));
	      server.once('timeout', handleInitialConnectEvent(self, 'timeout'));
	      server.once('parseError', handleInitialConnectEvent(self, 'parseError'));
	      server.once('error', handleInitialConnectEvent(self, 'error'));
	      server.once('connect', handleInitialConnectEvent(self, 'connect'));
	      // Start connection
	      server.connect(self.s.connectOptions);
	    }, timeoutInterval);
	  }
	  // Start all the servers
	  while(servers.length > 0) {
	    connect(servers.shift(), timeoutInterval++);
	  }
	}
	
	function pickProxy(self) {
	  // Get the currently connected Proxies
	  var connectedProxies = self.connectedProxies.slice(0);
	
	  // Set lower bound
	  var lowerBoundLatency = Number.MAX_VALUE;
	
	  // Determine the lower bound for the Proxies
	  for(var i = 0; i < connectedProxies.length; i++) {
	    if(connectedProxies[i].lastIsMasterMS < lowerBoundLatency) {
	      lowerBoundLatency = connectedProxies[i].lastIsMasterMS;
	    }
	  }
	
	  // Filter out the possible servers
	  connectedProxies = connectedProxies.filter(function(server) {
	    if((server.lastIsMasterMS <= (lowerBoundLatency + self.s.localThresholdMS))
	      && server.isConnected()) {
	      return true;
	    }
	  });
	
	  // We have no connectedProxies pick first of the connected ones
	  if(connectedProxies.length == 0) {
	    return self.connectedProxies[0];
	  }
	
	  // Get proxy
	  var proxy = connectedProxies[self.index % connectedProxies.length];
	  // Update the index
	  self.index = (self.index + 1) % connectedProxies.length;
	  // Return the proxy
	  return proxy;
	}
	
	function moveServerFrom(from, to, proxy) {
	  for(var i = 0; i < from.length; i++) {
	    if(from[i].name == proxy.name) {
	      from.splice(i, 1);
	    }
	  }
	
	  for(i = 0; i < to.length; i++) {
	    if(to[i].name == proxy.name) {
	      to.splice(i, 1);
	    }
	  }
	
	  to.push(proxy);
	}
	
	function removeProxyFrom(from, proxy) {
	  for(var i = 0; i < from.length; i++) {
	    if(from[i].name == proxy.name) {
	      from.splice(i, 1);
	    }
	  }
	}
	
	function reconnectProxies(self, proxies, callback) {
	  // Count lefts
	  var count = proxies.length;
	
	  // Handle events
	  var _handleEvent = function(self, event) {
	    return function() {
	      var _self = this;
	      count = count - 1;
	
	      // Destroyed
	      if(self.state == DESTROYED || self.state == UNREFERENCED) {
	        moveServerFrom(self.connectingProxies, self.disconnectedProxies, _self);
	        // Return destroy
	        return this.destroy();
	      }
	
	      if(event == 'connect' && !self.authenticating) {
	        // Do we have authentication contexts that need to be applied
	        applyAuthenticationContexts(self, _self, function() {
	          // Destroyed
	          if(self.state == DESTROYED || self.state == UNREFERENCED) {
	            moveServerFrom(self.connectingProxies, self.disconnectedProxies, _self);
	            return _self.destroy();
	          }
	
	          // Remove the handlers
	          for(var i = 0; i < handlers.length; i++) {
	            _self.removeAllListeners(handlers[i]);
	          }
	
	          // Add stable state handlers
	          _self.on('error', handleEvent(self, 'error'));
	          _self.on('close', handleEvent(self, 'close'));
	          _self.on('timeout', handleEvent(self, 'timeout'));
	          _self.on('parseError', handleEvent(self, 'parseError'));
	
	          // Move to the connected servers
	          moveServerFrom(self.disconnectedProxies, self.connectedProxies, _self);
	          // Emit topology Change
	          emitTopologyDescriptionChanged(self);
	          // Emit joined event
	          self.emit('joined', 'mongos', _self);
	        });
	      } else if(event == 'connect' && self.authenticating) {
	        // Move from connectingProxies
	        moveServerFrom(self.connectingProxies, self.disconnectedProxies, _self);
	        this.destroy();
	      }
	
	      // Are we done finish up callback
	      if(count == 0) {
	        callback();
	      }
	    }
	  }
	
	  // No new servers
	  if(count == 0) {
	    return callback();
	  }
	
	  // Execute method
	  function execute(_server, i) {
	    setTimeout(function() {
	      // Destroyed
	      if(self.state == DESTROYED || self.state == UNREFERENCED) {
	        return;
	      }
	
	      // Create a new server instance
	      var server = new Server(assign({}, self.s.options, {
	        host: _server.name.split(':')[0],
	        port: parseInt(_server.name.split(':')[1], 10)
	      }, {
	        authProviders: self.authProviders, reconnect:false, monitoring: false, inTopology: true
	      }, {
	        clientInfo: clone(self.s.clientInfo)
	      }));
	
	      // Relay the server description change
	      server.on('serverDescriptionChanged', function(event) { self.emit('serverDescriptionChanged', event); });
	
	      // Emit opening server event
	      self.emit('serverOpening', {
	        topologyId: server.s.topologyId != -1 ? server.s.topologyId : self.id,
	        address: server.name
	      });
	
	      // Add temp handlers
	      server.once('connect', _handleEvent(self, 'connect'));
	      server.once('close', _handleEvent(self, 'close'));
	      server.once('timeout', _handleEvent(self, 'timeout'));
	      server.once('error', _handleEvent(self, 'error'));
	      server.once('parseError', _handleEvent(self, 'parseError'));
	
	      // Connect to proxy
	      server.connect(self.s.connectOptions);
	    }, i);
	  }
	
	  // Create new instances
	  for(var i = 0; i < proxies.length; i++) {
	    execute(proxies[i], i);
	  }
	}
	
	function applyAuthenticationContexts(self, server, callback) {
	  if(self.s.authenticationContexts.length == 0) {
	    return callback();
	  }
	
	  // Copy contexts to ensure no modificiation in the middle of
	  // auth process.
	  var authContexts = self.s.authenticationContexts.slice(0);
	
	  // Apply one of the contexts
	  function applyAuth(authContexts, server, callback) {
	    if(authContexts.length == 0) return callback();
	    // Get the first auth context
	    var authContext = authContexts.shift();
	    // Copy the params
	    var customAuthContext = authContext.slice(0);
	    // Push our callback handler
	    customAuthContext.push(function(err) {
	      applyAuth(authContexts, server, callback);
	    });
	
	    // Attempt authentication
	    server.auth.apply(server, customAuthContext)
	  }
	
	  // Apply all auth contexts
	  applyAuth(authContexts, server, callback);
	}
	
	function topologyMonitor(self, options) {
	  options = options || {};
	
	  // Set momitoring timeout
	  self.haTimeoutId = setTimeout(function() {
	    if(self.state == DESTROYED || self.state == UNREFERENCED) return;
	    // If we have a primary and a disconnect handler, execute
	    // buffered operations
	    if(self.isConnected() && self.s.disconnectHandler) {
	      self.s.disconnectHandler.execute();
	    }
	
	    // Get the connectingServers
	    var proxies = self.connectedProxies.slice(0);
	    // Get the count
	    var count = proxies.length;
	
	    // If the count is zero schedule a new fast
	    function pingServer(_self, _server, cb) {
	      // Measure running time
	      var start = new Date().getTime();
	
	      // Emit the server heartbeat start
	      emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: _server.name });
	
	      // Execute ismaster
	      _server.command('admin.$cmd', {
	        ismaster:true
	      }, {
	        monitoring: true,
	        socketTimeout: self.s.options.connectionTimeout || 2000,
	      }, function(err, r) {
	        if(self.state == DESTROYED || self.state == UNREFERENCED) {
	          // Move from connectingProxies
	          moveServerFrom(self.connectedProxies, self.disconnectedProxies, _server);
	          _server.destroy();
	          return cb(err, r);
	        }
	
	        // Calculate latency
	        var latencyMS = new Date().getTime() - start;
	
	        // We had an error, remove it from the state
	        if(err) {
	          // Emit the server heartbeat failure
	          emitSDAMEvent(self, 'serverHeartbeatFailed', { durationMS: latencyMS, failure: err, connectionId: _server.name });
	          // Move from connected proxies to disconnected proxies
	          moveServerFrom(self.connectedProxies, self.disconnectedProxies, _server);
	        } else {
	          // Update the server ismaster
	          _server.ismaster = r.result;
	          _server.lastIsMasterMS = latencyMS;
	
	          // Server heart beat event
	          emitSDAMEvent(self, 'serverHeartbeatSucceeded', { durationMS: latencyMS, reply: r.result, connectionId: _server.name });
	        }
	
	        cb(err, r);
	      });
	    }
	
	    // No proxies initiate monitor again
	    if(proxies.length == 0) {
	      // Emit close event if any listeners registered
	      if(self.listeners("close").length > 0 && self.state == CONNECTING) {
	        self.emit('error', new MongoError('no mongos proxy available'));
	      } else {
	        self.emit('close', self);
	      }
	
	      // Attempt to connect to any unknown servers
	      return reconnectProxies(self, self.disconnectedProxies, function() {
	        if(self.state == DESTROYED || self.state == UNREFERENCED) return;
	
	        // Are we connected ? emit connect event
	        if(self.state == CONNECTING && options.firstConnect) {
	          self.emit('connect', self);
	          self.emit('fullsetup', self);
	          self.emit('all', self);
	        } else if(self.isConnected()) {
	          self.emit('reconnect', self);
	        } else if(!self.isConnected() && self.listeners("close").length > 0) {
	          self.emit('close', self);
	        }
	
	        // Perform topology monitor
	        topologyMonitor(self);
	      });
	    }
	
	    // Ping all servers
	    for(var i = 0; i < proxies.length; i++) {
	      pingServer(self, proxies[i], function() {
	        count = count - 1;
	
	        if(count == 0) {
	          if(self.state == DESTROYED || self.state == UNREFERENCED) return;
	
	          // Attempt to connect to any unknown servers
	          reconnectProxies(self, self.disconnectedProxies, function() {
	            if(self.state == DESTROYED || self.state == UNREFERENCED) return;
	            // Perform topology monitor
	            topologyMonitor(self);
	          });
	        }
	      });
	    }
	  }, self.s.haInterval);
	}
	
	/**
	 * Returns the last known ismaster document for this server
	 * @method
	 * @return {object}
	 */
	Mongos.prototype.lastIsMaster = function() {
	  return this.ismaster;
	}
	
	/**
	 * Unref all connections belong to this server
	 * @method
	 */
	Mongos.prototype.unref = function() {
	  // Transition state
	  stateTransition(this, UNREFERENCED);
	  // Get all proxies
	  var proxies = this.connectedProxies.concat(this.connectingProxies);
	  proxies.forEach(function(x) {
	    x.unref();
	  });
	
	  clearTimeout(this.haTimeoutId);
	}
	
	/**
	 * Destroy the server connection
	 * @param {boolean} [options.force=false] Force destroy the pool
	 * @method
	 */
	Mongos.prototype.destroy = function(options) {
	  var self = this;
	  // Transition state
	  stateTransition(this, DESTROYED);
	  // Get all proxies
	  var proxies = this.connectedProxies.concat(this.connectingProxies);
	  // Clear out any monitoring process
	  if(this.haTimeoutId) clearTimeout(this.haTimeoutId);
	  // Clear out authentication contexts
	  this.s.authenticationContexts = [];
	
	  // Destroy all connecting servers
	  proxies.forEach(function(x) {
	    // Emit the sdam event
	    self.emit('serverClosed', {
	      topologyId: self.id,
	      address: x.name
	    });
	
	    // Destroy the server
	    x.destroy(options);
	    // Move to list of disconnectedProxies
	    moveServerFrom(self.connectedProxies, self.disconnectedProxies, x);
	  });
	
	  // Emit the final topology change
	  emitTopologyDescriptionChanged(self);
	  // Emit toplogy closing event
	  emitSDAMEvent(this, 'topologyClosed', { topologyId: this.id });
	}
	
	/**
	 * Figure out if the server is connected
	 * @method
	 * @return {boolean}
	 */
	Mongos.prototype.isConnected = function() {
	  return this.connectedProxies.length > 0;
	}
	
	/**
	 * Figure out if the server instance was destroyed by calling destroy
	 * @method
	 * @return {boolean}
	 */
	Mongos.prototype.isDestroyed = function() {
	  return this.state == DESTROYED;
	}
	
	//
	// Operations
	//
	
	// Execute write operation
	var executeWriteOperation = function(self, op, ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {}, options = options || {};
	  // Ensure we have no options
	  options = options || {};
	  // Pick a server
	  var server = pickProxy(self);
	  // No server found error out
	  if(!server) return callback(new MongoError('no mongos proxy available'));
	  // Execute the command
	  server[op](ns, ops, options, callback);
	}
	
	/**
	 * Insert one or more documents
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of documents to insert
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Mongos.prototype.insert = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {}, options = options || {};
	  if(this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	
	  // Not connected but we have a disconnecthandler
	  if(!this.isConnected() && this.s.disconnectHandler != null) {
	    return this.s.disconnectHandler.add('insert', ns, ops, options, callback);
	  }
	
	  // No mongos proxy available
	  if(!this.isConnected()) {
	    return callback(new MongoError('no mongos proxy available'));
	  }
	
	  // Execute write operation
	  executeWriteOperation(this, 'insert', ns, ops, options, callback);
	}
	
	/**
	 * Perform one or more update operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of updates
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Mongos.prototype.update = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {}, options = options || {};
	  if(this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	
	  // Not connected but we have a disconnecthandler
	  if(!this.isConnected() && this.s.disconnectHandler != null) {
	    return this.s.disconnectHandler.add('update', ns, ops, options, callback);
	  }
	
	  // No mongos proxy available
	  if(!this.isConnected()) {
	    return callback(new MongoError('no mongos proxy available'));
	  }
	
	  // Execute write operation
	  executeWriteOperation(this, 'update', ns, ops, options, callback);
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of removes
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Mongos.prototype.remove = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {}, options = options || {};
	  if(this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	
	  // Not connected but we have a disconnecthandler
	  if(!this.isConnected() && this.s.disconnectHandler != null) {
	    return this.s.disconnectHandler.add('remove', ns, ops, options, callback);
	  }
	
	  // No mongos proxy available
	  if(!this.isConnected()) {
	    return callback(new MongoError('no mongos proxy available'));
	  }
	
	  // Execute write operation
	  executeWriteOperation(this, 'remove', ns, ops, options, callback);
	}
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {object} cmd The command hash
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {Connection} [options.connection] Specify connection object to execute command against
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Mongos.prototype.command = function(ns, cmd, options, callback) {
	  if(typeof options == 'function') callback = options, options = {}, options = options || {};
	  if(this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  var self = this;
	
	  // Pick a proxy
	  var server = pickProxy(self);
	
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if((server == null || !server.isConnected()) && this.s.disconnectHandler != null) {
	    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);
	  }
	
	  // No server returned we had an error
	  if(server == null) {
	    return callback(new MongoError('no mongos proxy available'));
	  }
	
	  // Cloned options
	  var clonedOptions = cloneOptions(options);
	  clonedOptions.topology = self;
	
	  // Execute the command
	  server.command(ns, cmd, clonedOptions, callback);
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {{object}|{Long}} cmd Can be either a command returning a cursor or a cursorId
	 * @param {object} [options.batchSize=0] Batchsize for the operation
	 * @param {array} [options.documents=[]] Initial documents list for cursor
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	Mongos.prototype.cursor = function(ns, cmd, cursorOptions) {
	  cursorOptions = cursorOptions || {};
	  var FinalCursor = cursorOptions.cursorFactory || this.s.Cursor;
	  return new FinalCursor(this.s.bson, ns, cmd, cursorOptions, this, this.s.options);
	}
	
	/**
	 * Authenticate using a specified mechanism
	 * @method
	 * @param {string} mechanism The Auth mechanism we are invoking
	 * @param {string} db The db we are invoking the mechanism against
	 * @param {...object} param Parameters for the specific mechanism
	 * @param {authResultCallback} callback A callback function
	 */
	Mongos.prototype.auth = function(mechanism, db) {
	  var allArgs = Array.prototype.slice.call(arguments, 0).slice(0);
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  var callback = args.pop();
	  var currentContextIndex = 0;
	
	  // If we don't have the mechanism fail
	  if(this.authProviders[mechanism] == null && mechanism != 'default') {
	    return callback(new MongoError(f("auth provider %s does not exist", mechanism)));
	  }
	
	  // Are we already authenticating, throw
	  if(this.authenticating) {
	    return callback(new MongoError('authentication or logout allready in process'));
	  }
	
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(!self.isConnected() && self.s.disconnectHandler != null) {
	    return self.s.disconnectHandler.add('auth', db, allArgs, {}, callback);
	  }
	
	  // Set to authenticating
	  this.authenticating = true;
	  // All errors
	  var errors = [];
	
	  // Get all the servers
	  var servers = this.connectedProxies.slice(0);
	  // No servers return
	  if(servers.length == 0) {
	    this.authenticating = false;
	    callback(null, true);
	  }
	
	  // Authenticate
	  function auth(server) {
	    // Arguments without a callback
	    var argsWithoutCallback = [mechanism, db].concat(args.slice(0));
	    // Create arguments
	    var finalArguments = argsWithoutCallback.concat([function(err) {
	      count = count - 1;
	      // Save all the errors
	      if(err) errors.push({name: server.name, err: err});
	      // We are done
	      if(count == 0) {
	        // Auth is done
	        self.authenticating = false;
	
	        // Return the auth error
	        if(errors.length) {
	          // Remove the entry from the stored authentication contexts
	          self.s.authenticationContexts.splice(currentContextIndex, 0);
	          // Return error
	          return callback(MongoError.create({
	            message: 'authentication fail', errors: errors
	          }), false);
	        }
	
	        // Successfully authenticated session
	        callback(null, self);
	      }
	    }]);
	
	    // Execute the auth only against non arbiter servers
	    if(!server.lastIsMaster().arbiterOnly) {
	      server.auth.apply(server, finalArguments);
	    }
	  }
	
	  // Save current context index
	  currentContextIndex = this.s.authenticationContexts.length;
	  // Store the auth context and return the last index
	  this.s.authenticationContexts.push([mechanism, db].concat(args.slice(0)));
	
	  // Get total count
	  var count = servers.length;
	  // Authenticate against all servers
	  while(servers.length > 0) {
	    auth(servers.shift());
	  }
	}
	
	/**
	 * Logout from a database
	 * @method
	 * @param {string} db The db we are logging out from
	 * @param {authResultCallback} callback A callback function
	 */
	Mongos.prototype.logout = function(dbName, callback) {
	  var self = this;
	  // Are we authenticating or logging out, throw
	  if(this.authenticating) {
	    throw new MongoError('authentication or logout allready in process');
	  }
	
	  // Ensure no new members are processed while logging out
	  this.authenticating = true;
	
	  // Remove from all auth providers (avoid any reaplication of the auth details)
	  var providers = Object.keys(this.authProviders);
	  for(var i = 0; i < providers.length; i++) {
	    this.authProviders[providers[i]].logout(dbName);
	  }
	
	  // Now logout all the servers
	  var servers = this.connectedProxies.slice(0);
	  var count = servers.length;
	  if(count == 0) return callback();
	  var errors = [];
	
	  function logoutServer(_server, cb) {
	    _server.logout(dbName, function(err) {
	      if(err) errors.push({name: _server.name, err: err});
	      cb();
	    });
	  }
	
	  // Execute logout on all server instances
	  for(i = 0; i < servers.length; i++) {
	    logoutServer(servers[i], function() {
	      count = count - 1;
	
	      if(count == 0) {
	        // Do not block new operations
	        self.authenticating = false;
	        // If we have one or more errors
	        if(errors.length) return callback(MongoError.create({
	          message: f('logout failed against db %s', dbName), errors: errors
	        }), false);
	
	        // No errors
	        callback();
	      }
	    })
	  }
	}
	
	/**
	 * Get server
	 * @method
	 * @return {Server}
	 */
	Mongos.prototype.getServer = function() {
	  var server = pickProxy(this);
	  if(this.s.debug) this.emit('pickedServer', null, server);
	  return server;
	}
	
	/**
	 * Get a direct connection
	 * @method
	 * @return {Connection}
	 */
	Mongos.prototype.getConnection = function() {
	  var server = this.getServer();
	  if(server) return server.getConnection();
	}
	
	/**
	 * All raw connections
	 * @method
	 * @return {Connection[]}
	 */
	Mongos.prototype.connections = function() {
	  var connections = [];
	
	  for(var i = 0; i < this.connectedProxies.length; i++) {
	    connections = connections.concat(this.connectedProxies[i].connections());
	  }
	
	  return connections;
	}
	
	function emitTopologyDescriptionChanged(self) {
	  if(self.listeners('topologyDescriptionChanged').length > 0) {
	    var topology = 'Unknown';
	    var setName = self.setName;
	
	    if(self.connectedProxies.length > 0) {
	      topology = 'Sharded';
	    }
	
	    // Generate description
	    var description = {
	      topologyType: topology,
	      servers: []
	    }
	
	    // All proxies
	    var proxies = self.disconnectedProxies
	      .concat(self.connectingProxies);
	
	    // Add all the disconnected proxies
	    description.servers = description.servers.concat(proxies.map(function(x) {
	      var description = x.getDescription();
	      description.type = 'Unknown';
	      return description;
	    }));
	
	    // Add all the connected proxies
	    description.servers = description.servers.concat(self.connectedProxies.map(function(x) {
	      var description = x.getDescription();
	      description.type = 'Mongos';
	      return description;
	    }));
	
	    // Get the diff
	    var diffResult = diff(self.topologyDescription, description);
	
	    // Create the result
	    var result = {
	      topologyId: self.id,
	      previousDescription: self.topologyDescription,
	      newDescription: description,
	      diff: diffResult
	    };
	
	    // Emit the topologyDescription change
	    if(diffResult.servers.length > 0) {
	      self.emit('topologyDescriptionChanged', result);
	    }
	
	    // Set the new description
	    self.topologyDescription = description;
	  }
	}
	
	/**
	 * A mongos connect event, used to verify that the connection is up and running
	 *
	 * @event Mongos#connect
	 * @type {Mongos}
	 */
	
	/**
	 * A mongos reconnect event, used to verify that the mongos topology has reconnected
	 *
	 * @event Mongos#reconnect
	 * @type {Mongos}
	 */
	
	/**
	 * A mongos fullsetup event, used to signal that all topology members have been contacted.
	 *
	 * @event Mongos#fullsetup
	 * @type {Mongos}
	 */
	
	/**
	 * A mongos all event, used to signal that all topology members have been contacted.
	 *
	 * @event Mongos#all
	 * @type {Mongos}
	 */
	
	/**
	 * A server member left the mongos list
	 *
	 * @event Mongos#left
	 * @type {Mongos}
	 * @param {string} type The type of member that left (mongos)
	 * @param {Server} server The server object that left
	 */
	
	/**
	 * A server member joined the mongos list
	 *
	 * @event Mongos#joined
	 * @type {Mongos}
	 * @param {string} type The type of member that left (mongos)
	 * @param {Server} server The server object that joined
	 */
	
	/**
	 * A server opening SDAM monitoring event
	 *
	 * @event Mongos#serverOpening
	 * @type {object}
	 */
	
	/**
	 * A server closed SDAM monitoring event
	 *
	 * @event Mongos#serverClosed
	 * @type {object}
	 */
	
	/**
	 * A server description SDAM change monitoring event
	 *
	 * @event Mongos#serverDescriptionChanged
	 * @type {object}
	 */
	
	/**
	 * A topology open SDAM event
	 *
	 * @event Mongos#topologyOpening
	 * @type {object}
	 */
	
	/**
	 * A topology closed SDAM event
	 *
	 * @event Mongos#topologyClosed
	 * @type {object}
	 */
	
	/**
	 * A topology structure SDAM change event
	 *
	 * @event Mongos#topologyDescriptionChanged
	 * @type {object}
	 */
	
	/**
	 * A topology serverHeartbeatStarted SDAM event
	 *
	 * @event Mongos#serverHeartbeatStarted
	 * @type {object}
	 */
	
	/**
	 * A topology serverHeartbeatFailed SDAM event
	 *
	 * @event Mongos#serverHeartbeatFailed
	 * @type {object}
	 */
	
	/**
	 * A topology serverHeartbeatSucceeded SDAM change event
	 *
	 * @event Mongos#serverHeartbeatSucceeded
	 * @type {object}
	 */
	
	module.exports = Mongos;


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict"
	
	var inherits = __webpack_require__(1).inherits,
	  f = __webpack_require__(1).format,
	  EventEmitter = __webpack_require__(6).EventEmitter,
	  ReadPreference = __webpack_require__(43),
	  BasicCursor = __webpack_require__(57),
	  retrieveBSON = __webpack_require__(11).retrieveBSON,
	  Logger = __webpack_require__(19),
	  MongoError = __webpack_require__(7),
	  Server = __webpack_require__(76),
	  ReplSetState = __webpack_require__(197),
	  assign = __webpack_require__(58).assign,
	  clone = __webpack_require__(15).clone,
	  Timeout = __webpack_require__(15).Timeout,
	  Interval = __webpack_require__(15).Interval,
	  createClientInfo = __webpack_require__(15).createClientInfo;
	
	var MongoCR = __webpack_require__(53)
	  , X509 = __webpack_require__(56)
	  , Plain = __webpack_require__(54)
	  , GSSAPI = __webpack_require__(52)
	  , SSPI = __webpack_require__(75)
	  , ScramSHA1 = __webpack_require__(55);
	
	var BSON = retrieveBSON();
	
	//
	// States
	var DISCONNECTED = 'disconnected';
	var CONNECTING = 'connecting';
	var CONNECTED = 'connected';
	var UNREFERENCED = 'unreferenced';
	var DESTROYED = 'destroyed';
	
	function stateTransition(self, newState) {
	  var legalTransitions = {
	    'disconnected': [CONNECTING, DESTROYED, DISCONNECTED],
	    'connecting': [CONNECTING, DESTROYED, CONNECTED, DISCONNECTED],
	    'connected': [CONNECTED, DISCONNECTED, DESTROYED, UNREFERENCED],
	    'unreferenced': [UNREFERENCED, DESTROYED],
	    'destroyed': [DESTROYED]
	  }
	
	  // Get current state
	  var legalStates = legalTransitions[self.state];
	  if(legalStates && legalStates.indexOf(newState) != -1) {
	    self.state = newState;
	  } else {
	    self.s.logger.error(f('Pool with id [%s] failed attempted illegal state transition from [%s] to [%s] only following state allowed [%s]'
	      , self.id, self.state, newState, legalStates));
	  }
	}
	
	//
	// ReplSet instance id
	var id = 1;
	var handlers = ['connect', 'close', 'error', 'timeout', 'parseError'];
	
	/**
	 * Creates a new Replset instance
	 * @class
	 * @param {array} seedlist A list of seeds for the replicaset
	 * @param {boolean} options.setName The Replicaset set name
	 * @param {boolean} [options.secondaryOnlyConnectionAllowed=false] Allow connection to a secondary only replicaset
	 * @param {number} [options.haInterval=10000] The High availability period for replicaset inquiry
	 * @param {boolean} [options.emitError=false] Server will emit errors events
	 * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors
	 * @param {number} [options.size=5] Server connection pool size
	 * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled
	 * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled
	 * @param {boolean} [options.noDelay=true] TCP Connection no delay
	 * @param {number} [options.connectionTimeout=10000] TCP Connection timeout setting
	 * @param {number} [options.socketTimeout=0] TCP Socket timeout setting
	 * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed
	 * @param {boolean} [options.ssl=false] Use SSL for connection
	 * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.
	 * @param {Buffer} [options.ca] SSL Certificate store binary buffer
	 * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer
	 * @param {Buffer} [options.cert] SSL Certificate binary buffer
	 * @param {Buffer} [options.key] SSL Key file binary buffer
	 * @param {string} [options.passphrase] SSL Certificate pass phrase
	 * @param {string} [options.servername=null] String containing the server name requested via TLS SNI.
	 * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates
	 * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits
	 * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.
	 * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.
	 * @param {number} [options.pingInterval=5000] Ping interval to check the response time to the different servers
	 * @param {number} [options.localThresholdMS=15] Cutoff latency point in MS for Replicaset member selection
	 * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.
	 * @return {ReplSet} A cursor instance
	 * @fires ReplSet#connect
	 * @fires ReplSet#ha
	 * @fires ReplSet#joined
	 * @fires ReplSet#left
	 * @fires ReplSet#failed
	 * @fires ReplSet#fullsetup
	 * @fires ReplSet#all
	 * @fires ReplSet#error
	 * @fires ReplSet#serverHeartbeatStarted
	 * @fires ReplSet#serverHeartbeatSucceeded
	 * @fires ReplSet#serverHeartbeatFailed
	 * @fires ReplSet#topologyOpening
	 * @fires ReplSet#topologyClosed
	 * @fires ReplSet#topologyDescriptionChanged
	 * @property {string} type the topology type.
	 * @property {string} parserType the parser type used (c++ or js).
	 */
	var ReplSet = function(seedlist, options) {
	  var self = this;
	  options = options || {};
	
	  // Validate seedlist
	  if(!Array.isArray(seedlist)) throw new MongoError("seedlist must be an array");
	  // Validate list
	  if(seedlist.length == 0) throw new MongoError("seedlist must contain at least one entry");
	  // Validate entries
	  seedlist.forEach(function(e) {
	    if(typeof e.host != 'string' || typeof e.port != 'number')
	      throw new MongoError("seedlist entry must contain a host and port");
	  });
	
	  // Add event listener
	  EventEmitter.call(this);
	
	  // Get replSet Id
	  this.id = id++;
	
	  // Get the localThresholdMS
	  var localThresholdMS = options.localThresholdMS || 15;
	  // Backward compatibility
	  if(options.acceptableLatency) localThresholdMS = options.acceptableLatency;
	
	  // Create a logger
	  var logger = Logger('ReplSet', options);
	
	  // Internal state
	  this.s = {
	    options: assign({}, options),
	    // BSON instance
	    bson: options.bson || new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128,
	      BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey,
	      BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]),
	    // Factory overrides
	    Cursor: options.cursorFactory || BasicCursor,
	    // Logger instance
	    logger: logger,
	    // Seedlist
	    seedlist: seedlist,
	    // Replicaset state
	    replicaSetState: new ReplSetState({
	      id: this.id, setName: options.setName,
	      acceptableLatency: localThresholdMS,
	      heartbeatFrequencyMS: options.haInterval ? options.haInterval : 10000,
	      logger: logger
	    }),
	    // Current servers we are connecting to
	    connectingServers: [],
	    // Ha interval
	    haInterval: options.haInterval ? options.haInterval : 10000,
	    // Minimum heartbeat frequency used if we detect a server close
	    minHeartbeatFrequencyMS: 500,
	    // Disconnect handler
	    disconnectHandler: options.disconnectHandler,
	    // Server selection index
	    index: 0,
	    // Connect function options passed in
	    connectOptions: {},
	    // Are we running in debug mode
	    debug: typeof options.debug == 'boolean' ? options.debug : false,
	    // Client info
	    clientInfo: createClientInfo(options),
	    // Authentication context
	    authenticationContexts: [],
	  }
	
	  // Add handler for topology change
	  this.s.replicaSetState.on('topologyDescriptionChanged', function(r) { self.emit('topologyDescriptionChanged', r); });
	
	  // Log info warning if the socketTimeout < haInterval as it will cause
	  // a lot of recycled connections to happen.
	  if(this.s.logger.isWarn()
	    && this.s.options.socketTimeout != 0
	    && this.s.options.socketTimeout < this.s.haInterval) {
	      this.s.logger.warn(f('warning socketTimeout %s is less than haInterval %s. This might cause unnecessary server reconnections due to socket timeouts'
	        , this.s.options.socketTimeout, this.s.haInterval));
	  }
	
	  // All the authProviders
	  this.authProviders = options.authProviders || {
	      'mongocr': new MongoCR(this.s.bson), 'x509': new X509(this.s.bson)
	    , 'plain': new Plain(this.s.bson), 'gssapi': new GSSAPI(this.s.bson)
	    , 'sspi': new SSPI(this.s.bson), 'scram-sha-1': new ScramSHA1(this.s.bson)
	  }
	
	  // Add forwarding of events from state handler
	  var types = ['joined', 'left'];
	  types.forEach(function(x) {
	    self.s.replicaSetState.on(x, function(t, s) {
	      self.emit(x, t, s);
	    });
	  });
	
	  // Connect stat
	  this.initialConnectState = {
	    connect: false, fullsetup: false, all: false
	  }
	
	  // Disconnected state
	  this.state = DISCONNECTED;
	  this.haTimeoutId = null;
	  // Are we authenticating
	  this.authenticating = false;
	  // Last ismaster
	  this.ismaster = null;
	  // Contains the intervalId
	  this.intervalIds = [];
	}
	
	inherits(ReplSet, EventEmitter);
	
	Object.defineProperty(ReplSet.prototype, 'type', {
	  enumerable:true, get: function() { return 'replset'; }
	});
	
	Object.defineProperty(ReplSet.prototype, 'parserType', {
	  enumerable:true, get: function() {
	    return BSON.native ? "c++" : "js";
	  }
	});
	
	function rexecuteOperations(self) {
	  // If we have a primary and a disconnect handler, execute
	  // buffered operations
	  if(self.s.replicaSetState.hasPrimaryAndSecondary() && self.s.disconnectHandler) {
	    self.s.disconnectHandler.execute();
	  } else if(self.s.replicaSetState.hasPrimary() && self.s.disconnectHandler) {
	    self.s.disconnectHandler.execute({ executePrimary:true });
	  } else if(self.s.replicaSetState.hasSecondary() && self.s.disconnectHandler) {
	    self.s.disconnectHandler.execute({ executeSecondary:true });
	  }
	}
	
	function connectNewServers(self, servers, callback) {
	  // Count lefts
	  var count = servers.length;
	  var error = null;
	
	  // Handle events
	  var _handleEvent = function(self, event) {
	    return function(err) {
	      var _self = this;
	      count = count - 1;
	
	      // Destroyed
	      if(self.state == DESTROYED || self.state == UNREFERENCED) {
	        return this.destroy({force:true});
	      }
	
	      if(event == 'connect' && !self.authenticating) {
	        // Destroyed
	        if(self.state == DESTROYED || self.state == UNREFERENCED) {
	          return _self.destroy({force:true});
	        }
	
	        // Do we have authentication contexts that need to be applied
	        applyAuthenticationContexts(self, _self, function() {
	          // Destroy the instance
	          if(self.state == DESTROYED || self.state == UNREFERENCED) {
	            return _self.destroy({force:true});
	          }
	
	          // Update the state
	          var result = self.s.replicaSetState.update(_self);
	          // Update the state with the new server
	          if(result) {
	            // Primary lastIsMaster store it
	            if(_self.lastIsMaster() && _self.lastIsMaster().ismaster) {
	              self.ismaster = _self.lastIsMaster();
	            }
	
	            // Remove the handlers
	            for(var i = 0; i < handlers.length; i++) {
	              _self.removeAllListeners(handlers[i]);
	            }
	
	            // Add stable state handlers
	            _self.on('error', handleEvent(self, 'error'));
	            _self.on('close', handleEvent(self, 'close'));
	            _self.on('timeout', handleEvent(self, 'timeout'));
	            _self.on('parseError', handleEvent(self, 'parseError'));
	
	            // Enalbe the monitoring of the new server
	            monitorServer(_self.lastIsMaster().me, self, {});
	
	            // Rexecute any stalled operation
	            rexecuteOperations(self);
	          } else {
	            _self.destroy({force:true});
	          }
	        });
	      } else if(event == 'connect' && self.authenticating) {
	        this.destroy({force:true});
	      } else if(event == 'error') {
	        error = err;
	      }
	
	      // Rexecute any stalled operation
	      rexecuteOperations(self);
	
	      // Are we done finish up callback
	      if(count == 0) { callback(error); }
	    }
	  }
	
	  // No new servers
	  if(count == 0) return callback();
	
	  // Execute method
	  function execute(_server, i) {
	    setTimeout(function() {
	      // Destroyed
	      if(self.state == DESTROYED || self.state == UNREFERENCED) {
	        return;
	      }
	
	      // Create a new server instance
	      var server = new Server(assign({}, self.s.options, {
	        host: _server.split(':')[0],
	        port: parseInt(_server.split(':')[1], 10)
	      }, {
	        authProviders: self.authProviders, reconnect:false, monitoring: false, inTopology: true
	      }, {
	        clientInfo: clone(self.s.clientInfo)
	      }));
	
	      // Add temp handlers
	      server.once('connect', _handleEvent(self, 'connect'));
	      server.once('close', _handleEvent(self, 'close'));
	      server.once('timeout', _handleEvent(self, 'timeout'));
	      server.once('error', _handleEvent(self, 'error'));
	      server.once('parseError', _handleEvent(self, 'parseError'));
	
	      // SDAM Monitoring events
	      server.on('serverOpening', function(e) { self.emit('serverOpening', e); });
	      server.on('serverDescriptionChanged', function(e) { self.emit('serverDescriptionChanged', e); });
	      server.on('serverClosed', function(e) { self.emit('serverClosed', e); });
	      server.connect(self.s.connectOptions);
	    }, i);
	  }
	
	  // Create new instances
	  for(var i = 0; i < servers.length; i++) {
	    execute(servers[i], i);
	  }
	}
	
	// Ping the server
	var pingServer = function(self, server, cb) {
	  // Measure running time
	  var start = new Date().getTime();
	
	  // Emit the server heartbeat start
	  emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: server.name });
	
	  // Execute ismaster
	  // Set the socketTimeout for a monitoring message to a low number
	  // Ensuring ismaster calls are timed out quickly
	  server.command('admin.$cmd', {
	    ismaster:true
	  }, {
	    monitoring: true,
	    socketTimeout: self.s.options.connectionTimeout || 2000,
	  }, function(err, r) {
	    if(self.state == DESTROYED || self.state == UNREFERENCED) {
	      server.destroy({force:true});
	      return cb(err, r);
	    }
	
	    // Calculate latency
	    var latencyMS = new Date().getTime() - start;
	    // Set the last updatedTime
	    var hrTime = process.hrtime();
	    // Calculate the last update time
	    server.lastUpdateTime = hrTime[0] * 1000 + Math.round(hrTime[1]/1000);
	
	    // We had an error, remove it from the state
	    if(err) {
	      // Emit the server heartbeat failure
	      emitSDAMEvent(self, 'serverHeartbeatFailed', { durationMS: latencyMS, failure: err, connectionId: server.name });
	
	      // Remove server from the state
	      self.s.replicaSetState.remove(server);
	    } else {
	      // Update the server ismaster
	      server.ismaster = r.result;
	
	      // Check if we have a lastWriteDate convert it to MS
	      // and store on the server instance for later use
	      if(server.ismaster.lastWrite && server.ismaster.lastWrite.lastWriteDate) {
	        server.lastWriteDate = server.ismaster.lastWrite.lastWriteDate.getTime();
	      }
	
	      // Do we have a brand new server
	      if(server.lastIsMasterMS == -1) {
	        server.lastIsMasterMS = latencyMS;
	      } else if(server.lastIsMasterMS) {
	        // After the first measurement, average RTT MUST be computed using an
	        // exponentially-weighted moving average formula, with a weighting factor (alpha) of 0.2.
	        // If the prior average is denoted old_rtt, then the new average (new_rtt) is
	        // computed from a new RTT measurement (x) using the following formula:
	        // alpha = 0.2
	        // new_rtt = alpha * x + (1 - alpha) * old_rtt
	        server.lastIsMasterMS = 0.2 * latencyMS + (1 - 0.2) * server.lastIsMasterMS;
	      }
	
	      if(self.s.replicaSetState.update(server)) {
	        // Primary lastIsMaster store it
	        if(server.lastIsMaster() && server.lastIsMaster().ismaster) {
	          self.ismaster = server.lastIsMaster();
	        }
	      }
	
	      // Server heart beat event
	      emitSDAMEvent(self, 'serverHeartbeatSucceeded', { durationMS: latencyMS, reply: r.result, connectionId: server.name });
	    }
	
	    // Calculate the stalness for this server
	    self.s.replicaSetState.updateServerMaxStaleness(server, self.s.haInterval);
	
	    // Callback
	    cb(err, r);
	  });
	}
	
	// Each server is monitored in parallel in their own timeout loop
	var monitorServer = function(host, self, options) {
	  // If this is not the initial scan
	  // Is this server already being monitoried, then skip monitoring
	  if(!options.haInterval) {
	    for(var i = 0; i < self.intervalIds.length; i++) {
	      if(self.intervalIds[i].__host === host) {
	        return;
	      }
	    }
	  }
	
	  // Get the haInterval
	  var _process = options.haInterval ? Timeout : Interval;
	  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval;
	
	  // Create the interval
	  var intervalId = new _process(function() {
	    if(self.state == DESTROYED || self.state == UNREFERENCED) {
	      // clearInterval(intervalId);
	      intervalId.stop();
	      return;
	    }
	
	    // Do we already have server connection available for this host
	    var _server = self.s.replicaSetState.get(host);
	
	    // Check if we have a known server connection and reuse
	    if(_server) {
	      // Ping the server
	      return pingServer(self, _server, function(err) {
	        if(self.state == DESTROYED || self.state == UNREFERENCED) {
	          intervalId.stop();
	          return;
	        }
	
	        // Filter out all called intervaliIds
	        self.intervalIds = self.intervalIds.filter(function(intervalId) {
	          return intervalId.isRunning();
	        } );
	
	        // Initial sweep
	        if(_process === Timeout) {
	          if(self.state == CONNECTING && (
	            (
	              self.s.replicaSetState.hasSecondary()
	              && self.s.options.secondaryOnlyConnectionAllowed
	            )
	            || self.s.replicaSetState.hasPrimary()
	          )) {
	            self.state = CONNECTED;
	
	            // Emit connected sign
	            process.nextTick(function() {
	              self.emit('connect', self);
	            });
	
	            // Start topology interval check
	            topologyMonitor(self, {});
	          }
	        } else {
	          if(self.state == DISCONNECTED && (
	            (
	              self.s.replicaSetState.hasSecondary()
	              && self.s.options.secondaryOnlyConnectionAllowed
	            )
	            || self.s.replicaSetState.hasPrimary()
	          )) {
	            self.state = CONNECTED;
	
	            // Rexecute any stalled operation
	            rexecuteOperations(self);
	
	            // Emit connected sign
	            process.nextTick(function() {
	              self.emit('reconnect', self);
	            });
	          }
	        }
	
	        if(self.initialConnectState.connect
	          && !self.initialConnectState.fullsetup
	          && self.s.replicaSetState.hasPrimaryAndSecondary()) {
	            // Set initial connect state
	            self.initialConnectState.fullsetup = true;
	            self.initialConnectState.all = true;
	
	            process.nextTick(function() {
	              self.emit('fullsetup', self);
	              self.emit('all', self);
	            });
	        }
	      });
	    }
	  }, _haInterval);
	
	  // Start the interval
	  intervalId.start();
	  // Add the intervalId host name
	  intervalId.__host = host;
	  // Add the intervalId to our list of intervalIds
	  self.intervalIds.push(intervalId);
	}
	
	function topologyMonitor(self, options) {
	  if(self.state == DESTROYED || self.state == UNREFERENCED) return;
	  options = options || {};
	
	  // Get the servers
	  var servers = Object.keys(self.s.replicaSetState.set);
	
	  // Get the haInterval
	  var _process = options.haInterval ? Timeout : Interval;
	  var _haInterval = options.haInterval ? options.haInterval : self.s.haInterval;
	
	  if(_process === Timeout) {
	    return connectNewServers(self, self.s.replicaSetState.unknownServers, function(err) {
	      // Don't emit errors if the connection was already
	      if(self.state === DESTROYED || self.state === UNREFERENCED) {
	        return;
	      }
	
	      if(!self.s.replicaSetState.hasPrimary() && !self.s.options.secondaryOnlyConnectionAllowed) {
	        if(err) return self.emit('error', err);
	        self.emit('error', new MongoError('no primary found in replicaset'));
	        return self.destroy({force:true});
	      } else if(!self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed) {
	        if(err) return self.emit('error', err);
	        self.emit('error', new MongoError('no secondary found in replicaset'));
	        return self.destroy({force:true});
	      }
	
	      for(var i = 0; i < servers.length; i++) {
	        monitorServer(servers[i], self, options);
	      }
	    });
	  } else {
	    for(var i = 0; i < servers.length; i++) {
	      monitorServer(servers[i], self, options);
	    }
	  }
	
	  // Run the reconnect process
	  function executeReconnect(self) {
	    return function() {
	      if(self.state == DESTROYED || self.state == UNREFERENCED) {
	        return;
	      }
	
	      connectNewServers(self, self.s.replicaSetState.unknownServers, function() {
	        var monitoringFrequencey = self.s.replicaSetState.hasPrimary()
	          ? _haInterval : self.s.minHeartbeatFrequencyMS;
	
	        // Create a timeout
	        self.intervalIds.push(new Timeout(executeReconnect(self), monitoringFrequencey).start());
	      });
	    }
	  }
	
	  // Decide what kind of interval to use
	  var intervalTime = !self.s.replicaSetState.hasPrimary()
	    ? self.s.minHeartbeatFrequencyMS
	    : _haInterval
	
	  self.intervalIds.push(new Timeout(executeReconnect(self), intervalTime).start());
	}
	
	function addServerToList(list, server) {
	  for(var i = 0; i < list.length; i++) {
	    if(list[i].name.toLowerCase() === server.name.toLowerCase()) return true;
	  }
	
	  list.push(server);
	}
	
	function handleEvent(self, event) {
	  return function() {
	    if(self.state == DESTROYED || self.state == UNREFERENCED) return;
	    // Debug log
	    if(self.s.logger.isDebug()) {
	      self.s.logger.debug(f('handleEvent %s from server %s in replset with id %s', event, this.name, self.id));
	    }
	
	    // Remove from the replicaset state
	    self.s.replicaSetState.remove(this);
	
	    // Are we in a destroyed state return
	    if(self.state == DESTROYED || self.state == UNREFERENCED) return;
	
	    // If no primary and secondary available
	    if(!self.s.replicaSetState.hasPrimary()
	      && !self.s.replicaSetState.hasSecondary()
	      && self.s.options.secondaryOnlyConnectionAllowed) {
	      stateTransition(self, DISCONNECTED);
	    } else if(!self.s.replicaSetState.hasPrimary()) {
	      stateTransition(self, DISCONNECTED);
	    }
	
	    addServerToList(self.s.connectingServers, this);
	  }
	}
	
	function applyAuthenticationContexts(self, server, callback) {
	  if(self.s.authenticationContexts.length == 0) {
	    return callback();
	  }
	
	  // Do not apply any auth contexts if it's an arbiter
	  if(server.lastIsMaster() && server.lastIsMaster().arbiterOnly) {
	    return callback();
	  }
	
	  // Copy contexts to ensure no modificiation in the middle of
	  // auth process.
	  var authContexts = self.s.authenticationContexts.slice(0);
	
	  // Apply one of the contexts
	  function applyAuth(authContexts, server, callback) {
	    if(authContexts.length == 0) return callback();
	    // Get the first auth context
	    var authContext = authContexts.shift();
	    // Copy the params
	    var customAuthContext = authContext.slice(0);
	    // Push our callback handler
	    customAuthContext.push(function(err) {
	      applyAuth(authContexts, server, callback);
	    });
	
	    // Attempt authentication
	    server.auth.apply(server, customAuthContext)
	  }
	
	  // Apply all auth contexts
	  applyAuth(authContexts, server, callback);
	}
	
	function handleInitialConnectEvent(self, event) {
	  return function() {
	    var _this = this;
	    // Debug log
	    if(self.s.logger.isDebug()) {
	      self.s.logger.debug(f('handleInitialConnectEvent %s from server %s in replset with id %s', event, this.name, self.id));
	    }
	
	    // Destroy the instance
	    if(self.state == DESTROYED || self.state == UNREFERENCED) {
	      return this.destroy({force:true});
	    }
	
	    // Check the type of server
	    if(event == 'connect') {
	      // Do we have authentication contexts that need to be applied
	      applyAuthenticationContexts(self, _this, function() {
	        // Destroy the instance
	        if(self.state == DESTROYED || self.state == UNREFERENCED) {
	          return _this.destroy({force:true});
	        }
	
	        // Update the state
	        var result = self.s.replicaSetState.update(_this);
	        if(result == true) {
	          // Primary lastIsMaster store it
	          if(_this.lastIsMaster() && _this.lastIsMaster().ismaster) {
	            self.ismaster = _this.lastIsMaster();
	          }
	
	          // Debug log
	          if(self.s.logger.isDebug()) {
	            self.s.logger.debug(f('handleInitialConnectEvent %s from server %s in replset with id %s has state [%s]', event, _this.name, self.id, JSON.stringify(self.s.replicaSetState.set)));
	          }
	
	          // Remove the handlers
	          for(var i = 0; i < handlers.length; i++) {
	            _this.removeAllListeners(handlers[i]);
	          }
	
	          // Add stable state handlers
	          _this.on('error', handleEvent(self, 'error'));
	          _this.on('close', handleEvent(self, 'close'));
	          _this.on('timeout', handleEvent(self, 'timeout'));
	          _this.on('parseError', handleEvent(self, 'parseError'));
	
	          // Do we have a primary or primaryAndSecondary
	          if(self.state === CONNECTING && self.s.replicaSetState.hasPrimary()
	            || (self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed)) {
	            // We are connected
	            self.state = CONNECTED;
	
	            // Set initial connect state
	            self.initialConnectState.connect = true;
	            // Emit connect event
	            process.nextTick(function() {
	              self.emit('connect', self);
	            });
	
	            topologyMonitor(self, {});
	          }
	        } else if(result instanceof MongoError) {
	          _this.destroy({force:true});
	          self.destroy({force:true});
	          return self.emit('error', result);
	        } else {
	          _this.destroy({force:true});
	        }
	      });
	    } else {
	      // Emit failure to connect
	      self.emit('failed', this);
	
	      addServerToList(self.s.connectingServers, this);
	      // Remove from the state
	      self.s.replicaSetState.remove(this);
	    }
	
	    if(self.initialConnectState.connect
	      && !self.initialConnectState.fullsetup
	      && self.s.replicaSetState.hasPrimaryAndSecondary()) {
	        // Set initial connect state
	        self.initialConnectState.fullsetup = true;
	        self.initialConnectState.all = true;
	
	        process.nextTick(function() {
	          self.emit('fullsetup', self);
	          self.emit('all', self);
	        });
	    }
	
	    // Remove from the list from connectingServers
	    for(var i = 0; i < self.s.connectingServers.length; i++) {
	      if(self.s.connectingServers[i].equals(this)) {
	        self.s.connectingServers.splice(i, 1);
	      }
	    }
	
	    // Trigger topologyMonitor
	    if(self.s.connectingServers.length == 0 && self.state == CONNECTING) {
	      topologyMonitor(self, {haInterval: 1});
	    }
	  };
	}
	
	function connectServers(self, servers) {
	  // Update connectingServers
	  self.s.connectingServers = self.s.connectingServers.concat(servers);
	
	  // Index used to interleaf the server connects, avoiding
	  // runtime issues on io constrained vm's
	  var timeoutInterval = 0;
	
	  function connect(server, timeoutInterval) {
	    setTimeout(function() {
	      // Add the server to the state
	      if(self.s.replicaSetState.update(server)) {
	        // Primary lastIsMaster store it
	        if(server.lastIsMaster() && server.lastIsMaster().ismaster) {
	          self.ismaster = server.lastIsMaster();
	        }
	      }
	
	      // Add event handlers
	      server.once('close', handleInitialConnectEvent(self, 'close'));
	      server.once('timeout', handleInitialConnectEvent(self, 'timeout'));
	      server.once('parseError', handleInitialConnectEvent(self, 'parseError'));
	      server.once('error', handleInitialConnectEvent(self, 'error'));
	      server.once('connect', handleInitialConnectEvent(self, 'connect'));
	      // SDAM Monitoring events
	      server.on('serverOpening', function(e) { self.emit('serverOpening', e); });
	      server.on('serverDescriptionChanged', function(e) { self.emit('serverDescriptionChanged', e); });
	      server.on('serverClosed', function(e) { self.emit('serverClosed', e); });
	      // Start connection
	      server.connect(self.s.connectOptions);
	    }, timeoutInterval);
	  }
	
	  // Start all the servers
	  while(servers.length > 0) {
	    connect(servers.shift(), timeoutInterval++);
	  }
	}
	
	/**
	 * Emit event if it exists
	 * @method
	 */
	function emitSDAMEvent(self, event, description) {
	  if(self.listeners(event).length > 0) {
	    self.emit(event, description);
	  }
	}
	
	/**
	 * Initiate server connect
	 * @method
	 * @param {array} [options.auth=null] Array of auth options to apply on connect
	 */
	ReplSet.prototype.connect = function(options) {
	  var self = this;
	  // Add any connect level options to the internal state
	  this.s.connectOptions = options || {};
	  // Set connecting state
	  stateTransition(this, CONNECTING);
	  // Create server instances
	  var servers = this.s.seedlist.map(function(x) {
	    return new Server(assign({}, self.s.options, x, {
	      authProviders: self.authProviders, reconnect:false, monitoring:false, inTopology: true
	    }, {
	      clientInfo: clone(self.s.clientInfo)
	    }));
	  });
	
	  // Error out as high availbility interval must be < than socketTimeout
	  if(this.s.options.socketTimeout > 0 && this.s.options.socketTimeout <= this.s.options.haInterval) {
	    return self.emit('error', new MongoError(f("haInterval [%s] MS must be set to less than socketTimeout [%s] MS"
	      , this.s.options.haInterval, this.s.options.socketTimeout)));
	  }
	
	  // Emit the topology opening event
	  emitSDAMEvent(this, 'topologyOpening', { topologyId: this.id });
	  // Start all server connections
	  connectServers(self, servers);
	}
	
	/**
	 * Destroy the server connection
	 * @param {boolean} [options.force=false] Force destroy the pool
	 * @method
	 */
	ReplSet.prototype.destroy = function(options) {
	  options = options || {};
	  // Transition state
	  stateTransition(this, DESTROYED);
	  // Clear out any monitoring process
	  if(this.haTimeoutId) clearTimeout(this.haTimeoutId);
	  // Destroy the replicaset
	  this.s.replicaSetState.destroy(options);
	  // Clear out authentication contexts
	  this.s.authenticationContexts = [];
	
	  // Destroy all connecting servers
	  this.s.connectingServers.forEach(function(x) {
	    x.destroy(options);
	  });
	
	  // Clear out all monitoring
	  for(var i = 0; i < this.intervalIds.length; i++) {
	    this.intervalIds[i].stop();
	    this.intervalIds[i].stop();
	  }
	
	  // Reset list of intervalIds
	  this.intervalIds = [];
	
	  // Emit toplogy closing event
	  emitSDAMEvent(this, 'topologyClosed', { topologyId: this.id });
	}
	
	/**
	 * Unref all connections belong to this server
	 * @method
	 */
	ReplSet.prototype.unref = function() {
	  // Transition state
	  stateTransition(this, UNREFERENCED);
	
	  this.s.replicaSetState.allServers().forEach(function(x) {
	    x.unref();
	  });
	
	  clearTimeout(this.haTimeoutId);
	}
	
	/**
	 * Returns the last known ismaster document for this server
	 * @method
	 * @return {object}
	 */
	ReplSet.prototype.lastIsMaster = function() {
	  // If secondaryOnlyConnectionAllowed and no primary but secondary
	  // return the secondaries ismaster result.
	  if (this.s.options.secondaryOnlyConnectionAllowed
	    && !this.s.replicaSetState.hasPrimary()
	    && this.s.replicaSetState.hasSecondary()) {
	      return this.s.replicaSetState.secondaries[0].lastIsMaster();
	    }
	
	  return this.s.replicaSetState.primary
	    ? this.s.replicaSetState.primary.lastIsMaster() : this.ismaster;
	}
	
	/**
	 * All raw connections
	 * @method
	 * @return {Connection[]}
	 */
	ReplSet.prototype.connections = function() {
	  var servers = this.s.replicaSetState.allServers();
	  var connections = [];
	  for(var i = 0; i < servers.length; i++) {
	    connections = connections.concat(servers[i].connections());
	  }
	
	  return connections;
	}
	
	/**
	 * Figure out if the server is connected
	 * @method
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @return {boolean}
	 */
	ReplSet.prototype.isConnected = function(options) {
	  options = options || {};
	
	  // If we are authenticating signal not connected
	  // To avoid interleaving of operations
	  if(this.authenticating) return false;
	
	  // If we specified a read preference check if we are connected to something
	  // than can satisfy this
	  if(options.readPreference
	    && options.readPreference.equals(ReadPreference.secondary)) {
	    return this.s.replicaSetState.hasSecondary();
	  }
	
	  if(options.readPreference
	    && options.readPreference.equals(ReadPreference.primary)) {
	    return this.s.replicaSetState.hasPrimary();
	  }
	
	  if(options.readPreference
	    && options.readPreference.equals(ReadPreference.primaryPreferred)) {
	    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
	  }
	
	  if(options.readPreference
	    && options.readPreference.equals(ReadPreference.secondaryPreferred)) {
	    return this.s.replicaSetState.hasSecondary() || this.s.replicaSetState.hasPrimary();
	  }
	
	  if(this.s.options.secondaryOnlyConnectionAllowed
	    && this.s.replicaSetState.hasSecondary()) {
	      return true;
	  }
	
	  return this.s.replicaSetState.hasPrimary();
	}
	
	/**
	 * Figure out if the replicaset instance was destroyed by calling destroy
	 * @method
	 * @return {boolean}
	 */
	ReplSet.prototype.isDestroyed = function() {
	  return this.state == DESTROYED;
	}
	
	/**
	 * Get server
	 * @method
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @return {Server}
	 */
	ReplSet.prototype.getServer = function(options) {
	  // Ensure we have no options
	  options = options || {};
	  // Pick the right server baspickServerd on readPreference
	  var server = this.s.replicaSetState.pickServer(options.readPreference);
	  if(this.s.debug) this.emit('pickedServer', options.readPreference, server);
	  return server;
	}
	
	/**
	 * Get a direct connection
	 * @method
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @return {Connection}
	 */
	ReplSet.prototype.getConnection = function(options) {
	  var server = this.getServer(options);
	  if(server) return server.getConnection();
	}
	
	/**
	 * Get all connected servers
	 * @method
	 * @return {Server[]}
	 */
	ReplSet.prototype.getServers = function() {
	  return this.s.replicaSetState.allServers();
	}
	
	//
	// Execute write operation
	var executeWriteOperation = function(self, op, ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {}, options = options || {};
	  // Ensure we have no options
	  options = options || {};
	
	  // No server returned we had an error
	  if(self.s.replicaSetState.primary == null) {
	    return callback(new MongoError("no primary server found"));
	  }
	
	  // Execute the command
	  self.s.replicaSetState.primary[op](ns, ops, options, callback);
	}
	
	/**
	 * Insert one or more documents
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of documents to insert
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	ReplSet.prototype.insert = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {}, options = options || {};
	  if(this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	
	  // Not connected but we have a disconnecthandler
	  if(!this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
	    return this.s.disconnectHandler.add('insert', ns, ops, options, callback);
	  }
	
	  // Execute write operation
	  executeWriteOperation(this, 'insert', ns, ops, options, callback);
	}
	
	/**
	 * Perform one or more update operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of updates
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	ReplSet.prototype.update = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {}, options = options || {};
	  if(this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	
	  // Not connected but we have a disconnecthandler
	  if(!this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
	    return this.s.disconnectHandler.add('update', ns, ops, options, callback);
	  }
	
	  // Execute write operation
	  executeWriteOperation(this, 'update', ns, ops, options, callback);
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {array} ops An array of removes
	 * @param {boolean} [options.ordered=true] Execute in order or out of order
	 * @param {object} [options.writeConcern={}] Write concern for the operation
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	ReplSet.prototype.remove = function(ns, ops, options, callback) {
	  if(typeof options == 'function') callback = options, options = {}, options = options || {};
	  if(this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	
	  // Not connected but we have a disconnecthandler
	  if(!this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
	    return this.s.disconnectHandler.add('remove', ns, ops, options, callback);
	  }
	
	  // Execute write operation
	  executeWriteOperation(this, 'remove', ns, ops, options, callback);
	}
	
	/**
	 * Execute a command
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {object} cmd The command hash
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {Connection} [options.connection] Specify connection object to execute command against
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	ReplSet.prototype.command = function(ns, cmd, options, callback) {
	  if(typeof options == 'function') callback = options, options = {}, options = options || {};
	  if(this.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));
	  var self = this;
	
	  // Establish readPreference
	  var readPreference = options.readPreference ? options.readPreference : ReadPreference.primary;
	
	  // If the readPreference is primary and we have no primary, store it
	  if(readPreference.preference == 'primary' && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
	    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);
	  } else if(readPreference.preference == 'secondary' && !this.s.replicaSetState.hasSecondary() && this.s.disconnectHandler != null) {
	    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);
	  } else if(readPreference.preference != 'primary' && !this.s.replicaSetState.hasSecondary() && !this.s.replicaSetState.hasPrimary() && this.s.disconnectHandler != null) {
	    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);
	  }
	
	  // Pick a server
	  var server = this.s.replicaSetState.pickServer(readPreference);
	  // We received an error, return it
	  if(!(server instanceof Server)) return callback(server);
	  // Emit debug event
	  if(self.s.debug) self.emit('pickedServer', ReadPreference.primary, server);
	
	  // No server returned we had an error
	  if(server == null) {
	    return callback(new MongoError(f("no server found that matches the provided readPreference %s", readPreference)));
	  }
	
	  // Execute the command
	  server.command(ns, cmd, options, callback);
	}
	
	/**
	 * Authenticate using a specified mechanism
	 * @method
	 * @param {string} mechanism The Auth mechanism we are invoking
	 * @param {string} db The db we are invoking the mechanism against
	 * @param {...object} param Parameters for the specific mechanism
	 * @param {authResultCallback} callback A callback function
	 */
	ReplSet.prototype.auth = function(mechanism, db) {
	  var allArgs = Array.prototype.slice.call(arguments, 0).slice(0);
	  var self = this;
	  var args = Array.prototype.slice.call(arguments, 2);
	  var callback = args.pop();
	  var currentContextIndex = 0;
	
	  // If we don't have the mechanism fail
	  if(this.authProviders[mechanism] == null && mechanism != 'default') {
	    return callback(new MongoError(f("auth provider %s does not exist", mechanism)));
	  }
	
	  // Are we already authenticating, throw
	  if(this.authenticating) {
	    return callback(new MongoError('authentication or logout allready in process'));
	  }
	
	  // Topology is not connected, save the call in the provided store to be
	  // Executed at some point when the handler deems it's reconnected
	  if(self.s.disconnectHandler != null) {
	    if(!self.s.replicaSetState.hasPrimary() && !self.s.options.secondaryOnlyConnectionAllowed) {
	      return self.s.disconnectHandler.add('auth', db, allArgs, {}, callback);
	    } else if(!self.s.replicaSetState.hasSecondary() && self.s.options.secondaryOnlyConnectionAllowed) {
	      return self.s.disconnectHandler.add('auth', db, allArgs, {}, callback);
	    }
	  }
	
	  // Set to authenticating
	  this.authenticating = true;
	  // All errors
	  var errors = [];
	
	  // Get all the servers
	  var servers = this.s.replicaSetState.allServers();
	  // No servers return
	  if(servers.length == 0) {
	    this.authenticating = false;
	    callback(null, true);
	  }
	
	  // Authenticate
	  function auth(server) {
	    // Arguments without a callback
	    var argsWithoutCallback = [mechanism, db].concat(args.slice(0));
	    // Create arguments
	    var finalArguments = argsWithoutCallback.concat([function(err) {
	      count = count - 1;
	      // Save all the errors
	      if(err) errors.push({name: server.name, err: err});
	      // We are done
	      if(count == 0) {
	        // Auth is done
	        self.authenticating = false;
	
	        // Return the auth error
	        if(errors.length) {
	          // Remove the entry from the stored authentication contexts
	          self.s.authenticationContexts.splice(currentContextIndex, 0);
	          // Return error
	          return callback(MongoError.create({
	            message: 'authentication fail', errors: errors
	          }), false);
	        }
	
	        // Successfully authenticated session
	        callback(null, self);
	      }
	    }]);
	
	    if(!server.lastIsMaster().arbiterOnly) {
	      // Execute the auth only against non arbiter servers
	      server.auth.apply(server, finalArguments);
	    } else {
	      // If we are authenticating against an arbiter just ignore it
	      finalArguments.pop()(null);
	    }
	  }
	
	  // Get total count
	  var count = servers.length;
	
	  // Save current context index
	  currentContextIndex = this.s.authenticationContexts.length;
	
	  // Store the auth context and return the last index
	  this.s.authenticationContexts.push([mechanism, db].concat(args.slice(0)));
	
	  // Authenticate against all servers
	  while(servers.length > 0) {
	    auth(servers.shift());
	  }
	}
	
	/**
	 * Logout from a database
	 * @method
	 * @param {string} db The db we are logging out from
	 * @param {authResultCallback} callback A callback function
	 */
	ReplSet.prototype.logout = function(dbName, callback) {
	  var self = this;
	  // Are we authenticating or logging out, throw
	  if(this.authenticating) {
	    throw new MongoError('authentication or logout allready in process');
	  }
	
	  // Ensure no new members are processed while logging out
	  this.authenticating = true;
	
	  // Remove from all auth providers (avoid any reaplication of the auth details)
	  var providers = Object.keys(this.authProviders);
	  for(var i = 0; i < providers.length; i++) {
	    this.authProviders[providers[i]].logout(dbName);
	  }
	
	  // Clear out any contexts associated with the db
	  self.s.authenticationContexts = self.s.authenticationContexts.filter(function(context) {
	    return context[1] !== dbName;
	  });
	
	  // Now logout all the servers
	  var servers = this.s.replicaSetState.allServers();
	  var count = servers.length;
	  if(count == 0) return callback();
	  var errors = [];
	
	  function logoutServer(_server, cb) {
	    _server.logout(dbName, function(err) {
	      if(err) errors.push({name: _server.name, err: err});
	      cb();
	    });
	  }
	
	  // Execute logout on all server instances
	  for(i = 0; i < servers.length; i++) {
	    logoutServer(servers[i], function() {
	      count = count - 1;
	
	      if(count == 0) {
	        // Do not block new operations
	        self.authenticating = false;
	        // If we have one or more errors
	        if(errors.length) return callback(MongoError.create({
	          message: f('logout failed against db %s', dbName), errors: errors
	        }), false);
	
	        // No errors
	        callback();
	      }
	    })
	  }
	}
	
	/**
	 * Perform one or more remove operations
	 * @method
	 * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)
	 * @param {{object}|{Long}} cmd Can be either a command returning a cursor or a cursorId
	 * @param {object} [options.batchSize=0] Batchsize for the operation
	 * @param {array} [options.documents=[]] Initial documents list for cursor
	 * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it
	 * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.
	 * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.
	 * @param {opResultCallback} callback A callback function
	 */
	ReplSet.prototype.cursor = function(ns, cmd, cursorOptions) {
	  cursorOptions = cursorOptions || {};
	  var FinalCursor = cursorOptions.cursorFactory || this.s.Cursor;
	  return new FinalCursor(this.s.bson, ns, cmd, cursorOptions, this, this.s.options);
	}
	
	/**
	 * A replset connect event, used to verify that the connection is up and running
	 *
	 * @event ReplSet#connect
	 * @type {ReplSet}
	 */
	
	/**
	 * A replset reconnect event, used to verify that the topology reconnected
	 *
	 * @event ReplSet#reconnect
	 * @type {ReplSet}
	 */
	
	/**
	 * A replset fullsetup event, used to signal that all topology members have been contacted.
	 *
	 * @event ReplSet#fullsetup
	 * @type {ReplSet}
	 */
	
	/**
	 * A replset all event, used to signal that all topology members have been contacted.
	 *
	 * @event ReplSet#all
	 * @type {ReplSet}
	 */
	
	/**
	 * A replset failed event, used to signal that initial replset connection failed.
	 *
	 * @event ReplSet#failed
	 * @type {ReplSet}
	 */
	
	/**
	 * A server member left the replicaset
	 *
	 * @event ReplSet#left
	 * @type {function}
	 * @param {string} type The type of member that left (primary|secondary|arbiter)
	 * @param {Server} server The server object that left
	 */
	
	/**
	 * A server member joined the replicaset
	 *
	 * @event ReplSet#joined
	 * @type {function}
	 * @param {string} type The type of member that joined (primary|secondary|arbiter)
	 * @param {Server} server The server object that joined
	 */
	
	/**
	 * A server opening SDAM monitoring event
	 *
	 * @event ReplSet#serverOpening
	 * @type {object}
	 */
	
	/**
	 * A server closed SDAM monitoring event
	 *
	 * @event ReplSet#serverClosed
	 * @type {object}
	 */
	
	/**
	 * A server description SDAM change monitoring event
	 *
	 * @event ReplSet#serverDescriptionChanged
	 * @type {object}
	 */
	
	/**
	 * A topology open SDAM event
	 *
	 * @event ReplSet#topologyOpening
	 * @type {object}
	 */
	
	/**
	 * A topology closed SDAM event
	 *
	 * @event ReplSet#topologyClosed
	 * @type {object}
	 */
	
	/**
	 * A topology structure SDAM change event
	 *
	 * @event ReplSet#topologyDescriptionChanged
	 * @type {object}
	 */
	
	/**
	 * A topology serverHeartbeatStarted SDAM event
	 *
	 * @event ReplSet#serverHeartbeatStarted
	 * @type {object}
	 */
	
	/**
	 * A topology serverHeartbeatFailed SDAM event
	 *
	 * @event ReplSet#serverHeartbeatFailed
	 * @type {object}
	 */
	
	/**
	 * A topology serverHeartbeatSucceeded SDAM change event
	 *
	 * @event ReplSet#serverHeartbeatSucceeded
	 * @type {object}
	 */
	
	module.exports = ReplSet;


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict"
	
	var inherits = __webpack_require__(1).inherits,
	  f = __webpack_require__(1).format,
	  diff = __webpack_require__(15).diff,
	  EventEmitter = __webpack_require__(6).EventEmitter,
	  Logger = __webpack_require__(19),
	  ReadPreference = __webpack_require__(43),
	  MongoError = __webpack_require__(7);
	
	var TopologyType = {
	  'Single': 'Single', 'ReplicaSetNoPrimary': 'ReplicaSetNoPrimary',
	  'ReplicaSetWithPrimary': 'ReplicaSetWithPrimary', 'Sharded': 'Sharded',
	  'Unknown': 'Unknown'
	};
	
	var ServerType = {
	  'Standalone': 'Standalone', 'Mongos': 'Mongos', 'PossiblePrimary': 'PossiblePrimary',
	  'RSPrimary': 'RSPrimary', 'RSSecondary': 'RSSecondary', 'RSArbiter': 'RSArbiter',
	  'RSOther': 'RSOther', 'RSGhost': 'RSGhost', 'Unknown': 'Unknown'
	};
	
	var ReplSetState = function(options) {
	  options = options || {};
	  // Add event listener
	  EventEmitter.call(this);
	  // Topology state
	  this.topologyType = TopologyType.ReplicaSetNoPrimary;
	  this.setName = options.setName;
	
	  // Server set
	  this.set = {};
	
	  // Unpacked options
	  this.id = options.id;
	  this.setName = options.setName;
	
	  // Replicaset logger
	  this.logger = options.logger || Logger('ReplSet', options);
	
	  // Server selection index
	  this.index = 0;
	  // Acceptable latency
	  this.acceptableLatency = options.acceptableLatency || 15;
	
	  // heartbeatFrequencyMS
	  this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 10000;
	
	  // Server side
	  this.primary = null;
	  this.secondaries = [];
	  this.arbiters = [];
	  this.passives = [];
	  this.ghosts = [];
	  // Current unknown hosts
	  this.unknownServers = [];
	  // In set status
	  this.set = {};
	  // Status
	  this.maxElectionId = null;
	  this.maxSetVersion = 0;
	  // Description of the Replicaset
	  this.replicasetDescription = {
	    "topologyType": "Unknown", "servers": []
	  };
	}
	
	inherits(ReplSetState, EventEmitter);
	
	ReplSetState.prototype.hasPrimaryAndSecondary = function() {
	  return this.primary != null && this.secondaries.length > 0;
	}
	
	ReplSetState.prototype.hasPrimaryOrSecondary = function() {
	  return this.hasPrimary() || this.hasSecondary();
	}
	
	ReplSetState.prototype.hasPrimary = function() {
	  return this.primary != null;
	}
	
	ReplSetState.prototype.hasSecondary = function() {
	  return this.secondaries.length > 0;
	}
	
	ReplSetState.prototype.get = function(host) {
	  var servers = this.allServers();
	
	  for(var i = 0; i < servers.length; i++) {
	    if(servers[i].name.toLowerCase() === host.toLowerCase()) {
	      return servers[i];
	    }
	  }
	
	  return null;
	}
	
	ReplSetState.prototype.allServers = function(options) {
	  options = options || {};
	  var servers = this.primary ? [this.primary] : [];
	  servers = servers.concat(this.secondaries);
	  if(!options.ignoreArbiters) servers = servers.concat(this.arbiters);
	  servers = servers.concat(this.passives);
	  return servers;
	}
	
	ReplSetState.prototype.destroy = function(options) {
	  // Destroy all sockets
	  if(this.primary) this.primary.destroy(options);
	  this.secondaries.forEach(function(x) { x.destroy(options); });
	  this.arbiters.forEach(function(x) { x.destroy(options); });
	  this.passives.forEach(function(x) { x.destroy(options); });
	  this.ghosts.forEach(function(x) { x.destroy(options); });
	  // Clear out the complete state
	  this.secondaries = [];
	  this.arbiters = [];
	  this.passives = [];
	  this.ghosts = [];
	  this.unknownServers = [];
	  this.set = {};
	  this.primary = null;
	  // Emit the topology changed
	  emitTopologyDescriptionChanged(this);
	}
	
	ReplSetState.prototype.remove = function(server, options) {
	  options = options || {};
	
	  // Get the server name and lowerCase it
	  var serverName = server.name.toLowerCase();
	
	  // Only remove if the current server is not connected
	  var servers = this.primary ? [this.primary] : [];
	  servers = servers.concat(this.secondaries);
	  servers = servers.concat(this.arbiters);
	  servers = servers.concat(this.passives);
	
	  // Check if it's active and this is just a failed connection attempt
	  for(var i = 0; i < servers.length; i++) {
	    if(!options.force
	      && servers[i].equals(server)
	      && servers[i].isConnected
	      && servers[i].isConnected()) {
	      return;
	    }
	  }
	
	  // If we have it in the set remove it
	  if(this.set[serverName]) {
	    this.set[serverName].type = ServerType.Unknown;
	    this.set[serverName].electionId = null;
	    this.set[serverName].setName = null;
	    this.set[serverName].setVersion = null;
	  }
	
	  // Remove type
	  var removeType = null;
	
	  // Remove from any lists
	  if(this.primary && this.primary.equals(server)) {
	    this.primary = null;
	    this.topologyType = TopologyType.ReplicaSetNoPrimary;
	    removeType = 'primary';
	  }
	
	  // Remove from any other server lists
	  removeType = removeFrom(server, this.secondaries) ? 'secondary' : removeType;
	  removeType = removeFrom(server, this.arbiters) ? 'arbiter' : removeType;
	  removeType = removeFrom(server, this.passives) ? 'secondary' : removeType;
	  removeFrom(server, this.ghosts);
	  removeFrom(server, this.unknownServers);
	
	  // Push to unknownServers
	  this.unknownServers.push(serverName);
	
	  // Do we have a removeType
	  if(removeType) {
	    this.emit('left', removeType, server);
	  }
	}
	
	ReplSetState.prototype.update = function(server) {
	  var self = this;
	  // Get the current ismaster
	  var ismaster = server.lastIsMaster();
	
	  // Get the server name and lowerCase it
	  var serverName = server.name.toLowerCase();
	
	  //
	  // Add any hosts
	  //
	  if(ismaster) {
	    // Join all the possible new hosts
	    var hosts = Array.isArray(ismaster.hosts) ? ismaster.hosts : [];
	    hosts = hosts.concat(Array.isArray(ismaster.arbiters) ? ismaster.arbiters : []);
	    hosts = hosts.concat(Array.isArray(ismaster.passives) ? ismaster.passives : []);
	    hosts = hosts.map(function(s) { return s.toLowerCase() });
	
	    // Add all hosts as unknownServers
	    for(var i = 0; i < hosts.length; i++) {
	      // Add to the list of unknown server
	      if(this.unknownServers.indexOf(hosts[i]) == -1
	        && (!this.set[hosts[i]] || this.set[hosts[i]].type == ServerType.Unknown)) {
	        this.unknownServers.push(hosts[i].toLowerCase());
	      }
	
	      if(!this.set[hosts[i]]) {
	        this.set[hosts[i]] = {
	          type: ServerType.Unknown,
	          electionId: null,
	          setName: null,
	          setVersion: null
	        }
	      }
	    }
	  }
	
	  //
	  // Unknown server
	  //
	  if(!ismaster && !inList(ismaster, server, this.unknownServers)) {
	    self.set[serverName] = {
	      type: ServerType.Unknown, setVersion: null, electionId: null, setName: null
	    }
	    // Update set information about the server instance
	    self.set[serverName].type = ServerType.Unknown;
	    self.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
	    self.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
	    self.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
	
	    if(self.unknownServers.indexOf(server.name) == -1) {
	      self.unknownServers.push(serverName);
	    }
	
	    // Set the topology
	    return false;
	  }
	
	  //
	  // Is this a mongos
	  //
	  if(ismaster && ismaster.msg == 'isdbgrid') {
	    return false;
	  }
	
	  // A RSOther instance
	  if((ismaster.setName && ismaster.hidden)
	    || (ismaster.setName && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly && !ismaster.passive)) {
	    self.set[serverName] = {
	      type: ServerType.RSOther, setVersion: null,
	      electionId: null, setName: ismaster.setName
	    }
	    // Set the topology
	    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
	    if(ismaster.setName) this.setName = ismaster.setName;
	    return false;
	  }
	
	  // A RSGhost instance
	  if(ismaster.isreplicaset) {
	    self.set[serverName] = {
	      type: ServerType.RSGhost, setVersion: null,
	      electionId: null, setName: null
	    }
	
	    // Set the topology
	    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
	    if(ismaster.setName) this.setName = ismaster.setName;
	
	    // Set the topology
	    return false;
	  }
	
	  //
	  // Standalone server, destroy and return
	  //
	  if(ismaster && ismaster.ismaster && !ismaster.setName) {
	    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.Unknown;
	    this.remove(server, {force:true});
	    return false;
	  }
	
	  //
	  // Server in maintanance mode
	  //
	  if(ismaster && !ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly) {
	    this.remove(server, {force:true});
	    return false;
	  }
	
	  //
	  // If the .me field does not match the passed in server
	  //
	  if(ismaster.me && ismaster.me.toLowerCase() != serverName) {
	    if(this.logger.isWarn()) {
	      this.logger.warn(f('the seedlist server was removed due to its address %s not matching its ismaster.me address %s', server.name, ismaster.me));
	    }
	
	    // Delete from the set
	    delete this.set[serverName];
	    // Delete unknown servers
	    removeFrom(server, self.unknownServers);
	
	    // Destroy the instance
	    server.destroy();
	
	    // Set the type of topology we have
	    if(this.primary && !this.primary.equals(server)) {
	      this.topologyType = TopologyType.ReplicaSetWithPrimary;
	    } else {
	      this.topologyType = TopologyType.ReplicaSetNoPrimary;
	    }
	
	    //
	    // We have a potential primary
	    //
	    if(!this.primary && ismaster.primary) {
	      this.set[ismaster.primary.toLowerCase()] = {
	        type: ServerType.PossiblePrimary,
	        setName: null,
	        electionId: null,
	        setVersion: null,
	      }
	    }
	
	    return false;
	  }
	
	  //
	  // Primary handling
	  //
	  if(!this.primary && ismaster.ismaster && ismaster.setName) {
	    var ismasterElectionId = server.lastIsMaster().electionId;
	    if(this.setName && this.setName != ismaster.setName) {
	      this.topologyType = TopologyType.ReplicaSetNoPrimary;
	      return new MongoError(f('setName from ismaster does not match provided connection setName [%s] != [%s]', ismaster.setName, this.setName));
	    }
	
	    if(!this.maxElectionId && ismasterElectionId) {
	      this.maxElectionId = ismasterElectionId;
	    } else if(this.maxElectionId && ismasterElectionId) {
	      var result = compareObjectIds(this.maxElectionId, ismasterElectionId);
	      // Get the electionIds
	      var ismasterSetVersion = server.lastIsMaster().setVersion;
	
	      if(result == 1) {
	        this.topologyType = TopologyType.ReplicaSetNoPrimary;
	        return false;
	      } else if(result == 0 && ismasterSetVersion) {
	        if(ismasterSetVersion < this.maxSetVersion) {
	          this.topologyType = TopologyType.ReplicaSetNoPrimary;
	          return false;
	        }
	      }
	
	      this.maxSetVersion = ismasterSetVersion;
	      this.maxElectionId = ismasterElectionId;
	    }
	
	    // Hande normalization of server names
	    var normalizedHosts = ismaster.hosts.map(function(x) { return x.toLowerCase() });
	    var locationIndex = normalizedHosts.indexOf(serverName);
	
	    // Validate that the server exists in the host list
	    if(locationIndex != -1) {
	      self.primary = server;
	      self.set[serverName] = {
	        type: ServerType.RSPrimary,
	        setVersion: ismaster.setVersion,
	        electionId: ismaster.electionId,
	        setName: ismaster.setName
	      }
	
	      // Set the topology
	      this.topologyType = TopologyType.ReplicaSetWithPrimary;
	      if(ismaster.setName) this.setName = ismaster.setName;
	      removeFrom(server, self.unknownServers);
	      removeFrom(server, self.secondaries);
	      removeFrom(server, self.passives);
	      self.emit('joined', 'primary', server);
	    } else {
	      this.topologyType = TopologyType.ReplicaSetNoPrimary;
	    }
	
	    emitTopologyDescriptionChanged(self);
	    return true;
	  } else if(ismaster.ismaster && ismaster.setName) {
	    // Get the electionIds
	    var currentElectionId = self.set[self.primary.name.toLowerCase()].electionId;
	    var currentSetVersion = self.set[self.primary.name.toLowerCase()].setVersion;
	    var currentSetName = self.set[self.primary.name.toLowerCase()].setName;
	    ismasterElectionId = server.lastIsMaster().electionId;
	    ismasterSetVersion = server.lastIsMaster().setVersion;
	    var ismasterSetName = server.lastIsMaster().setName;
	
	    // Is it the same server instance
	    if(this.primary.equals(server)
	      && currentSetName == ismasterSetName) {
	        return false;
	    }
	
	    // If we do not have the same rs name
	    if(currentSetName && currentSetName != ismasterSetName) {
	      if(!this.primary.equals(server)) {
	        this.topologyType = TopologyType.ReplicaSetWithPrimary;
	      } else {
	        this.topologyType = TopologyType.ReplicaSetNoPrimary;
	      }
	
	      return false;
	    }
	
	    // Check if we need to replace the server
	    if(currentElectionId && ismasterElectionId) {
	      result = compareObjectIds(currentElectionId, ismasterElectionId);
	
	      if(result == 1) {
	        return false;
	      } else if(result == 0 && (currentSetVersion > ismasterSetVersion)) {
	        return false;
	      }
	    } else if(!currentElectionId && ismasterElectionId
	      && ismasterSetVersion) {
	        if(ismasterSetVersion < this.maxSetVersion) {
	          return false;
	        }
	    }
	
	    if(!this.maxElectionId && ismasterElectionId) {
	      this.maxElectionId = ismasterElectionId;
	    } else if(this.maxElectionId && ismasterElectionId) {
	      result = compareObjectIds(this.maxElectionId, ismasterElectionId);
	
	      if(result == 1) {
	        return false;
	      } else if(result == 0 && currentSetVersion && ismasterSetVersion) {
	        if(ismasterSetVersion < this.maxSetVersion) {
	          return false;
	        }
	      } else {
	        if(ismasterSetVersion < this.maxSetVersion) {
	          return false;
	        }
	      }
	
	      this.maxElectionId = ismasterElectionId;
	      this.maxSetVersion = ismasterSetVersion;
	    } else {
	      this.maxSetVersion = ismasterSetVersion;
	    }
	
	    // Modify the entry to unknown
	    self.set[self.primary.name.toLowerCase()] = {
	      type: ServerType.Unknown, setVersion: null,
	      electionId: null, setName: null
	    }
	
	    // Signal primary left
	    self.emit('left', 'primary', this.primary);
	    // Destroy the instance
	    self.primary.destroy();
	    // Set the new instance
	    self.primary = server;
	    // Set the set information
	    self.set[serverName] = {
	      type: ServerType.RSPrimary, setVersion: ismaster.setVersion,
	      electionId: ismaster.electionId, setName: ismaster.setName
	    }
	
	    // Set the topology
	    this.topologyType = TopologyType.ReplicaSetWithPrimary;
	    if(ismaster.setName) this.setName = ismaster.setName;
	    removeFrom(server, self.unknownServers);
	    removeFrom(server, self.secondaries);
	    removeFrom(server, self.passives);
	    self.emit('joined', 'primary', server);
	    emitTopologyDescriptionChanged(self);
	    return true;
	  }
	
	  // A possible instance
	  if(!this.primary && ismaster.primary) {
	    self.set[ismaster.primary.toLowerCase()] = {
	      type: ServerType.PossiblePrimary, setVersion: null,
	      electionId: null, setName: null
	    }
	  }
	
	  //
	  // Secondary handling
	  //
	  if(ismaster.secondary && ismaster.setName
	    && !inList(ismaster, server, this.secondaries)
	    && this.setName && this.setName == ismaster.setName) {
	    addToList(self, ServerType.RSSecondary, ismaster, server, this.secondaries);
	    // Set the topology
	    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
	    if(ismaster.setName) this.setName = ismaster.setName;
	    removeFrom(server, self.unknownServers);
	
	    // Remove primary
	    if(this.primary
	      && this.primary.name.toLowerCase() == serverName) {
	        server.destroy();
	        this.primary = null;
	        self.emit('left', 'primary', server);
	    }
	
	    // Emit secondary joined replicaset
	    self.emit('joined', 'secondary', server);
	    emitTopologyDescriptionChanged(self);
	    return true;
	  }
	
	  //
	  // Arbiter handling
	  //
	  if(ismaster.arbiterOnly && ismaster.setName
	    && !inList(ismaster, server, this.arbiters)
	    && this.setName && this.setName == ismaster.setName) {
	    addToList(self, ServerType.RSArbiter, ismaster, server, this.arbiters);
	    // Set the topology
	    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
	    if(ismaster.setName) this.setName = ismaster.setName;
	    removeFrom(server, self.unknownServers);
	    self.emit('joined', 'arbiter', server);
	    emitTopologyDescriptionChanged(self);
	    return true;
	  }
	
	  //
	  // Passive handling
	  //
	  if(ismaster.passive && ismaster.setName
	    && !inList(ismaster, server, this.passives)
	    && this.setName && this.setName == ismaster.setName) {
	    addToList(self, ServerType.RSSecondary, ismaster, server, this.passives);
	    // Set the topology
	    this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
	    if(ismaster.setName) this.setName = ismaster.setName;
	    removeFrom(server, self.unknownServers);
	
	    // Remove primary
	    if(this.primary
	      && this.primary.name.toLowerCase() == serverName) {
	        server.destroy();
	        this.primary = null;
	        self.emit('left', 'primary', server);
	    }
	
	    self.emit('joined', 'secondary', server);
	    emitTopologyDescriptionChanged(self);
	    return true;
	  }
	
	  //
	  // Remove the primary
	  //
	  if(this.set[serverName] && this.set[serverName].type == ServerType.RSPrimary) {
	    self.emit('left', 'primary', this.primary);
	    this.primary.destroy();
	    this.primary = null;
	    this.topologyType = TopologyType.ReplicaSetNoPrimary;
	    return false;
	  }
	
	  this.topologyType = this.primary ? TopologyType.ReplicaSetWithPrimary : TopologyType.ReplicaSetNoPrimary;
	  return false;
	}
	
	/**
	 * Recalculate single server max staleness
	 * @method
	 */
	ReplSetState.prototype.updateServerMaxStaleness = function(server, haInterval) {
	  // Locate the max secondary lastwrite
	  var max = 0;
	  // Go over all secondaries
	  for(var i = 0; i < this.secondaries.length; i++) {
	    max = Math.max(max, this.secondaries[i].lastWriteDate);
	  }
	
	  // Perform this servers staleness calculation
	  if(server.ismaster.maxWireVersion >= 5
	    && server.ismaster.secondary
	    && this.hasPrimary()) {
	    server.staleness = (server.lastUpdateTime - server.lastWriteDate)
	      - (this.primary.lastUpdateTime - this.primary.lastWriteDate)
	      + haInterval;
	  } else if(server.ismaster.maxWireVersion >= 5
	    && server.ismaster.secondary){
	    server.staleness = max - server.lastWriteDate + haInterval;
	  }
	}
	
	/**
	 * Recalculate all the stalness values for secodaries
	 * @method
	 */
	ReplSetState.prototype.updateSecondariesMaxStaleness = function(haInterval) {
	  for(var i = 0; i < this.secondaries.length; i++) {
	    this.updateServerMaxStaleness(this.secondaries[i], haInterval);
	  }
	}
	
	/**
	 * Pick a server by the passed in ReadPreference
	 * @method
	 * @param {ReadPreference} readPreference The ReadPreference instance to use
	 */
	ReplSetState.prototype.pickServer = function(readPreference) {
	  // If no read Preference set to primary by default
	  readPreference = readPreference || ReadPreference.primary;
	
	  // maxStalenessSeconds is not allowed with a primary read
	  if(readPreference.preference == 'primary' && readPreference.maxStalenessSeconds != null) {
	    return new MongoError('primary readPreference incompatible with maxStalenessSeconds');
	  }
	
	  // Check if we have any non compatible servers for maxStalenessSeconds
	  var allservers = this.primary ? [this.primary] : [];
	  allservers = allservers.concat(this.secondaries);
	
	  // Does any of the servers not support the right wire protocol version
	  // for maxStalenessSeconds when maxStalenessSeconds specified on readPreference. Then error out
	  if(readPreference.maxStalenessSeconds != null) {
	    for(var i = 0; i < allservers.length; i++) {
	      if(allservers[i].ismaster.maxWireVersion < 5) {
	        return new MongoError('maxStalenessSeconds not supported by at least one of the replicaset members');
	      }
	    }
	  }
	
	  // Do we have the nearest readPreference
	  if(readPreference.preference == 'nearest' && readPreference.maxStalenessSeconds == null) {
	    return pickNearest(this, readPreference);
	  } else if(readPreference.preference == 'nearest' && readPreference.maxStalenessSeconds != null) {
	    return pickNearestMaxStalenessSeconds(this, readPreference);
	  }
	
	  // Get all the secondaries
	  var secondaries = this.secondaries;
	
	  // Check if we can satisfy and of the basic read Preferences
	  if(readPreference.equals(ReadPreference.secondary)
	    && secondaries.length == 0) {
	      return new MongoError("no secondary server available");
	    }
	
	  if(readPreference.equals(ReadPreference.secondaryPreferred)
	    && secondaries.length == 0
	    && this.primary == null) {
	      return new MongoError("no secondary or primary server available");
	    }
	
	  if(readPreference.equals(ReadPreference.primary)
	    && this.primary == null) {
	      return new MongoError("no primary server available");
	    }
	
	  // Secondary preferred or just secondaries
	  if(readPreference.equals(ReadPreference.secondaryPreferred)
	    || readPreference.equals(ReadPreference.secondary)) {
	
	    if(secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
	      // Pick nearest of any other servers available
	      var server = pickNearest(this, readPreference);
	      // No server in the window return primary
	      if(server) {
	        return server;
	      }
	    } else if(secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
	      // Pick nearest of any other servers available
	      server = pickNearestMaxStalenessSeconds(this, readPreference);
	      // No server in the window return primary
	      if(server) {
	        return server;
	      }
	    }
	
	    if(readPreference.equals(ReadPreference.secondaryPreferred)){
	      return this.primary;
	    }
	
	    return null;
	  }
	
	  // Primary preferred
	  if(readPreference.equals(ReadPreference.primaryPreferred)) {
	    server = null;
	
	    // We prefer the primary if it's available
	    if(this.primary) {
	      return this.primary;
	    }
	
	    // Pick a secondary
	    if(secondaries.length > 0 && readPreference.maxStalenessSeconds == null) {
	      server = pickNearest(this, readPreference);
	    } else if(secondaries.length > 0 && readPreference.maxStalenessSeconds != null) {
	      server = pickNearestMaxStalenessSeconds(this, readPreference);
	    }
	
	    //  Did we find a server
	    if(server) return server;
	  }
	
	  // Return the primary
	  return this.primary;
	}
	
	//
	// Filter serves by tags
	var filterByTags = function(readPreference, servers) {
	  if(readPreference.tags == null) return servers;
	  var filteredServers = [];
	  var tagsArray = Array.isArray(readPreference.tags) ? readPreference.tags : [readPreference.tags];
	
	  // Iterate over the tags
	  for(var j = 0; j < tagsArray.length; j++) {
	    var tags = tagsArray[j];
	
	    // Iterate over all the servers
	    for(var i = 0; i < servers.length; i++) {
	      var serverTag = servers[i].lastIsMaster().tags || {};
	
	      // Did we find the a matching server
	      var found = true;
	      // Check if the server is valid
	      for(var name in tags) {
	        if(serverTag[name] != tags[name]) {
	          found = false;
	        }
	      }
	
	      // Add to candidate list
	      if(found) {
	        filteredServers.push(servers[i]);
	      }
	    }
	  }
	
	  // Returned filtered servers
	  return filteredServers;
	}
	
	function pickNearestMaxStalenessSeconds(self, readPreference) {
	  // Only get primary and secondaries as seeds
	  var servers = [];
	  var heartbeatFrequencyMS = self.heartbeatFrequencyMS;
	
	  // Get the maxStalenessMS
	  var maxStalenessMS = readPreference.maxStalenessSeconds * 1000;
	
	  // Check if the maxStalenessMS > 90 seconds
	  if(maxStalenessMS < 90 * 1000) {
	    return new MongoError('maxStalenessSeconds must be set to at least 90 seconds');
	  }
	
	  // Add primary to list if not a secondary read preference
	  if(self.primary 
	    && readPreference.preference != 'secondary' 
	    && readPreference.preference != 'secondaryPreferred') {
	      servers.push(self.primary);
	  }
	
	  // Add all the secondaries
	  for(var i = 0; i < self.secondaries.length; i++) {
	    servers.push(self.secondaries[i]);
	  }
	
	  // If we have a secondaryPreferred readPreference and no server add the primary
	  if(self.primary 
	    && servers.length == 0 
	    && readPreference.preference != 'secondaryPreferred') {
	      servers.push(self.primary);
	  }
	
	  // Filter by tags
	  servers = filterByTags(readPreference, servers);
	
	  //
	  // Locate lowest time (picked servers are lowest time + acceptable Latency margin)
	  // var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;
	
	  // Filter by latency
	  servers = servers.filter(function(s) {
	    return s.staleness <= maxStalenessMS;
	  });
	
	  // Sort by time
	  servers.sort(function(a, b) {
	    // return a.time > b.time;
	    return a.lastIsMasterMS > b.lastIsMasterMS
	  });
	
	  // No servers, default to primary
	  if(servers.length == 0) {
	    return null
	  }
	
	  // Ensure index does not overflow the number of available servers
	  self.index = self.index % servers.length;
	
	  // Get the server
	  var server = servers[self.index];
	  // Add to the index
	  self.index = self.index + 1;
	  // Return the first server of the sorted and filtered list
	  return server;
	}
	
	function pickNearest(self, readPreference) {
	  // Only get primary and secondaries as seeds
	  var servers = [];
	
	  // Add primary to list if not a secondary read preference
	  if(self.primary 
	    && readPreference.preference != 'secondary'
	    && readPreference.preference != 'secondaryPreferred') {
	      servers.push(self.primary);
	  }
	
	  // Add all the secondaries
	  for(var i = 0; i < self.secondaries.length; i++) {
	    servers.push(self.secondaries[i]);
	  }
	
	  // If we have a secondaryPreferred readPreference and no server add the primary
	  if(servers.length == 0 
	    && self.primary
	    && readPreference.preference != 'secondaryPreferred') {
	      servers.push(self.primary);
	  }
	
	  // Filter by tags
	  servers = filterByTags(readPreference, servers);
	
	  // Sort by time
	  servers.sort(function(a, b) {
	    // return a.time > b.time;
	    return a.lastIsMasterMS > b.lastIsMasterMS
	  });
	
	  // Locate lowest time (picked servers are lowest time + acceptable Latency margin)
	  var lowest = servers.length > 0 ? servers[0].lastIsMasterMS : 0;
	
	  // Filter by latency
	  servers = servers.filter(function(s) {
	    return s.lastIsMasterMS <= lowest + self.acceptableLatency;
	  });
	
	  // No servers, default to primary
	  if(servers.length == 0) {
	    return null
	  }
	
	  // Ensure index does not overflow the number of available servers
	  self.index = self.index % servers.length;
	  // Get the server
	  var server = servers[self.index];
	  // Add to the index
	  self.index = self.index + 1;
	  // Return the first server of the sorted and filtered list
	  return server;
	}
	
	function inList(ismaster, server, list) {
	  for(var i = 0; i < list.length; i++) {
	    if(list[i] && list[i].name
	      && list[i].name.toLowerCase() == server.name.toLowerCase()) return true;
	  }
	
	  return false;
	}
	
	function addToList(self, type, ismaster, server, list) {
	  var serverName = server.name.toLowerCase();
	  // Update set information about the server instance
	  self.set[serverName].type = type;
	  self.set[serverName].electionId = ismaster ? ismaster.electionId : ismaster;
	  self.set[serverName].setName = ismaster ? ismaster.setName : ismaster;
	  self.set[serverName].setVersion = ismaster ? ismaster.setVersion : ismaster;
	  // Add to the list
	  list.push(server);
	}
	
	function compareObjectIds(id1, id2) {
	  var a = new Buffer(id1.toHexString(), 'hex');
	  var b = new Buffer(id2.toHexString(), 'hex');
	
	  if(a === b) {
	    return 0;
	  }
	
	  if(typeof Buffer.compare === 'function') {
	    return Buffer.compare(a, b);
	  }
	
	  var x = a.length;
	  var y = b.length;
	  var len = Math.min(x, y);
	
	  for (var i = 0; i < len; i++) {
	    if (a[i] !== b[i]) {
	      break;
	    }
	  }
	
	  if (i !== len) {
	    x = a[i];
	    y = b[i];
	  }
	
	  return x < y ? -1 : y < x ? 1 : 0;
	}
	
	function removeFrom(server, list) {
	  for(var i = 0; i < list.length; i++) {
	    if(list[i].equals && list[i].equals(server)) {
	      list.splice(i, 1);
	      return true;
	    } else if(typeof list[i] == 'string'
	      && list[i].toLowerCase() == server.name.toLowerCase()) {
	        list.splice(i, 1);
	        return true;
	    }
	  }
	
	  return false;
	}
	
	function emitTopologyDescriptionChanged(self) {
	  if(self.listeners('topologyDescriptionChanged').length > 0) {
	    var topology = 'Unknown';
	    var setName = self.setName;
	
	    if(self.hasPrimaryAndSecondary()) {
	      topology = 'ReplicaSetWithPrimary';
	    } else if(!self.hasPrimary() && self.hasSecondary()) {
	      topology = 'ReplicaSetNoPrimary';
	    }
	
	    // Generate description
	    var description = {
	      topologyType: topology,
	      setName: setName,
	      servers: []
	    }
	
	    // Add the primary to the list
	    if(self.hasPrimary()) {
	      var desc = self.primary.getDescription();
	      desc.type = 'RSPrimary';
	      description.servers.push(desc);
	    }
	
	    // Add all the secondaries
	    description.servers = description.servers.concat(self.secondaries.map(function(x) {
	      var description = x.getDescription();
	      description.type = 'RSSecondary';
	      return description;
	    }));
	
	    // Add all the arbiters
	    description.servers = description.servers.concat(self.arbiters.map(function(x) {
	      var description = x.getDescription();
	      description.type = 'RSArbiter';
	      return description;
	    }));
	
	    // Add all the passives
	    description.servers = description.servers.concat(self.passives.map(function(x) {
	      var description = x.getDescription();
	      description.type = 'RSSecondary';
	      return description;
	    }));
	
	    // Get the diff
	    var diffResult = diff(self.replicasetDescription, description);
	
	    // Create the result
	    var result = {
	      topologyId: self.id,
	      previousDescription: self.replicasetDescription,
	      newDescription: description,
	      diff: diffResult,
	    };
	
	    // Emit the topologyDescription change
	    // if(diffResult.servers.length > 0) {
	      self.emit('topologyDescriptionChanged', result);
	    // }
	
	    // Set the new description
	    self.replicasetDescription = description;
	  }
	}
	
	module.exports = ReplSetState;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var Insert = __webpack_require__(77).Insert
	  , Update = __webpack_require__(77).Update
	  , Remove = __webpack_require__(77).Remove
	  , copy = __webpack_require__(11).copy
	  , retrieveBSON = __webpack_require__(11).retrieveBSON
	  , KillCursor = __webpack_require__(9).KillCursor
	  , GetMore = __webpack_require__(9).GetMore
	  , Query = __webpack_require__(9).Query
	  , f = __webpack_require__(1).format
	  , CommandResult = __webpack_require__(119)
	  , MongoError = __webpack_require__(7)
	  , getReadPreference = __webpack_require__(78).getReadPreference;
	
	var BSON = retrieveBSON(),
	  Long = BSON.Long;
	
	// Write concern fields
	var writeConcernFields = ['w', 'wtimeout', 'j', 'fsync'];
	
	var WireProtocol = function() {}
	
	//
	// Needs to support legacy mass insert as well as ordered/unordered legacy
	// emulation
	//
	WireProtocol.prototype.insert = function(pool, ismaster, ns, bson, ops, options, callback) {
	  options = options || {};
	  // Default is ordered execution
	  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
	  ops = Array.isArray(ops) ? ops :[ops];
	
	  // If we have more than a 1000 ops fails
	  if(ops.length > 1000) return callback(new MongoError("exceeded maximum write batch size of 1000"));
	
	  // Write concern
	  var writeConcern = options.writeConcern || {w:1};
	
	  // We are unordered
	  if(!ordered || writeConcern.w == 0) {
	    return executeUnordered('insert', Insert, ismaster, ns, bson, pool, ops, options, callback);
	  }
	
	  return executeOrdered('insert', Insert, ismaster, ns, bson, pool, ops, options, callback);
	}
	
	WireProtocol.prototype.update = function(pool, ismaster, ns, bson, ops, options, callback) {
	  options = options || {};
	  // Default is ordered execution
	  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
	  ops = Array.isArray(ops) ? ops :[ops];
	
	  // Write concern
	  var writeConcern = options.writeConcern || {w:1};
	
	  // We are unordered
	  if(!ordered || writeConcern.w == 0) {
	    return executeUnordered('update', Update, ismaster, ns, bson, pool, ops, options, callback);
	  }
	
	  return executeOrdered('update', Update, ismaster, ns, bson, pool, ops, options, callback);
	}
	
	WireProtocol.prototype.remove = function(pool, ismaster, ns, bson, ops, options, callback) {
	  options = options || {};
	  // Default is ordered execution
	  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
	  ops = Array.isArray(ops) ? ops :[ops];
	
	  // Write concern
	  var writeConcern = options.writeConcern || {w:1};
	
	  // We are unordered
	  if(!ordered || writeConcern.w == 0) {
	    return executeUnordered('remove', Remove, ismaster, ns, bson, pool, ops, options, callback);
	  }
	
	  return executeOrdered('remove', Remove, ismaster, ns, bson, pool, ops, options, callback);
	}
	
	WireProtocol.prototype.killCursor = function(bson, ns, cursorId, pool, callback) {
	  // Create a kill cursor command
	  var killCursor = new KillCursor(bson, [cursorId]);
	  // Execute the kill cursor command
	  if(pool && pool.isConnected()) {
	    pool.write(killCursor, {
	      immediateRelease:true, noResponse: true
	    });
	  }
	
	  // Callback
	  if(typeof callback == 'function') callback(null, null);
	}
	
	WireProtocol.prototype.getMore = function(bson, ns, cursorState, batchSize, raw, connection, options, callback) {
	  // Create getMore command
	  var getMore = new GetMore(bson, ns, cursorState.cursorId, {numberToReturn: batchSize});
	
	  // Query callback
	  var queryCallback = function(err, result) {
	    if(err) return callback(err);
	    // Get the raw message
	    var r = result.message;
	
	    // If we have a timed out query or a cursor that was killed
	    if((r.responseFlags & (1 << 0)) != 0) {
	      return callback(new MongoError("cursor does not exist, was killed or timed out"), null);
	    }
	
	    // Ensure we have a Long valie cursor id
	    var cursorId = typeof r.cursorId == 'number'
	      ? Long.fromNumber(r.cursorId)
	      : r.cursorId;
	
	    // Set all the values
	    cursorState.documents = r.documents;
	    cursorState.cursorId = cursorId;
	
	    // Return
	    callback(null, null, r.connection);
	  }
	
	  // Contains any query options
	  var queryOptions = {};
	
	  // If we have a raw query decorate the function
	  if(raw) {
	    queryOptions.raw = raw;
	  }
	
	  // Check if we need to promote longs
	  if(typeof cursorState.promoteLongs == 'boolean') {
	    queryOptions.promoteLongs = cursorState.promoteLongs;
	  }
	
	  if(typeof cursorState.promoteValues == 'boolean') {
	    queryOptions.promoteValues = cursorState.promoteValues;
	  }
	
	  if(typeof cursorState.promoteBuffers == 'boolean') {
	    queryOptions.promoteBuffers = cursorState.promoteBuffers;
	  }
	
	  // Write out the getMore command
	  connection.write(getMore, queryOptions, queryCallback);
	}
	
	WireProtocol.prototype.command = function(bson, ns, cmd, cursorState, topology, options) {
	  // Establish type of command
	  if(cmd.find) {
	    return setupClassicFind(bson, ns, cmd, cursorState, topology, options)
	  } else if(cursorState.cursorId != null) {
	    return;
	  } else if(cmd) {
	    return setupCommand(bson, ns, cmd, cursorState, topology, options);
	  } else {
	    throw new MongoError(f("command %s does not return a cursor", JSON.stringify(cmd)));
	  }
	}
	
	//
	// Execute a find command
	var setupClassicFind = function(bson, ns, cmd, cursorState, topology, options) {
	  // Ensure we have at least some options
	  options = options || {};
	  // Get the readPreference
	  var readPreference = getReadPreference(cmd, options);
	  // Set the optional batchSize
	  cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
	  var numberToReturn = 0;
	
	  // Unpack the limit and batchSize values
	  if(cursorState.limit == 0) {
	    numberToReturn = cursorState.batchSize;
	  } else if(cursorState.limit < 0 || cursorState.limit < cursorState.batchSize || (cursorState.limit > 0 && cursorState.batchSize == 0)) {
	    numberToReturn = cursorState.limit;
	  } else {
	    numberToReturn = cursorState.batchSize;
	  }
	
	  var numberToSkip = cursorState.skip || 0;
	  // Build actual find command
	  var findCmd = {};
	  // Using special modifier
	  var usesSpecialModifier = false;
	
	  // We have a Mongos topology, check if we need to add a readPreference
	  if(topology.type == 'mongos' && readPreference) {
	    findCmd['$readPreference'] = readPreference.toJSON();
	    usesSpecialModifier = true;
	  }
	
	  // Add special modifiers to the query
	  if(cmd.sort) findCmd['orderby'] = cmd.sort, usesSpecialModifier = true;
	  if(cmd.hint) findCmd['$hint'] = cmd.hint, usesSpecialModifier = true;
	  if(cmd.snapshot) findCmd['$snapshot'] = cmd.snapshot, usesSpecialModifier = true;
	  if(cmd.returnKey) findCmd['$returnKey'] = cmd.returnKey, usesSpecialModifier = true;
	  if(cmd.maxScan) findCmd['$maxScan'] = cmd.maxScan, usesSpecialModifier = true;
	  if(cmd.min) findCmd['$min'] = cmd.min, usesSpecialModifier = true;
	  if(cmd.max) findCmd['$max'] = cmd.max, usesSpecialModifier = true;
	  if(cmd.showDiskLoc) findCmd['$showDiskLoc'] = cmd.showDiskLoc, usesSpecialModifier = true;
	  if(cmd.comment) findCmd['$comment'] = cmd.comment, usesSpecialModifier = true;
	  if(cmd.maxTimeMS) findCmd['$maxTimeMS'] = cmd.maxTimeMS, usesSpecialModifier = true;
	
	  if(cmd.explain) {
		// nToReturn must be 0 (match all) or negative (match N and close cursor)
		// nToReturn > 0 will give explain results equivalent to limit(0)
	    numberToReturn = -Math.abs(cmd.limit || 0);
	    usesSpecialModifier = true;
	    findCmd['$explain'] = true;
	  }
	
	  // If we have a special modifier
	  if(usesSpecialModifier) {
	    findCmd['$query'] = cmd.query;
	  } else {
	    findCmd = cmd.query;
	  }
	
	  // Throw on majority readConcern passed in
	  if(cmd.readConcern && cmd.readConcern.level != 'local') {
	    throw new MongoError(f('server find command does not support a readConcern level of %s', cmd.readConcern.level));
	  }
	
	  // Remove readConcern, ensure no failing commands
	  if(cmd.readConcern) {
	    cmd = copy(cmd);
	    delete cmd['readConcern'];
	  }
	
	  // Set up the serialize and ignoreUndefined fields
	  var serializeFunctions = typeof options.serializeFunctions == 'boolean'
	    ? options.serializeFunctions : false;
	  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
	    ? options.ignoreUndefined : false;
	
	  // Build Query object
	  var query = new Query(bson, ns, findCmd, {
	      numberToSkip: numberToSkip, numberToReturn: numberToReturn
	    , checkKeys: false, returnFieldSelector: cmd.fields
	    , serializeFunctions: serializeFunctions, ignoreUndefined: ignoreUndefined
	  });
	
	  // Set query flags
	  query.slaveOk = readPreference.slaveOk();
	
	  // Set up the option bits for wire protocol
	  if(typeof cmd.tailable == 'boolean') query.tailable = cmd.tailable;
	  if(typeof cmd.oplogReplay == 'boolean') query.oplogReplay = cmd.oplogReplay;
	  if(typeof cmd.noCursorTimeout == 'boolean') query.noCursorTimeout = cmd.noCursorTimeout;
	  if(typeof cmd.awaitData == 'boolean') query.awaitData = cmd.awaitData;
	  if(typeof cmd.partial == 'boolean') query.partial = cmd.partial;
	  // Return the query
	  return query;
	}
	
	//
	// Set up a command cursor
	var setupCommand = function(bson, ns, cmd, cursorState, topology, options) {
	  // Set empty options object
	  options = options || {}
	  // Get the readPreference
	  var readPreference = getReadPreference(cmd, options);
	  // Final query
	  var finalCmd = {};
	  for(var name in cmd) {
	    finalCmd[name] = cmd[name];
	  }
	
	  // Build command namespace
	  var parts = ns.split(/\./);
	
	  // Throw on majority readConcern passed in
	  if(cmd.readConcern && cmd.readConcern.level != 'local') {
	    throw new MongoError(f('server %s command does not support a readConcern level of %s', JSON.stringify(cmd), cmd.readConcern.level));
	  }
	
	  // Remove readConcern, ensure no failing commands
	  if(cmd.readConcern) delete cmd['readConcern'];
	
	  // Serialize functions
	  var serializeFunctions = typeof options.serializeFunctions == 'boolean'
	    ? options.serializeFunctions : false;
	
	  // Set up the serialize and ignoreUndefined fields
	  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
	    ? options.ignoreUndefined : false;
	
	  // We have a Mongos topology, check if we need to add a readPreference
	  if(topology.type == 'mongos'
	    && readPreference
	    && readPreference.preference != 'primary') {
	    finalCmd = {
	      '$query': finalCmd,
	      '$readPreference': readPreference.toJSON()
	    };
	  }
	
	  // Build Query object
	  var query = new Query(bson, f('%s.$cmd', parts.shift()), finalCmd, {
	      numberToSkip: 0, numberToReturn: -1
	    , checkKeys: false, serializeFunctions: serializeFunctions
	    , ignoreUndefined: ignoreUndefined
	  });
	
	  // Set query flags
	  query.slaveOk = readPreference.slaveOk();
	
	  // Return the query
	  return query;
	}
	
	var hasWriteConcern = function(writeConcern) {
	  if(writeConcern.w
	    || writeConcern.wtimeout
	    || writeConcern.j == true
	    || writeConcern.fsync == true
	    || Object.keys(writeConcern).length == 0) {
	    return true;
	  }
	  return false;
	}
	
	var cloneWriteConcern = function(writeConcern) {
	  var wc = {};
	  if(writeConcern.w != null) wc.w = writeConcern.w;
	  if(writeConcern.wtimeout != null) wc.wtimeout = writeConcern.wtimeout;
	  if(writeConcern.j != null) wc.j = writeConcern.j;
	  if(writeConcern.fsync != null) wc.fsync = writeConcern.fsync;
	  return wc;
	}
	
	//
	// Aggregate up all the results
	//
	var aggregateWriteOperationResults = function(opType, ops, results, connection) {
	  var finalResult = { ok: 1, n: 0 }
	  if(opType == 'update') {
	    finalResult.nModified = 0;
	  }
	
	  // Map all the results coming back
	  for(var i = 0; i < results.length; i++) {
	    var result = results[i];
	    var op = ops[i];
	
	    if((result.upserted || (result.updatedExisting == false)) && finalResult.upserted == null) {
	      finalResult.upserted = [];
	    }
	
	    // Push the upserted document to the list of upserted values
	    if(result.upserted) {
	      finalResult.upserted.push({index: i, _id: result.upserted});
	    }
	
	    // We have an upsert where we passed in a _id
	    if(result.updatedExisting == false && result.n == 1 && result.upserted == null) {
	      finalResult.upserted.push({index: i, _id: op.q._id});
	    } else if(result.updatedExisting == true) {
	      finalResult.nModified += result.n;
	    }
	
	    // We have an insert command
	    if(result.ok == 1 && opType == 'insert' && result.err == null) {
	      finalResult.n = finalResult.n + 1;
	    }
	
	    // We have a command error
	    if(result != null && result.ok == 0 || result.err || result.errmsg) {
	      if(result.ok == 0) finalResult.ok = 0;
	      finalResult.code = result.code;
	      finalResult.errmsg = result.errmsg || result.err || result.errMsg;
	
	      // Check if we have a write error
	      if(result.code == 11000
	        || result.code == 11001
	        || result.code == 12582
	        || result.code == 16544
	        || result.code == 16538
	        || result.code == 16542
	        || result.code == 14
	        || result.code == 13511) {
	        if(finalResult.writeErrors == null) finalResult.writeErrors = [];
	        finalResult.writeErrors.push({
	            index: i
	          , code: result.code
	          , errmsg: result.errmsg || result.err || result.errMsg
	        });
	      } else {
	        finalResult.writeConcernError = {
	            code: result.code
	          , errmsg: result.errmsg || result.err || result.errMsg
	        }
	      }
	    } else if(typeof result.n == 'number') {
	      finalResult.n += result.n;
	    } else {
	      finalResult.n += 1;
	    }
	
	    // Result as expected
	    if(result != null && result.lastOp) finalResult.lastOp = result.lastOp;
	  }
	
	  // Return finalResult aggregated results
	  return new CommandResult(finalResult, connection);
	}
	
	//
	// Execute all inserts in an ordered manner
	//
	var executeOrdered = function(opType ,command, ismaster, ns, bson, pool, ops, options, callback) {
	  var _ops = ops.slice(0);
	  // Collect all the getLastErrors
	  var getLastErrors = [];
	  // Execute an operation
	  var executeOp = function(list, _callback) {
	    // No more items in the list
	    if(list.length == 0) {
	      return process.nextTick(function() {
	        _callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, null));
	      });
	    }
	
	    // Get the first operation
	    var doc = list.shift();
	    // Create an insert command
	    var op = new command(Query.getRequestId(), ismaster, bson, ns, [doc], options);
	    // Write concern
	    var optionWriteConcern = options.writeConcern || {w:1};
	    // Final write concern
	    var writeConcern = cloneWriteConcern(optionWriteConcern);
	
	    // Get the db name
	    var db = ns.split('.').shift();
	
	    try {
	      // Add binary message to list of commands to execute
	      var commands = [op];
	
	      // Add getLastOrdered
	      var getLastErrorCmd = {getlasterror: 1};
	      // Merge all the fields
	      for(var i = 0; i < writeConcernFields.length; i++) {
	        if(writeConcern[writeConcernFields[i]] != null) {
	          getLastErrorCmd[writeConcernFields[i]] = writeConcern[writeConcernFields[i]];
	        }
	      }
	
	      // Create a getLastError command
	      var getLastErrorOp = new Query(bson, f("%s.$cmd", db), getLastErrorCmd, {numberToReturn: -1});
	      // Add getLastError command to list of ops to execute
	      commands.push(getLastErrorOp);
	
	      // getLastError callback
	      var getLastErrorCallback = function(err, result) {
	        if(err) return callback(err);
	        // Get the document
	        var doc = result.result;
	        // Save the getLastError document
	        getLastErrors.push(doc);
	
	        // If we have an error terminate
	        if(doc.ok == 0 || doc.err || doc.errmsg) {
	          return callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, result.connection));
	        }
	
	        // Execute the next op in the list
	        executeOp(list, callback);
	      }
	
	      // Write both commands out at the same time
	      pool.write(commands, getLastErrorCallback);
	    } catch(err) {
	      // We have a serialization error, rewrite as a write error to have same behavior as modern
	      // write commands
	      getLastErrors.push({ ok: 1, errmsg: typeof err == 'string' ? err : err.message, code: 14 });
	      // Return due to an error
	      process.nextTick(function() {
	        _callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, null));
	      });
	    }
	  }
	
	  // Execute the operations
	  executeOp(_ops, callback);
	}
	
	var executeUnordered = function(opType, command, ismaster, ns, bson, pool, ops, options, callback) {
	  // Total operations to write
	  var totalOps = ops.length;
	  // Collect all the getLastErrors
	  var getLastErrors = [];
	  // Write concern
	  var optionWriteConcern = options.writeConcern || {w:1};
	  // Final write concern
	  var writeConcern = cloneWriteConcern(optionWriteConcern);
	  // Driver level error
	  var error;
	
	  // Execute all the operations
	  for(var i = 0; i < ops.length; i++) {
	    // Create an insert command
	    var op = new command(Query.getRequestId(), ismaster, bson, ns, [ops[i]], options);
	    // Get db name
	    var db = ns.split('.').shift();
	
	    try {
	      // Add binary message to list of commands to execute
	      var commands = [op];
	
	      // If write concern 0 don't fire getLastError
	      if(hasWriteConcern(writeConcern)) {
	        var getLastErrorCmd = {getlasterror: 1};
	        // Merge all the fields
	        for(var j = 0; j < writeConcernFields.length; j++) {
	          if(writeConcern[writeConcernFields[j]] != null)
	            getLastErrorCmd[writeConcernFields[j]] = writeConcern[writeConcernFields[j]];
	        }
	
	        // Create a getLastError command
	        var getLastErrorOp = new Query(bson, f("%s.$cmd", db), getLastErrorCmd, {numberToReturn: -1});
	        // Add getLastError command to list of ops to execute
	        commands.push(getLastErrorOp);
	
	        // Give the result from getLastError the right index
	        var callbackOp = function(_index) {
	          return function(err, result) {
	            if(err) error = err;
	            // Update the number of operations executed
	            totalOps = totalOps - 1;
	            // Save the getLastError document
	            if(!err) getLastErrors[_index] = result.result;
	            // Check if we are done
	            if(totalOps == 0) {
	              process.nextTick(function() {
	                if(error) return callback(error);
	                callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, result.connection));
	              });
	            }
	          }
	        }
	
	        // Write both commands out at the same time
	        pool.write(commands, callbackOp(i));
	      } else {
	        pool.write(commands, {immediateRelease:true, noResponse:true});
	      }
	    } catch(err) {
	      // Update the number of operations executed
	      totalOps = totalOps - 1;
	      // We have a serialization error, rewrite as a write error to have same behavior as modern
	      // write commands
	      getLastErrors[i] = { ok: 1, errmsg: typeof err == 'string' ? err : err.message, code: 14 };
	      // Check if we are done
	      if(totalOps == 0) {
	        callback(null, aggregateWriteOperationResults(opType, ops, getLastErrors, null));
	      }
	    }
	  }
	
	  // Empty w:0 return
	  if(writeConcern
	    && writeConcern.w == 0 && callback) {
	    callback(null, new CommandResult({ok:1}, null));
	  }
	}
	
	module.exports = WireProtocol;


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var copy = __webpack_require__(11).copy
	  , retrieveBSON = __webpack_require__(11).retrieveBSON
	  , KillCursor = __webpack_require__(9).KillCursor
	  , GetMore = __webpack_require__(9).GetMore
	  , Query = __webpack_require__(9).Query
	  , f = __webpack_require__(1).format
	  , MongoError = __webpack_require__(7)
	  , getReadPreference = __webpack_require__(78).getReadPreference;
	
	var BSON = retrieveBSON(),
	  Long = BSON.Long;
	
	var WireProtocol = function() {}
	
	//
	// Execute a write operation
	var executeWrite = function(pool, bson, type, opsField, ns, ops, options, callback) {
	  if(ops.length == 0) throw new MongoError("insert must contain at least one document");
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	    options = options || {};
	  }
	
	  // Split the ns up to get db and collection
	  var p = ns.split(".");
	  var d = p.shift();
	  // Options
	  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
	  var writeConcern = options.writeConcern;
	
	  // return skeleton
	  var writeCommand = {};
	  writeCommand[type] = p.join('.');
	  writeCommand[opsField] = ops;
	  writeCommand.ordered = ordered;
	
	  // Did we specify a write concern
	  if(writeConcern && Object.keys(writeConcern).length > 0) {
	    writeCommand.writeConcern = writeConcern;
	  }
	
	  // Do we have bypassDocumentValidation set, then enable it on the write command
	  if(typeof options.bypassDocumentValidation == 'boolean') {
	    writeCommand.bypassDocumentValidation = options.bypassDocumentValidation;
	  }
	
	  // Options object
	  var opts = { command: true };
	  var queryOptions = { checkKeys : false, numberToSkip: 0, numberToReturn: 1 };
	  if(type == 'insert') queryOptions.checkKeys = true;
	  if(typeof options.checkKeys == 'boolean') queryOptions.checkKeys = options.checkKeys;
	  // Ensure we support serialization of functions
	  if(options.serializeFunctions) queryOptions.serializeFunctions = options.serializeFunctions;
	  // Do not serialize the undefined fields
	  if(options.ignoreUndefined) queryOptions.ignoreUndefined = options.ignoreUndefined;
	
	  try {
	    // Create write command
	    var cmd = new Query(bson, f("%s.$cmd", d), writeCommand, queryOptions);
	    // Execute command
	    pool.write(cmd, opts, callback);
	  } catch(err) {
	    callback(err);
	  }
	}
	
	//
	// Needs to support legacy mass insert as well as ordered/unordered legacy
	// emulation
	//
	WireProtocol.prototype.insert = function(pool, ismaster, ns, bson, ops, options, callback) {
	  executeWrite(pool, bson, 'insert', 'documents', ns, ops, options, callback);
	}
	
	WireProtocol.prototype.update = function(pool, ismaster, ns, bson, ops, options, callback) {
	  executeWrite(pool, bson, 'update', 'updates', ns, ops, options, callback);
	}
	
	WireProtocol.prototype.remove = function(pool, ismaster, ns, bson, ops, options, callback) {
	  executeWrite(pool, bson, 'delete', 'deletes', ns, ops, options, callback);
	}
	
	WireProtocol.prototype.killCursor = function(bson, ns, cursorId, pool, callback) {
	  // Create a kill cursor command
	  var killCursor = new KillCursor(bson, [cursorId]);
	  // Execute the kill cursor command
	  if(pool && pool.isConnected()) {
	    pool.write(killCursor, {
	      immediateRelease:true, noResponse: true
	    });
	  }
	
	  // Callback
	  if(typeof callback == 'function') callback(null, null);
	}
	
	WireProtocol.prototype.getMore = function(bson, ns, cursorState, batchSize, raw, connection, options, callback) {
	  // Create getMore command
	  var getMore = new GetMore(bson, ns, cursorState.cursorId, {numberToReturn: batchSize});
	
	  // Query callback
	  var queryCallback = function(err, result) {
	    if(err) return callback(err);
	    // Get the raw message
	    var r = result.message;
	
	    // If we have a timed out query or a cursor that was killed
	    if((r.responseFlags & (1 << 0)) != 0) {
	      return callback(new MongoError("cursor does not exist, was killed or timed out"), null);
	    }
	
	    // Ensure we have a Long valie cursor id
	    var cursorId = typeof r.cursorId == 'number'
	      ? Long.fromNumber(r.cursorId)
	      : r.cursorId;
	
	    // Set all the values
	    cursorState.documents = r.documents;
	    cursorState.cursorId = cursorId;
	
	    // Return
	    callback(null, null, r.connection);
	  }
	
	  // Contains any query options
	  var queryOptions = {};
	
	  // If we have a raw query decorate the function
	  if(raw) {
	    queryOptions.raw = raw;
	  }
	
	  // Check if we need to promote longs
	  if(typeof cursorState.promoteLongs == 'boolean') {
	    queryOptions.promoteLongs = cursorState.promoteLongs;
	  }
	
	  if(typeof cursorState.promoteValues == 'boolean') {
	    queryOptions.promoteValues = cursorState.promoteValues;
	  }
	
	  if(typeof cursorState.promoteBuffers == 'boolean') {
	    queryOptions.promoteBuffers = cursorState.promoteBuffers;
	  }
	
	  // Write out the getMore command
	  connection.write(getMore, queryOptions, queryCallback);
	}
	
	WireProtocol.prototype.command = function(bson, ns, cmd, cursorState, topology, options) {
	  // Establish type of command
	  if(cmd.find) {
	    return setupClassicFind(bson, ns, cmd, cursorState, topology, options)
	  } else if(cursorState.cursorId != null) {
	    return;
	  } else if(cmd) {
	    return setupCommand(bson, ns, cmd, cursorState, topology, options);
	  } else {
	    throw new MongoError(f("command %s does not return a cursor", JSON.stringify(cmd)));
	  }
	}
	
	//
	// Execute a find command
	var setupClassicFind = function(bson, ns, cmd, cursorState, topology, options) {
	  // Ensure we have at least some options
	  options = options || {};
	  // Get the readPreference
	  var readPreference = getReadPreference(cmd, options);
	  // Set the optional batchSize
	  cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
	  var numberToReturn = 0;
	
	  // Unpack the limit and batchSize values
	  if(cursorState.limit == 0) {
	    numberToReturn = cursorState.batchSize;
	  } else if(cursorState.limit < 0 || cursorState.limit < cursorState.batchSize || (cursorState.limit > 0 && cursorState.batchSize == 0)) {
	    numberToReturn = cursorState.limit;
	  } else {
	    numberToReturn = cursorState.batchSize;
	  }
	
	  var numberToSkip = cursorState.skip || 0;
	  // Build actual find command
	  var findCmd = {};
	  // Using special modifier
	  var usesSpecialModifier = false;
	
	  // We have a Mongos topology, check if we need to add a readPreference
	  if(topology.type == 'mongos' && readPreference) {
	    findCmd['$readPreference'] = readPreference.toJSON();
	    usesSpecialModifier = true;
	  }
	
	  // Add special modifiers to the query
	  if(cmd.sort) findCmd['orderby'] = cmd.sort, usesSpecialModifier = true;
	  if(cmd.hint) findCmd['$hint'] = cmd.hint, usesSpecialModifier = true;
	  if(cmd.snapshot) findCmd['$snapshot'] = cmd.snapshot, usesSpecialModifier = true;
	  if(cmd.returnKey) findCmd['$returnKey'] = cmd.returnKey, usesSpecialModifier = true;
	  if(cmd.maxScan) findCmd['$maxScan'] = cmd.maxScan, usesSpecialModifier = true;
	  if(cmd.min) findCmd['$min'] = cmd.min, usesSpecialModifier = true;
	  if(cmd.max) findCmd['$max'] = cmd.max, usesSpecialModifier = true;
	  if(cmd.showDiskLoc) findCmd['$showDiskLoc'] = cmd.showDiskLoc, usesSpecialModifier = true;
	  if(cmd.comment) findCmd['$comment'] = cmd.comment, usesSpecialModifier = true;
	  if(cmd.maxTimeMS) findCmd['$maxTimeMS'] = cmd.maxTimeMS, usesSpecialModifier = true;
	
	  if(cmd.explain) {
		// nToReturn must be 0 (match all) or negative (match N and close cursor)
		// nToReturn > 0 will give explain results equivalent to limit(0)
	    numberToReturn = -Math.abs(cmd.limit || 0);
	    usesSpecialModifier = true;
	    findCmd['$explain'] = true;
	  }
	
	  // If we have a special modifier
	  if(usesSpecialModifier) {
	    findCmd['$query'] = cmd.query;
	  } else {
	    findCmd = cmd.query;
	  }
	
	  // Throw on majority readConcern passed in
	  if(cmd.readConcern && cmd.readConcern.level != 'local') {
	    throw new MongoError(f('server find command does not support a readConcern level of %s', cmd.readConcern.level));
	  }
	
	  // Remove readConcern, ensure no failing commands
	  if(cmd.readConcern) {
	    cmd = copy(cmd);
	    delete cmd['readConcern'];
	  }
	
	  // Serialize functions
	  var serializeFunctions = typeof options.serializeFunctions == 'boolean'
	    ? options.serializeFunctions : false;
	  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
	    ? options.ignoreUndefined : false;
	
	  // Build Query object
	  var query = new Query(bson, ns, findCmd, {
	      numberToSkip: numberToSkip, numberToReturn: numberToReturn
	    , checkKeys: false, returnFieldSelector: cmd.fields
	    , serializeFunctions: serializeFunctions
	    , ignoreUndefined: ignoreUndefined
	  });
	
	  // Set query flags
	  query.slaveOk = readPreference.slaveOk();
	
	  // Set up the option bits for wire protocol
	  if(typeof cmd.tailable == 'boolean') {
	    query.tailable = cmd.tailable;
	  }
	
	  if(typeof cmd.oplogReplay == 'boolean') {
	    query.oplogReplay = cmd.oplogReplay;
	  }
	
	  if(typeof cmd.noCursorTimeout == 'boolean') {
	    query.noCursorTimeout = cmd.noCursorTimeout;
	  }
	
	  if(typeof cmd.awaitData == 'boolean') {
	    query.awaitData = cmd.awaitData;
	  }
	
	  if(typeof cmd.partial == 'boolean') {
	    query.partial = cmd.partial;
	  }
	
	  // Return the query
	  return query;
	}
	
	//
	// Set up a command cursor
	var setupCommand = function(bson, ns, cmd, cursorState, topology, options) {
	  // Set empty options object
	  options = options || {}
	  // Get the readPreference
	  var readPreference = getReadPreference(cmd, options);
	
	  // Final query
	  var finalCmd = {};
	  for(var name in cmd) {
	    finalCmd[name] = cmd[name];
	  }
	
	  // Build command namespace
	  var parts = ns.split(/\./);
	
	  // Serialize functions
	  var serializeFunctions = typeof options.serializeFunctions == 'boolean'
	    ? options.serializeFunctions : false;
	
	  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
	    ? options.ignoreUndefined : false;
	
	  // Throw on majority readConcern passed in
	  if(cmd.readConcern && cmd.readConcern.level != 'local') {
	    throw new MongoError(f('server %s command does not support a readConcern level of %s', JSON.stringify(cmd), cmd.readConcern.level));
	  }
	
	  // Remove readConcern, ensure no failing commands
	  if(cmd.readConcern) delete cmd['readConcern'];
	
	  // We have a Mongos topology, check if we need to add a readPreference
	  if(topology.type == 'mongos'
	    && readPreference
	    && readPreference.preference != 'primary') {
	    finalCmd = {
	      '$query': finalCmd,
	      '$readPreference': readPreference.toJSON()
	    };
	  }
	
	  // Build Query object
	  var query = new Query(bson, f('%s.$cmd', parts.shift()), finalCmd, {
	      numberToSkip: 0, numberToReturn: -1
	    , checkKeys: false, serializeFunctions: serializeFunctions
	    , ignoreUndefined: ignoreUndefined
	  });
	
	  // Set query flags
	  query.slaveOk = readPreference.slaveOk();
	
	  // Return the query
	  return query;
	}
	
	module.exports = WireProtocol;


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var Query = __webpack_require__(9).Query
	  , retrieveBSON = __webpack_require__(11).retrieveBSON
	  , f = __webpack_require__(1).format
	  , MongoError = __webpack_require__(7)
	  , getReadPreference = __webpack_require__(78).getReadPreference;
	
	var BSON = retrieveBSON(),
	  Long = BSON.Long;
	
	var WireProtocol = function(legacyWireProtocol) {
	  this.legacyWireProtocol = legacyWireProtocol;
	}
	
	//
	// Execute a write operation
	var executeWrite = function(pool, bson, type, opsField, ns, ops, options, callback) {
	  if(ops.length == 0) throw new MongoError("insert must contain at least one document");
	  if(typeof options == 'function') {
	    callback = options;
	    options = {};
	    options = options || {};
	  }
	
	  // Split the ns up to get db and collection
	  var p = ns.split(".");
	  var d = p.shift();
	  // Options
	  var ordered = typeof options.ordered == 'boolean' ? options.ordered : true;
	  var writeConcern = options.writeConcern;
	
	  // return skeleton
	  var writeCommand = {};
	  writeCommand[type] = p.join('.');
	  writeCommand[opsField] = ops;
	  writeCommand.ordered = ordered;
	
	  // Did we specify a write concern
	  if(writeConcern && Object.keys(writeConcern).length > 0) {
	    writeCommand.writeConcern = writeConcern;
	  }
	
	  // If we have collation passed in
	  if(options.collation) {
	    for(var i = 0; i < writeCommand[opsField].length; i++) {
	      if(!writeCommand[opsField][i].collation) {
	        writeCommand[opsField][i].collation = options.collation;
	      }
	    }
	  }
	
	  // Do we have bypassDocumentValidation set, then enable it on the write command
	  if(typeof options.bypassDocumentValidation == 'boolean') {
	    writeCommand.bypassDocumentValidation = options.bypassDocumentValidation;
	  }
	
	  // Options object
	  var opts = { command: true };
	  var queryOptions = { checkKeys : false, numberToSkip: 0, numberToReturn: 1 };
	  if(type == 'insert') queryOptions.checkKeys = true;
	  if(typeof options.checkKeys == 'boolean') queryOptions.checkKeys = options.checkKeys;
	
	  // Ensure we support serialization of functions
	  if(options.serializeFunctions) queryOptions.serializeFunctions = options.serializeFunctions;
	  // Do not serialize the undefined fields
	  if(options.ignoreUndefined) queryOptions.ignoreUndefined = options.ignoreUndefined;
	
	  try {
	    // Create write command
	    var cmd = new Query(bson, f("%s.$cmd", d), writeCommand, queryOptions);
	    // Execute command
	    pool.write(cmd, opts, callback);
	  } catch(err) {
	    callback(err);
	  }
	}
	
	//
	// Needs to support legacy mass insert as well as ordered/unordered legacy
	// emulation
	//
	WireProtocol.prototype.insert = function(pool, ismaster, ns, bson, ops, options, callback) {
	  executeWrite(pool, bson, 'insert', 'documents', ns, ops, options, callback);
	}
	
	WireProtocol.prototype.update = function(pool, ismaster, ns, bson, ops, options, callback) {
	  executeWrite(pool, bson, 'update', 'updates', ns, ops, options, callback);
	}
	
	WireProtocol.prototype.remove = function(pool, ismaster, ns, bson, ops, options, callback) {
	  executeWrite(pool, bson, 'delete', 'deletes', ns, ops, options, callback);
	}
	
	WireProtocol.prototype.killCursor = function(bson, ns, cursorId, pool, callback) {
	  // Build command namespace
	  var parts = ns.split(/\./);
	  // Command namespace
	  var commandns = f('%s.$cmd', parts.shift());
	  // Create getMore command
	  var killcursorCmd = {
	    killCursors: parts.join('.'),
	    cursors: [cursorId]
	  }
	
	  // Build Query object
	  var query = new Query(bson, commandns, killcursorCmd, {
	      numberToSkip: 0, numberToReturn: -1
	    , checkKeys: false, returnFieldSelector: null
	  });
	
	  // Set query flags
	  query.slaveOk = true;
	
	  // Kill cursor callback
	  var killCursorCallback = function(err, result) {
	    if(err) {
	      if(typeof callback != 'function') return;
	      return callback(err);
	    }
	
	    // Result
	    var r = result.message;
	    // If we have a timed out query or a cursor that was killed
	    if((r.responseFlags & (1 << 0)) != 0) {
	      if(typeof callback != 'function') return;
	      return callback(new MongoError("cursor killed or timed out"), null);
	    }
	
	    if(!Array.isArray(r.documents) || r.documents.length == 0) {
	      if(typeof callback != 'function') return;
	      return callback(new MongoError(f('invalid killCursors result returned for cursor id %s', cursorId)));
	    }
	
	    // Return the result
	    if(typeof callback == 'function') {
	      callback(null, r.documents[0]);
	    }
	  }
	
	  // Execute the kill cursor command
	  if(pool && pool.isConnected()) {
	    pool.write(query, {
	      command: true
	    }, killCursorCallback);
	  }
	}
	
	WireProtocol.prototype.getMore = function(bson, ns, cursorState, batchSize, raw, connection, options, callback) {
	  options = options || {};
	  // Build command namespace
	  var parts = ns.split(/\./);
	  // Command namespace
	  var commandns = f('%s.$cmd', parts.shift());
	
	  // Create getMore command
	  var getMoreCmd = {
	    getMore: cursorState.cursorId,
	    collection: parts.join('.'),
	    batchSize: Math.abs(batchSize)
	  }
	
	  if(cursorState.cmd.tailable
	    && typeof cursorState.cmd.maxAwaitTimeMS == 'number') {
	    getMoreCmd.maxTimeMS = cursorState.cmd.maxAwaitTimeMS;
	  }
	
	  // Build Query object
	  var query = new Query(bson, commandns, getMoreCmd, {
	      numberToSkip: 0, numberToReturn: -1
	    , checkKeys: false, returnFieldSelector: null
	  });
	
	  // Set query flags
	  query.slaveOk = true;
	
	  // Query callback
	  var queryCallback = function(err, result) {
	    if(err) return callback(err);
	    // Get the raw message
	    var r = result.message;
	
	    // If we have a timed out query or a cursor that was killed
	    if((r.responseFlags & (1 << 0)) != 0) {
	      return callback(new MongoError("cursor killed or timed out"), null);
	    }
	
	    // Raw, return all the extracted documents
	    if(raw) {
	      cursorState.documents = r.documents;
	      cursorState.cursorId = r.cursorId;
	      return callback(null, r.documents);
	    }
	
	    // We have an error detected
	    if(r.documents[0].ok == 0) {
	      return callback(MongoError.create(r.documents[0]));
	    }
	
	    // Ensure we have a Long valid cursor id
	    var cursorId = typeof r.documents[0].cursor.id == 'number'
	      ? Long.fromNumber(r.documents[0].cursor.id)
	      : r.documents[0].cursor.id;
	
	    // Set all the values
	    cursorState.documents = r.documents[0].cursor.nextBatch;
	    cursorState.cursorId = cursorId;
	
	    // Return the result
	    callback(null, r.documents[0], r.connection);
	  }
	
	  // Query options
	  var queryOptions = { command: true };
	
	  // If we have a raw query decorate the function
	  if(raw) {
	    queryOptions.raw = raw;
	  }
	
	  // Add the result field needed
	  queryOptions.documentsReturnedIn = 'nextBatch';
	
	  // Check if we need to promote longs
	  if(typeof cursorState.promoteLongs == 'boolean') {
	    queryOptions.promoteLongs = cursorState.promoteLongs;
	  }
	
	  if(typeof cursorState.promoteValues == 'boolean') {
	    queryOptions.promoteValues = cursorState.promoteValues;
	  }
	
	  if(typeof cursorState.promoteBuffers == 'boolean') {
	    queryOptions.promoteBuffers = cursorState.promoteBuffers;
	  }
	
	  // Write out the getMore command
	  connection.write(query, queryOptions, queryCallback);
	}
	
	WireProtocol.prototype.command = function(bson, ns, cmd, cursorState, topology, options) {
	  options = options || {}
	  // Check if this is a wire protocol command or not
	  var wireProtocolCommand = typeof options.wireProtocolCommand == 'boolean' ? options.wireProtocolCommand : true;
	
	  // Establish type of command
	  if(cmd.find && wireProtocolCommand) {
	    // Create the find command
	    var query = executeFindCommand(bson, ns, cmd, cursorState, topology, options)
	    // Mark the cmd as virtual
	    cmd.virtual = false;
	    // Signal the documents are in the firstBatch value
	    query.documentsReturnedIn = 'firstBatch';
	    // Return the query
	    return query;
	  } else if(cursorState.cursorId != null) {
	    return;
	  } else if(cmd) {
	    return setupCommand(bson, ns, cmd, cursorState, topology, options);
	  } else {
	    throw new MongoError(f("command %s does not return a cursor", JSON.stringify(cmd)));
	  }
	}
	
	// // Command
	// {
	//     find: ns
	//   , query: <object>
	//   , limit: <n>
	//   , fields: <object>
	//   , skip: <n>
	//   , hint: <string>
	//   , explain: <boolean>
	//   , snapshot: <boolean>
	//   , batchSize: <n>
	//   , returnKey: <boolean>
	//   , maxScan: <n>
	//   , min: <n>
	//   , max: <n>
	//   , showDiskLoc: <boolean>
	//   , comment: <string>
	//   , maxTimeMS: <n>
	//   , raw: <boolean>
	//   , readPreference: <ReadPreference>
	//   , tailable: <boolean>
	//   , oplogReplay: <boolean>
	//   , noCursorTimeout: <boolean>
	//   , awaitdata: <boolean>
	//   , exhaust: <boolean>
	//   , partial: <boolean>
	// }
	
	// FIND/GETMORE SPEC
	// {
	//     find: <string>,
	//     filter: { ... },
	//     sort: { ... },
	//     projection: { ... },
	//     hint: { ... },
	//     skip: <int>,
	//     limit: <int>,
	//     batchSize: <int>,
	//     singleBatch: <bool>,
	//     comment: <string>,
	//     maxScan: <int>,
	//     maxTimeMS: <int>,
	//     max: { ... },
	//     min: { ... },
	//     returnKey: <bool>,
	//     showRecordId: <bool>,
	//     snapshot: <bool>,
	//     tailable: <bool>,
	//     oplogReplay: <bool>,
	//     noCursorTimeout: <bool>,
	//     awaitData: <bool>,
	//     partial: <bool>,
	//     $readPreference: { ... }
	// }
	
	//
	// Execute a find command
	var executeFindCommand = function(bson, ns, cmd, cursorState, topology, options) {
	  // Ensure we have at least some options
	  options = options || {};
	  // Get the readPreference
	  var readPreference = getReadPreference(cmd, options);
	  // Set the optional batchSize
	  cursorState.batchSize = cmd.batchSize || cursorState.batchSize;
	
	  // Build command namespace
	  var parts = ns.split(/\./);
	  // Command namespace
	  var commandns = f('%s.$cmd', parts.shift());
	
	  // Build actual find command
	  var findCmd = {
	    find: parts.join('.')
	  };
	
	  // I we provided a filter
	  if(cmd.query) {
	    // Check if the user is passing in the $query parameter
	    if(cmd.query['$query']) {
	      findCmd.filter = cmd.query['$query'];
	    } else {
	      findCmd.filter = cmd.query;
	    }
	  }
	
	  // Sort value
	  var sortValue = cmd.sort;
	
	  // Handle issue of sort being an Array
	  if(Array.isArray(sortValue)) {
	    var sortObject = {};
	
	    if(sortValue.length > 0 && !Array.isArray(sortValue[0])) {
	      var sortDirection = sortValue[1];
	      // Translate the sort order text
	      if(sortDirection == 'asc') {
	        sortDirection = 1;
	      } else if(sortDirection == 'desc') {
	        sortDirection = -1;
	      }
	
	      // Set the sort order
	      sortObject[sortValue[0]] = sortDirection;
	    } else {
	      for(var i = 0; i < sortValue.length; i++) {
	        sortDirection = sortValue[i][1];
	        // Translate the sort order text
	        if(sortDirection == 'asc') {
	          sortDirection = 1;
	        } else if(sortDirection == 'desc') {
	          sortDirection = -1;
	        }
	
	        // Set the sort order
	        sortObject[sortValue[i][0]] = sortDirection;
	      }
	    }
	
	    sortValue = sortObject;
	  }
	
	  // Add sort to command
	  if(cmd.sort) findCmd.sort = sortValue;
	  // Add a projection to the command
	  if(cmd.fields) findCmd.projection = cmd.fields;
	  // Add a hint to the command
	  if(cmd.hint) findCmd.hint = cmd.hint;
	  // Add a skip
	  if(cmd.skip) findCmd.skip = cmd.skip;
	  // Add a limit
	  if(cmd.limit) findCmd.limit = cmd.limit;
	
	  // Check if we wish to have a singleBatch
	  if(cmd.limit < 0) {
	    findCmd.limit = Math.abs(cmd.limit);
	    findCmd.singleBatch = true;
	  }
	
	  // Add a batchSize
	  if(typeof cmd.batchSize == 'number') {
	    if (cmd.batchSize < 0) {
	      if (cmd.limit != 0 && Math.abs(cmd.batchSize) < Math.abs(cmd.limit)) {
	        findCmd.limit = Math.abs(cmd.batchSize);
	      }
	
	      findCmd.singleBatch = true;
	    }
	
	    findCmd.batchSize = Math.abs(cmd.batchSize);
	  }
	
	  // If we have comment set
	  if(cmd.comment) findCmd.comment = cmd.comment;
	
	  // If we have maxScan
	  if(cmd.maxScan) findCmd.maxScan = cmd.maxScan;
	
	  // If we have maxTimeMS set
	  if(cmd.maxTimeMS) findCmd.maxTimeMS = cmd.maxTimeMS;
	
	  // If we have min
	  if(cmd.min) findCmd.min = cmd.min;
	
	  // If we have max
	  if(cmd.max) findCmd.max = cmd.max;
	
	  // If we have returnKey set
	  if(cmd.returnKey) findCmd.returnKey = cmd.returnKey;
	
	  // If we have showDiskLoc set
	  if(cmd.showDiskLoc) findCmd.showRecordId = cmd.showDiskLoc;
	
	  // If we have snapshot set
	  if(cmd.snapshot) findCmd.snapshot = cmd.snapshot;
	
	  // If we have tailable set
	  if(cmd.tailable) findCmd.tailable = cmd.tailable;
	
	  // If we have oplogReplay set
	  if(cmd.oplogReplay) findCmd.oplogReplay = cmd.oplogReplay;
	
	  // If we have noCursorTimeout set
	  if(cmd.noCursorTimeout) findCmd.noCursorTimeout = cmd.noCursorTimeout;
	
	  // If we have awaitData set
	  if(cmd.awaitData) findCmd.awaitData = cmd.awaitData;
	  if(cmd.awaitdata) findCmd.awaitData = cmd.awaitdata;
	
	  // If we have partial set
	  if(cmd.partial) findCmd.partial = cmd.partial;
	
	  // If we have collation passed in
	  if(cmd.collation) findCmd.collation = cmd.collation;
	
	  // If we have explain, we need to rewrite the find command
	  // to wrap it in the explain command
	  if(cmd.explain) {
	    findCmd = {
	      explain: findCmd
	    }
	  }
	
	  // Did we provide a readConcern
	  if(cmd.readConcern) findCmd.readConcern = cmd.readConcern;
	
	  // Set up the serialize and ignoreUndefined fields
	  var serializeFunctions = typeof options.serializeFunctions == 'boolean'
	    ? options.serializeFunctions : false;
	  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
	    ? options.ignoreUndefined : false;
	
	  // We have a Mongos topology, check if we need to add a readPreference
	  if(topology.type == 'mongos'
	    && readPreference
	    && readPreference.preference != 'primary') {
	    findCmd = {
	      '$query': findCmd,
	      '$readPreference': readPreference.toJSON()
	    };
	  }
	
	  // Build Query object
	  var query = new Query(bson, commandns, findCmd, {
	      numberToSkip: 0, numberToReturn: 1
	    , checkKeys: false, returnFieldSelector: null
	    , serializeFunctions: serializeFunctions, ignoreUndefined: ignoreUndefined
	  });
	
	  // Set query flags
	  query.slaveOk = readPreference.slaveOk();
	
	  // Return the query
	  return query;
	}
	
	//
	// Set up a command cursor
	var setupCommand = function(bson, ns, cmd, cursorState, topology, options) {
	  // Set empty options object
	  options = options || {}
	  // Get the readPreference
	  var readPreference = getReadPreference(cmd, options);
	
	  // Final query
	  var finalCmd = {};
	  for(var name in cmd) {
	    finalCmd[name] = cmd[name];
	  }
	
	  // Build command namespace
	  var parts = ns.split(/\./);
	
	  // Serialize functions
	  var serializeFunctions = typeof options.serializeFunctions == 'boolean'
	    ? options.serializeFunctions : false;
	
	  // Set up the serialize and ignoreUndefined fields
	  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean'
	    ? options.ignoreUndefined : false;
	
	  // We have a Mongos topology, check if we need to add a readPreference
	  if(topology.type == 'mongos'
	    && readPreference
	    && readPreference.preference != 'primary') {
	    finalCmd = {
	      '$query': finalCmd,
	      '$readPreference': readPreference.toJSON()
	    };
	  }
	
	  // Build Query object
	  var query = new Query(bson, f('%s.$cmd', parts.shift()), finalCmd, {
	      numberToSkip: 0, numberToReturn: -1
	    , checkKeys: false, serializeFunctions: serializeFunctions
	    , ignoreUndefined: ignoreUndefined
	  });
	
	  // Set query flags
	  query.slaveOk = readPreference.slaveOk();
	
	  // Return the query
	  return query;
	}
	
	module.exports = WireProtocol;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	var EventEmitter = __webpack_require__(6).EventEmitter,
	  inherits = __webpack_require__(1).inherits;
	
	// Get prototypes
	var AggregationCursor = __webpack_require__(27),
	  CommandCursor = __webpack_require__(23),
	  OrderedBulkOperation = __webpack_require__(80).OrderedBulkOperation,
	  UnorderedBulkOperation = __webpack_require__(81).UnorderedBulkOperation,
	  GridStore = __webpack_require__(124),
	  Cursor = __webpack_require__(17),
	  Collection = __webpack_require__(59),
	  Db = __webpack_require__(82);
	
	var basicOperationIdGenerator = {
	  operationId: 1,
	
	  next: function() {
	    return this.operationId++;
	  }
	}
	
	var basicTimestampGenerator = {
	  current: function() {
	    return new Date().getTime();
	  },
	
	  duration: function(start, end) {
	    return end - start;
	  }
	}
	
	var senstiveCommands = ['authenticate', 'saslStart', 'saslContinue', 'getnonce',
	  'createUser', 'updateUser', 'copydbgetnonce', 'copydbsaslstart', 'copydb'];
	
	var Instrumentation = function(core, options, callback) {
	  options = options || {};
	
	  // Optional id generators
	  var operationIdGenerator = options.operationIdGenerator || basicOperationIdGenerator;
	  // Optional timestamp generator
	  var timestampGenerator = options.timestampGenerator || basicTimestampGenerator;
	  // Extend with event emitter functionality
	  EventEmitter.call(this);
	
	  // Contains all the instrumentation overloads
	  this.overloads = [];
	
	  // ---------------------------------------------------------
	  //
	  // Instrument prototype
	  //
	  // ---------------------------------------------------------
	
	  var instrumentPrototype = function(callback) {
	    var instrumentations = []
	
	    // Classes to support
	    var classes = [GridStore, OrderedBulkOperation, UnorderedBulkOperation,
	      CommandCursor, AggregationCursor, Cursor, Collection, Db];
	
	    // Add instrumentations to the available list
	    for(var i = 0; i < classes.length; i++) {
	      if(classes[i].define) {
	        instrumentations.push(classes[i].define.generate());
	      }
	    }
	
	    // Return the list of instrumentation points
	    callback(null, instrumentations);
	  }
	
	  // Did the user want to instrument the prototype
	  if(typeof callback == 'function') {
	    instrumentPrototype(callback);
	  }
	
	  // ---------------------------------------------------------
	  //
	  // Server
	  //
	  // ---------------------------------------------------------
	
	  // Reference
	  var self = this;
	  // Names of methods we need to wrap
	  var methods = ['command', 'insert', 'update', 'remove'];
	  // Prototype
	  var proto = core.Server.prototype;
	  // Core server method we are going to wrap
	  methods.forEach(function(x) {
	    var func = proto[x];
	
	    // Add to overloaded methods
	    self.overloads.push({proto: proto, name:x, func:func});
	
	    // The actual prototype
	    proto[x] = function() {
	      var requestId = core.Query.nextRequestId();
	      // Get the aruments
	      var args = Array.prototype.slice.call(arguments, 0);
	      var ns = args[0];
	      var commandObj = args[1];
	      var options = args[2] || {};
	      var keys = Object.keys(commandObj);
	      var commandName = keys[0];
	      var db = ns.split('.')[0];
	
	      // Get the collection
	      var col = ns.split('.');
	      col.shift();
	      col = col.join('.');
	
	      // Do we have a legacy insert/update/remove command
	      if(x == 'insert') { //} && !this.lastIsMaster().maxWireVersion) {
	        commandName = 'insert';
	
	        // Re-write the command
	        commandObj = {
	          insert: col, documents: commandObj
	        }
	
	        if(options.writeConcern && Object.keys(options.writeConcern).length > 0)  {
	          commandObj.writeConcern = options.writeConcern;
	        }
	
	        commandObj.ordered = options.ordered != undefined ? options.ordered : true;
	      } else if(x == 'update') { // && !this.lastIsMaster().maxWireVersion) {
	        commandName = 'update';
	
	        // Re-write the command
	        commandObj = {
	          update: col, updates: commandObj
	        }
	
	        if(options.writeConcern && Object.keys(options.writeConcern).length > 0) {
	          commandObj.writeConcern = options.writeConcern;
	        }
	
	        commandObj.ordered = options.ordered != undefined ? options.ordered : true;
	      } else if(x == 'remove') { //&& !this.lastIsMaster().maxWireVersion) {
	        commandName = 'delete';
	
	        // Re-write the command
	        commandObj = {
	          delete: col, deletes: commandObj
	        }
	
	        if(options.writeConcern && Object.keys(options.writeConcern).length > 0) {
	          commandObj.writeConcern = options.writeConcern;
	        }
	
	        commandObj.ordered = options.ordered != undefined ? options.ordered : true;
	      }
	
	      // Get the callback
	      var callback = args.pop();
	      // Set current callback operation id from the current context or create
	      // a new one
	      var ourOpId = callback.operationId || operationIdGenerator.next();
	
	      // Get a connection reference for this server instance
	      var connection = this.s.pool.get()
	
	      // Emit the start event for the command
	      var command = {
	        // Returns the command.
	        command: commandObj,
	        // Returns the database name.
	        databaseName: db,
	        // Returns the command name.
	        commandName: commandName,
	        // Returns the driver generated request id.
	        requestId: requestId,
	        // Returns the driver generated operation id.
	        // This is used to link events together such as bulk write operations. OPTIONAL.
	        operationId: ourOpId,
	        // Returns the connection id for the command. For languages that do not have this,
	        // this MUST return the driver equivalent which MUST include the server address and port.
	        // The name of this field is flexible to match the object that is returned from the driver.
	        connectionId: connection
	      };
	
	      // Filter out any sensitive commands
	      if(senstiveCommands.indexOf(commandName.toLowerCase()) != -1) {
	        command.commandObj = {};
	        command.commandObj[commandName] = true;
	      }
	
	      // Emit the started event
	      self.emit('started', command)
	
	      // Start time
	      var startTime = timestampGenerator.current();
	
	      // Push our handler callback
	      args.push(function(err, r) {
	        var endTime = timestampGenerator.current();
	        var command = {
	          duration: timestampGenerator.duration(startTime, endTime),
	          commandName: commandName,
	          requestId: requestId,
	          operationId: ourOpId,
	          connectionId: connection
	        };
	
	        // If we have an error
	        if(err || (r && r.result && r.result.ok == 0)) {
	          command.failure = err || r.result.writeErrors || r.result;
	
	          // Filter out any sensitive commands
	          if(senstiveCommands.indexOf(commandName.toLowerCase()) != -1) {
	            command.failure = {};
	          }
	
	          self.emit('failed', command);
	        } else if(commandObj && commandObj.writeConcern
	          && commandObj.writeConcern.w == 0) {
	          // If we have write concern 0
	          command.reply = {ok:1};
	          self.emit('succeeded', command);
	        } else {
	          command.reply = r && r.result ? r.result : r;
	
	          // Filter out any sensitive commands
	          if(senstiveCommands.indexOf(commandName.toLowerCase()) != -1) {
	            command.reply = {};
	          }
	
	          self.emit('succeeded', command);
	        }
	
	        // Return to caller
	        callback(err, r);
	      });
	
	      // Apply the call
	      func.apply(this, args);
	    }
	  });
	
	  // ---------------------------------------------------------
	  //
	  // Bulk Operations
	  //
	  // ---------------------------------------------------------
	
	  // Inject ourselves into the Bulk methods
	  methods = ['execute'];
	  var prototypes = [
	    __webpack_require__(80).Bulk.prototype,
	    __webpack_require__(81).Bulk.prototype
	  ]
	
	  prototypes.forEach(function(proto) {
	    // Core server method we are going to wrap
	    methods.forEach(function(x) {
	      var func = proto[x];
	
	      // Add to overloaded methods
	      self.overloads.push({proto: proto, name:x, func:func});
	
	      // The actual prototype
	      proto[x] = function() {
	        // Get the aruments
	        var args = Array.prototype.slice.call(arguments, 0);
	        // Set an operation Id on the bulk object
	        this.operationId = operationIdGenerator.next();
	
	        // Get the callback
	        var callback = args.pop();
	        // If we have a callback use this
	        if(typeof callback == 'function') {
	          args.push(function(err, r) {
	            // Return to caller
	            callback(err, r);
	          });
	
	          // Apply the call
	          func.apply(this, args);
	        } else {
	          return func.apply(this, args);
	        }
	      }
	    });
	  });
	
	  // ---------------------------------------------------------
	  //
	  // Cursor
	  //
	  // ---------------------------------------------------------
	
	  // Inject ourselves into the Cursor methods
	  methods = ['_find', '_getmore', '_killcursor'];
	  prototypes = [
	    __webpack_require__(17).prototype,
	    __webpack_require__(23).prototype,
	    __webpack_require__(27).prototype
	  ]
	
	  // Command name translation
	  var commandTranslation = {
	    '_find': 'find', '_getmore': 'getMore', '_killcursor': 'killCursors', '_explain': 'explain'
	  }
	
	  prototypes.forEach(function(proto) {
	
	    // Core server method we are going to wrap
	    methods.forEach(function(x) {
	      var func = proto[x];
	
	      // Add to overloaded methods
	      self.overloads.push({proto: proto, name:x, func:func});
	
	      // The actual prototype
	      proto[x] = function() {
	        var cursor = this;
	        var requestId = core.Query.nextRequestId();
	        var ourOpId = operationIdGenerator.next();
	        var parts = this.ns.split('.');
	        var db = parts[0];
	
	        // Get the collection
	        parts.shift();
	        var collection = parts.join('.');
	
	        // Set the command
	        var command = this.query;
	        var cmd = this.s.cmd;
	
	        // If we have a find method, set the operationId on the cursor
	        if(x == '_find') {
	          cursor.operationId = ourOpId;
	        }
	
	        // Do we have a find command rewrite it
	        if(x == '_getmore') {
	          command = {
	            getMore: this.cursorState.cursorId,
	            collection: collection,
	            batchSize: cmd.batchSize
	          }
	
	          if(cmd.maxTimeMS) command.maxTimeMS = cmd.maxTimeMS;
	        } else if(x == '_killcursor') {
	          command = {
	            killCursors: collection,
	            cursors: [this.cursorState.cursorId]
	          }
	        } else if(cmd.find) {
	          command = {
	            find: collection, filter: cmd.query
	          }
	
	          if(cmd.sort) command.sort = cmd.sort;
	          if(cmd.fields) command.projection = cmd.fields;
	          if(cmd.limit && cmd.limit < 0) {
	            command.limit = Math.abs(cmd.limit);
	            command.singleBatch = true;
	          } else if(cmd.limit) {
	            command.limit = Math.abs(cmd.limit);
	          }
	
	          // Options
	          if(cmd.skip) command.skip = cmd.skip;
	          if(cmd.hint) command.hint = cmd.hint;
	          if(cmd.batchSize) command.batchSize = cmd.batchSize;
	          if(typeof cmd.returnKey == 'boolean') command.returnKey = cmd.returnKey;
	          if(cmd.comment) command.comment = cmd.comment;
	          if(cmd.min) command.min = cmd.min;
	          if(cmd.max) command.max = cmd.max;
	          if(cmd.maxScan) command.maxScan = cmd.maxScan;
	          if(cmd.maxTimeMS) command.maxTimeMS = cmd.maxTimeMS;
	
	          // Flags
	          if(typeof cmd.awaitData == 'boolean') command.awaitData = cmd.awaitData;
	          if(typeof cmd.snapshot == 'boolean') command.snapshot = cmd.snapshot;
	          if(typeof cmd.tailable == 'boolean') command.tailable = cmd.tailable;
	          if(typeof cmd.oplogReplay == 'boolean') command.oplogReplay = cmd.oplogReplay;
	          if(typeof cmd.noCursorTimeout == 'boolean') command.noCursorTimeout = cmd.noCursorTimeout;
	          if(typeof cmd.partial == 'boolean') command.partial = cmd.partial;
	          if(typeof cmd.showDiskLoc == 'boolean') command.showRecordId = cmd.showDiskLoc;
	
	          // Read Concern
	          if(cmd.readConcern) command.readConcern = cmd.readConcern;
	
	          // Override method
	          if(cmd.explain) command.explain = cmd.explain;
	          if(cmd.exhaust) command.exhaust = cmd.exhaust;
	
	          // If we have a explain flag
	          if(cmd.explain) {
	            // Create fake explain command
	            command = {
	              explain: command,
	              verbosity: 'allPlansExecution'
	            }
	
	            // Set readConcern on the command if available
	            if(cmd.readConcern) command.readConcern = cmd.readConcern
	
	            // Set up the _explain name for the command
	            x = '_explain';
	          }
	        } else {
	          command = cmd;
	        }
	
	        // Set up the connection
	        var connectionId = null;
	
	        // Set local connection
	        if(this.connection) connectionId = this.connection;
	        if(!connectionId && this.server && this.server.getConnection) connectionId = this.server.getConnection();
	
	        // Get the command Name
	        var commandName = x == '_find' ? Object.keys(command)[0] : commandTranslation[x];
	
	        // Emit the start event for the command
	        command = {
	          // Returns the command.
	          command: command,
	          // Returns the database name.
	          databaseName: db,
	          // Returns the command name.
	          commandName: commandName,
	          // Returns the driver generated request id.
	          requestId: requestId,
	          // Returns the driver generated operation id.
	          // This is used to link events together such as bulk write operations. OPTIONAL.
	          operationId: this.operationId,
	          // Returns the connection id for the command. For languages that do not have this,
	          // this MUST return the driver equivalent which MUST include the server address and port.
	          // The name of this field is flexible to match the object that is returned from the driver.
	          connectionId: connectionId
	        };
	
	        // Get the aruments
	        var args = Array.prototype.slice.call(arguments, 0);
	
	        // Get the callback
	        var callback = args.pop();
	
	        // We do not have a callback but a Promise
	        if(typeof callback == 'function' || command.commandName == 'killCursors') {
	          var startTime = timestampGenerator.current();
	          // Emit the started event
	          self.emit('started', command)
	
	          // Emit succeeded event with killcursor if we have a legacy protocol
	          if(command.commandName == 'killCursors'
	            && this.server.lastIsMaster()
	            && this.server.lastIsMaster().maxWireVersion < 4) {
	            // Emit the succeeded command
	            command = {
	              duration: timestampGenerator.duration(startTime, timestampGenerator.current()),
	              commandName: commandName,
	              requestId: requestId,
	              operationId: cursor.operationId,
	              connectionId: cursor.server.getConnection(),
	              reply: [{ok:1}]
	            };
	
	            // Apply callback to the list of args
	            args.push(callback);
	            // Apply the call
	            func.apply(this, args);
	            // Emit the command
	            return self.emit('succeeded', command)
	          }
	
	          // Add our callback handler
	          args.push(function(err, r) {
	            if(err) {
	              // Command
	              var command = {
	                duration: timestampGenerator.duration(startTime, timestampGenerator.current()),
	                commandName: commandName,
	                requestId: requestId,
	                operationId: ourOpId,
	                connectionId: cursor.server.getConnection(),
	                failure: err };
	
	              // Emit the command
	              self.emit('failed', command)
	            } else {
	              // Do we have a getMore
	              if(commandName.toLowerCase() == 'getmore' && r == null) {
	                r = {
	                  cursor: {
	                    id: cursor.cursorState.cursorId,
	                    ns: cursor.ns,
	                    nextBatch: cursor.cursorState.documents
	                  }, ok:1
	                }
	              } else if((commandName.toLowerCase() == 'find' 
	                || commandName.toLowerCase() == 'aggregate'
	                || commandName.toLowerCase() == 'listcollections') && r == null) {
	                r = {
	                  cursor: {
	                    id: cursor.cursorState.cursorId,
	                    ns: cursor.ns,
	                    firstBatch: cursor.cursorState.documents
	                  }, ok:1
	                }
	              } else if(commandName.toLowerCase() == 'killcursors' && r == null) {
	                r = {
	                  cursorsUnknown:[cursor.cursorState.lastCursorId],
	                  ok:1
	                }
	              }
	
	              // cursor id is zero, we can issue success command
	              command = {
	                duration: timestampGenerator.duration(startTime, timestampGenerator.current()),
	                commandName: commandName,
	                requestId: requestId,
	                operationId: cursor.operationId,
	                connectionId: cursor.server.getConnection(),
	                reply: r && r.result ? r.result : r
	              };
	
	              // Emit the command
	              self.emit('succeeded', command)
	            }
	
	            // Return
	            if(!callback) return;
	
	            // Return to caller
	            callback(err, r);
	          });
	
	          // Apply the call
	          func.apply(this, args);
	        } else {
	          // Assume promise, push back the missing value
	          args.push(callback);
	          // Get the promise
	          var promise = func.apply(this, args);
	          // Return a new promise
	          return new cursor.s.promiseLibrary(function(resolve, reject) {
	            var startTime = timestampGenerator.current();
	            // Emit the started event
	            self.emit('started', command)
	            // Execute the function
	            promise.then(function() {
	              // cursor id is zero, we can issue success command
	              var command = {
	                duration: timestampGenerator.duration(startTime, timestampGenerator.current()),
	                commandName: commandName,
	                requestId: requestId,
	                operationId: cursor.operationId,
	                connectionId: cursor.server.getConnection(),
	                reply: cursor.cursorState.documents
	              };
	
	              // Emit the command
	              self.emit('succeeded', command)
	            }).catch(function(err) {
	              // Command
	              var command = {
	                duration: timestampGenerator.duration(startTime, timestampGenerator.current()),
	                commandName: commandName,
	                requestId: requestId,
	                operationId: ourOpId,
	                connectionId: cursor.server.getConnection(),
	                failure: err };
	
	              // Emit the command
	              self.emit('failed', command)
	              // reject the promise
	              reject(err);
	            });
	          });
	        }
	      }
	    });
	  });
	}
	
	inherits(Instrumentation, EventEmitter);
	
	Instrumentation.prototype.uninstrument = function() {
	  for(var i = 0; i < this.overloads.length; i++) {
	    var obj = this.overloads[i];
	    obj.proto[obj.name] = obj.func;
	  }
	
	  // Remove all listeners
	  this.removeAllListeners('started');
	  this.removeAllListeners('succeeded');
	  this.removeAllListeners('failed');
	}
	
	module.exports = Instrumentation;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	var stream = __webpack_require__(18),
	  util = __webpack_require__(1);
	
	module.exports = GridFSBucketReadStream;
	
	/**
	 * A readable stream that enables you to read buffers from GridFS.
	 *
	 * Do not instantiate this class directly. Use `openDownloadStream()` instead.
	 *
	 * @class
	 * @param {Collection} chunks Handle for chunks collection
	 * @param {Collection} files Handle for files collection
	 * @param {Object} readPreference The read preference to use
	 * @param {Object} filter The query to use to find the file document
	 * @param {Object} [options=null] Optional settings.
	 * @param {Number} [options.sort=null] Optional sort for the file find query
	 * @param {Number} [options.skip=null] Optional skip for the file find query
	 * @param {Number} [options.start=null] Optional 0-based offset in bytes to start streaming from
	 * @param {Number} [options.end=null] Optional 0-based offset in bytes to stop streaming before
	 * @fires GridFSBucketReadStream#error
	 * @fires GridFSBucketReadStream#file
	 * @return {GridFSBucketReadStream} a GridFSBucketReadStream instance.
	 */
	
	function GridFSBucketReadStream(chunks, files, readPreference, filter, options) {
	  this.s = {
	    bytesRead: 0,
	    chunks: chunks,
	    cursor: null,
	    expected: 0,
	    files: files,
	    filter: filter,
	    init: false,
	    expectedEnd: 0,
	    file: null,
	    options: options,
	    readPreference: readPreference
	  };
	
	  stream.Readable.call(this);
	}
	
	util.inherits(GridFSBucketReadStream, stream.Readable);
	
	/**
	 * An error occurred
	 *
	 * @event GridFSBucketReadStream#error
	 * @type {Error}
	 */
	
	/**
	 * Fires when the stream loaded the file document corresponding to the
	 * provided id.
	 *
	 * @event GridFSBucketReadStream#file
	 * @type {object}
	 */
	
	/**
	 * Emitted when a chunk of data is available to be consumed.
	 *
	 * @event GridFSBucketReadStream#data
	 * @type {object}
	 */
	
	/**
	 * Fired when the stream is exhausted (no more data events).
	 *
	 * @event GridFSBucketReadStream#end
	 * @type {object}
	 */
	
	/**
	 * Fired when the stream is exhausted and the underlying cursor is killed
	 *
	 * @event GridFSBucketReadStream#close
	 * @type {object}
	 */
	
	/**
	 * Reads from the cursor and pushes to the stream.
	 * @method
	 */
	
	GridFSBucketReadStream.prototype._read = function() {
	  var _this = this;
	  if (this.destroyed) {
	    return;
	  }
	
	  waitForFile(_this, function() {
	    doRead(_this);
	  });
	};
	
	/**
	 * Sets the 0-based offset in bytes to start streaming from. Throws
	 * an error if this stream has entered flowing mode
	 * (e.g. if you've already called `on('data')`)
	 * @method
	 * @param {Number} start Offset in bytes to start reading at
	 * @return {GridFSBucketReadStream}
	 */
	
	GridFSBucketReadStream.prototype.start = function(start) {
	  throwIfInitialized(this);
	  this.s.options.start = start;
	  return this;
	};
	
	/**
	 * Sets the 0-based offset in bytes to start streaming from. Throws
	 * an error if this stream has entered flowing mode
	 * (e.g. if you've already called `on('data')`)
	 * @method
	 * @param {Number} end Offset in bytes to stop reading at
	 * @return {GridFSBucketReadStream}
	 */
	
	GridFSBucketReadStream.prototype.end = function(end) {
	  throwIfInitialized(this);
	  this.s.options.end = end;
	  return this;
	};
	
	/**
	 * Marks this stream as aborted (will never push another `data` event)
	 * and kills the underlying cursor. Will emit the 'end' event, and then
	 * the 'close' event once the cursor is successfully killed.
	 *
	 * @method
	 * @param {GridFSBucket~errorCallback} [callback] called when the cursor is successfully closed or an error occurred.
	 * @fires GridFSBucketWriteStream#close
	 * @fires GridFSBucketWriteStream#end
	 */
	
	GridFSBucketReadStream.prototype.abort = function(callback) {
	  var _this = this;
	  this.push(null);
	  this.destroyed = true;
	  if (this.s.cursor) {
	    this.s.cursor.close(function(error) {
	      _this.emit('close');
	      callback && callback(error);
	    });
	  } else {
	    if (!this.s.init) {
	      // If not initialized, fire close event because we will never
	      // get a cursor
	      _this.emit('close');
	    }
	    callback && callback();
	  }
	};
	
	/**
	 * @ignore
	 */
	
	function throwIfInitialized(self) {
	  if (self.s.init) {
	    throw new Error('You cannot change options after the stream has entered' +
	      'flowing mode!');
	  }
	}
	
	/**
	 * @ignore
	 */
	
	function doRead(_this) {
	  if (_this.destroyed) {
	    return;
	  }
	
	  _this.s.cursor.next(function(error, doc) {
	    if (_this.destroyed) {
	      return;
	    }
	    if (error) {
	      return __handleError(_this, error);
	    }
	    if (!doc) {
	      _this.push(null);
	      return _this.s.cursor.close(function(error) {
	        if (error) {
	          return __handleError(_this, error);
	        }
	        _this.emit('close');
	      });
	    }
	
	    var bytesRemaining = _this.s.file.length - _this.s.bytesRead;
	    var expectedN = _this.s.expected++;
	    var expectedLength = Math.min(_this.s.file.chunkSize,
	      bytesRemaining);
	
	    if (doc.n > expectedN) {
	      var errmsg = 'ChunkIsMissing: Got unexpected n: ' + doc.n +
	        ', expected: ' + expectedN;
	      return __handleError(_this, new Error(errmsg));
	    }
	
	    if (doc.n < expectedN) {
	      errmsg = 'ExtraChunk: Got unexpected n: ' + doc.n +
	        ', expected: ' + expectedN;
	      return __handleError(_this, new Error(errmsg));
	    }
	
	    if (doc.data.length() !== expectedLength) {
	      if (bytesRemaining <= 0) {
	        errmsg = 'ExtraChunk: Got unexpected n: ' + doc.n;
	        return __handleError(_this, new Error(errmsg));
	      }
	
	      errmsg = 'ChunkIsWrongSize: Got unexpected length: ' +
	        doc.data.length() + ', expected: ' + expectedLength;
	      return __handleError(_this, new Error(errmsg));
	    }
	
	    _this.s.bytesRead += doc.data.length();
	
	    if (doc.data.buffer.length === 0) {
	      return _this.push(null);
	    }
	
	    var sliceStart = null;
	    var sliceEnd = null;
	    var buf = doc.data.buffer;
	
	    if (_this.s.bytesToSkip != null) {
	      sliceStart = _this.s.bytesToSkip;
	      _this.s.bytesToSkip = 0;
	    }
	
	    if (expectedN === _this.s.expectedEnd && _this.s.bytesToTrim != null) {
	      sliceEnd = _this.s.bytesToTrim;
	    }
	
	    // If the remaining amount of data left is < chunkSize read the right amount of data
	    if (_this.s.options.end && (
	      (_this.s.options.end - _this.s.bytesToSkip) < doc.data.length()
	    )) {
	      sliceEnd = (_this.s.options.end - _this.s.bytesToSkip);
	    }
	
	    if (sliceStart != null || sliceEnd != null) {
	      buf = buf.slice(sliceStart || 0, sliceEnd || buf.length);
	    }
	
	    _this.push(buf);
	  })
	}
	
	/**
	 * @ignore
	 */
	
	function init(self) {
	  var findOneOptions = {};
	  if (self.s.readPreference) {
	    findOneOptions.readPreference = self.s.readPreference;
	  }
	  if (self.s.options && self.s.options.sort) {
	    findOneOptions.sort = self.s.options.sort;
	  }
	  if (self.s.options && self.s.options.skip) {
	    findOneOptions.skip = self.s.options.skip;
	  }
	
	  self.s.files.findOne(self.s.filter, findOneOptions, function(error, doc) {
	    if (error) {
	      return __handleError(self, error);
	    }
	    if (!doc) {
	      var identifier = self.s.filter._id ?
	        self.s.filter._id.toString() : self.s.filter.filename;
	      var errmsg = 'FileNotFound: file ' + identifier + ' was not found';
	      var err = new Error(errmsg);
	      err.code = 'ENOENT';
	      return __handleError(self, err);
	    }
	
	    // If document is empty, kill the stream immediately and don't
	    // execute any reads
	    if (doc.length <= 0) {
	      self.push(null);
	      return;
	    }
	
	    if (self.destroyed) {
	      // If user destroys the stream before we have a cursor, wait
	      // until the query is done to say we're 'closed' because we can't
	      // cancel a query.
	      self.emit('close');
	      return;
	    }
	
	    self.s.bytesToSkip = handleStartOption(self, doc, self.s.options);
	
	    var filter = { files_id: doc._id };
	
	    // Currently (MongoDB 3.4.4) skip function does not support the index,
	    // it needs to retrieve all the documents first and then skip them. (CS-25811)
	    // As work around we use $gte on the "n" field.
	    if (self.s.options && self.s.options.start != null){
	      var skip = Math.floor(self.s.options.start / doc.chunkSize);
	      if (skip > 0){
	        filter["n"] = {"$gte": skip};
	      }
	    }
	    self.s.cursor = self.s.chunks.find(filter).sort({ n: 1 });
	
	    if (self.s.readPreference) {
	      self.s.cursor.setReadPreference(self.s.readPreference);
	    }
	
	    self.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
	    self.s.file = doc;
	    self.s.bytesToTrim = handleEndOption(self, doc, self.s.cursor,
	      self.s.options);
	    self.emit('file', doc);
	  });
	}
	
	/**
	 * @ignore
	 */
	
	function waitForFile(_this, callback) {
	  if (_this.s.file) {
	    return callback();
	  }
	
	  if (!_this.s.init) {
	    init(_this);
	    _this.s.init = true;
	  }
	
	  _this.once('file', function() {
	    callback();
	  })
	}
	
	/**
	 * @ignore
	 */
	
	function handleStartOption(stream, doc, options) {
	  if (options && options.start != null) {
	    if (options.start > doc.length) {
	      throw new Error('Stream start (' + options.start + ') must not be ' +
	        'more than the length of the file (' + doc.length +')');
	    }
	    if (options.start < 0) {
	      throw new Error('Stream start (' + options.start + ') must not be ' +
	        'negative');
	    }
	    if (options.end != null && options.end < options.start) {
	      throw new Error('Stream start (' + options.start + ') must not be ' +
	        'greater than stream end (' + options.end + ')');
	    }
	
	    stream.s.bytesRead = Math.floor(options.start / doc.chunkSize) *
	      doc.chunkSize;
	    stream.s.expected = Math.floor(options.start / doc.chunkSize);
	
	    return options.start - stream.s.bytesRead;
	  }
	}
	
	/**
	 * @ignore
	 */
	
	function handleEndOption(stream, doc, cursor, options) {
	  if (options && options.end != null) {
	    if (options.end > doc.length) {
	      throw new Error('Stream end (' + options.end + ') must not be ' +
	        'more than the length of the file (' + doc.length +')')
	    }
	    if (options.start < 0) {
	      throw new Error('Stream end (' + options.end + ') must not be ' +
	        'negative');
	    }
	
	    var start = options.start != null ?
	      Math.floor(options.start / doc.chunkSize) :
	      0;
	
	    cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);
	
	    stream.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);
	
	    return (Math.ceil(options.end / doc.chunkSize) * doc.chunkSize) -
	      options.end;
	  }
	}
	
	/**
	 * @ignore
	 */
	
	function __handleError(_this, error) {
	  _this.emit('error', error);
	}


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	var Emitter = __webpack_require__(6).EventEmitter;
	var GridFSBucketReadStream = __webpack_require__(202);
	var GridFSBucketWriteStream = __webpack_require__(204);
	var shallowClone = __webpack_require__(2).shallowClone;
	var toError = __webpack_require__(2).toError;
	var util = __webpack_require__(1);
	
	var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
	  bucketName: 'fs',
	  chunkSizeBytes: 255 * 1024
	};
	
	module.exports = GridFSBucket;
	
	/**
	 * Constructor for a streaming GridFS interface
	 * @class
	 * @param {Db} db A db handle
	 * @param {object} [options=null] Optional settings.
	 * @param {string} [options.bucketName="fs"] The 'files' and 'chunks' collections will be prefixed with the bucket name followed by a dot.
	 * @param {number} [options.chunkSizeBytes=255 * 1024] Number of bytes stored in each chunk. Defaults to 255KB
	 * @param {object} [options.writeConcern=null] Optional write concern to be passed to write operations, for instance `{ w: 1 }`
	 * @param {object} [options.readPreference=null] Optional read preference to be passed to read operations
	 * @fires GridFSBucketWriteStream#index
	 * @return {GridFSBucket}
	 */
	
	function GridFSBucket(db, options) {
	  Emitter.apply(this);
	  this.setMaxListeners(0);
	
	  if (options && typeof options === 'object') {
	    options = shallowClone(options);
	    var keys = Object.keys(DEFAULT_GRIDFS_BUCKET_OPTIONS);
	    for (var i = 0; i < keys.length; ++i) {
	      if (!options[keys[i]]) {
	        options[keys[i]] = DEFAULT_GRIDFS_BUCKET_OPTIONS[keys[i]];
	      }
	    }
	  } else {
	    options = DEFAULT_GRIDFS_BUCKET_OPTIONS;
	  }
	
	  this.s = {
	    db: db,
	    options: options,
	    _chunksCollection: db.collection(options.bucketName + '.chunks'),
	    _filesCollection: db.collection(options.bucketName + '.files'),
	    checkedIndexes: false,
	    calledOpenUploadStream: false,
	    promiseLibrary: db.s.promiseLibrary ||
	      (typeof global.Promise == 'function' ? global.Promise : __webpack_require__(10).Promise)
	  };
	}
	
	util.inherits(GridFSBucket, Emitter);
	
	/**
	 * When the first call to openUploadStream is made, the upload stream will
	 * check to see if it needs to create the proper indexes on the chunks and
	 * files collections. This event is fired either when 1) it determines that
	 * no index creation is necessary, 2) when it successfully creates the
	 * necessary indexes.
	 *
	 * @event GridFSBucket#index
	 * @type {Error}
	 */
	
	/**
	 * Returns a writable stream (GridFSBucketWriteStream) for writing
	 * buffers to GridFS. The stream's 'id' property contains the resulting
	 * file's id.
	 * @method
	 * @param {string} filename The value of the 'filename' key in the files doc
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.chunkSizeBytes=null] Optional overwrite this bucket's chunkSizeBytes for this file
	 * @param {object} [options.metadata=null] Optional object to store in the file document's `metadata` field
	 * @param {string} [options.contentType=null] Optional string to store in the file document's `contentType` field
	 * @param {array} [options.aliases=null] Optional array of strings to store in the file document's `aliases` field
	 * @return {GridFSBucketWriteStream}
	 */
	
	GridFSBucket.prototype.openUploadStream = function(filename, options) {
	  if (options) {
	    options = shallowClone(options);
	  } else {
	    options = {};
	  }
	  if (!options.chunkSizeBytes) {
	    options.chunkSizeBytes = this.s.options.chunkSizeBytes;
	  }
	  return new GridFSBucketWriteStream(this, filename, options);
	};
	
	/**
	 * Returns a writable stream (GridFSBucketWriteStream) for writing
	 * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting
	 * file's id.
	 * @method
	 * @param {string|number|object} id A custom id used to identify the file
	 * @param {string} filename The value of the 'filename' key in the files doc
	 * @param {object} [options=null] Optional settings.
	 * @param {number} [options.chunkSizeBytes=null] Optional overwrite this bucket's chunkSizeBytes for this file
	 * @param {object} [options.metadata=null] Optional object to store in the file document's `metadata` field
	 * @param {string} [options.contentType=null] Optional string to store in the file document's `contentType` field
	 * @param {array} [options.aliases=null] Optional array of strings to store in the file document's `aliases` field
	 * @return {GridFSBucketWriteStream}
	 */
	
	GridFSBucket.prototype.openUploadStreamWithId = function(id, filename, options) {
	  if (options) {
	    options = shallowClone(options);
	  } else {
	    options = {};
	  }
	
	  if (!options.chunkSizeBytes) {
	    options.chunkSizeBytes = this.s.options.chunkSizeBytes;
	  }
	
	  options.id = id;
	
	  return new GridFSBucketWriteStream(this, filename, options);
	};
	
	/**
	 * Returns a readable stream (GridFSBucketReadStream) for streaming file
	 * data from GridFS.
	 * @method
	 * @param {ObjectId} id The id of the file doc
	 * @param {Object} [options=null] Optional settings.
	 * @param {Number} [options.start=null] Optional 0-based offset in bytes to start streaming from
	 * @param {Number} [options.end=null] Optional 0-based offset in bytes to stop streaming before
	 * @return {GridFSBucketReadStream}
	 */
	
	GridFSBucket.prototype.openDownloadStream = function(id, options) {
	  var filter = { _id: id };
	  options = {
	    start: options && options.start,
	    end: options && options.end
	  };
	
	  return new GridFSBucketReadStream(this.s._chunksCollection,
	    this.s._filesCollection, this.s.options.readPreference, filter, options);
	};
	
	/**
	 * Deletes a file with the given id
	 * @method
	 * @param {ObjectId} id The id of the file doc
	 * @param {GridFSBucket~errorCallback} [callback]
	 */
	
	GridFSBucket.prototype.delete = function(id, callback) {
	  if (typeof callback === 'function') {
	    return _delete(this, id, callback);
	  }
	
	  var _this = this;
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    _delete(_this, id, function(error, res) {
	      if (error) {
	        reject(error);
	      } else {
	        resolve(res);
	      }
	    });
	  });
	};
	
	/**
	 * @ignore
	 */
	
	function _delete(_this, id, callback) {
	  _this.s._filesCollection.deleteOne({ _id: id }, function(error, res) {
	    if (error) {
	      return callback(error);
	    }
	
	    _this.s._chunksCollection.deleteMany({ files_id: id }, function(error) {
	      if (error) {
	        return callback(error);
	      }
	
	      // Delete orphaned chunks before returning FileNotFound
	      if (!res.result.n) {
	        var errmsg = 'FileNotFound: no file with id ' + id + ' found';
	        return callback(new Error(errmsg));
	      }
	
	      callback();
	    });
	  });
	}
	
	/**
	 * Convenience wrapper around find on the files collection
	 * @method
	 * @param {Object} filter
	 * @param {Object} [options=null] Optional settings for cursor
	 * @param {number} [options.batchSize=null] Optional batch size for cursor
	 * @param {number} [options.limit=null] Optional limit for cursor
	 * @param {number} [options.maxTimeMS=null] Optional maxTimeMS for cursor
	 * @param {boolean} [options.noCursorTimeout=null] Optionally set cursor's `noCursorTimeout` flag
	 * @param {number} [options.skip=null] Optional skip for cursor
	 * @param {object} [options.sort=null] Optional sort for cursor
	 * @return {Cursor}
	 */
	
	GridFSBucket.prototype.find = function(filter, options) {
	  filter = filter || {};
	  options = options || {};
	
	  var cursor = this.s._filesCollection.find(filter);
	
	  if (options.batchSize != null) {
	    cursor.batchSize(options.batchSize);
	  }
	  if (options.limit != null) {
	    cursor.limit(options.limit);
	  }
	  if (options.maxTimeMS != null) {
	    cursor.maxTimeMS(options.maxTimeMS);
	  }
	  if (options.noCursorTimeout != null) {
	    cursor.addCursorFlag('noCursorTimeout', options.noCursorTimeout);
	  }
	  if (options.skip != null) {
	    cursor.skip(options.skip);
	  }
	  if (options.sort != null) {
	    cursor.sort(options.sort);
	  }
	
	  return cursor;
	};
	
	/**
	 * Returns a readable stream (GridFSBucketReadStream) for streaming the
	 * file with the given name from GridFS. If there are multiple files with
	 * the same name, this will stream the most recent file with the given name
	 * (as determined by the `uploadDate` field). You can set the `revision`
	 * option to change this behavior.
	 * @method
	 * @param {String} filename The name of the file to stream
	 * @param {Object} [options=null] Optional settings
	 * @param {number} [options.revision=-1] The revision number relative to the oldest file with the given filename. 0 gets you the oldest file, 1 gets you the 2nd oldest, -1 gets you the newest.
	 * @param {Number} [options.start=null] Optional 0-based offset in bytes to start streaming from
	 * @param {Number} [options.end=null] Optional 0-based offset in bytes to stop streaming before
	 * @return {GridFSBucketReadStream}
	 */
	
	GridFSBucket.prototype.openDownloadStreamByName = function(filename, options) {
	  var sort = { uploadDate: -1 };
	  var skip = null;
	  if (options && options.revision != null) {
	    if (options.revision >= 0) {
	      sort = { uploadDate: 1 };
	      skip = options.revision;
	    } else {
	      skip = -options.revision - 1;
	    }
	  }
	
	  var filter = { filename: filename };
	  options = {
	    sort: sort,
	    skip: skip,
	    start: options && options.start,
	    end: options && options.end
	  };
	  return new GridFSBucketReadStream(this.s._chunksCollection,
	    this.s._filesCollection, this.s.options.readPreference, filter, options);
	};
	
	/**
	 * Renames the file with the given _id to the given string
	 * @method
	 * @param {ObjectId} id the id of the file to rename
	 * @param {String} filename new name for the file
	 * @param {GridFSBucket~errorCallback} [callback]
	 */
	
	GridFSBucket.prototype.rename = function(id, filename, callback) {
	  if (typeof callback === 'function') {
	    return _rename(this, id, filename, callback);
	  }
	
	  var _this = this;
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    _rename(_this, id, filename, function(error, res) {
	      if (error) {
	        reject(error);
	      } else {
	        resolve(res);
	      }
	    });
	  });
	};
	
	/**
	 * @ignore
	 */
	
	function _rename(_this, id, filename, callback) {
	  var filter = { _id: id };
	  var update = { $set: { filename: filename } };
	  _this.s._filesCollection.updateOne(filter, update, function(error, res) {
	    if (error) {
	      return callback(error);
	    }
	    if (!res.result.n) {
	      return callback(toError('File with id ' + id + ' not found'));
	    }
	    callback();
	  });
	}
	
	/**
	 * Removes this bucket's files collection, followed by its chunks collection.
	 * @method
	 * @param {GridFSBucket~errorCallback} [callback]
	 */
	
	GridFSBucket.prototype.drop = function(callback) {
	  if (typeof callback === 'function') {
	    return _drop(this, callback);
	  }
	
	  var _this = this;
	  return new this.s.promiseLibrary(function(resolve, reject) {
	    _drop(_this, function(error, res) {
	      if (error) {
	        reject(error);
	      } else {
	        resolve(res);
	      }
	    });
	  });
	};
	
	/**
	 * @ignore
	 */
	
	function _drop(_this, callback) {
	  _this.s._filesCollection.drop(function(error) {
	    if (error) {
	      return callback(error);
	    }
	    _this.s._chunksCollection.drop(function(error) {
	      if (error) {
	        return callback(error);
	      }
	
	      return callback();
	    });
	  });
	}
	
	/**
	 * Callback format for all GridFSBucket methods that can accept a callback.
	 * @callback GridFSBucket~errorCallback
	 * @param {MongoError} error An error instance representing any errors that occurred
	 */


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	var core = __webpack_require__(3);
	var crypto = __webpack_require__(48);
	var stream = __webpack_require__(18);
	var util = __webpack_require__(1);
	
	var ERROR_NAMESPACE_NOT_FOUND = 26;
	
	module.exports = GridFSBucketWriteStream;
	
	/**
	 * A writable stream that enables you to write buffers to GridFS.
	 *
	 * Do not instantiate this class directly. Use `openUploadStream()` instead.
	 *
	 * @class
	 * @param {GridFSBucket} bucket Handle for this stream's corresponding bucket
	 * @param {string} filename The value of the 'filename' key in the files doc
	 * @param {object} [options=null] Optional settings.
	 * @param {string|number|object} [options.id=null] Custom file id for the GridFS file.
	 * @param {number} [options.chunkSizeBytes=null] The chunk size to use, in bytes
	 * @param {number} [options.w=null] The write concern
	 * @param {number} [options.wtimeout=null] The write concern timeout
	 * @param {number} [options.j=null] The journal write concern
	 * @fires GridFSBucketWriteStream#error
	 * @fires GridFSBucketWriteStream#finish
	 * @return {GridFSBucketWriteStream} a GridFSBucketWriteStream instance.
	 */
	
	function GridFSBucketWriteStream(bucket, filename, options) {
	  options = options || {};
	  this.bucket = bucket;
	  this.chunks = bucket.s._chunksCollection;
	  this.filename = filename;
	  this.files = bucket.s._filesCollection;
	  this.options = options;
	  // Signals the write is all done
	  this.done = false;
	
	  this.id = options.id ? options.id : core.BSON.ObjectId();
	  this.chunkSizeBytes = this.options.chunkSizeBytes;
	  this.bufToStore = new Buffer(this.chunkSizeBytes);
	  this.length = 0;
	  this.md5 = crypto.createHash('md5');
	  this.n = 0;
	  this.pos = 0;
	  this.state = {
	    streamEnd: false,
	    outstandingRequests: 0,
	    errored: false,
	    aborted: false,
	    promiseLibrary: this.bucket.s.promiseLibrary
	  };
	
	  if (!this.bucket.s.calledOpenUploadStream) {
	    this.bucket.s.calledOpenUploadStream = true;
	
	    var _this = this;
	    checkIndexes(this, function() {
	      _this.bucket.s.checkedIndexes = true;
	      _this.bucket.emit('index');
	    });
	  }
	}
	
	util.inherits(GridFSBucketWriteStream, stream.Writable);
	
	/**
	 * An error occurred
	 *
	 * @event GridFSBucketWriteStream#error
	 * @type {Error}
	 */
	
	/**
	 * `end()` was called and the write stream successfully wrote the file
	 * metadata and all the chunks to MongoDB.
	 *
	 * @event GridFSBucketWriteStream#finish
	 * @type {object}
	 */
	
	/**
	 * Write a buffer to the stream.
	 *
	 * @method
	 * @param {Buffer} chunk Buffer to write
	 * @param {String} encoding Optional encoding for the buffer
	 * @param {Function} callback Function to call when the chunk was added to the buffer, or if the entire chunk was persisted to MongoDB if this chunk caused a flush.
	 * @return {Boolean} False if this write required flushing a chunk to MongoDB. True otherwise.
	 */
	
	GridFSBucketWriteStream.prototype.write = function(chunk, encoding, callback) {
	  var _this = this;
	  return waitForIndexes(this, function() {
	    return doWrite(_this, chunk, encoding, callback);
	  });
	};
	
	/**
	 * Places this write stream into an aborted state (all future writes fail)
	 * and deletes all chunks that have already been written.
	 *
	 * @method
	 * @param {GridFSBucket~errorCallback} callback called when chunks are successfully removed or error occurred
	 * @return {Promise} if no callback specified
	 */
	
	GridFSBucketWriteStream.prototype.abort = function(callback) {
	  if (this.state.streamEnd) {
	    var error = new Error('Cannot abort a stream that has already completed');
	    if (typeof callback == 'function') {
	      return callback(error);
	    }
	    return this.state.promiseLibrary.reject(error);
	  }
	  if (this.state.aborted) {
	    error = new Error('Cannot call abort() on a stream twice');
	    if (typeof callback == 'function') {
	      return callback(error);
	    }
	    return this.state.promiseLibrary.reject(error);
	  }
	  this.state.aborted = true;
	  this.chunks.deleteMany({ files_id: this.id }, function(error) {
	    if(typeof callback == 'function') callback(error);
	  });
	};
	
	/**
	 * Tells the stream that no more data will be coming in. The stream will
	 * persist the remaining data to MongoDB, write the files document, and
	 * then emit a 'finish' event.
	 *
	 * @method
	 * @param {Buffer} chunk Buffer to write
	 * @param {String} encoding Optional encoding for the buffer
	 * @param {Function} callback Function to call when all files and chunks have been persisted to MongoDB
	 */
	
	GridFSBucketWriteStream.prototype.end = function(chunk, encoding, callback) {
	  var _this = this;
	  if(typeof chunk == 'function') {
	    callback = chunk, chunk = null, encoding = null;
	  } else if(typeof encoding == 'function') {
	    callback = encoding, encoding = null;
	  }
	
	  if (checkAborted(this, callback)) {
	    return;
	  }
	  this.state.streamEnd = true;
	
	  if (callback) {
	    this.once('finish', function(result) {
	      callback(null, result);
	    });
	  }
	
	  if (!chunk) {
	    waitForIndexes(this, function() {
	      writeRemnant(_this);
	    });
	    return;
	  }
	
	  this.write(chunk, encoding, function() {
	    writeRemnant(_this);
	  });
	};
	
	/**
	 * @ignore
	 */
	
	function __handleError(_this, error, callback) {
	  if (_this.state.errored) {
	    return;
	  }
	  _this.state.errored = true;
	  if (callback) {
	    return callback(error);
	  }
	  _this.emit('error', error);
	}
	
	/**
	 * @ignore
	 */
	
	function createChunkDoc(filesId, n, data) {
	  return {
	    _id: core.BSON.ObjectId(),
	    files_id: filesId,
	    n: n,
	    data: data
	  };
	}
	
	/**
	 * @ignore
	 */
	
	function checkChunksIndex(_this, callback) {
	  _this.chunks.listIndexes().toArray(function(error, indexes) {
	    if (error) {
	      // Collection doesn't exist so create index
	      if (error.code === ERROR_NAMESPACE_NOT_FOUND) {
	        var index = { files_id: 1, n: 1 };
	        _this.chunks.createIndex(index, { background: false, unique: true }, function(error) {
	          if (error) {
	            return callback(error);
	          }
	
	          callback();
	        });
	        return;
	      }
	      return callback(error);
	    }
	
	    var hasChunksIndex = false;
	    indexes.forEach(function(index) {
	      if (index.key) {
	        var keys = Object.keys(index.key);
	        if (keys.length === 2 && index.key.files_id === 1 &&
	            index.key.n === 1) {
	          hasChunksIndex = true;
	        }
	      }
	    });
	
	    if (hasChunksIndex) {
	      callback();
	    } else {
	      index = { files_id: 1, n: 1 };
	      var indexOptions = getWriteOptions(_this);
	
	      indexOptions.background = false;
	      indexOptions.unique = true;
	
	      _this.chunks.createIndex(index, indexOptions, function(error) {
	        if (error) {
	          return callback(error);
	        }
	
	        callback();
	      });
	    }
	  });
	}
	
	/**
	 * @ignore
	 */
	
	function checkDone(_this, callback) {
	  if(_this.done) return true;
	  if (_this.state.streamEnd &&
	      _this.state.outstandingRequests === 0 &&
	      !_this.state.errored) {
	    // Set done so we dont' trigger duplicate createFilesDoc
	    _this.done = true;
	    // Create a new files doc
	    var filesDoc = createFilesDoc(_this.id, _this.length, _this.chunkSizeBytes,
	      _this.md5.digest('hex'), _this.filename, _this.options.contentType,
	      _this.options.aliases, _this.options.metadata);
	
	    if (checkAborted(_this, callback)) {
	      return false;
	    }
	
	    _this.files.insert(filesDoc, getWriteOptions(_this), function(error) {
	      if (error) {
	        return __handleError(_this, error, callback);
	      }
	      _this.emit('finish', filesDoc);
	    });
	
	    return true;
	  }
	
	  return false;
	}
	
	/**
	 * @ignore
	 */
	
	function checkIndexes(_this, callback) {
	  _this.files.findOne({}, { _id: 1 }, function(error, doc) {
	    if (error) {
	      return callback(error);
	    }
	    if (doc) {
	      return callback();
	    }
	
	    _this.files.listIndexes().toArray(function(error, indexes) {
	      if (error) {
	        // Collection doesn't exist so create index
	        if (error.code === ERROR_NAMESPACE_NOT_FOUND) {
	          var index = { filename: 1, uploadDate: 1 };
	          _this.files.createIndex(index, { background: false }, function(error) {
	            if (error) {
	              return callback(error);
	            }
	
	            checkChunksIndex(_this, callback);
	          });
	          return;
	        }
	        return callback(error);
	      }
	
	      var hasFileIndex = false;
	      indexes.forEach(function(index) {
	        var keys = Object.keys(index.key);
	        if (keys.length === 2 && index.key.filename === 1 &&
	            index.key.uploadDate === 1) {
	          hasFileIndex = true;
	        }
	      });
	
	      if (hasFileIndex) {
	        checkChunksIndex(_this, callback);
	      } else {
	        index = { filename: 1, uploadDate: 1 };
	
	        var indexOptions = getWriteOptions(_this);
	
	        indexOptions.background = false;
	
	        _this.files.createIndex(index, indexOptions, function(error) {
	          if (error) {
	            return callback(error);
	          }
	
	          checkChunksIndex(_this, callback);
	        });
	      }
	    });
	  });
	}
	
	/**
	 * @ignore
	 */
	
	function createFilesDoc(_id, length, chunkSize, md5, filename, contentType,
	  aliases, metadata) {
	  var ret = {
	    _id: _id,
	    length: length,
	    chunkSize: chunkSize,
	    uploadDate: new Date(),
	    md5: md5,
	    filename: filename
	  };
	
	  if (contentType) {
	    ret.contentType = contentType;
	  }
	
	  if (aliases) {
	    ret.aliases = aliases;
	  }
	
	  if (metadata) {
	    ret.metadata = metadata;
	  }
	
	  return ret;
	}
	
	/**
	 * @ignore
	 */
	
	function doWrite(_this, chunk, encoding, callback) {
	  if (checkAborted(_this, callback)) {
	    return false;
	  }
	
	  var inputBuf = (Buffer.isBuffer(chunk)) ?
	    chunk : new Buffer(chunk, encoding);
	
	  _this.length += inputBuf.length;
	
	  // Input is small enough to fit in our buffer
	  if (_this.pos + inputBuf.length < _this.chunkSizeBytes) {
	    inputBuf.copy(_this.bufToStore, _this.pos);
	    _this.pos += inputBuf.length;
	
	    callback && callback();
	
	    // Note that we reverse the typical semantics of write's return value
	    // to be compatible with node's `.pipe()` function.
	    // True means client can keep writing.
	    return true;
	  }
	
	  // Otherwise, buffer is too big for current chunk, so we need to flush
	  // to MongoDB.
	  var inputBufRemaining = inputBuf.length;
	  var spaceRemaining = _this.chunkSizeBytes - _this.pos;
	  var numToCopy = Math.min(spaceRemaining, inputBuf.length);
	  var outstandingRequests = 0;
	  while (inputBufRemaining > 0) {
	    var inputBufPos = inputBuf.length - inputBufRemaining;
	    inputBuf.copy(_this.bufToStore, _this.pos,
	      inputBufPos, inputBufPos + numToCopy);
	    _this.pos += numToCopy;
	    spaceRemaining -= numToCopy;
	    if (spaceRemaining === 0) {
	      _this.md5.update(_this.bufToStore);
	      var doc = createChunkDoc(_this.id, _this.n, _this.bufToStore);
	      ++_this.state.outstandingRequests;
	      ++outstandingRequests;
	
	      if (checkAborted(_this, callback)) {
	        return false;
	      }
	
	      _this.chunks.insert(doc, getWriteOptions(_this), function(error) {
	        if (error) {
	          return __handleError(_this, error);
	        }
	        --_this.state.outstandingRequests;
	        --outstandingRequests;
	        
	        if (!outstandingRequests) {
	          _this.emit('drain', doc);
	          callback && callback();
	          checkDone(_this);
	        }
	      });
	
	      spaceRemaining = _this.chunkSizeBytes;
	      _this.pos = 0;
	      ++_this.n;
	    }
	    inputBufRemaining -= numToCopy;
	    numToCopy = Math.min(spaceRemaining, inputBufRemaining);
	  }
	
	  // Note that we reverse the typical semantics of write's return value
	  // to be compatible with node's `.pipe()` function.
	  // False means the client should wait for the 'drain' event.
	  return false;
	}
	
	/**
	 * @ignore
	 */
	
	function getWriteOptions(_this) {
	  var obj = {};
	  if (_this.options.writeConcern) {
	    obj.w = _this.options.writeConcern.w;
	    obj.wtimeout = _this.options.writeConcern.wtimeout;
	    obj.j = _this.options.writeConcern.j;
	  }
	  return obj;
	}
	
	/**
	 * @ignore
	 */
	
	function waitForIndexes(_this, callback) {
	  if (_this.bucket.s.checkedIndexes) {
	    return callback(false);
	  }
	
	  _this.bucket.once('index', function() {
	    callback(true);
	  });
	
	  return true;
	}
	
	/**
	 * @ignore
	 */
	
	function writeRemnant(_this, callback) {
	  // Buffer is empty, so don't bother to insert
	  if (_this.pos === 0) {
	    return checkDone(_this, callback);
	  }
	
	  ++_this.state.outstandingRequests;
	
	  // Create a new buffer to make sure the buffer isn't bigger than it needs
	  // to be.
	  var remnant = new Buffer(_this.pos);
	  _this.bufToStore.copy(remnant, 0, 0, _this.pos);
	  _this.md5.update(remnant);
	  var doc = createChunkDoc(_this.id, _this.n, remnant);
	
	  // If the stream was aborted, do not write remnant
	  if (checkAborted(_this, callback)) {
	    return false;
	  }
	
	  _this.chunks.insert(doc, getWriteOptions(_this), function(error) {
	    if (error) {
	      return __handleError(_this, error);
	    }
	    --_this.state.outstandingRequests;
	    checkDone(_this);
	  });
	}
	
	/**
	 * @ignore
	 */
	
	function checkAborted(_this, callback) {
	  if (_this.state.aborted) {
	    if(typeof callback == 'function') {
	      callback(new Error('this stream has been aborted'));
	    }
	    return true;
	  }
	  return false;
	}


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var ReadPreference = __webpack_require__(16),
	  parser = __webpack_require__(281),
	  f = __webpack_require__(1).format,
	  assign = __webpack_require__(2).assign;
	
	module.exports = function(url, options) {
	  // Variables
	  var connection_part = '';
	  var auth_part = '';
	  var query_string_part = '';
	  var dbName = 'admin';
	
	  // Url parser result
	  var result = parser.parse(url, true);
	
	  if(result.protocol != 'mongodb:') {
	    throw new Error('invalid schema, expected mongodb');
	  }
	
	  if((result.hostname == null || result.hostname == '') && url.indexOf('.sock') == -1) {
	    throw new Error('no hostname or hostnames provided in connection string');
	  }
	
	  if(result.port == '0') {
	    throw new Error('invalid port (zero) with hostname');
	  }
	
	  if(!isNaN(parseInt(result.port, 10)) && parseInt(result.port, 10) > 65535) {
	    throw new Error('invalid port (larger than 65535) with hostname');
	  }
	
	  if(result.path
	    && result.path.length > 0
	    && result.path[0] != '/'
	    && url.indexOf('.sock') == -1) {
	    throw new Error('missing delimiting slash between hosts and options');
	  }
	
	  if(result.query) {
	    for(var name in result.query) {
	      if(name.indexOf('::') != -1) {
	        throw new Error('double colon in host identifier');
	      }
	
	      if(result.query[name] == '') {
	        throw new Error('query parameter ' + name + ' is an incomplete value pair');
	      }
	    }
	  }
	
	  if(result.auth) {
	    var parts = result.auth.split(':');
	    if(url.indexOf(result.auth) != -1 && parts.length > 2) {
	      throw new Error('Username with password containing an unescaped colon');
	    }
	
	    if(url.indexOf(result.auth) != -1 && result.auth.indexOf('@') != -1) {
	      throw new Error('Username containing an unescaped at-sign');
	    }
	  }
	
	  // Remove query
	  var clean = url.split('?').shift();
	
	  // Extract the list of hosts
	  var strings = clean.split(',');
	  var hosts = [];
	
	  for(var i = 0; i < strings.length; i++) {
	    var hostString = strings[i];
	
	    if(hostString.indexOf('mongodb') != -1) {
	      if(hostString.indexOf('@') != -1) {
	        hosts.push(hostString.split('@').pop())
	      } else {
	        hosts.push(hostString.substr('mongodb://'.length));
	      }
	    } else if(hostString.indexOf('/') != -1) {
	      hosts.push(hostString.split('/').shift());
	    } else if(hostString.indexOf('/') == -1) {
	      hosts.push(hostString.trim());
	    }
	  }
	
	  for(i = 0; i < hosts.length; i++) {
	    var r = parser.parse(f('mongodb://%s', hosts[i].trim()));
	    if(r.path && r.path.indexOf(':') != -1) {
	      throw new Error('double colon in host identifier');
	    }
	  }
	
	  // If we have a ? mark cut the query elements off
	  if(url.indexOf("?") != -1) {
	    query_string_part = url.substr(url.indexOf("?") + 1);
	    connection_part = url.substring("mongodb://".length, url.indexOf("?"))
	  } else {
	    connection_part = url.substring("mongodb://".length);
	  }
	
	  // Check if we have auth params
	  if(connection_part.indexOf("@") != -1) {
	    auth_part = connection_part.split("@")[0];
	    connection_part = connection_part.split("@")[1];
	  }
	
	  // Check if the connection string has a db
	  if(connection_part.indexOf(".sock") != -1) {
	    if(connection_part.indexOf(".sock/") != -1) {
	      dbName = connection_part.split(".sock/")[1];
	      // Check if multiple database names provided, or just an illegal trailing backslash
	      if (dbName.indexOf("/") != -1) {
	        if (dbName.split("/").length == 2 && dbName.split("/")[1].length == 0) {
	          throw new Error('Illegal trailing backslash after database name');
	        }
	        throw new Error('More than 1 database name in URL');
	      }
	      connection_part = connection_part.split("/", connection_part.indexOf(".sock") + ".sock".length);
	    }
	  } else if(connection_part.indexOf("/") != -1) {
	    // Check if multiple database names provided, or just an illegal trailing backslash
	    if (connection_part.split("/").length > 2) {
	      if (connection_part.split("/")[2].length == 0) {
	        throw new Error('Illegal trailing backslash after database name');
	      }
	      throw new Error('More than 1 database name in URL');
	    }
	    dbName = connection_part.split("/")[1];
	    connection_part = connection_part.split("/")[0];
	  }
	
	  // Result object
	  var object = {};
	
	  // Pick apart the authentication part of the string
	  var authPart = auth_part || '';
	  var auth = authPart.split(':', 2);
	
	  // Decode the URI components
	  auth[0] = decodeURIComponent(auth[0]);
	  if(auth[1]){
	    auth[1] = decodeURIComponent(auth[1]);
	  }
	
	  // Add auth to final object if we have 2 elements
	  if(auth.length == 2) object.auth = {user: auth[0], password: auth[1]};
	  // if user provided auth options, use that
	  if(options && options.auth != null) object.auth = options.auth;
	
	  // Variables used for temporary storage
	  var hostPart;
	  var urlOptions;
	  var servers;
	  var serverOptions = {socketOptions: {}};
	  var dbOptions = {read_preference_tags: []};
	  var replSetServersOptions = {socketOptions: {}};
	  var mongosOptions = {socketOptions: {}};
	  // Add server options to final object
	  object.server_options = serverOptions;
	  object.db_options = dbOptions;
	  object.rs_options = replSetServersOptions;
	  object.mongos_options = mongosOptions;
	
	  // Let's check if we are using a domain socket
	  if(url.match(/\.sock/)) {
	    // Split out the socket part
	    var domainSocket = url.substring(
	        url.indexOf("mongodb://") + "mongodb://".length
	      , url.lastIndexOf(".sock") + ".sock".length);
	    // Clean out any auth stuff if any
	    if(domainSocket.indexOf("@") != -1) domainSocket = domainSocket.split("@")[1];
	    servers = [{domain_socket: domainSocket}];
	  } else {
	    // Split up the db
	    hostPart = connection_part;
	    // Deduplicate servers
	    var deduplicatedServers = {};
	
	    // Parse all server results
	    servers = hostPart.split(',').map(function(h) {
	      var _host, _port, ipv6match;
	      //check if it matches [IPv6]:port, where the port number is optional
	      if ((ipv6match = /\[([^\]]+)\](?:\:(.+))?/.exec(h))) {
	        _host = ipv6match[1];
	        _port = parseInt(ipv6match[2], 10) || 27017;
	      } else {
	        //otherwise assume it's IPv4, or plain hostname
	        var hostPort = h.split(':', 2);
	        _host = hostPort[0] || 'localhost';
	        _port = hostPort[1] != null ? parseInt(hostPort[1], 10) : 27017;
	        // Check for localhost?safe=true style case
	        if(_host.indexOf("?") != -1) _host = _host.split(/\?/)[0];
	      }
	
	      // No entry returned for duplicate servr
	      if(deduplicatedServers[_host + "_" + _port]) return null;
	      deduplicatedServers[_host + "_" + _port] = 1;
	
	      // Return the mapped object
	      return {host: _host, port: _port};
	    }).filter(function(x) {
	      return x != null;
	    });
	  }
	
	  // Get the db name
	  object.dbName = dbName || 'admin';
	  // Split up all the options
	  urlOptions = (query_string_part || '').split(/[&;]/);
	  // Ugh, we have to figure out which options go to which constructor manually.
	  urlOptions.forEach(function(opt) {
	    if(!opt) return;
	    var splitOpt = opt.split('='), name = splitOpt[0], value = splitOpt[1];
	    // Options implementations
	    switch(name) {
	      case 'slaveOk':
	      case 'slave_ok':
	        serverOptions.slave_ok = (value == 'true');
	        dbOptions.slaveOk = (value == 'true');
	        break;
	      case 'maxPoolSize':
	      case 'poolSize':
	        serverOptions.poolSize = parseInt(value, 10);
	        replSetServersOptions.poolSize = parseInt(value, 10);
	        break;
	      case 'appname':
	        object.appname = decodeURIComponent(value);
	        break;
	      case 'autoReconnect':
	      case 'auto_reconnect':
	        serverOptions.auto_reconnect = (value == 'true');
	        break;
	      case 'minPoolSize':
	        throw new Error("minPoolSize not supported");
	      case 'maxIdleTimeMS':
	        throw new Error("maxIdleTimeMS not supported");
	      case 'waitQueueMultiple':
	        throw new Error("waitQueueMultiple not supported");
	      case 'waitQueueTimeoutMS':
	        throw new Error("waitQueueTimeoutMS not supported");
	      case 'uuidRepresentation':
	        throw new Error("uuidRepresentation not supported");
	      case 'ssl':
	        if(value == 'prefer') {
	          serverOptions.ssl = value;
	          replSetServersOptions.ssl = value;
	          mongosOptions.ssl = value;
	          break;
	        }
	        serverOptions.ssl = (value == 'true');
	        replSetServersOptions.ssl = (value == 'true');
	        mongosOptions.ssl = (value == 'true');
	        break;
	      case 'sslValidate':
	        serverOptions.sslValidate = (value == 'true');
	        replSetServersOptions.sslValidate = (value == 'true');
	        mongosOptions.sslValidate = (value == 'true');
	        break;
	      case 'replicaSet':
	      case 'rs_name':
	        replSetServersOptions.rs_name = value;
	        break;
	      case 'reconnectWait':
	        replSetServersOptions.reconnectWait = parseInt(value, 10);
	        break;
	      case 'retries':
	        replSetServersOptions.retries = parseInt(value, 10);
	        break;
	      case 'readSecondary':
	      case 'read_secondary':
	        replSetServersOptions.read_secondary = (value == 'true');
	        break;
	      case 'fsync':
	        dbOptions.fsync = (value == 'true');
	        break;
	      case 'journal':
	        dbOptions.j = (value == 'true');
	        break;
	      case 'safe':
	        dbOptions.safe = (value == 'true');
	        break;
	      case 'nativeParser':
	      case 'native_parser':
	        dbOptions.native_parser = (value == 'true');
	        break;
	      case 'readConcernLevel':
	        dbOptions.readConcern = {level: value};
	        break;
	      case 'connectTimeoutMS':
	        serverOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
	        replSetServersOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
	        mongosOptions.socketOptions.connectTimeoutMS = parseInt(value, 10);
	        break;
	      case 'socketTimeoutMS':
	        serverOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
	        replSetServersOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
	        mongosOptions.socketOptions.socketTimeoutMS = parseInt(value, 10);
	        break;
	      case 'w':
	        dbOptions.w = parseInt(value, 10);
	        if(isNaN(dbOptions.w)) dbOptions.w = value;
	        break;
	      case 'authSource':
	        dbOptions.authSource = value;
	        break;
	      case 'gssapiServiceName':
	        dbOptions.gssapiServiceName = value;
	        break;
	      case 'authMechanism':
	        if(value == 'GSSAPI') {
	          // If no password provided decode only the principal
	          if(object.auth == null) {
	            var urlDecodeAuthPart = decodeURIComponent(authPart);
	            if(urlDecodeAuthPart.indexOf("@") == -1) throw new Error("GSSAPI requires a provided principal");
	            object.auth = {user: urlDecodeAuthPart, password: null};
	          } else {
	            object.auth.user = decodeURIComponent(object.auth.user);
	          }
	        } else if(value == 'MONGODB-X509') {
	          object.auth = {user: decodeURIComponent(authPart)};
	        }
	
	        // Only support GSSAPI or MONGODB-CR for now
	        if(value != 'GSSAPI'
	          && value != 'MONGODB-X509'
	          && value != 'MONGODB-CR'
	          && value != 'DEFAULT'
	          && value != 'SCRAM-SHA-1'
	          && value != 'PLAIN')
	            throw new Error("only DEFAULT, GSSAPI, PLAIN, MONGODB-X509, SCRAM-SHA-1 or MONGODB-CR is supported by authMechanism");
	
	        // Authentication mechanism
	        dbOptions.authMechanism = value;
	        break;
	      case 'authMechanismProperties':
	        // Split up into key, value pairs
	        var values = value.split(',');
	        var o = {};
	        // For each value split into key, value
	        values.forEach(function(x) {
	          var v = x.split(':');
	          o[v[0]] = v[1];
	        });
	
	        // Set all authMechanismProperties
	        dbOptions.authMechanismProperties = o;
	        // Set the service name value
	        if(typeof o.SERVICE_NAME == 'string') dbOptions.gssapiServiceName = o.SERVICE_NAME;
	        if(typeof o.SERVICE_REALM == 'string') dbOptions.gssapiServiceRealm = o.SERVICE_REALM;
	        if(typeof o.CANONICALIZE_HOST_NAME == 'string') dbOptions.gssapiCanonicalizeHostName = o.CANONICALIZE_HOST_NAME == 'true' ? true : false;
	        break;
	      case 'wtimeoutMS':
	        dbOptions.wtimeout = parseInt(value, 10);
	        break;
	      case 'readPreference':
	        if(!ReadPreference.isValid(value)) throw new Error("readPreference must be either primary/primaryPreferred/secondary/secondaryPreferred/nearest");
	        dbOptions.readPreference = value;
	        break;
	      case 'maxStalenessSeconds':
	        dbOptions.maxStalenessSeconds = parseInt(value, 10);
	        break;
	      case 'readPreferenceTags':
	        // Decode the value
	        value = decodeURIComponent(value);
	        // Contains the tag object
	        var tagObject = {};
	        if(value == null || value == '') {
	          dbOptions.read_preference_tags.push(tagObject);
	          break;
	        }
	
	        // Split up the tags
	        var tags = value.split(/\,/);
	        for(var i = 0; i < tags.length; i++) {
	          var parts = tags[i].trim().split(/\:/);
	          tagObject[parts[0]] = parts[1];
	        }
	
	        // Set the preferences tags
	        dbOptions.read_preference_tags.push(tagObject);
	        break;
	      default:
	        break;
	    }
	  });
	
	  // No tags: should be null (not [])
	  if(dbOptions.read_preference_tags.length === 0) {
	    dbOptions.read_preference_tags = null;
	  }
	
	  // Validate if there are an invalid write concern combinations
	  if((dbOptions.w == -1 || dbOptions.w == 0) && (
	      dbOptions.journal == true
	      || dbOptions.fsync == true
	      || dbOptions.safe == true)) throw new Error("w set to -1 or 0 cannot be combined with safe/w/journal/fsync")
	
	  // If no read preference set it to primary
	  if(!dbOptions.readPreference) {
	    dbOptions.readPreference = 'primary';
	  }
	
	  // make sure that user-provided options are applied with priority
	  dbOptions = assign(dbOptions, options);
	
	  // Add servers to result
	  object.servers = servers;
	
	  // Returned parsed object
	  return object;
	}


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

	
	/**
	 * Export lib/mongoose
	 *
	 */
	
	module.exports = __webpack_require__(223);


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	var map = {
		"./connection": 131,
		"./drivers/node-mongodb-native/connection": 90
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 207;


/***/ }),
/* 208 */
/***/ (function(module, exports) {

	/**
	 * ES6 Promise wrapper constructor.
	 *
	 * Promises are returned from executed queries. Example:
	 *
	 *     var query = Candy.find({ bar: true });
	 *     var promise = query.exec();
	 *
	 * DEPRECATED. Mongoose 5.0 will use native promises by default (or bluebird,
	 * if native promises are not present) but still
	 * support plugging in your own ES6-compatible promises library. Mongoose 5.0
	 * will **not** support mpromise.
	 *
	 * @param {Function} fn a function which will be called when the promise is resolved that accepts `fn(err, ...){}` as signature
	 * @api public
	 */
	
	function ES6Promise() {
	  throw new Error('Can\'t use ES6 promise with mpromise style constructor');
	}
	
	ES6Promise.use = function(Promise) {
	  ES6Promise.ES6 = Promise;
	};
	
	module.exports = ES6Promise;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var NodeJSDocument = __webpack_require__(8);
	var EventEmitter = __webpack_require__(6).EventEmitter;
	var MongooseError = __webpack_require__(5);
	var Schema = __webpack_require__(45);
	var ObjectId = __webpack_require__(24);
	var utils = __webpack_require__(4);
	var ValidationError = MongooseError.ValidationError;
	var InternalCache = __webpack_require__(135);
	var PromiseProvider = __webpack_require__(14);
	var VersionError = __webpack_require__(5).VersionError;
	
	var Embedded;
	
	/**
	 * Document constructor.
	 *
	 * @param {Object} obj the values to set
	 * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data
	 * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `init`: Emitted on a document after it has was retrieved from the db and fully hydrated by Mongoose.
	 * @event `save`: Emitted when the document is successfully saved
	 * @api private
	 */
	
	function Document(obj, schema, fields, skipId, skipInit) {
	  if (!(this instanceof Document)) {
	    return new Document(obj, schema, fields, skipId, skipInit);
	  }
	
	
	  if (utils.isObject(schema) && !schema.instanceOfSchema) {
	    schema = new Schema(schema);
	  }
	
	  // When creating EmbeddedDocument, it already has the schema and he doesn't need the _id
	  schema = this.schema || schema;
	
	  // Generate ObjectId if it is missing, but it requires a scheme
	  if (!this.schema && schema.options._id) {
	    obj = obj || {};
	
	    if (obj._id === undefined) {
	      obj._id = new ObjectId();
	    }
	  }
	
	  if (!schema) {
	    throw new MongooseError.MissingSchemaError();
	  }
	
	  this.$__setSchema(schema);
	
	  this.$__ = new InternalCache;
	  this.$__.emitter = new EventEmitter();
	  this.isNew = true;
	  this.errors = undefined;
	
	  if (typeof fields === 'boolean') {
	    this.$__.strictMode = fields;
	    fields = undefined;
	  } else {
	    this.$__.strictMode = this.schema.options && this.schema.options.strict;
	    this.$__.selected = fields;
	  }
	
	  var required = this.schema.requiredPaths();
	  for (var i = 0; i < required.length; ++i) {
	    this.$__.activePaths.require(required[i]);
	  }
	
	  this.$__.emitter.setMaxListeners(0);
	  this._doc = this.$__buildDoc(obj, fields, skipId);
	
	  if (!skipInit && obj) {
	    this.init(obj);
	  }
	
	  this.$__registerHooksFromSchema();
	
	  // apply methods
	  for (var m in schema.methods) {
	    this[m] = schema.methods[m];
	  }
	  // apply statics
	  for (var s in schema.statics) {
	    this[s] = schema.statics[s];
	  }
	}
	
	/*!
	 * Inherit from the NodeJS document
	 */
	
	Document.prototype = Object.create(NodeJSDocument.prototype);
	Document.prototype.constructor = Document;
	
	/*!
	 * Browser doc exposes the event emitter API
	 */
	
	Document.$emitter = new EventEmitter();
	
	utils.each(
	    ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',
	      'removeAllListeners', 'addListener'],
	    function(emitterFn) {
	      Document[emitterFn] = function() {
	        return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);
	      };
	    });
	
	/*!
	 * Executes methods queued from the Schema definition
	 *
	 * @api private
	 * @method $__registerHooksFromSchema
	 * @deprecated
	 * @memberOf Document
	 */
	
	Document.prototype.$__registerHooksFromSchema = function() {
	  Embedded = Embedded || __webpack_require__(30);
	  var Promise = PromiseProvider.get();
	
	  var _this = this;
	  var q = _this.schema && _this.schema.callQueue;
	  var toWrapEl;
	  var len;
	  var i;
	  var j;
	  var pointCut;
	  var keys;
	  if (!q.length) {
	    return _this;
	  }
	
	  // we are only interested in 'pre' hooks, and group by point-cut
	  var toWrap = { post: [] };
	  var pair;
	
	  for (i = 0; i < q.length; ++i) {
	    pair = q[i];
	    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {
	      _this[pair[0]].apply(_this, pair[1]);
	      continue;
	    }
	    var args = [].slice.call(pair[1]);
	    pointCut = pair[0] === 'on' ? 'post' : args[0];
	    if (!(pointCut in toWrap)) {
	      toWrap[pointCut] = {post: [], pre: []};
	    }
	    if (pair[0] === 'post') {
	      toWrap[pointCut].post.push(args);
	    } else if (pair[0] === 'on') {
	      toWrap[pointCut].push(args);
	    } else {
	      toWrap[pointCut].pre.push(args);
	    }
	  }
	
	  // 'post' hooks are simpler
	  len = toWrap.post.length;
	  toWrap.post.forEach(function(args) {
	    _this.on.apply(_this, args);
	  });
	  delete toWrap.post;
	
	  // 'init' should be synchronous on subdocuments
	  if (toWrap.init && _this instanceof Embedded) {
	    if (toWrap.init.pre) {
	      toWrap.init.pre.forEach(function(args) {
	        _this.$pre.apply(_this, args);
	      });
	    }
	    if (toWrap.init.post) {
	      toWrap.init.post.forEach(function(args) {
	        _this.$post.apply(_this, args);
	      });
	    }
	    delete toWrap.init;
	  } else if (toWrap.set) {
	    // Set hooks also need to be sync re: gh-3479
	    if (toWrap.set.pre) {
	      toWrap.set.pre.forEach(function(args) {
	        _this.$pre.apply(_this, args);
	      });
	    }
	    if (toWrap.set.post) {
	      toWrap.set.post.forEach(function(args) {
	        _this.$post.apply(_this, args);
	      });
	    }
	    delete toWrap.set;
	  }
	
	  keys = Object.keys(toWrap);
	  len = keys.length;
	  for (i = 0; i < len; ++i) {
	    pointCut = keys[i];
	    // this is so we can wrap everything into a promise;
	    var newName = ('$__original_' + pointCut);
	    if (!_this[pointCut]) {
	      continue;
	    }
	    if (_this[pointCut].$isWrapped) {
	      continue;
	    }
	    _this[newName] = _this[pointCut];
	    _this[pointCut] = (function(_newName) {
	      return function wrappedPointCut() {
	        var args = [].slice.call(arguments);
	        var lastArg = args.pop();
	        var fn;
	        var originalError = new Error();
	        var $results;
	        if (lastArg && typeof lastArg !== 'function') {
	          args.push(lastArg);
	        } else {
	          fn = lastArg;
	        }
	
	        var promise = new Promise.ES6(function(resolve, reject) {
	          args.push(function(error) {
	            if (error) {
	              // gh-2633: since VersionError is very generic, take the
	              // stack trace of the original save() function call rather
	              // than the async trace
	              if (error instanceof VersionError) {
	                error.stack = originalError.stack;
	              }
	              _this.$__handleReject(error);
	              reject(error);
	              return;
	            }
	
	            // There may be multiple results and promise libs other than
	            // mpromise don't support passing multiple values to `resolve()`
	            $results = Array.prototype.slice.call(arguments, 1);
	            resolve.apply(promise, $results);
	          });
	
	          _this[_newName].apply(_this, args);
	        });
	        if (fn) {
	          if (_this.constructor.$wrapCallback) {
	            fn = _this.constructor.$wrapCallback(fn);
	          }
	          return promise.then(
	            function() {
	              process.nextTick(function() {
	                fn.apply(null, [null].concat($results));
	              });
	            },
	            function(error) {
	              process.nextTick(function() {
	                fn(error);
	              });
	            });
	        }
	        return promise;
	      };
	    })(newName);
	    _this[pointCut].$isWrapped = true;
	
	    toWrapEl = toWrap[pointCut];
	    var _len = toWrapEl.pre.length;
	    args;
	    for (j = 0; j < _len; ++j) {
	      args = toWrapEl.pre[j];
	      args[0] = newName;
	      _this.$pre.apply(_this, args);
	    }
	
	    _len = toWrapEl.post.length;
	    for (j = 0; j < _len; ++j) {
	      args = toWrapEl.post[j];
	      args[0] = newName;
	      _this.$post.apply(_this, args);
	    }
	  }
	  return _this;
	};
	
	/*!
	 * Module exports.
	 */
	
	Document.ValidationError = ValidationError;
	module.exports = exports = Document;


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var PromiseProvider = __webpack_require__(14);
	var Readable = __webpack_require__(18).Readable;
	var util = __webpack_require__(1);
	
	/**
	 * An AggregationCursor is a concurrency primitive for processing aggregation
	 * results one document at a time. It is analogous to QueryCursor.
	 *
	 * An AggregationCursor fulfills the [Node.js streams3 API](https://strongloop.com/strongblog/whats-new-io-js-beta-streams3/),
	 * in addition to several other mechanisms for loading documents from MongoDB
	 * one at a time.
	 *
	 * Unless you're an advanced user, do **not** instantiate this class directly.
	 * Use [`Aggregate#cursor()`](/docs/api.html#aggregate_Aggregate-cursor) instead.
	 *
	 * @param {Aggregate} agg
	 * @param {Object} options
	 * @inherits Readable
	 * @event `cursor`: Emitted when the cursor is created
	 * @event `error`: Emitted when an error occurred
	 * @event `data`: Emitted when the stream is flowing and the next doc is ready
	 * @event `end`: Emitted when the stream is exhausted
	 * @api public
	 */
	
	function AggregationCursor(agg) {
	  Readable.call(this, { objectMode: true });
	
	  this.cursor = null;
	  this.agg = agg;
	  this._transforms = [];
	  var model = agg._model;
	  delete agg.options.cursor.useMongooseAggCursor;
	
	  _init(model, this, agg);
	}
	
	util.inherits(AggregationCursor, Readable);
	
	/*!
	 * ignore
	 */
	
	function _init(model, c, agg) {
	  if (!model.collection.buffer) {
	    c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
	    c.emit('cursor', c.cursor);
	  } else {
	    model.collection.emitter.once('queue', function() {
	      c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
	      c.emit('cursor', c.cursor);
	    });
	  }
	}
	
	/*!
	 * Necessary to satisfy the Readable API
	 */
	
	AggregationCursor.prototype._read = function() {
	  var _this = this;
	  _next(this, function(error, doc) {
	    if (error) {
	      return _this.emit('error', error);
	    }
	    if (!doc) {
	      _this.push(null);
	      _this.cursor.close(function(error) {
	        if (error) {
	          return _this.emit('error', error);
	        }
	        setTimeout(function() {
	          _this.emit('close');
	        }, 0);
	      });
	      return;
	    }
	    _this.push(doc);
	  });
	};
	
	/**
	 * Registers a transform function which subsequently maps documents retrieved
	 * via the streams interface or `.next()`
	 *
	 * ####Example
	 *
	 *     // Map documents returned by `data` events
	 *     Thing.
	 *       find({ name: /^hello/ }).
	 *       cursor().
	 *       map(function (doc) {
	 *        doc.foo = "bar";
	 *        return doc;
	 *       })
	 *       on('data', function(doc) { console.log(doc.foo); });
	 *
	 *     // Or map documents returned by `.next()`
	 *     var cursor = Thing.find({ name: /^hello/ }).
	 *       cursor().
	 *       map(function (doc) {
	 *         doc.foo = "bar";
	 *         return doc;
	 *       });
	 *     cursor.next(function(error, doc) {
	 *       console.log(doc.foo);
	 *     });
	 *
	 * @param {Function} fn
	 * @return {QueryCursor}
	 * @api public
	 * @method map
	 */
	
	AggregationCursor.prototype.map = function(fn) {
	  this._transforms.push(fn);
	  return this;
	};
	
	/*!
	 * Marks this cursor as errored
	 */
	
	AggregationCursor.prototype._markError = function(error) {
	  this._error = error;
	  return this;
	};
	
	/**
	 * Marks this cursor as closed. Will stop streaming and subsequent calls to
	 * `next()` will error.
	 *
	 * @param {Function} callback
	 * @return {Promise}
	 * @api public
	 * @method close
	 * @emits close
	 * @see MongoDB driver cursor#close http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#close
	 */
	
	AggregationCursor.prototype.close = function(callback) {
	  var Promise = PromiseProvider.get();
	  var _this = this;
	  return new Promise.ES6(function(resolve, reject) {
	    _this.cursor.close(function(error) {
	      if (error) {
	        callback && callback(error);
	        reject(error);
	        return _this.listeners('error').length > 0 &&
	          _this.emit('error', error);
	      }
	      _this.emit('close');
	      resolve();
	      callback && callback();
	    });
	  });
	};
	
	/**
	 * Get the next document from this cursor. Will return `null` when there are
	 * no documents left.
	 *
	 * @param {Function} callback
	 * @return {Promise}
	 * @api public
	 * @method next
	 */
	
	AggregationCursor.prototype.next = function(callback) {
	  var Promise = PromiseProvider.get();
	  var _this = this;
	  return new Promise.ES6(function(resolve, reject) {
	    _next(_this, function(error, doc) {
	      if (error) {
	        callback && callback(error);
	        return reject(error);
	      }
	      callback && callback(null, doc);
	      resolve(doc);
	    });
	  });
	};
	
	/**
	 * Execute `fn` for every document in the cursor. If `fn` returns a promise,
	 * will wait for the promise to resolve before iterating on to the next one.
	 * Returns a promise that resolves when done.
	 *
	 * @param {Function} fn
	 * @param {Function} [callback] executed when all docs have been processed
	 * @return {Promise}
	 * @api public
	 * @method eachAsync
	 */
	
	AggregationCursor.prototype.eachAsync = function(fn, callback) {
	  var Promise = PromiseProvider.get();
	  var _this = this;
	
	  var handleNextResult = function(doc, callback) {
	    var promise = fn(doc);
	    if (promise && typeof promise.then === 'function') {
	      promise.then(
	        function() { callback(null); },
	        function(error) { callback(error); });
	    } else {
	      callback(null);
	    }
	  };
	
	  var iterate = function(callback) {
	    return _next(_this, function(error, doc) {
	      if (error) {
	        return callback(error);
	      }
	      if (!doc) {
	        return callback(null);
	      }
	      handleNextResult(doc, function(error) {
	        if (error) {
	          return callback(error);
	        }
	        // Make sure to clear the stack re: gh-4697
	        setTimeout(function() {
	          iterate(callback);
	        }, 0);
	      });
	    });
	  };
	
	  return new Promise.ES6(function(resolve, reject) {
	    iterate(function(error) {
	      if (error) {
	        callback && callback(error);
	        return reject(error);
	      }
	      callback && callback(null);
	      return resolve();
	    });
	  });
	};
	
	/**
	 * Adds a [cursor flag](http://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag).
	 * Useful for setting the `noCursorTimeout` and `tailable` flags.
	 *
	 * @param {String} flag
	 * @param {Boolean} value
	 * @return {AggregationCursor} this
	 * @api public
	 * @method addCursorFlag
	 */
	
	AggregationCursor.prototype.addCursorFlag = function(flag, value) {
	  var _this = this;
	  _waitForCursor(this, function() {
	    _this.cursor.addCursorFlag(flag, value);
	  });
	  return this;
	};
	
	/*!
	 * ignore
	 */
	
	function _waitForCursor(ctx, cb) {
	  if (ctx.cursor) {
	    return cb();
	  }
	  ctx.once('cursor', function() {
	    cb();
	  });
	}
	
	/*!
	 * Get the next doc from the underlying cursor and mongooseify it
	 * (populate, etc.)
	 */
	
	function _next(ctx, cb) {
	  var callback = cb;
	  if (ctx._transforms.length) {
	    callback = function(err, doc) {
	      if (err || doc === null) {
	        return cb(err, doc);
	      }
	      cb(err, ctx._transforms.reduce(function(doc, fn) {
	        return fn(doc);
	      }, doc));
	    };
	  }
	
	  if (ctx._error) {
	    return process.nextTick(function() {
	      callback(ctx._error);
	    });
	  }
	
	  if (ctx.cursor) {
	    return ctx.cursor.next(function(error, doc) {
	      if (error) {
	        return callback(error);
	      }
	      if (!doc) {
	        return callback(null, null);
	      }
	
	      callback(null, doc);
	    });
	  } else {
	    ctx.once('cursor', function() {
	      _next(ctx, cb);
	    });
	  }
	}
	
	module.exports = AggregationCursor;


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var PromiseProvider = __webpack_require__(14);
	var Readable = __webpack_require__(18).Readable;
	var eachAsync = __webpack_require__(144);
	var helpers = __webpack_require__(63);
	var util = __webpack_require__(1);
	
	/**
	 * A QueryCursor is a concurrency primitive for processing query results
	 * one document at a time. A QueryCursor fulfills the [Node.js streams3 API](https://strongloop.com/strongblog/whats-new-io-js-beta-streams3/),
	 * in addition to several other mechanisms for loading documents from MongoDB
	 * one at a time.
	 *
	 * QueryCursors execute the model's pre find hooks, but **not** the model's
	 * post find hooks.
	 *
	 * Unless you're an advanced user, do **not** instantiate this class directly.
	 * Use [`Query#cursor()`](/docs/api.html#query_Query-cursor) instead.
	 *
	 * @param {Query} query
	 * @param {Object} options query options passed to `.find()`
	 * @inherits Readable
	 * @event `cursor`: Emitted when the cursor is created
	 * @event `error`: Emitted when an error occurred
	 * @event `data`: Emitted when the stream is flowing and the next doc is ready
	 * @event `end`: Emitted when the stream is exhausted
	 * @api public
	 */
	
	function QueryCursor(query, options) {
	  Readable.call(this, { objectMode: true });
	
	  this.cursor = null;
	  this.query = query;
	  this._transforms = options.transform ? [options.transform] : [];
	  var _this = this;
	  var model = query.model;
	  model.hooks.execPre('find', query, function() {
	    model.collection.find(query._conditions, options, function(err, cursor) {
	      if (_this._error) {
	        cursor.close(function() {});
	        _this.listeners('error').length > 0 && _this.emit('error', _this._error);
	      }
	      if (err) {
	        return _this.emit('error', err);
	      }
	      _this.cursor = cursor;
	      _this.emit('cursor', cursor);
	    });
	  });
	}
	
	util.inherits(QueryCursor, Readable);
	
	/*!
	 * Necessary to satisfy the Readable API
	 */
	
	QueryCursor.prototype._read = function() {
	  var _this = this;
	  _next(this, function(error, doc) {
	    if (error) {
	      return _this.emit('error', error);
	    }
	    if (!doc) {
	      _this.push(null);
	      _this.cursor.close(function(error) {
	        if (error) {
	          return _this.emit('error', error);
	        }
	        setTimeout(function() {
	          _this.emit('close');
	        }, 0);
	      });
	      return;
	    }
	    _this.push(doc);
	  });
	};
	
	/**
	 * Registers a transform function which subsequently maps documents retrieved
	 * via the streams interface or `.next()`
	 *
	 * ####Example
	 *
	 *     // Map documents returned by `data` events
	 *     Thing.
	 *       find({ name: /^hello/ }).
	 *       cursor().
	 *       map(function (doc) {
	 *        doc.foo = "bar";
	 *        return doc;
	 *       })
	 *       on('data', function(doc) { console.log(doc.foo); });
	 *
	 *     // Or map documents returned by `.next()`
	 *     var cursor = Thing.find({ name: /^hello/ }).
	 *       cursor().
	 *       map(function (doc) {
	 *         doc.foo = "bar";
	 *         return doc;
	 *       });
	 *     cursor.next(function(error, doc) {
	 *       console.log(doc.foo);
	 *     });
	 *
	 * @param {Function} fn
	 * @return {QueryCursor}
	 * @api public
	 * @method map
	 */
	
	QueryCursor.prototype.map = function(fn) {
	  this._transforms.push(fn);
	  return this;
	};
	
	/*!
	 * Marks this cursor as errored
	 */
	
	QueryCursor.prototype._markError = function(error) {
	  this._error = error;
	  return this;
	};
	
	/**
	 * Marks this cursor as closed. Will stop streaming and subsequent calls to
	 * `next()` will error.
	 *
	 * @param {Function} callback
	 * @return {Promise}
	 * @api public
	 * @method close
	 * @emits close
	 * @see MongoDB driver cursor#close http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#close
	 */
	
	QueryCursor.prototype.close = function(callback) {
	  var Promise = PromiseProvider.get();
	  var _this = this;
	  return new Promise.ES6(function(resolve, reject) {
	    _this.cursor.close(function(error) {
	      if (error) {
	        callback && callback(error);
	        reject(error);
	        return _this.listeners('error').length > 0 &&
	          _this.emit('error', error);
	      }
	      _this.emit('close');
	      resolve();
	      callback && callback();
	    });
	  });
	};
	
	/**
	 * Get the next document from this cursor. Will return `null` when there are
	 * no documents left.
	 *
	 * @param {Function} callback
	 * @return {Promise}
	 * @api public
	 * @method next
	 */
	
	QueryCursor.prototype.next = function(callback) {
	  var Promise = PromiseProvider.get();
	  var _this = this;
	  return new Promise.ES6(function(resolve, reject) {
	    _next(_this, function(error, doc) {
	      if (error) {
	        callback && callback(error);
	        return reject(error);
	      }
	      callback && callback(null, doc);
	      resolve(doc);
	    });
	  });
	};
	
	/**
	 * Execute `fn` for every document in the cursor. If `fn` returns a promise,
	 * will wait for the promise to resolve before iterating on to the next one.
	 * Returns a promise that resolves when done.
	 *
	 * @param {Function} fn
	 * @param {Object} [options]
	 * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.
	 * @param {Function} [callback] executed when all docs have been processed
	 * @return {Promise}
	 * @api public
	 * @method eachAsync
	 */
	
	QueryCursor.prototype.eachAsync = function(fn, opts, callback) {
	  var _this = this;
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  opts = opts || {};
	
	  return eachAsync(function(cb) { return _next(_this, cb); }, fn, opts, callback);
	};
	
	/**
	 * Adds a [cursor flag](http://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag).
	 * Useful for setting the `noCursorTimeout` and `tailable` flags.
	 *
	 * @param {String} flag
	 * @param {Boolean} value
	 * @return {AggregationCursor} this
	 * @api public
	 * @method addCursorFlag
	 */
	
	QueryCursor.prototype.addCursorFlag = function(flag, value) {
	  var _this = this;
	  _waitForCursor(this, function() {
	    _this.cursor.addCursorFlag(flag, value);
	  });
	  return this;
	};
	
	/*!
	 * Get the next doc from the underlying cursor and mongooseify it
	 * (populate, etc.)
	 */
	
	function _next(ctx, cb) {
	  var callback = cb;
	  if (ctx._transforms.length) {
	    callback = function(err, doc) {
	      if (err || doc === null) {
	        return cb(err, doc);
	      }
	      cb(err, ctx._transforms.reduce(function(doc, fn) {
	        return fn(doc);
	      }, doc));
	    };
	  }
	
	  if (ctx._error) {
	    return process.nextTick(function() {
	      callback(ctx._error);
	    });
	  }
	
	  if (ctx.cursor) {
	    return ctx.cursor.next(function(error, doc) {
	      if (error) {
	        return callback(error);
	      }
	      if (!doc) {
	        return callback(null, null);
	      }
	
	      var opts = ctx.query._mongooseOptions;
	      if (!opts.populate) {
	        return opts.lean === true ?
	                callback(null, doc) :
	                _create(ctx, doc, null, callback);
	      }
	
	      var pop = helpers.preparePopulationOptionsMQ(ctx.query,
	        ctx.query._mongooseOptions);
	      pop.__noPromise = true;
	      ctx.query.model.populate(doc, pop, function(err, doc) {
	        if (err) {
	          return callback(err);
	        }
	        return opts.lean === true ?
	          callback(null, doc) :
	          _create(ctx, doc, pop, callback);
	      });
	    });
	  } else {
	    ctx.once('cursor', function() {
	      _next(ctx, cb);
	    });
	  }
	}
	
	/*!
	 * ignore
	 */
	
	function _waitForCursor(ctx, cb) {
	  if (ctx.cursor) {
	    return cb();
	  }
	  ctx.once('cursor', function() {
	    cb();
	  });
	}
	
	/*!
	 * Convert a raw doc into a full mongoose doc.
	 */
	
	function _create(ctx, doc, populatedIds, cb) {
	  var instance = helpers.createModel(ctx.query.model, doc, ctx.query._fields);
	  var opts = populatedIds ?
	    { populated: populatedIds } :
	    undefined;
	
	  instance.init(doc, opts, function(err) {
	    if (err) {
	      return cb(err);
	    }
	    cb(null, instance);
	  });
	}
	
	module.exports = QueryCursor;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	var map = {
		"./browser/ReadPreference": 84,
		"./browser/ReadPreference.js": 84,
		"./browser/binary": 85,
		"./browser/binary.js": 85,
		"./browser/index": 62,
		"./browser/index.js": 62,
		"./browser/objectid": 86,
		"./browser/objectid.js": 86,
		"./index": 29,
		"./index.js": 29,
		"./index.web": 133,
		"./index.web.js": 133,
		"./node-mongodb-native/ReadPreference": 87,
		"./node-mongodb-native/ReadPreference.js": 87,
		"./node-mongodb-native/binary": 88,
		"./node-mongodb-native/binary.js": 88,
		"./node-mongodb-native/collection": 89,
		"./node-mongodb-native/collection.js": 89,
		"./node-mongodb-native/connection": 90,
		"./node-mongodb-native/connection.js": 90,
		"./node-mongodb-native/index": 91,
		"./node-mongodb-native/index.js": 91,
		"./node-mongodb-native/objectid": 92,
		"./node-mongodb-native/objectid.js": 92
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 212;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(5);
	
	/**
	 * Casting Error constructor.
	 *
	 * @param {String} type
	 * @param {String} value
	 * @inherits MongooseError
	 * @api private
	 */
	
	function DisconnectedError(connectionString) {
	  MongooseError.call(this, 'Ran out of retries trying to reconnect to "' +
	    connectionString + '". Try setting `server.reconnectTries` and ' +
	    '`server.reconnectInterval` to something higher.');
	  this.name = 'DisconnectedError';
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	DisconnectedError.prototype = Object.create(MongooseError.prototype);
	DisconnectedError.prototype.constructor = MongooseError;
	
	
	/*!
	 * exports
	 */
	
	module.exports = DisconnectedError;


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(5);
	
	/*!
	 * DivergentArrayError constructor.
	 *
	 * @inherits MongooseError
	 */
	
	function DivergentArrayError(paths) {
	  var msg = 'For your own good, using `document.save()` to update an array '
	          + 'which was selected using an $elemMatch projection OR '
	          + 'populated using skip, limit, query conditions, or exclusion of '
	          + 'the _id field when the operation results in a $pop or $set of '
	          + 'the entire array is not supported. The following '
	          + 'path(s) would have been modified unsafely:\n'
	          + '  ' + paths.join('\n  ') + '\n'
	          + 'Use Model.update() to update these arrays instead.';
	          // TODO write up a docs page (FAQ) and link to it
	
	  MongooseError.call(this, msg);
	  this.name = 'DivergentArrayError';
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	DivergentArrayError.prototype = Object.create(MongooseError.prototype);
	DivergentArrayError.prototype.constructor = MongooseError;
	
	
	/*!
	 * exports
	 */
	
	module.exports = DivergentArrayError;


/***/ }),
/* 215 */
/***/ (function(module, exports) {

	
	/**
	 * The default built-in validator error messages. These may be customized.
	 *
	 *     // customize within each schema or globally like so
	 *     var mongoose = require('mongoose');
	 *     mongoose.Error.messages.String.enum  = "Your custom message for {PATH}.";
	 *
	 * As you might have noticed, error messages support basic templating
	 *
	 * - `{PATH}` is replaced with the invalid document path
	 * - `{VALUE}` is replaced with the invalid value
	 * - `{TYPE}` is replaced with the validator type such as "regexp", "min", or "user defined"
	 * - `{MIN}` is replaced with the declared min value for the Number.min validator
	 * - `{MAX}` is replaced with the declared max value for the Number.max validator
	 *
	 * Click the "show code" link below to see all defaults.
	 *
	 * @static messages
	 * @receiver MongooseError
	 * @api public
	 */
	
	var msg = module.exports = exports = {};
	
	msg.DocumentNotFoundError = null;
	
	msg.general = {};
	msg.general.default = 'Validator failed for path `{PATH}` with value `{VALUE}`';
	msg.general.required = 'Path `{PATH}` is required.';
	
	msg.Number = {};
	msg.Number.min = 'Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).';
	msg.Number.max = 'Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).';
	
	msg.Date = {};
	msg.Date.min = 'Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).';
	msg.Date.max = 'Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).';
	
	msg.String = {};
	msg.String.enum = '`{VALUE}` is not a valid enum value for path `{PATH}`.';
	msg.String.match = 'Path `{PATH}` is invalid ({VALUE}).';
	msg.String.minlength = 'Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).';
	msg.String.maxlength = 'Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).';


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(5);
	
	/*!
	 * MissingSchema Error constructor.
	 *
	 * @inherits MongooseError
	 */
	
	function MissingSchemaError(name) {
	  var msg = 'Schema hasn\'t been registered for model "' + name + '".\n'
	          + 'Use mongoose.model(name, schema)';
	  MongooseError.call(this, msg);
	  this.name = 'MissingSchemaError';
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	MissingSchemaError.prototype = Object.create(MongooseError.prototype);
	MissingSchemaError.prototype.constructor = MongooseError;
	
	/*!
	 * exports
	 */
	
	module.exports = MissingSchemaError;


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(5);
	var util = __webpack_require__(1);
	
	/*!
	 * OverwriteModel Error constructor.
	 *
	 * @inherits MongooseError
	 */
	
	function DocumentNotFoundError(query) {
	  var msg;
	  var messages = MongooseError.messages;
	  if (messages.DocumentNotFoundError != null) {
	    msg = typeof messages.DocumentNotFoundError === 'function' ?
	      messages.DocumentNotFoundError(query) :
	      messages.DocumentNotFoundError;
	  } else {
	    msg = 'No document found for query "' + util.inspect(query) + '"';
	  }
	
	  MongooseError.call(this, msg);
	
	  this.name = 'DocumentNotFoundError';
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	
	  this.query = query;
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	DocumentNotFoundError.prototype = Object.create(MongooseError.prototype);
	DocumentNotFoundError.prototype.constructor = MongooseError;
	
	/*!
	 * exports
	 */
	
	module.exports = DocumentNotFoundError;


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(5);
	
	/**
	 * Strict mode error constructor
	 *
	 * @param {String} type
	 * @param {String} value
	 * @inherits MongooseError
	 * @api private
	 */
	
	function ObjectExpectedError(path, val) {
	  MongooseError.call(this, 'Tried to set nested object field `' + path +
	    '` to primitive value `' + val + '` and strict mode is set to throw.');
	  this.name = 'ObjectExpectedError';
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	  this.path = path;
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	ObjectExpectedError.prototype = Object.create(MongooseError.prototype);
	ObjectExpectedError.prototype.constructor = MongooseError;
	
	module.exports = ObjectExpectedError;


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(5);
	
	/**
	 * Constructor for errors that happen when a parameter that's expected to be
	 * an object isn't an object
	 *
	 * @param {Any} value
	 * @param {String} paramName
	 * @param {String} fnName
	 * @inherits MongooseError
	 * @api private
	 */
	
	function ObjectParameterError(value, paramName, fnName) {
	  MongooseError.call(this, 'Parameter "' + paramName + '" to ' + fnName +
	    '() must be an object, got ' + value.toString());
	  this.name = 'ObjectParameterError';
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	ObjectParameterError.prototype = Object.create(MongooseError.prototype);
	ObjectParameterError.prototype.constructor = MongooseError;
	
	module.exports = ObjectParameterError;


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(5);
	
	/*!
	 * OverwriteModel Error constructor.
	 *
	 * @inherits MongooseError
	 */
	
	function OverwriteModelError(name) {
	  MongooseError.call(this, 'Cannot overwrite `' + name + '` model once compiled.');
	  this.name = 'OverwriteModelError';
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	OverwriteModelError.prototype = Object.create(MongooseError.prototype);
	OverwriteModelError.prototype.constructor = MongooseError;
	
	/*!
	 * exports
	 */
	
	module.exports = OverwriteModelError;


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(5);
	
	/**
	 * Schema validator error
	 *
	 * @param {Object} properties
	 * @inherits MongooseError
	 * @api private
	 */
	
	function ValidatorError(properties) {
	  var msg = properties.message;
	  if (!msg) {
	    msg = MongooseError.messages.general.default;
	  }
	
	  var message = this.formatMessage(msg, properties);
	  MongooseError.call(this, message);
	  this.name = 'ValidatorError';
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this);
	  } else {
	    this.stack = new Error().stack;
	  }
	  this.properties = properties;
	  this.kind = properties.type;
	  this.path = properties.path;
	  this.value = properties.value;
	  this.reason = properties.reason;
	}
	
	/*!
	 * Inherits from MongooseError
	 */
	
	ValidatorError.prototype = Object.create(MongooseError.prototype);
	ValidatorError.prototype.constructor = MongooseError;
	
	/*!
	 * The object used to define this validator. Not enumerable to hide
	 * it from `require('util').inspect()` output re: gh-3925
	 */
	
	Object.defineProperty(ValidatorError.prototype, 'properties', {
	  enumerable: false,
	  writable: true,
	  value: null
	});
	
	/*!
	 * Formats error messages
	 */
	
	ValidatorError.prototype.formatMessage = function(msg, properties) {
	  var propertyNames = Object.keys(properties);
	  for (var i = 0; i < propertyNames.length; ++i) {
	    var propertyName = propertyNames[i];
	    if (propertyName === 'message') {
	      continue;
	    }
	    msg = msg.replace('{' + propertyName.toUpperCase() + '}', properties[propertyName]);
	  }
	  return msg;
	};
	
	/*!
	 * toString helper
	 */
	
	ValidatorError.prototype.toString = function() {
	  return this.message;
	};
	
	/*!
	 * exports
	 */
	
	module.exports = ValidatorError;


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/*!
	 * Module dependencies.
	 */
	
	var MongooseError = __webpack_require__(5);
	
	/**
	 * Version Error constructor.
	 *
	 * @inherits MongooseError
	 * @api private
	 */
	
	function VersionError(doc) {
	  MongooseError.call(this, 'No matching document found for id "' + doc._id +
	    '"');
	  this.name = 'VersionError';
	}
	
	/*!
	 * Inherits from MongooseError.
	 */
	
	VersionError.prototype = Object.create(MongooseError.prototype);
	VersionError.prototype.constructor = MongooseError;
	
	/*!
	 * exports
	 */
	
	module.exports = VersionError;


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/*!
	 * Module dependencies.
	 */
	
	var Schema = __webpack_require__(45);
	var SchemaType = __webpack_require__(12);
	var VirtualType = __webpack_require__(103);
	var STATES = __webpack_require__(61);
	var Types = __webpack_require__(31);
	var Query = __webpack_require__(94);
	var Model = __webpack_require__(224);
	var Document = __webpack_require__(8);
	var utils = __webpack_require__(4);
	var format = utils.toCollectionName;
	var pkg = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../package.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	
	var querystring = __webpack_require__(155);
	var saveSubdocs = __webpack_require__(226);
	var validateBeforeSave = __webpack_require__(228);
	
	var Aggregate = __webpack_require__(129);
	var PromiseProvider = __webpack_require__(14);
	var shardingPlugin = __webpack_require__(227);
	
	/**
	 * Mongoose constructor.
	 *
	 * The exports object of the `mongoose` module is an instance of this class.
	 * Most apps will only use this one instance.
	 *
	 * @api public
	 */
	
	function Mongoose() {
	  this.connections = [];
	  this.models = {};
	  this.modelSchemas = {};
	  // default global options
	  this.options = {
	    pluralization: true
	  };
	  var conn = this.createConnection(); // default connection
	  conn.models = this.models;
	
	  Object.defineProperty(this, 'plugins', {
	    configurable: false,
	    enumerable: true,
	    writable: false,
	    value: [
	      [saveSubdocs, { deduplicate: true }],
	      [validateBeforeSave, { deduplicate: true }],
	      [shardingPlugin, { deduplicate: true }]
	    ]
	  });
	}
	
	/**
	 * Expose connection states for user-land
	 *
	 */
	Mongoose.prototype.STATES = STATES;
	
	/**
	 * Sets mongoose options
	 *
	 * ####Example:
	 *
	 *     mongoose.set('test', value) // sets the 'test' option to `value`
	 *
	 *     mongoose.set('debug', true) // enable logging collection methods + arguments to the console
	 *
	 *     mongoose.set('debug', function(collectionName, methodName, arg1, arg2...) {}); // use custom function to log collection methods + arguments
	 *
	 * @param {String} key
	 * @param {String|Function|Boolean} value
	 * @api public
	 */
	
	Mongoose.prototype.set = function(key, value) {
	  if (arguments.length === 1) {
	    return this.options[key];
	  }
	
	  this.options[key] = value;
	  return this;
	};
	Mongoose.prototype.set.$hasSideEffects = true;
	
	/**
	 * Gets mongoose options
	 *
	 * ####Example:
	 *
	 *     mongoose.get('test') // returns the 'test' value
	 *
	 * @param {String} key
	 * @method get
	 * @api public
	 */
	
	Mongoose.prototype.get = Mongoose.prototype.set;
	
	/*!
	 * ReplSet connection string check.
	 */
	
	var rgxReplSet = /^.+,.+$/;
	
	/**
	 * Checks if ?replicaSet query parameter is specified in URI
	 *
	 * ####Example:
	 *
	 *     checkReplicaSetInUri('localhost:27000?replicaSet=rs0'); // true
	 *
	 * @param {String} uri
	 * @return {boolean}
	 * @api private
	 */
	
	var checkReplicaSetInUri = function(uri) {
	  if (!uri) {
	    return false;
	  }
	
	  var queryStringStart = uri.indexOf('?');
	  var isReplicaSet = false;
	  if (queryStringStart !== -1) {
	    try {
	      var obj = querystring.parse(uri.substr(queryStringStart + 1));
	      if (obj && obj.replicaSet) {
	        isReplicaSet = true;
	      }
	    } catch (e) {
	      return false;
	    }
	  }
	
	  return isReplicaSet;
	};
	
	/**
	 * Creates a Connection instance.
	 *
	 * Each `connection` instance maps to a single database. This method is helpful when mangaging multiple db connections.
	 *
	 * If arguments are passed, they are proxied to either [Connection#open](#connection_Connection-open) or [Connection#openSet](#connection_Connection-openSet) appropriately. This means we can pass `db`, `server`, and `replset` options to the driver. _Note that the `safe` option specified in your schema will overwrite the `safe` db option specified here unless you set your schemas `safe` option to `undefined`. See [this](/docs/guide.html#safe) for more information._
	 *
	 * _Options passed take precedence over options included in connection strings._
	 *
	 * ####Example:
	 *
	 *     // with mongodb:// URI
	 *     db = mongoose.createConnection('mongodb://user:pass@localhost:port/database');
	 *
	 *     // and options
	 *     var opts = { db: { native_parser: true }}
	 *     db = mongoose.createConnection('mongodb://user:pass@localhost:port/database', opts);
	 *
	 *     // replica sets
	 *     db = mongoose.createConnection('mongodb://user:pass@localhost:port,anotherhost:port,yetanother:port/database');
	 *
	 *     // and options
	 *     var opts = { replset: { strategy: 'ping', rs_name: 'testSet' }}
	 *     db = mongoose.createConnection('mongodb://user:pass@localhost:port,anotherhost:port,yetanother:port/database', opts);
	 *
	 *     // with [host, database_name[, port] signature
	 *     db = mongoose.createConnection('localhost', 'database', port)
	 *
	 *     // and options
	 *     var opts = { server: { auto_reconnect: false }, user: 'username', pass: 'mypassword' }
	 *     db = mongoose.createConnection('localhost', 'database', port, opts)
	 *
	 *     // initialize now, connect later
	 *     db = mongoose.createConnection();
	 *     db.open('localhost', 'database', port, [opts]);
	 *
	 * @param {String} [uri] a mongodb:// URI
	 * @param {Object} [options] options to pass to the driver
	 * @param {Object} [options.config] mongoose-specific options
	 * @param {Boolean} [options.config.autoIndex] set to false to disable automatic index creation for all models associated with this connection.
	 * @param {Boolean} [options.useMongoClient] false by default, set to true to use new mongoose connection logic
	 * @see Connection#open #connection_Connection-open
	 * @see Connection#openSet #connection_Connection-openSet
	 * @return {Connection|Promise} the created Connection object, or promise that resolves to the connection if `useMongoClient` option specified.
	 * @api public
	 */
	
	Mongoose.prototype.createConnection = function(uri, options) {
	  var conn = new Connection(this);
	  this.connections.push(conn);
	
	  var rsOption = options && (options.replset || options.replSet);
	
	  if (options && options.useMongoClient) {
	    return conn.openUri(uri, options);
	  }
	
	  if (arguments.length) {
	    if (rgxReplSet.test(arguments[0]) || checkReplicaSetInUri(arguments[0])) {
	      conn._openSetWithoutPromise.apply(conn, arguments);
	    } else if (rsOption &&
	        (rsOption.replicaSet || rsOption.rs_name)) {
	      conn._openSetWithoutPromise.apply(conn, arguments);
	    } else {
	      conn._openWithoutPromise.apply(conn, arguments);
	    }
	  }
	
	  return conn;
	};
	Mongoose.prototype.createConnection.$hasSideEffects = true;
	
	/**
	 * Opens the default mongoose connection.
	 *
	 * If arguments are passed, they are proxied to either
	 * [Connection#open](#connection_Connection-open) or
	 * [Connection#openSet](#connection_Connection-openSet) appropriately.
	 *
	 * _Options passed take precedence over options included in connection strings._
	 *
	 * ####Example:
	 *
	 *     mongoose.connect('mongodb://user:pass@localhost:port/database');
	 *
	 *     // replica sets
	 *     var uri = 'mongodb://user:pass@localhost:port,anotherhost:port,yetanother:port/mydatabase';
	 *     mongoose.connect(uri);
	 *
	 *     // with options
	 *     mongoose.connect(uri, options);
	 *
	 *     // connecting to multiple mongos
	 *     var uri = 'mongodb://hostA:27501,hostB:27501';
	 *     var opts = { mongos: true };
	 *     mongoose.connect(uri, opts);
	 *
	 *     // optional callback that gets fired when initial connection completed
	 *     var uri = 'mongodb://nonexistent.domain:27000';
	 *     mongoose.connect(uri, function(error) {
	 *       // if error is truthy, the initial connection failed.
	 *     })
	 *
	 * @param {String} uri(s)
	 * @param {Object} [options]
	 * @param {Boolean} [options.useMongoClient] false by default, set to true to use new mongoose connection logic
	 * @param {Function} [callback]
	 * @see Mongoose#createConnection #index_Mongoose-createConnection
	 * @api public
	 * @return {MongooseThenable} pseudo-promise wrapper around this
	 */
	
	Mongoose.prototype.connect = function() {
	  var conn = this.connection;
	  if ((arguments.length === 2 || arguments.length === 3) &&
	      typeof arguments[0] === 'string' &&
	      typeof arguments[1] === 'object' &&
	      arguments[1].useMongoClient === true) {
	    return conn.openUri(arguments[0], arguments[1], arguments[2]);
	  }
	  if (rgxReplSet.test(arguments[0]) || checkReplicaSetInUri(arguments[0])) {
	    return new MongooseThenable(this, conn.openSet.apply(conn, arguments));
	  }
	
	  return new MongooseThenable(this, conn.open.apply(conn, arguments));
	};
	Mongoose.prototype.connect.$hasSideEffects = true;
	
	/**
	 * Disconnects all connections.
	 *
	 * @param {Function} [fn] called after all connection close.
	 * @return {MongooseThenable} pseudo-promise wrapper around this
	 * @api public
	 */
	
	Mongoose.prototype.disconnect = function(fn) {
	  var _this = this;
	
	  var Promise = PromiseProvider.get();
	  return new MongooseThenable(this, new Promise.ES6(function(resolve, reject) {
	    var remaining = _this.connections.length;
	    if (remaining <= 0) {
	      fn && fn();
	      resolve();
	      return;
	    }
	    _this.connections.forEach(function(conn) {
	      conn.close(function(error) {
	        if (error) {
	          fn && fn(error);
	          reject(error);
	          return;
	        }
	        if (!--remaining) {
	          fn && fn();
	          resolve();
	        }
	      });
	    });
	  }));
	};
	Mongoose.prototype.disconnect.$hasSideEffects = true;
	
	/**
	 * Defines a model or retrieves it.
	 *
	 * Models defined on the `mongoose` instance are available to all connection created by the same `mongoose` instance.
	 *
	 * ####Example:
	 *
	 *     var mongoose = require('mongoose');
	 *
	 *     // define an Actor model with this mongoose instance
	 *     mongoose.model('Actor', new Schema({ name: String }));
	 *
	 *     // create a new connection
	 *     var conn = mongoose.createConnection(..);
	 *
	 *     // retrieve the Actor model
	 *     var Actor = conn.model('Actor');
	 *
	 * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the [utils.toCollectionName](#utils_exports.toCollectionName) method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._
	 *
	 * ####Example:
	 *
	 *     var schema = new Schema({ name: String }, { collection: 'actor' });
	 *
	 *     // or
	 *
	 *     schema.set('collection', 'actor');
	 *
	 *     // or
	 *
	 *     var collectionName = 'actor'
	 *     var M = mongoose.model('Actor', schema, collectionName)
	 *
	 * @param {String|Function} name model name or class extending Model
	 * @param {Schema} [schema]
	 * @param {String} [collection] name (optional, inferred from model name)
	 * @param {Boolean} [skipInit] whether to skip initialization (defaults to false)
	 * @api public
	 */
	
	Mongoose.prototype.model = function(name, schema, collection, skipInit) {
	  var model;
	  if (typeof name === 'function') {
	    model = name;
	    name = model.name;
	    if (!(model.prototype instanceof Model)) {
	      throw new mongoose.Error('The provided class ' + name + ' must extend Model');
	    }
	  }
	
	  if (typeof schema === 'string') {
	    collection = schema;
	    schema = false;
	  }
	
	  if (utils.isObject(schema) && !(schema.instanceOfSchema)) {
	    schema = new Schema(schema);
	  }
	  if (schema && !schema.instanceOfSchema) {
	    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +
	      'schema or a POJO');
	  }
	
	  if (typeof collection === 'boolean') {
	    skipInit = collection;
	    collection = null;
	  }
	
	  // handle internal options from connection.model()
	  var options;
	  if (skipInit && utils.isObject(skipInit)) {
	    options = skipInit;
	    skipInit = true;
	  } else {
	    options = {};
	  }
	
	  // look up schema for the collection.
	  if (!this.modelSchemas[name]) {
	    if (schema) {
	      // cache it so we only apply plugins once
	      this.modelSchemas[name] = schema;
	    } else {
	      throw new mongoose.Error.MissingSchemaError(name);
	    }
	  }
	
	  if (schema) {
	    this._applyPlugins(schema);
	  }
	
	  var sub;
	
	  // connection.model() may be passing a different schema for
	  // an existing model name. in this case don't read from cache.
	  if (this.models[name] && options.cache !== false) {
	    if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {
	      throw new mongoose.Error.OverwriteModelError(name);
	    }
	
	    if (collection) {
	      // subclass current model with alternate collection
	      model = this.models[name];
	      schema = model.prototype.schema;
	      sub = model.__subclass(this.connection, schema, collection);
	      // do not cache the sub model
	      return sub;
	    }
	
	    return this.models[name];
	  }
	
	  // ensure a schema exists
	  if (!schema) {
	    schema = this.modelSchemas[name];
	    if (!schema) {
	      throw new mongoose.Error.MissingSchemaError(name);
	    }
	  }
	
	  // Apply relevant "global" options to the schema
	  if (!('pluralization' in schema.options)) schema.options.pluralization = this.options.pluralization;
	
	
	  if (!collection) {
	    collection = schema.get('collection') || format(name, schema.options);
	  }
	
	  var connection = options.connection || this.connection;
	  model = this.Model.compile(model || name, schema, collection, connection, this);
	
	  if (!skipInit) {
	    model.init();
	  }
	
	  if (options.cache === false) {
	    return model;
	  }
	
	  this.models[name] = model;
	  return this.models[name];
	};
	Mongoose.prototype.model.$hasSideEffects = true;
	
	/**
	 * Returns an array of model names created on this instance of Mongoose.
	 *
	 * ####Note:
	 *
	 * _Does not include names of models created using `connection.model()`._
	 *
	 * @api public
	 * @return {Array}
	 */
	
	Mongoose.prototype.modelNames = function() {
	  var names = Object.keys(this.models);
	  return names;
	};
	Mongoose.prototype.modelNames.$hasSideEffects = true;
	
	/**
	 * Applies global plugins to `schema`.
	 *
	 * @param {Schema} schema
	 * @api private
	 */
	
	Mongoose.prototype._applyPlugins = function(schema) {
	  if (schema.$globalPluginsApplied) {
	    return;
	  }
	  var i;
	  var len;
	  for (i = 0, len = this.plugins.length; i < len; ++i) {
	    schema.plugin(this.plugins[i][0], this.plugins[i][1]);
	  }
	  schema.$globalPluginsApplied = true;
	  for (i = 0, len = schema.childSchemas.length; i < len; ++i) {
	    this._applyPlugins(schema.childSchemas[i].schema);
	  }
	};
	Mongoose.prototype._applyPlugins.$hasSideEffects = true;
	
	/**
	 * Declares a global plugin executed on all Schemas.
	 *
	 * Equivalent to calling `.plugin(fn)` on each Schema you create.
	 *
	 * @param {Function} fn plugin callback
	 * @param {Object} [opts] optional options
	 * @return {Mongoose} this
	 * @see plugins ./plugins.html
	 * @api public
	 */
	
	Mongoose.prototype.plugin = function(fn, opts) {
	  this.plugins.push([fn, opts]);
	  return this;
	};
	Mongoose.prototype.plugin.$hasSideEffects = true;
	
	/**
	 * The default connection of the mongoose module.
	 *
	 * ####Example:
	 *
	 *     var mongoose = require('mongoose');
	 *     mongoose.connect(...);
	 *     mongoose.connection.on('error', cb);
	 *
	 * This is the connection used by default for every model created using [mongoose.model](#index_Mongoose-model).
	 *
	 * @property connection
	 * @return {Connection}
	 * @api public
	 */
	
	Mongoose.prototype.__defineGetter__('connection', function() {
	  return this.connections[0];
	});
	
	Mongoose.prototype.__defineSetter__('connection', function(v) {
	  this.connections[0] = v;
	});
	
	/*!
	 * Driver depentend APIs
	 */
	
	var driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native';
	
	/*!
	 * Connection
	 */
	
	var Connection = __webpack_require__(207)(driver + '/connection');
	
	/*!
	 * Collection
	 */
	
	var Collection = __webpack_require__(128)(driver + '/collection');
	
	/**
	 * The Mongoose Aggregate constructor
	 *
	 * @method Aggregate
	 * @api public
	 */
	
	Mongoose.prototype.Aggregate = Aggregate;
	
	/**
	 * The Mongoose Collection constructor
	 *
	 * @method Collection
	 * @api public
	 */
	
	Mongoose.prototype.Collection = Collection;
	
	/**
	 * The Mongoose [Connection](#connection_Connection) constructor
	 *
	 * @method Connection
	 * @api public
	 */
	
	Mongoose.prototype.Connection = Connection;
	
	/**
	 * The Mongoose version
	 *
	 * @property version
	 * @api public
	 */
	
	Mongoose.prototype.version = pkg.version;
	
	/**
	 * The Mongoose constructor
	 *
	 * The exports of the mongoose module is an instance of this class.
	 *
	 * ####Example:
	 *
	 *     var mongoose = require('mongoose');
	 *     var mongoose2 = new mongoose.Mongoose();
	 *
	 * @method Mongoose
	 * @api public
	 */
	
	Mongoose.prototype.Mongoose = Mongoose;
	
	/**
	 * The Mongoose [Schema](#schema_Schema) constructor
	 *
	 * ####Example:
	 *
	 *     var mongoose = require('mongoose');
	 *     var Schema = mongoose.Schema;
	 *     var CatSchema = new Schema(..);
	 *
	 * @method Schema
	 * @api public
	 */
	
	Mongoose.prototype.Schema = Schema;
	
	/**
	 * The Mongoose [SchemaType](#schematype_SchemaType) constructor
	 *
	 * @method SchemaType
	 * @api public
	 */
	
	Mongoose.prototype.SchemaType = SchemaType;
	
	/**
	 * The various Mongoose SchemaTypes.
	 *
	 * ####Note:
	 *
	 * _Alias of mongoose.Schema.Types for backwards compatibility._
	 *
	 * @property SchemaTypes
	 * @see Schema.SchemaTypes #schema_Schema.Types
	 * @api public
	 */
	
	Mongoose.prototype.SchemaTypes = Schema.Types;
	
	/**
	 * The Mongoose [VirtualType](#virtualtype_VirtualType) constructor
	 *
	 * @method VirtualType
	 * @api public
	 */
	
	Mongoose.prototype.VirtualType = VirtualType;
	
	/**
	 * The various Mongoose Types.
	 *
	 * ####Example:
	 *
	 *     var mongoose = require('mongoose');
	 *     var array = mongoose.Types.Array;
	 *
	 * ####Types:
	 *
	 * - [ObjectId](#types-objectid-js)
	 * - [Buffer](#types-buffer-js)
	 * - [SubDocument](#types-embedded-js)
	 * - [Array](#types-array-js)
	 * - [DocumentArray](#types-documentarray-js)
	 *
	 * Using this exposed access to the `ObjectId` type, we can construct ids on demand.
	 *
	 *     var ObjectId = mongoose.Types.ObjectId;
	 *     var id1 = new ObjectId;
	 *
	 * @property Types
	 * @api public
	 */
	
	Mongoose.prototype.Types = Types;
	
	/**
	 * The Mongoose [Query](#query_Query) constructor.
	 *
	 * @method Query
	 * @api public
	 */
	
	Mongoose.prototype.Query = Query;
	
	/**
	 * The Mongoose [Promise](#promise_Promise) constructor.
	 *
	 * @method Promise
	 * @api public
	 */
	
	Object.defineProperty(Mongoose.prototype, 'Promise', {
	  get: function() {
	    return PromiseProvider.get();
	  },
	  set: function(lib) {
	    PromiseProvider.set(lib);
	  }
	});
	
	/**
	 * Returns the current ES6-style promise constructor. In Mongoose 4.x,
	 * equivalent to `mongoose.Promise.ES6`, but will change once we get rid
	 * of the `.ES6` bit.
	 *
	 * @method Promise
	 * @api public
	 */
	
	Mongoose.prototype.getPromiseConstructor = function() {
	  return PromiseProvider.get().ES6;
	};
	
	/**
	 * Storage layer for mongoose promises
	 *
	 * @method PromiseProvider
	 * @api public
	 */
	
	Mongoose.prototype.PromiseProvider = PromiseProvider;
	
	/**
	 * The Mongoose [Model](#model_Model) constructor.
	 *
	 * @method Model
	 * @api public
	 */
	
	Mongoose.prototype.Model = Model;
	
	/**
	 * The Mongoose [Document](#document-js) constructor.
	 *
	 * @method Document
	 * @api public
	 */
	
	Mongoose.prototype.Document = Document;
	
	/**
	 * The Mongoose DocumentProvider constructor.
	 *
	 * @method DocumentProvider
	 * @api public
	 */
	
	Mongoose.prototype.DocumentProvider = __webpack_require__(132);
	
	/**
	 * The [MongooseError](#error_MongooseError) constructor.
	 *
	 * @method Error
	 * @api public
	 */
	
	Mongoose.prototype.Error = __webpack_require__(5);
	
	/**
	 * The Mongoose CastError constructor
	 *
	 * @method CastError
	 * @param {String} type The name of the type
	 * @param {Any} value The value that failed to cast
	 * @param {String} path The path `a.b.c` in the doc where this cast error occurred
	 * @param {Error} [reason] The original error that was thrown
	 * @api public
	 */
	
	Mongoose.prototype.CastError = __webpack_require__(44);
	
	/**
	 * The [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver Mongoose uses.
	 *
	 * @property mongo
	 * @api public
	 */
	
	Mongoose.prototype.mongo = __webpack_require__(22);
	
	/**
	 * The [mquery](https://github.com/aheckmann/mquery) query builder Mongoose uses.
	 *
	 * @property mquery
	 * @api public
	 */
	
	Mongoose.prototype.mquery = __webpack_require__(104);
	
	/**
	 * Wraps the given Mongoose instance into a thenable (pseudo-promise). This
	 * is so `connect()` and `disconnect()` can return a thenable while maintaining
	 * backwards compatibility.
	 *
	 * @api private
	 */
	
	function MongooseThenable(mongoose, promise) {
	  var _this = this;
	  for (var key in mongoose) {
	    if (typeof mongoose[key] === 'function' && mongoose[key].$hasSideEffects) {
	      (function(key) {
	        _this[key] = function() {
	          return mongoose[key].apply(mongoose, arguments);
	        };
	      })(key);
	    } else if (['connection', 'connections'].indexOf(key) !== -1) {
	      _this[key] = mongoose[key];
	    }
	  }
	  this.$opPromise = promise;
	}
	
	MongooseThenable.prototype = new Mongoose;
	
	/**
	 * Ability to use mongoose object as a pseudo-promise so `.connect().then()`
	 * and `.disconnect().then()` are viable.
	 *
	 * @param {Function} onFulfilled
	 * @param {Function} onRejected
	 * @return {Promise}
	 * @api private
	 */
	
	MongooseThenable.prototype.then = function(onFulfilled, onRejected) {
	  var Promise = PromiseProvider.get();
	  if (!this.$opPromise) {
	    return new Promise.ES6(function(resolve, reject) {
	      reject(new Error('Can only call `.then()` if connect() or disconnect() ' +
	        'has been called'));
	    }).then(onFulfilled, onRejected);
	  }
	  this.$opPromise.$hasHandler = true;
	  return this.$opPromise.then(onFulfilled, onRejected);
	};
	
	/**
	 * Ability to use mongoose object as a pseudo-promise so `.connect().then()`
	 * and `.disconnect().then()` are viable.
	 *
	 * @param {Function} onFulfilled
	 * @param {Function} onRejected
	 * @return {Promise}
	 * @api private
	 */
	
	MongooseThenable.prototype.catch = function(onRejected) {
	  return this.then(null, onRejected);
	};
	
	/*!
	 * The exports object is an instance of Mongoose.
	 *
	 * @api public
	 */
	
	var mongoose = module.exports = exports = new Mongoose;


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var Aggregate = __webpack_require__(129);
	var Document = __webpack_require__(8);
	var DocumentNotFoundError = __webpack_require__(5).DocumentNotFoundError;
	var DivergentArrayError = __webpack_require__(5).DivergentArrayError;
	var Error = __webpack_require__(5);
	var EventEmitter = __webpack_require__(6).EventEmitter;
	var OverwriteModelError = __webpack_require__(5).OverwriteModelError;
	var PromiseProvider = __webpack_require__(14);
	var Query = __webpack_require__(94);
	var Schema = __webpack_require__(45);
	var VersionError = __webpack_require__(5).VersionError;
	var applyHooks = __webpack_require__(234);
	var applyMethods = __webpack_require__(235);
	var applyStatics = __webpack_require__(236);
	var cast = __webpack_require__(83);
	var castUpdate = __webpack_require__(146);
	var discriminator = __webpack_require__(100);
	var isPathSelectedInclusive = __webpack_require__(237);
	var mpath = __webpack_require__(67);
	var parallel = __webpack_require__(114);
	var parallelLimit = __webpack_require__(163);
	var util = __webpack_require__(1);
	var utils = __webpack_require__(4);
	
	var VERSION_WHERE = 1,
	    VERSION_INC = 2,
	    VERSION_ALL = VERSION_WHERE | VERSION_INC;
	
	/**
	 * Model constructor
	 *
	 * Provides the interface to MongoDB collections as well as creates document instances.
	 *
	 * @param {Object} doc values with which to create the document
	 * @inherits Document http://mongoosejs.com/docs/api.html#document-js
	 * @event `error`: If listening to this event, 'error' is emitted when a document was saved without passing a callback and an `error` occurred. If not listening, the event bubbles to the connection used to create this Model.
	 * @event `index`: Emitted after `Model#ensureIndexes` completes. If an error occurred it is passed with the event.
	 * @event `index-single-start`: Emitted when an individual index starts within `Model#ensureIndexes`. The fields and options being used to build the index are also passed with the event.
	 * @event `index-single-done`: Emitted when an individual index finishes within `Model#ensureIndexes`. If an error occurred it is passed with the event. The fields, options, and index name are also passed.
	 * @api public
	 */
	
	function Model(doc, fields, skipId) {
	  Document.call(this, doc, fields, skipId, true);
	}
	
	/*!
	 * Inherits from Document.
	 *
	 * All Model.prototype features are available on
	 * top level (non-sub) documents.
	 */
	
	Model.prototype.__proto__ = Document.prototype;
	Model.prototype.$isMongooseModelPrototype = true;
	
	/**
	 * Connection the model uses.
	 *
	 * @api public
	 * @property db
	 */
	
	Model.prototype.db;
	
	/**
	 * Collection the model uses.
	 *
	 * @api public
	 * @property collection
	 */
	
	Model.prototype.collection;
	
	/**
	 * The name of the model
	 *
	 * @api public
	 * @property modelName
	 */
	
	Model.prototype.modelName;
	
	/**
	 * Additional properties to attach to the query when calling `save()` and
	 * `isNew` is false.
	 *
	 * @api public
	 * @property $where
	 */
	
	Model.prototype.$where;
	
	/**
	 * If this is a discriminator model, `baseModelName` is the name of
	 * the base model.
	 *
	 * @api public
	 * @property baseModelName
	 */
	
	Model.prototype.baseModelName;
	
	Model.prototype.$__handleSave = function(options, callback) {
	  var _this = this;
	  var i;
	  var keys;
	  var len;
	  if (!options.safe && this.schema.options.safe) {
	    options.safe = this.schema.options.safe;
	  }
	  if (typeof options.safe === 'boolean') {
	    options.safe = null;
	  }
	  var safe = options.safe ? utils.clone(options.safe, { retainKeyOrder: true }) : options.safe;
	
	  if (this.isNew) {
	    // send entire doc
	    var toObjectOptions = {};
	
	    toObjectOptions.retainKeyOrder = this.schema.options.retainKeyOrder;
	    toObjectOptions.depopulate = 1;
	    toObjectOptions._skipDepopulateTopLevel = true;
	    toObjectOptions.transform = false;
	    toObjectOptions.flattenDecimals = false;
	
	    var obj = this.toObject(toObjectOptions);
	
	    if ((obj || {})._id === void 0) {
	      // documents must have an _id else mongoose won't know
	      // what to update later if more changes are made. the user
	      // wouldn't know what _id was generated by mongodb either
	      // nor would the ObjectId generated my mongodb necessarily
	      // match the schema definition.
	      setTimeout(function() {
	        callback(new Error('document must have an _id before saving'));
	      }, 0);
	      return;
	    }
	
	    this.$__version(true, obj);
	    this.collection.insert(obj, safe, function(err, ret) {
	      if (err) {
	        _this.isNew = true;
	        _this.emit('isNew', true);
	        _this.constructor.emit('isNew', true);
	
	        callback(err);
	        return;
	      }
	
	      callback(null, ret);
	    });
	    this.$__reset();
	    this.isNew = false;
	    this.emit('isNew', false);
	    this.constructor.emit('isNew', false);
	    // Make it possible to retry the insert
	    this.$__.inserting = true;
	  } else {
	    // Make sure we don't treat it as a new object on error,
	    // since it already exists
	    this.$__.inserting = false;
	
	    var delta = this.$__delta();
	
	    if (delta) {
	      if (delta instanceof Error) {
	        callback(delta);
	        return;
	      }
	
	      var where = this.$__where(delta[0]);
	      if (where instanceof Error) {
	        callback(where);
	        return;
	      }
	
	      if (this.$where) {
	        keys = Object.keys(this.$where);
	        len = keys.length;
	        for (i = 0; i < len; ++i) {
	          where[keys[i]] = this.$where[keys[i]];
	        }
	      }
	
	      this.collection.update(where, delta[1], safe, function(err, ret) {
	        if (err) {
	          callback(err);
	          return;
	        }
	        ret.$where = where;
	        callback(null, ret);
	      });
	    } else {
	      this.$__reset();
	      callback();
	      return;
	    }
	
	    this.emit('isNew', false);
	    this.constructor.emit('isNew', false);
	  }
	};
	
	/*!
	 * ignore
	 */
	
	Model.prototype.$__save = function(options, callback) {
	  var _this = this;
	
	  _this.$__handleSave(options, function(error, result) {
	    if (error) {
	      return _this.schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {
	        callback(error);
	      });
	    }
	
	    _this.$__reset();
	
	    var numAffected = 0;
	    if (result) {
	      if (Array.isArray(result)) {
	        numAffected = result.length;
	      } else if (result.result && result.result.n !== undefined) {
	        numAffected = result.result.n;
	      } else if (result.result && result.result.nModified !== undefined) {
	        numAffected = result.result.nModified;
	      } else {
	        numAffected = result;
	      }
	    }
	
	    if (_this.schema.options &&
	        _this.schema.options.saveErrorIfNotFound &&
	        numAffected <= 0) {
	      error = new DocumentNotFoundError(result.$where);
	      return _this.schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {
	        callback(error);
	      });
	    }
	
	    // was this an update that required a version bump?
	    if (_this.$__.version && !_this.$__.inserting) {
	      var doIncrement = VERSION_INC === (VERSION_INC & _this.$__.version);
	      _this.$__.version = undefined;
	
	      if (numAffected <= 0) {
	        // the update failed. pass an error back
	        var err = new VersionError(_this);
	        return callback(err);
	      }
	
	      // increment version if was successful
	      if (doIncrement) {
	        var key = _this.schema.options.versionKey;
	        var version = _this.getValue(key) | 0;
	        _this.setValue(key, version + 1);
	      }
	    }
	
	    _this.emit('save', _this, numAffected);
	    _this.constructor.emit('save', _this, numAffected);
	    callback(null, _this, numAffected);
	  });
	};
	
	/**
	 * Saves this document.
	 *
	 * ####Example:
	 *
	 *     product.sold = Date.now();
	 *     product.save(function (err, product, numAffected) {
	 *       if (err) ..
	 *     })
	 *
	 * The callback will receive three parameters
	 *
	 * 1. `err` if an error occurred
	 * 2. `product` which is the saved `product`
	 * 3. `numAffected` will be 1 when the document was successfully persisted to MongoDB, otherwise 0. Unless you tweak mongoose's internals, you don't need to worry about checking this parameter for errors - checking `err` is sufficient to make sure your document was properly saved.
	 *
	 * As an extra measure of flow control, save will return a Promise.
	 * ####Example:
	 *     product.save().then(function(product) {
	 *        ...
	 *     });
	 *
	 * For legacy reasons, mongoose stores object keys in reverse order on initial
	 * save. That is, `{ a: 1, b: 2 }` will be saved as `{ b: 2, a: 1 }` in
	 * MongoDB. To override this behavior, set
	 * [the `toObject.retainKeyOrder` option](http://mongoosejs.com/docs/api.html#document_Document-toObject)
	 * to true on your schema.
	 *
	 * @param {Object} [options] options optional options
	 * @param {Object} [options.safe] overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe)
	 * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.
	 * @param {Function} [fn] optional callback
	 * @return {Promise} Promise
	 * @api public
	 * @see middleware http://mongoosejs.com/docs/middleware.html
	 */
	
	Model.prototype.save = function(options, fn) {
	  if (typeof options === 'function') {
	    fn = options;
	    options = undefined;
	  }
	
	  if (!options) {
	    options = {};
	  }
	
	  if (fn) {
	    fn = this.constructor.$wrapCallback(fn);
	  }
	
	  return this.$__save(options, fn);
	};
	
	/*!
	 * Determines whether versioning should be skipped for the given path
	 *
	 * @param {Document} self
	 * @param {String} path
	 * @return {Boolean} true if versioning should be skipped for the given path
	 */
	function shouldSkipVersioning(self, path) {
	  var skipVersioning = self.schema.options.skipVersioning;
	  if (!skipVersioning) return false;
	
	  // Remove any array indexes from the path
	  path = path.replace(/\.\d+\./, '.');
	
	  return skipVersioning[path];
	}
	
	/*!
	 * Apply the operation to the delta (update) clause as
	 * well as track versioning for our where clause.
	 *
	 * @param {Document} self
	 * @param {Object} where
	 * @param {Object} delta
	 * @param {Object} data
	 * @param {Mixed} val
	 * @param {String} [operation]
	 */
	
	function operand(self, where, delta, data, val, op) {
	  // delta
	  op || (op = '$set');
	  if (!delta[op]) delta[op] = {};
	  delta[op][data.path] = val;
	
	  // disabled versioning?
	  if (self.schema.options.versionKey === false) return;
	
	  // path excluded from versioning?
	  if (shouldSkipVersioning(self, data.path)) return;
	
	  // already marked for versioning?
	  if (VERSION_ALL === (VERSION_ALL & self.$__.version)) return;
	
	  switch (op) {
	    case '$set':
	    case '$unset':
	    case '$pop':
	    case '$pull':
	    case '$pullAll':
	    case '$push':
	    case '$pushAll':
	    case '$addToSet':
	      break;
	    default:
	      // nothing to do
	      return;
	  }
	
	  // ensure updates sent with positional notation are
	  // editing the correct array element.
	  // only increment the version if an array position changes.
	  // modifying elements of an array is ok if position does not change.
	
	  if (op === '$push' || op === '$pushAll' || op === '$addToSet') {
	    self.$__.version = VERSION_INC;
	  } else if (/^\$p/.test(op)) {
	    // potentially changing array positions
	    self.increment();
	  } else if (Array.isArray(val)) {
	    // $set an array
	    self.increment();
	  } else if (/\.\d+\.|\.\d+$/.test(data.path)) {
	    // now handling $set, $unset
	    // subpath of array
	    self.$__.version = VERSION_WHERE;
	  }
	}
	
	/*!
	 * Compiles an update and where clause for a `val` with _atomics.
	 *
	 * @param {Document} self
	 * @param {Object} where
	 * @param {Object} delta
	 * @param {Object} data
	 * @param {Array} value
	 */
	
	function handleAtomics(self, where, delta, data, value) {
	  if (delta.$set && delta.$set[data.path]) {
	    // $set has precedence over other atomics
	    return;
	  }
	
	  if (typeof value.$__getAtomics === 'function') {
	    value.$__getAtomics().forEach(function(atomic) {
	      var op = atomic[0];
	      var val = atomic[1];
	      if (self.schema.options.usePushEach && op === '$pushAll') {
	        op = '$push';
	        val = { $each: val };
	      }
	      operand(self, where, delta, data, val, op);
	    });
	    return;
	  }
	
	  // legacy support for plugins
	
	  var atomics = value._atomics,
	      ops = Object.keys(atomics),
	      i = ops.length,
	      val,
	      op;
	
	  if (i === 0) {
	    // $set
	
	    if (utils.isMongooseObject(value)) {
	      value = value.toObject({depopulate: 1, _isNested: true});
	    } else if (value.valueOf) {
	      value = value.valueOf();
	    }
	
	    return operand(self, where, delta, data, value);
	  }
	
	  function iter(mem) {
	    return utils.isMongooseObject(mem)
	        ? mem.toObject({depopulate: 1, _isNested: true})
	        : mem;
	  }
	
	  while (i--) {
	    op = ops[i];
	    val = atomics[op];
	
	    if (utils.isMongooseObject(val)) {
	      val = val.toObject({depopulate: true, transform: false, _isNested: true});
	    } else if (Array.isArray(val)) {
	      val = val.map(iter);
	    } else if (val.valueOf) {
	      val = val.valueOf();
	    }
	
	    if (op === '$addToSet') {
	      val = {$each: val};
	    }
	
	    operand(self, where, delta, data, val, op);
	  }
	}
	
	/**
	 * Produces a special query document of the modified properties used in updates.
	 *
	 * @api private
	 * @method $__delta
	 * @memberOf Model
	 */
	
	Model.prototype.$__delta = function() {
	  var dirty = this.$__dirty();
	  if (!dirty.length && VERSION_ALL !== this.$__.version) return;
	
	  var where = {},
	      delta = {},
	      len = dirty.length,
	      divergent = [],
	      d = 0;
	
	  where._id = this._doc._id;
	  if (where._id.toObject) {
	    where._id = where._id.toObject({ transform: false, depopulate: true });
	  }
	
	  for (; d < len; ++d) {
	    var data = dirty[d];
	    var value = data.value;
	
	    var match = checkDivergentArray(this, data.path, value);
	    if (match) {
	      divergent.push(match);
	      continue;
	    }
	
	    var pop = this.populated(data.path, true);
	    if (!pop && this.$__.selected) {
	      // If any array was selected using an $elemMatch projection, we alter the path and where clause
	      // NOTE: MongoDB only supports projected $elemMatch on top level array.
	      var pathSplit = data.path.split('.');
	      var top = pathSplit[0];
	      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {
	        // If the selected array entry was modified
	        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === 'undefined') {
	          where[top] = this.$__.selected[top];
	          pathSplit[1] = '$';
	          data.path = pathSplit.join('.');
	        }
	        // if the selected array was modified in any other way throw an error
	        else {
	          divergent.push(data.path);
	          continue;
	        }
	      }
	    }
	
	    if (divergent.length) continue;
	
	    if (undefined === value) {
	      operand(this, where, delta, data, 1, '$unset');
	    } else if (value === null) {
	      operand(this, where, delta, data, null);
	    } else if (value._path && value._atomics) {
	      // arrays and other custom types (support plugins etc)
	      handleAtomics(this, where, delta, data, value);
	    } else if (value._path && Buffer.isBuffer(value)) {
	      // MongooseBuffer
	      value = value.toObject();
	      operand(this, where, delta, data, value);
	    } else {
	      value = utils.clone(value, {depopulate: 1, _isNested: true});
	      operand(this, where, delta, data, value);
	    }
	  }
	
	  if (divergent.length) {
	    return new DivergentArrayError(divergent);
	  }
	
	  if (this.$__.version) {
	    this.$__version(where, delta);
	  }
	
	  return [where, delta];
	};
	
	/*!
	 * Determine if array was populated with some form of filter and is now
	 * being updated in a manner which could overwrite data unintentionally.
	 *
	 * @see https://github.com/Automattic/mongoose/issues/1334
	 * @param {Document} doc
	 * @param {String} path
	 * @return {String|undefined}
	 */
	
	function checkDivergentArray(doc, path, array) {
	  // see if we populated this path
	  var pop = doc.populated(path, true);
	
	  if (!pop && doc.$__.selected) {
	    // If any array was selected using an $elemMatch projection, we deny the update.
	    // NOTE: MongoDB only supports projected $elemMatch on top level array.
	    var top = path.split('.')[0];
	    if (doc.$__.selected[top + '.$']) {
	      return top;
	    }
	  }
	
	  if (!(pop && array && array.isMongooseArray)) return;
	
	  // If the array was populated using options that prevented all
	  // documents from being returned (match, skip, limit) or they
	  // deselected the _id field, $pop and $set of the array are
	  // not safe operations. If _id was deselected, we do not know
	  // how to remove elements. $pop will pop off the _id from the end
	  // of the array in the db which is not guaranteed to be the
	  // same as the last element we have here. $set of the entire array
	  // would be similarily destructive as we never received all
	  // elements of the array and potentially would overwrite data.
	  var check = pop.options.match ||
	      pop.options.options && utils.object.hasOwnProperty(pop.options.options, 'limit') || // 0 is not permitted
	      pop.options.options && pop.options.options.skip || // 0 is permitted
	      pop.options.select && // deselected _id?
	      (pop.options.select._id === 0 ||
	      /\s?-_id\s?/.test(pop.options.select));
	
	  if (check) {
	    var atomics = array._atomics;
	    if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {
	      return path;
	    }
	  }
	}
	
	/**
	 * Appends versioning to the where and update clauses.
	 *
	 * @api private
	 * @method $__version
	 * @memberOf Model
	 */
	
	Model.prototype.$__version = function(where, delta) {
	  var key = this.schema.options.versionKey;
	
	  if (where === true) {
	    // this is an insert
	    if (key) this.setValue(key, delta[key] = 0);
	    return;
	  }
	
	  // updates
	
	  // only apply versioning if our versionKey was selected. else
	  // there is no way to select the correct version. we could fail
	  // fast here and force them to include the versionKey but
	  // thats a bit intrusive. can we do this automatically?
	  if (!this.isSelected(key)) {
	    return;
	  }
	
	  // $push $addToSet don't need the where clause set
	  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {
	    var value = this.getValue(key);
	    if (value != null) where[key] = value;
	  }
	
	  if (VERSION_INC === (VERSION_INC & this.$__.version)) {
	    if (!delta.$set || typeof delta.$set[key] === 'undefined') {
	      delta.$inc || (delta.$inc = {});
	      delta.$inc[key] = 1;
	    }
	  }
	};
	
	/**
	 * Signal that we desire an increment of this documents version.
	 *
	 * ####Example:
	 *
	 *     Model.findById(id, function (err, doc) {
	 *       doc.increment();
	 *       doc.save(function (err) { .. })
	 *     })
	 *
	 * @see versionKeys http://mongoosejs.com/docs/guide.html#versionKey
	 * @api public
	 */
	
	Model.prototype.increment = function increment() {
	  this.$__.version = VERSION_ALL;
	  return this;
	};
	
	/**
	 * Returns a query object
	 *
	 * @api private
	 * @method $__where
	 * @memberOf Model
	 */
	
	Model.prototype.$__where = function _where(where) {
	  where || (where = {});
	
	  if (!where._id) {
	    where._id = this._doc._id;
	  }
	
	  if (this._doc._id == null) {
	    return new Error('No _id found on document!');
	  }
	
	  return where;
	};
	
	/**
	 * Removes this document from the db.
	 *
	 * ####Example:
	 *     product.remove(function (err, product) {
	 *       if (err) return handleError(err);
	 *       Product.findById(product._id, function (err, product) {
	 *         console.log(product) // null
	 *       })
	 *     })
	 *
	 *
	 * As an extra measure of flow control, remove will return a Promise (bound to `fn` if passed) so it could be chained, or hooked to recive errors
	 *
	 * ####Example:
	 *     product.remove().then(function (product) {
	 *        ...
	 *     }).catch(function (err) {
	 *        assert.ok(err)
	 *     })
	 *
	 * @param {function(err,product)} [fn] optional callback
	 * @return {Promise} Promise
	 * @api public
	 */
	
	Model.prototype.remove = function remove(options, fn) {
	  if (typeof options === 'function') {
	    fn = options;
	    options = undefined;
	  }
	
	  var _this = this;
	
	  if (!options) {
	    options = {};
	  }
	
	  if (this.$__.removing) {
	    if (fn) {
	      this.$__.removing.then(
	          function(res) { fn(null, res); },
	          function(err) { fn(err); });
	    }
	    return this;
	  }
	  if (this.$__.isDeleted) {
	    setImmediate(function() {
	      fn(null, _this);
	    });
	    return this;
	  }
	
	  var Promise = PromiseProvider.get();
	
	  if (fn) {
	    fn = this.constructor.$wrapCallback(fn);
	  }
	
	  this.$__.removing = new Promise.ES6(function(resolve, reject) {
	    var where = _this.$__where();
	    if (where instanceof Error) {
	      reject(where);
	      fn && fn(where);
	      return;
	    }
	
	    if (!options.safe && _this.schema.options.safe) {
	      options.safe = _this.schema.options.safe;
	    }
	
	    _this.collection.remove(where, options, function(err) {
	      if (!err) {
	        _this.$__.isDeleted = true;
	        _this.emit('remove', _this);
	        _this.constructor.emit('remove', _this);
	        resolve(_this);
	        fn && fn(null, _this);
	        return;
	      }
	      _this.$__.isDeleted = false;
	      reject(err);
	      fn && fn(err);
	    });
	  });
	  return this.$__.removing;
	};
	
	/**
	 * Returns another Model instance.
	 *
	 * ####Example:
	 *
	 *     var doc = new Tank;
	 *     doc.model('User').findById(id, callback);
	 *
	 * @param {String} name model name
	 * @api public
	 */
	
	Model.prototype.model = function model(name) {
	  return this.db.model(name);
	};
	
	/**
	 * Adds a discriminator type.
	 *
	 * ####Example:
	 *
	 *     function BaseSchema() {
	 *       Schema.apply(this, arguments);
	 *
	 *       this.add({
	 *         name: String,
	 *         createdAt: Date
	 *       });
	 *     }
	 *     util.inherits(BaseSchema, Schema);
	 *
	 *     var PersonSchema = new BaseSchema();
	 *     var BossSchema = new BaseSchema({ department: String });
	 *
	 *     var Person = mongoose.model('Person', PersonSchema);
	 *     var Boss = Person.discriminator('Boss', BossSchema);
	 *
	 * @param {String} name   discriminator model name
	 * @param {Schema} schema discriminator model schema
	 * @api public
	 */
	
	Model.discriminator = function(name, schema) {
	  var model;
	  if (typeof name === 'function') {
	    model = name;
	    name = utils.getFunctionName(model);
	    if (!(model.prototype instanceof Model)) {
	      throw new Error('The provided class ' + name + ' must extend Model');
	    }
	  }
	
	  schema = discriminator(this, name, schema);
	  if (this.db.models[name]) {
	    throw new OverwriteModelError(name);
	  }
	
	  schema.$isRootDiscriminator = true;
	
	  model = this.db.model(model || name, schema, this.collection.name);
	  this.discriminators[name] = model;
	  var d = this.discriminators[name];
	  d.prototype.__proto__ = this.prototype;
	  Object.defineProperty(d, 'baseModelName', {
	    value: this.modelName,
	    configurable: true,
	    writable: false
	  });
	
	  // apply methods and statics
	  applyMethods(d, schema);
	  applyStatics(d, schema);
	
	  return d;
	};
	
	// Model (class) features
	
	/*!
	 * Give the constructor the ability to emit events.
	 */
	
	for (var i in EventEmitter.prototype) {
	  Model[i] = EventEmitter.prototype[i];
	}
	
	/**
	 * Performs any async initialization of this model against MongoDB. Currently,
	 * this function is only responsible for building [indexes](https://docs.mongodb.com/manual/indexes/),
	 * unless [`autoIndex`](http://mongoosejs.com/docs/guide.html#autoIndex) is turned off.
	 *
	 * This function is called automatically, so you don't need to call it.
	 * This function is also idempotent, so you may call it to get back a promise
	 * that will resolve when your indexes are finished building as an alternative
	 * to `MyModel.on('index')`
	 *
	 * ####Example:
	 *
	 *     var eventSchema = new Schema({ thing: { type: 'string', unique: true }})
	 *     // This calls `Event.init()` implicitly, so you don't need to call
	 *     // `Event.init()` on your own.
	 *     var Event = mongoose.model('Event', eventSchema);
	 *
	 *     Event.init().then(function(Event) {
	 *       // You can also use `Event.on('index')` if you prefer event emitters
	 *       // over promises.
	 *       console.log('Indexes are done building!');
	 *     });
	 *
	 * @api public
	 * @param {Function} [callback]
	 * @returns {Promise}
	 */
	
	Model.init = function init(callback) {
	  this.schema.emit('init', this);
	
	  if (this.$init) {
	    return this.$init;
	  }
	
	  var _this = this;
	  var Promise = PromiseProvider.get();
	  this.$init = new Promise.ES6(function(resolve, reject) {
	    if ((_this.schema.options.autoIndex) ||
	        (_this.schema.options.autoIndex == null && _this.db.config.autoIndex)) {
	      _this.ensureIndexes({ _automatic: true, __noPromise: true }, function(error) {
	        if (error) {
	          callback && callback(error);
	          return reject(error);
	        }
	        callback && callback(null, _this);
	        resolve(_this);
	      });
	    }
	
	    return _this;
	  });
	
	  return this.$init;
	};
	
	/**
	 * Sends `createIndex` commands to mongo for each index declared in the schema.
	 * The `createIndex` commands are sent in series.
	 *
	 * ####Example:
	 *
	 *     Event.createIndexes(function (err) {
	 *       if (err) return handleError(err);
	 *     });
	 *
	 * After completion, an `index` event is emitted on this `Model` passing an error if one occurred.
	 *
	 * ####Example:
	 *
	 *     var eventSchema = new Schema({ thing: { type: 'string', unique: true }})
	 *     var Event = mongoose.model('Event', eventSchema);
	 *
	 *     Event.on('index', function (err) {
	 *       if (err) console.error(err); // error occurred during index creation
	 *     })
	 *
	 * _NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution._
	 *
	 * @param {Object} [options] internal options
	 * @param {Function} [cb] optional callback
	 * @return {Promise}
	 * @api public
	 */
	
	Model.createIndexes = Model.ensureIndexes = function createIndexes(options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = null;
	  }
	
	  if (options && options.__noPromise) {
	    _createIndexes(this, options, callback);
	    return;
	  }
	
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	
	  var _this = this;
	  var Promise = PromiseProvider.get();
	  return new Promise.ES6(function(resolve, reject) {
	    _createIndexes(_this, options || {}, function(error) {
	      if (error) {
	        callback && callback(error);
	        reject(error);
	      }
	      callback && callback();
	      resolve();
	    });
	  });
	};
	
	function _createIndexes(model, options, callback) {
	  var indexes = model.schema.indexes();
	
	  var done = function(err) {
	    if (err && model.schema.options.emitIndexErrors) {
	      model.emit('error', err);
	    }
	    model.emit('index', err);
	    callback && callback(err);
	  };
	
	  if (!indexes.length) {
	    setImmediate(function() {
	      done();
	    });
	    return;
	  }
	  // Indexes are created one-by-one to support how MongoDB < 2.4 deals
	  // with background indexes.
	
	  var indexSingleDone = function(err, fields, options, name) {
	    model.emit('index-single-done', err, fields, options, name);
	  };
	  var indexSingleStart = function(fields, options) {
	    model.emit('index-single-start', fields, options);
	  };
	
	  var create = function() {
	    if (options && options._automatic) {
	      if (model.schema.options.autoIndex === false ||
	          (model.schema.options.autoIndex == null && model.db.config.autoIndex === false)) {
	        return done();
	      }
	    }
	
	    var index = indexes.shift();
	    if (!index) return done();
	
	    var indexFields = index[0];
	    var indexOptions = index[1];
	    _handleSafe(options);
	
	    indexSingleStart(indexFields, options);
	    model.collection.createIndex(indexFields, indexOptions, utils.tick(function(err, name) {
	      indexSingleDone(err, indexFields, indexOptions, name);
	      if (err) {
	        return done(err);
	      }
	      create();
	    }));
	  };
	
	  setImmediate(function() {
	    // If buffering is off, do this manually.
	    if (options._automatic && !model.collection.collection) {
	      model.collection.addQueue(create, []);
	    } else {
	      create();
	    }
	  });
	}
	
	function _handleSafe(options) {
	  if (options.safe) {
	    if (typeof options.safe === 'boolean') {
	      options.w = options.safe;
	      delete options.safe;
	    }
	    if (typeof options.safe === 'object') {
	      options.w = options.safe.w;
	      options.j = options.safe.j;
	      options.wtimeout = options.safe.wtimeout;
	      delete options.safe;
	    }
	  }
	}
	
	/**
	 * Schema the model uses.
	 *
	 * @property schema
	 * @receiver Model
	 * @api public
	 */
	
	Model.schema;
	
	/*!
	 * Connection instance the model uses.
	 *
	 * @property db
	 * @receiver Model
	 * @api public
	 */
	
	Model.db;
	
	/*!
	 * Collection the model uses.
	 *
	 * @property collection
	 * @receiver Model
	 * @api public
	 */
	
	Model.collection;
	
	/**
	 * Base Mongoose instance the model uses.
	 *
	 * @property base
	 * @receiver Model
	 * @api public
	 */
	
	Model.base;
	
	/**
	 * Registered discriminators for this model.
	 *
	 * @property discriminators
	 * @receiver Model
	 * @api public
	 */
	
	Model.discriminators;
	
	/**
	 * Translate any aliases fields/conditions so the final query or document object is pure
	 *
	 * ####Example:
	 *
	 *     Character
	 *       .find(Character.translateAliases({
	 *         '': 'Eddard Stark' // Alias for 'name'
	 *       })
	 *       .exec(function(err, characters) {})
	 *
	 * ####Note:
	 * Only translate arguments of object type anything else is returned raw
	 *
	 * @param {Object} raw fields/conditions that may contain aliased keys
	 * @return {Object} the translated 'pure' fields/conditions
	 */
	Model.translateAliases = function translateAliases(fields) {
	  var aliases = this.schema.aliases;
	
	  if (typeof fields === 'object') {
	    // Fields is an object (query conditions or document fields)
	    for (var key in fields) {
	      if (aliases[key]) {
	        fields[aliases[key]] = fields[key];
	        delete fields[key];
	      }
	    }
	
	    return fields;
	  } else {
	    // Don't know typeof fields
	    return fields;
	  }
	};
	
	/**
	 * Removes all documents that match `conditions` from the collection.
	 * To remove just the first document that matches `conditions`, set the `single`
	 * option to true.
	 *
	 * ####Example:
	 *
	 *     Character.remove({ name: 'Eddard Stark' }, function (err) {});
	 *
	 * ####Note:
	 *
	 * This method sends a remove command directly to MongoDB, no Mongoose documents
	 * are involved. Because no Mongoose documents are involved, _no middleware
	 * (hooks) are executed_.
	 *
	 * @param {Object} conditions
	 * @param {Function} [callback]
	 * @return {Query}
	 * @api public
	 */
	
	Model.remove = function remove(conditions, callback) {
	  if (typeof conditions === 'function') {
	    callback = conditions;
	    conditions = {};
	  }
	
	  // get the mongodb collection object
	  var mq = new this.Query({}, {}, this, this.collection);
	
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	
	  return mq.remove(conditions, callback);
	};
	
	/**
	 * Deletes the first document that matches `conditions` from the collection.
	 * Behaves like `remove()`, but deletes at most one document regardless of the
	 * `single` option.
	 *
	 * ####Example:
	 *
	 *     Character.deleteOne({ name: 'Eddard Stark' }, function (err) {});
	 *
	 * ####Note:
	 *
	 * Like `Model.remove()`, this function does **not** trigger `pre('remove')` or `post('remove')` hooks.
	 *
	 * @param {Object} conditions
	 * @param {Function} [callback]
	 * @return {Query}
	 * @api public
	 */
	
	Model.deleteOne = function deleteOne(conditions, callback) {
	  if (typeof conditions === 'function') {
	    callback = conditions;
	    conditions = {};
	  }
	
	  // get the mongodb collection object
	  var mq = new this.Query(conditions, {}, this, this.collection);
	
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	
	  return mq.deleteOne(callback);
	};
	
	/**
	 * Deletes all of the documents that match `conditions` from the collection.
	 * Behaves like `remove()`, but deletes all documents that match `conditions`
	 * regardless of the `single` option.
	 *
	 * ####Example:
	 *
	 *     Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }, function (err) {});
	 *
	 * ####Note:
	 *
	 * Like `Model.remove()`, this function does **not** trigger `pre('remove')` or `post('remove')` hooks.
	 *
	 * @param {Object} conditions
	 * @param {Function} [callback]
	 * @return {Query}
	 * @api public
	 */
	
	Model.deleteMany = function deleteMany(conditions, callback) {
	  if (typeof conditions === 'function') {
	    callback = conditions;
	    conditions = {};
	  }
	
	  // get the mongodb collection object
	  var mq = new this.Query(conditions, {}, this, this.collection);
	
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	
	  return mq.deleteMany(callback);
	};
	
	/**
	 * Finds documents
	 *
	 * The `conditions` are cast to their respective SchemaTypes before the command is sent.
	 *
	 * ####Examples:
	 *
	 *     // named john and at least 18
	 *     MyModel.find({ name: 'john', age: { $gte: 18 }});
	 *
	 *     // executes immediately, passing results to callback
	 *     MyModel.find({ name: 'john', age: { $gte: 18 }}, function (err, docs) {});
	 *
	 *     // name LIKE john and only selecting the "name" and "friends" fields, executing immediately
	 *     MyModel.find({ name: /john/i }, 'name friends', function (err, docs) { })
	 *
	 *     // passing options
	 *     MyModel.find({ name: /john/i }, null, { skip: 10 })
	 *
	 *     // passing options and executing immediately
	 *     MyModel.find({ name: /john/i }, null, { skip: 10 }, function (err, docs) {});
	 *
	 *     // executing a query explicitly
	 *     var query = MyModel.find({ name: /john/i }, null, { skip: 10 })
	 *     query.exec(function (err, docs) {});
	 *
	 *     // using the promise returned from executing a query
	 *     var query = MyModel.find({ name: /john/i }, null, { skip: 10 });
	 *     var promise = query.exec();
	 *     promise.addBack(function (err, docs) {});
	 *
	 * @param {Object} conditions
	 * @param {Object} [projection] optional fields to return (http://bit.ly/1HotzBo)
	 * @param {Object} [options] optional
	 * @param {Function} [callback]
	 * @return {Query}
	 * @see field selection #query_Query-select
	 * @see promise #promise-js
	 * @api public
	 */
	
	Model.find = function find(conditions, projection, options, callback) {
	  if (typeof conditions === 'function') {
	    callback = conditions;
	    conditions = {};
	    projection = null;
	    options = null;
	  } else if (typeof projection === 'function') {
	    callback = projection;
	    projection = null;
	    options = null;
	  } else if (typeof options === 'function') {
	    callback = options;
	    options = null;
	  }
	
	  var mq = new this.Query({}, {}, this, this.collection);
	  mq.select(projection);
	  mq.setOptions(options);
	  if (this.schema.discriminatorMapping &&
	      this.schema.discriminatorMapping.isRoot &&
	      mq.selectedInclusively()) {
	    // Need to select discriminator key because original schema doesn't have it
	    mq.select(this.schema.options.discriminatorKey);
	  }
	
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	
	  return mq.find(conditions, callback);
	};
	
	/**
	 * Finds a single document by its _id field. `findById(id)` is almost*
	 * equivalent to `findOne({ _id: id })`. If you want to query by a document's
	 * `_id`, use `findById()` instead of `findOne()`.
	 *
	 * The `id` is cast based on the Schema before sending the command.
	 *
	 * This function triggers the following middleware:
	 * - `findOne()`
	 *
	 * \* Except for how it treats `undefined`. If you use `findOne()`, you'll see
	 * that `findOne(undefined)` and `findOne({ _id: undefined })` are equivalent
	 * to `findOne({})` and return arbitrary documents. However, mongoose
	 * translates `findById(undefined)` into `findOne({ _id: null })`.
	 *
	 * ####Example:
	 *
	 *     // find adventure by id and execute immediately
	 *     Adventure.findById(id, function (err, adventure) {});
	 *
	 *     // same as above
	 *     Adventure.findById(id).exec(callback);
	 *
	 *     // select only the adventures name and length
	 *     Adventure.findById(id, 'name length', function (err, adventure) {});
	 *
	 *     // same as above
	 *     Adventure.findById(id, 'name length').exec(callback);
	 *
	 *     // include all properties except for `length`
	 *     Adventure.findById(id, '-length').exec(function (err, adventure) {});
	 *
	 *     // passing options (in this case return the raw js objects, not mongoose documents by passing `lean`
	 *     Adventure.findById(id, 'name', { lean: true }, function (err, doc) {});
	 *
	 *     // same as above
	 *     Adventure.findById(id, 'name').lean().exec(function (err, doc) {});
	 *
	 * @param {Object|String|Number} id value of `_id` to query by
	 * @param {Object} [projection] optional fields to return (http://bit.ly/1HotzBo)
	 * @param {Object} [options] optional
	 * @param {Function} [callback]
	 * @return {Query}
	 * @see field selection #query_Query-select
	 * @see lean queries #query_Query-lean
	 * @api public
	 */
	
	Model.findById = function findById(id, projection, options, callback) {
	  if (typeof id === 'undefined') {
	    id = null;
	  }
	
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	
	  return this.findOne({_id: id}, projection, options, callback);
	};
	
	/**
	 * Finds one document.
	 *
	 * The `conditions` are cast to their respective SchemaTypes before the command is sent.
	 *
	 * *Note:* `conditions` is optional, and if `conditions` is null or undefined,
	 * mongoose will send an empty `findOne` command to MongoDB, which will return
	 * an arbitrary document. If you're querying by `_id`, use `findById()` instead.
	 *
	 * ####Example:
	 *
	 *     // find one iphone adventures - iphone adventures??
	 *     Adventure.findOne({ type: 'iphone' }, function (err, adventure) {});
	 *
	 *     // same as above
	 *     Adventure.findOne({ type: 'iphone' }).exec(function (err, adventure) {});
	 *
	 *     // select only the adventures name
	 *     Adventure.findOne({ type: 'iphone' }, 'name', function (err, adventure) {});
	 *
	 *     // same as above
	 *     Adventure.findOne({ type: 'iphone' }, 'name').exec(function (err, adventure) {});
	 *
	 *     // specify options, in this case lean
	 *     Adventure.findOne({ type: 'iphone' }, 'name', { lean: true }, callback);
	 *
	 *     // same as above
	 *     Adventure.findOne({ type: 'iphone' }, 'name', { lean: true }).exec(callback);
	 *
	 *     // chaining findOne queries (same as above)
	 *     Adventure.findOne({ type: 'iphone' }).select('name').lean().exec(callback);
	 *
	 * @param {Object} [conditions]
	 * @param {Object} [projection] optional fields to return (http://bit.ly/1HotzBo)
	 * @param {Object} [options] optional
	 * @param {Function} [callback]
	 * @return {Query}
	 * @see field selection #query_Query-select
	 * @see lean queries #query_Query-lean
	 * @api public
	 */
	
	Model.findOne = function findOne(conditions, projection, options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = null;
	  } else if (typeof projection === 'function') {
	    callback = projection;
	    projection = null;
	    options = null;
	  } else if (typeof conditions === 'function') {
	    callback = conditions;
	    conditions = {};
	    projection = null;
	    options = null;
	  }
	
	  // get the mongodb collection object
	  var mq = new this.Query({}, {}, this, this.collection);
	  mq.select(projection);
	  mq.setOptions(options);
	  if (this.schema.discriminatorMapping &&
	      this.schema.discriminatorMapping.isRoot &&
	      mq.selectedInclusively()) {
	    mq.select(this.schema.options.discriminatorKey);
	  }
	
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	
	  return mq.findOne(conditions, callback);
	};
	
	/**
	 * Counts number of matching documents in a database collection.
	 *
	 * ####Example:
	 *
	 *     Adventure.count({ type: 'jungle' }, function (err, count) {
	 *       if (err) ..
	 *       console.log('there are %d jungle adventures', count);
	 *     });
	 *
	 * @param {Object} conditions
	 * @param {Function} [callback]
	 * @return {Query}
	 * @api public
	 */
	
	Model.count = function count(conditions, callback) {
	  if (typeof conditions === 'function') {
	    callback = conditions;
	    conditions = {};
	  }
	
	  // get the mongodb collection object
	  var mq = new this.Query({}, {}, this, this.collection);
	
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	
	  return mq.count(conditions, callback);
	};
	
	/**
	 * Creates a Query for a `distinct` operation.
	 *
	 * Passing a `callback` immediately executes the query.
	 *
	 * ####Example
	 *
	 *     Link.distinct('url', { clicks: {$gt: 100}}, function (err, result) {
	 *       if (err) return handleError(err);
	 *
	 *       assert(Array.isArray(result));
	 *       console.log('unique urls with more than 100 clicks', result);
	 *     })
	 *
	 *     var query = Link.distinct('url');
	 *     query.exec(callback);
	 *
	 * @param {String} field
	 * @param {Object} [conditions] optional
	 * @param {Function} [callback]
	 * @return {Query}
	 * @api public
	 */
	
	Model.distinct = function distinct(field, conditions, callback) {
	  // get the mongodb collection object
	  var mq = new this.Query({}, {}, this, this.collection);
	
	  if (typeof conditions === 'function') {
	    callback = conditions;
	    conditions = {};
	  }
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	
	  return mq.distinct(field, conditions, callback);
	};
	
	/**
	 * Creates a Query, applies the passed conditions, and returns the Query.
	 *
	 * For example, instead of writing:
	 *
	 *     User.find({age: {$gte: 21, $lte: 65}}, callback);
	 *
	 * we can instead write:
	 *
	 *     User.where('age').gte(21).lte(65).exec(callback);
	 *
	 * Since the Query class also supports `where` you can continue chaining
	 *
	 *     User
	 *     .where('age').gte(21).lte(65)
	 *     .where('name', /^b/i)
	 *     ... etc
	 *
	 * @param {String} path
	 * @param {Object} [val] optional value
	 * @return {Query}
	 * @api public
	 */
	
	Model.where = function where(path, val) {
	  void val; // eslint
	  // get the mongodb collection object
	  var mq = new this.Query({}, {}, this, this.collection).find({});
	  return mq.where.apply(mq, arguments);
	};
	
	/**
	 * Creates a `Query` and specifies a `$where` condition.
	 *
	 * Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.
	 *
	 *     Blog.$where('this.username.indexOf("val") !== -1').exec(function (err, docs) {});
	 *
	 * @param {String|Function} argument is a javascript string or anonymous function
	 * @method $where
	 * @memberOf Model
	 * @return {Query}
	 * @see Query.$where #query_Query-%24where
	 * @api public
	 */
	
	Model.$where = function $where() {
	  var mq = new this.Query({}, {}, this, this.collection).find({});
	  return mq.$where.apply(mq, arguments);
	};
	
	/**
	 * Issues a mongodb findAndModify update command.
	 *
	 * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed else a Query object is returned.
	 *
	 * ####Options:
	 *
	 * - `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)
	 * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.
	 * - `fields`: {Object|String} - Field selection. Equivalent to `.select(fields).findOneAndUpdate()`
	 * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 * - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.
	 * - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).
	 * - `passRawResult`: if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)
	 * - `strict`: overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict) for this update
	 * - `runSettersOnQuery`: bool - if true, run all setters defined on the associated model's schema for all fields defined in the query and the update.
	 *
	 * ####Examples:
	 *
	 *     A.findOneAndUpdate(conditions, update, options, callback) // executes
	 *     A.findOneAndUpdate(conditions, update, options)  // returns Query
	 *     A.findOneAndUpdate(conditions, update, callback) // executes
	 *     A.findOneAndUpdate(conditions, update)           // returns Query
	 *     A.findOneAndUpdate()                             // returns Query
	 *
	 * ####Note:
	 *
	 * All top level update keys which are not `atomic` operation names are treated as set operations:
	 *
	 * ####Example:
	 *
	 *     var query = { name: 'borne' };
	 *     Model.findOneAndUpdate(query, { name: 'jason bourne' }, options, callback)
	 *
	 *     // is sent as
	 *     Model.findOneAndUpdate(query, { $set: { name: 'jason bourne' }}, options, callback)
	 *
	 * This helps prevent accidentally overwriting your document with `{ name: 'jason bourne' }`.
	 *
	 * ####Note:
	 *
	 * Values are cast to their appropriate types when using the findAndModify helpers.
	 * However, the below are not executed by default.
	 *
	 * - defaults. Use the `setDefaultsOnInsert` option to override.
	 * - setters. Use the `runSettersOnQuery` option to override.
	 *
	 * `findAndModify` helpers support limited validation. You can
	 * enable these by setting the `runValidators` options,
	 * respectively.
	 *
	 * If you need full-fledged validation, use the traditional approach of first
	 * retrieving the document.
	 *
	 *     Model.findById(id, function (err, doc) {
	 *       if (err) ..
	 *       doc.name = 'jason bourne';
	 *       doc.save(callback);
	 *     });
	 *
	 * @param {Object} [conditions]
	 * @param {Object} [update]
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query}
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 * @api public
	 */
	
	Model.findOneAndUpdate = function(conditions, update, options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = null;
	  } else if (arguments.length === 1) {
	    if (typeof conditions === 'function') {
	      var msg = 'Model.findOneAndUpdate(): First argument must not be a function.\n\n'
	          + '  ' + this.modelName + '.findOneAndUpdate(conditions, update, options, callback)\n'
	          + '  ' + this.modelName + '.findOneAndUpdate(conditions, update, options)\n'
	          + '  ' + this.modelName + '.findOneAndUpdate(conditions, update)\n'
	          + '  ' + this.modelName + '.findOneAndUpdate(update)\n'
	          + '  ' + this.modelName + '.findOneAndUpdate()\n';
	      throw new TypeError(msg);
	    }
	    update = conditions;
	    conditions = undefined;
	  }
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	
	  var fields;
	  if (options && options.fields) {
	    fields = options.fields;
	  }
	
	  update = utils.clone(update, {depopulate: 1, _isNested: true});
	  if (this.schema.options.versionKey && options && options.upsert) {
	    if (options.overwrite) {
	      update[this.schema.options.versionKey] = 0;
	    } else {
	      if (!update.$setOnInsert) {
	        update.$setOnInsert = {};
	      }
	      update.$setOnInsert[this.schema.options.versionKey] = 0;
	    }
	  }
	
	  var mq = new this.Query({}, {}, this, this.collection);
	  mq.select(fields);
	
	  return mq.findOneAndUpdate(conditions, update, options, callback);
	};
	
	/**
	 * Issues a mongodb findAndModify update command by a document's _id field.
	 * `findByIdAndUpdate(id, ...)` is equivalent to `findOneAndUpdate({ _id: id }, ...)`.
	 *
	 * Finds a matching document, updates it according to the `update` arg,
	 * passing any `options`, and returns the found document (if any) to the
	 * callback. The query executes immediately if `callback` is passed else a
	 * Query object is returned.
	 *
	 * This function triggers the following middleware:
	 * - `findOneAndUpdate()`
	 *
	 * ####Options:
	 *
	 * - `new`: bool - true to return the modified document rather than the original. defaults to false
	 * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.
	 * - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.
	 * - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 * - `select`: sets the document fields to return
	 * - `passRawResult`: if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)
	 * - `strict`: overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict) for this update
	 * - `runSettersOnQuery`: bool - if true, run all setters defined on the associated model's schema for all fields defined in the query and the update.
	 *
	 * ####Examples:
	 *
	 *     A.findByIdAndUpdate(id, update, options, callback) // executes
	 *     A.findByIdAndUpdate(id, update, options)  // returns Query
	 *     A.findByIdAndUpdate(id, update, callback) // executes
	 *     A.findByIdAndUpdate(id, update)           // returns Query
	 *     A.findByIdAndUpdate()                     // returns Query
	 *
	 * ####Note:
	 *
	 * All top level update keys which are not `atomic` operation names are treated as set operations:
	 *
	 * ####Example:
	 *
	 *     Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options, callback)
	 *
	 *     // is sent as
	 *     Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options, callback)
	 *
	 * This helps prevent accidentally overwriting your document with `{ name: 'jason bourne' }`.
	 *
	 * ####Note:
	 *
	 * Values are cast to their appropriate types when using the findAndModify helpers.
	 * However, the below are not executed by default.
	 *
	 * - defaults. Use the `setDefaultsOnInsert` option to override.
	 * - setters. Use the `runSettersOnQuery` option to override.
	 *
	 * `findAndModify` helpers support limited validation. You can
	 * enable these by setting the `runValidators` options,
	 * respectively.
	 *
	 * If you need full-fledged validation, use the traditional approach of first
	 * retrieving the document.
	 *
	 *     Model.findById(id, function (err, doc) {
	 *       if (err) ..
	 *       doc.name = 'jason bourne';
	 *       doc.save(callback);
	 *     });
	 *
	 * @param {Object|Number|String} id value of `_id` to query by
	 * @param {Object} [update]
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query}
	 * @see Model.findOneAndUpdate #model_Model.findOneAndUpdate
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 * @api public
	 */
	
	Model.findByIdAndUpdate = function(id, update, options, callback) {
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	  if (arguments.length === 1) {
	    if (typeof id === 'function') {
	      var msg = 'Model.findByIdAndUpdate(): First argument must not be a function.\n\n'
	          + '  ' + this.modelName + '.findByIdAndUpdate(id, callback)\n'
	          + '  ' + this.modelName + '.findByIdAndUpdate(id)\n'
	          + '  ' + this.modelName + '.findByIdAndUpdate()\n';
	      throw new TypeError(msg);
	    }
	    return this.findOneAndUpdate({_id: id}, undefined);
	  }
	
	  // if a model is passed in instead of an id
	  if (id instanceof Document) {
	    id = id._id;
	  }
	
	  return this.findOneAndUpdate.call(this, {_id: id}, update, options, callback);
	};
	
	/**
	 * Issue a mongodb findAndModify remove command.
	 *
	 * Finds a matching document, removes it, passing the found document (if any) to the callback.
	 *
	 * Executes immediately if `callback` is passed else a Query object is returned.
	 *
	 * This function triggers the following middleware:
	 * - `findOneAndRemove()`
	 *
	 * ####Options:
	 *
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0
	 * - `select`: sets the document fields to return
	 * - `passRawResult`: if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)
	 * - `strict`: overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict) for this update
	 *
	 * ####Examples:
	 *
	 *     A.findOneAndRemove(conditions, options, callback) // executes
	 *     A.findOneAndRemove(conditions, options)  // return Query
	 *     A.findOneAndRemove(conditions, callback) // executes
	 *     A.findOneAndRemove(conditions) // returns Query
	 *     A.findOneAndRemove()           // returns Query
	 *
	 * Values are cast to their appropriate types when using the findAndModify helpers.
	 * However, the below are not executed by default.
	 *
	 * - defaults. Use the `setDefaultsOnInsert` option to override.
	 * - setters. Use the `runSettersOnQuery` option to override.
	 *
	 * `findAndModify` helpers support limited validation. You can
	 * enable these by setting the `runValidators` options,
	 * respectively.
	 *
	 * If you need full-fledged validation, use the traditional approach of first
	 * retrieving the document.
	 *
	 *     Model.findById(id, function (err, doc) {
	 *       if (err) ..
	 *       doc.name = 'jason bourne';
	 *       doc.save(callback);
	 *     });
	 *
	 * @param {Object} conditions
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query}
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 * @api public
	 */
	
	Model.findOneAndRemove = function(conditions, options, callback) {
	  if (arguments.length === 1 && typeof conditions === 'function') {
	    var msg = 'Model.findOneAndRemove(): First argument must not be a function.\n\n'
	        + '  ' + this.modelName + '.findOneAndRemove(conditions, callback)\n'
	        + '  ' + this.modelName + '.findOneAndRemove(conditions)\n'
	        + '  ' + this.modelName + '.findOneAndRemove()\n';
	    throw new TypeError(msg);
	  }
	
	  if (typeof options === 'function') {
	    callback = options;
	    options = undefined;
	  }
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	
	  var fields;
	  if (options) {
	    fields = options.select;
	    options.select = undefined;
	  }
	
	  var mq = new this.Query({}, {}, this, this.collection);
	  mq.select(fields);
	
	  return mq.findOneAndRemove(conditions, options, callback);
	};
	
	/**
	 * Issue a mongodb findAndModify remove command by a document's _id field. `findByIdAndRemove(id, ...)` is equivalent to `findOneAndRemove({ _id: id }, ...)`.
	 *
	 * Finds a matching document, removes it, passing the found document (if any) to the callback.
	 *
	 * Executes immediately if `callback` is passed, else a `Query` object is returned.
	 *
	 * This function triggers the following middleware:
	 * - `findOneAndRemove()`
	 *
	 * ####Options:
	 *
	 * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
	 * - `select`: sets the document fields to return
	 * - `passRawResult`: if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)
	 * - `strict`: overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict) for this update
	 *
	 * ####Examples:
	 *
	 *     A.findByIdAndRemove(id, options, callback) // executes
	 *     A.findByIdAndRemove(id, options)  // return Query
	 *     A.findByIdAndRemove(id, callback) // executes
	 *     A.findByIdAndRemove(id) // returns Query
	 *     A.findByIdAndRemove()           // returns Query
	 *
	 * @param {Object|Number|String} id value of `_id` to query by
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query}
	 * @see Model.findOneAndRemove #model_Model.findOneAndRemove
	 * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command
	 */
	
	Model.findByIdAndRemove = function(id, options, callback) {
	  if (arguments.length === 1 && typeof id === 'function') {
	    var msg = 'Model.findByIdAndRemove(): First argument must not be a function.\n\n'
	        + '  ' + this.modelName + '.findByIdAndRemove(id, callback)\n'
	        + '  ' + this.modelName + '.findByIdAndRemove(id)\n'
	        + '  ' + this.modelName + '.findByIdAndRemove()\n';
	    throw new TypeError(msg);
	  }
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	
	  return this.findOneAndRemove({_id: id}, options, callback);
	};
	
	/**
	 * Shortcut for saving one or more documents to the database.
	 * `MyModel.create(docs)` does `new MyModel(doc).save()` for every doc in
	 * docs.
	 *
	 * This function triggers the following middleware:
	 * - `save()`
	 *
	 * ####Example:
	 *
	 *     // pass individual docs
	 *     Candy.create({ type: 'jelly bean' }, { type: 'snickers' }, function (err, jellybean, snickers) {
	 *       if (err) // ...
	 *     });
	 *
	 *     // pass an array
	 *     var array = [{ type: 'jelly bean' }, { type: 'snickers' }];
	 *     Candy.create(array, function (err, candies) {
	 *       if (err) // ...
	 *
	 *       var jellybean = candies[0];
	 *       var snickers = candies[1];
	 *       // ...
	 *     });
	 *
	 *     // callback is optional; use the returned promise if you like:
	 *     var promise = Candy.create({ type: 'jawbreaker' });
	 *     promise.then(function (jawbreaker) {
	 *       // ...
	 *     })
	 *
	 * @param {Array|Object|*} doc(s)
	 * @param {Function} [callback] callback
	 * @return {Promise}
	 * @api public
	 */
	
	Model.create = function create(doc, callback) {
	  var args;
	  var cb;
	  var discriminatorKey = this.schema.options.discriminatorKey;
	
	  if (Array.isArray(doc)) {
	    args = doc;
	    cb = callback;
	  } else {
	    var last = arguments[arguments.length - 1];
	    // Handle falsy callbacks re: #5061
	    if (typeof last === 'function' || !last) {
	      cb = last;
	      args = utils.args(arguments, 0, arguments.length - 1);
	    } else {
	      args = utils.args(arguments);
	    }
	  }
	
	  var Promise = PromiseProvider.get();
	  var _this = this;
	  if (cb) {
	    cb = this.$wrapCallback(cb);
	  }
	
	  var promise = new Promise.ES6(function(resolve, reject) {
	    if (args.length === 0) {
	      setImmediate(function() {
	        cb && cb(null);
	        resolve(null);
	      });
	      return;
	    }
	
	    var toExecute = [];
	    var firstError;
	    args.forEach(function(doc) {
	      toExecute.push(function(callback) {
	        var Model = _this.discriminators && doc[discriminatorKey] ?
	          _this.discriminators[doc[discriminatorKey]] :
	          _this;
	        var toSave = doc instanceof Model ? doc : new Model(doc);
	        var callbackWrapper = function(error, doc) {
	          if (error) {
	            if (!firstError) {
	              firstError = error;
	            }
	            return callback(null, { error: error });
	          }
	          callback(null, { doc: doc });
	        };
	
	        // Hack to avoid getting a promise because of
	        // $__registerHooksFromSchema
	        if (toSave.$__original_save) {
	          toSave.$__original_save({ __noPromise: true }, callbackWrapper);
	        } else {
	          toSave.save({ __noPromise: true }, callbackWrapper);
	        }
	      });
	    });
	
	    parallel(toExecute, function(error, res) {
	      var savedDocs = [];
	      var len = res.length;
	      for (var i = 0; i < len; ++i) {
	        if (res[i].doc) {
	          savedDocs.push(res[i].doc);
	        }
	      }
	
	      if (firstError) {
	        if (cb) {
	          cb(firstError, savedDocs);
	        } else {
	          reject(firstError);
	        }
	        return;
	      }
	
	      if (doc instanceof Array) {
	        resolve(savedDocs);
	        cb && cb.call(_this, null, savedDocs);
	      } else {
	        resolve.apply(promise, savedDocs);
	        if (cb) {
	          cb.apply(_this, [null].concat(savedDocs));
	        }
	      }
	    });
	  });
	
	  return promise;
	};
	
	/*!
	 * ignore
	 */
	
	var INSERT_MANY_CONVERT_OPTIONS = {
	  depopulate: true,
	  transform: false,
	  _skipDepopulateTopLevel: true,
	  flattenDecimals: false
	};
	
	/**
	 * Shortcut for validating an array of documents and inserting them into
	 * MongoDB if they're all valid. This function is faster than `.create()`
	 * because it only sends one operation to the server, rather than one for each
	 * document.
	 *
	 * This function does **not** trigger save middleware.
	 *
	 * This function triggers the following middleware:
	 * - `insertMany()`
	 *
	 * ####Example:
	 *
	 *     var arr = [{ name: 'Star Wars' }, { name: 'The Empire Strikes Back' }];
	 *     Movies.insertMany(arr, function(error, docs) {});
	 *
	 * @param {Array|Object|*} doc(s)
	 * @param {Object} [options] see the [mongodb driver options](http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#insertMany)
	 * @param {Function} [callback] callback
	 * @return {Promise}
	 * @api public
	 */
	
	Model.insertMany = function(arr, options, callback) {
	  var _this = this;
	  if (typeof options === 'function') {
	    callback = options;
	    options = null;
	  }
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	  var limit = options && options.limit;
	  if (typeof limit !== 'number') {
	    limit = 1000;
	  }
	
	  if (!Array.isArray(arr)) {
	    arr = [arr];
	  }
	
	  var toExecute = [];
	  arr.forEach(function(doc) {
	    toExecute.push(function(callback) {
	      doc = new _this(doc);
	      doc.validate({ __noPromise: true }, function(error) {
	        if (error) {
	          // Option `ordered` signals that insert should be continued after reaching
	          // a failing insert. Therefore we delegate "null", meaning the validation
	          // failed. It's up to the next function to filter out all failed models
	          if (options != null && typeof options === 'object' && options['ordered'] === false) {
	            return callback(null, null);
	          }
	          return callback(error);
	        }
	        callback(null, doc);
	      });
	    });
	  });
	
	  parallelLimit(toExecute, limit, function(error, docs) {
	    if (error) {
	      callback && callback(error);
	      return;
	    }
	    // We filter all failed pre-validations by removing nulls
	    var docAttributes = docs.filter(function(doc) {
	      return doc != null;
	    });
	    // Quickly escape while there aren't any valid docAttributes
	    if (docAttributes.length < 1) {
	      callback && callback(null, []);
	      return;
	    }
	    var docObjects = docAttributes.map(function(doc) {
	      if (doc.schema.options.versionKey) {
	        doc[doc.schema.options.versionKey] = 0;
	      }
	      if (doc.initializeTimestamps) {
	        return doc.initializeTimestamps().toObject(INSERT_MANY_CONVERT_OPTIONS);
	      }
	      return doc.toObject(INSERT_MANY_CONVERT_OPTIONS);
	    });
	
	    _this.collection.insertMany(docObjects, options, function(error) {
	      if (error) {
	        callback && callback(error);
	        return;
	      }
	      for (var i = 0; i < docAttributes.length; ++i) {
	        docAttributes[i].isNew = false;
	        docAttributes[i].emit('isNew', false);
	        docAttributes[i].constructor.emit('isNew', false);
	      }
	      callback && callback(null, docAttributes);
	    });
	  });
	};
	
	/**
	 * Sends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`,
	 * `deleteOne`, and/or `deleteMany` operations to the MongoDB server in one
	 * command. This is faster than sending multiple independent operations (like)
	 * if you use `create()`) because with `bulkWrite()` there is only one round
	 * trip to MongoDB.
	 *
	 * Mongoose will perform casting on all operations you provide.
	 *
	 * This function does **not** trigger any middleware, not `save()` nor `update()`.
	 * If you need to trigger
	 * `save()` middleware for every document use [`create()`](http://mongoosejs.com/docs/api.html#model_Model.create) instead.
	 *
	 * ####Example:
	 *
	 *     Character.bulkWrite([
	 *       {
	 *         insertOne: {
	 *           document: {
	 *             name: 'Eddard Stark',
	 *             title: 'Warden of the North'
	 *           }
	 *         }
	 *       },
	 *       {
	 *         updateOne: {
	 *           filter: { name: 'Eddard Stark' },
	 *           // If you were using the MongoDB driver directly, you'd need to do
	 *           // `update: { $set: { title: ... } }` but mongoose adds $set for
	 *           // you.
	 *           update: { title: 'Hand of the King' }
	 *         }
	 *       },
	 *       {
	 *         deleteOne: {
	 *           {
	 *             filter: { name: 'Eddard Stark' }
	 *           }
	 *         }
	 *       }
	 *     ]).then(handleResult);
	 *
	 * @param {Array} ops
	 * @param {Object} [options]
	 * @param {Function} [callback] callback `function(error, bulkWriteOpResult) {}`
	 * @return {Promise} resolves to a `BulkWriteOpResult` if the operation succeeds
	 * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~BulkWriteOpResult
	 * @api public
	 */
	
	Model.bulkWrite = function(ops, options, callback) {
	  var Promise = PromiseProvider.get();
	  var _this = this;
	  if (typeof options === 'function') {
	    callback = options;
	    options = null;
	  }
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	  options = options || {};
	
	  var validations = ops.map(function(op) {
	    if (op['insertOne']) {
	      return function(callback) {
	        op['insertOne']['document'] = new _this(op['insertOne']['document']);
	        op['insertOne']['document'].validate({ __noPromise: true }, function(error) {
	          if (error) {
	            return callback(error);
	          }
	          callback(null);
	        });
	      };
	    } else if (op['updateOne']) {
	      return function(callback) {
	        try {
	          op['updateOne']['filter'] = cast(_this.schema,
	            op['updateOne']['filter']);
	          op['updateOne']['update'] = castUpdate(_this.schema,
	            op['updateOne']['update'], _this.schema.options.strict);
	        } catch (error) {
	          return callback(error);
	        }
	
	        callback(null);
	      };
	    } else if (op['updateMany']) {
	      return function(callback) {
	        try {
	          op['updateMany']['filter'] = cast(_this.schema,
	            op['updateMany']['filter']);
	          op['updateMany']['update'] = castUpdate(_this.schema, op['updateMany']['update'], {
	            strict: _this.schema.options.strict,
	            overwrite: false
	          });
	        } catch (error) {
	          return callback(error);
	        }
	
	        callback(null);
	      };
	    } else if (op['replaceOne']) {
	      return function(callback) {
	        try {
	          op['replaceOne']['filter'] = cast(_this.schema,
	            op['replaceOne']['filter']);
	        } catch (error) {
	          return callback(error);
	        }
	
	        // set `skipId`, otherwise we get "_id field cannot be changed"
	        op['replaceOne']['replacement'] =
	          new _this(op['replaceOne']['replacement'], null, true);
	        op['replaceOne']['replacement'].validate({ __noPromise: true }, function(error) {
	          if (error) {
	            return callback(error);
	          }
	          callback(null);
	        });
	      };
	    } else if (op['deleteOne']) {
	      return function(callback) {
	        try {
	          op['deleteOne']['filter'] = cast(_this.schema,
	            op['deleteOne']['filter']);
	        } catch (error) {
	          return callback(error);
	        }
	
	        callback(null);
	      };
	    } else if (op['deleteMany']) {
	      return function(callback) {
	        try {
	          op['deleteMany']['filter'] = cast(_this.schema,
	            op['deleteMany']['filter']);
	        } catch (error) {
	          return callback(error);
	        }
	
	        callback(null);
	      };
	    } else {
	      return function(callback) {
	        callback(new Error('Invalid op passed to `bulkWrite()`'));
	      };
	    }
	  });
	
	  var promise = new Promise.ES6(function(resolve, reject) {
	    parallel(validations, function(error) {
	      if (error) {
	        callback && callback(error);
	        return reject(error);
	      }
	
	      _this.collection.bulkWrite(ops, options, function(error, res) {
	        if (error) {
	          callback && callback(error);
	          return reject(error);
	        }
	
	        callback && callback(null, res);
	        resolve(res);
	      });
	    });
	  });
	
	  return promise;
	};
	
	/**
	 * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.
	 * The document returned has no paths marked as modified initially.
	 *
	 * ####Example:
	 *
	 *     // hydrate previous data into a Mongoose document
	 *     var mongooseCandy = Candy.hydrate({ _id: '54108337212ffb6d459f854c', type: 'jelly bean' });
	 *
	 * @param {Object} obj
	 * @return {Document}
	 * @api public
	 */
	
	Model.hydrate = function(obj) {
	  var model = __webpack_require__(63).createModel(this, obj);
	  model.init(obj);
	  return model;
	};
	
	/**
	 * Updates one document in the database without returning it.
	 *
	 * This function triggers the following middleware:
	 * - `update()`
	 *
	 * ####Examples:
	 *
	 *     MyModel.update({ age: { $gt: 18 } }, { oldEnough: true }, fn);
	 *     MyModel.update({ name: 'Tobi' }, { ferret: true }, { multi: true }, function (err, raw) {
	 *       if (err) return handleError(err);
	 *       console.log('The raw response from Mongo was ', raw);
	 *     });
	 *
	 * ####Valid options:
	 *
	 *  - `safe` (boolean) safe mode (defaults to value set in schema (true))
	 *  - `upsert` (boolean) whether to create the doc if it doesn't match (false)
	 *  - `multi` (boolean) whether multiple documents should be updated (false)
	 *  - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.
	 *  - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).
	 *  - `strict` (boolean) overrides the `strict` option for this update
	 *  - `overwrite` (boolean) disables update-only mode, allowing you to overwrite the doc (false)
	 *
	 * All `update` values are cast to their appropriate SchemaTypes before being sent.
	 *
	 * The `callback` function receives `(err, rawResponse)`.
	 *
	 * - `err` is the error if any occurred
	 * - `rawResponse` is the full response from Mongo
	 *
	 * ####Note:
	 *
	 * All top level keys which are not `atomic` operation names are treated as set operations:
	 *
	 * ####Example:
	 *
	 *     var query = { name: 'borne' };
	 *     Model.update(query, { name: 'jason bourne' }, options, callback)
	 *
	 *     // is sent as
	 *     Model.update(query, { $set: { name: 'jason bourne' }}, options, callback)
	 *     // if overwrite option is false. If overwrite is true, sent without the $set wrapper.
	 *
	 * This helps prevent accidentally overwriting all documents in your collection with `{ name: 'jason bourne' }`.
	 *
	 * ####Note:
	 *
	 * Be careful to not use an existing model instance for the update clause (this won't work and can cause weird behavior like infinite loops). Also, ensure that the update clause does not have an _id property, which causes Mongo to return a "Mod on _id not allowed" error.
	 *
	 * ####Note:
	 *
	 * To update documents without waiting for a response from MongoDB, do not pass a `callback`, then call `exec` on the returned [Query](#query-js):
	 *
	 *     Comment.update({ _id: id }, { $set: { text: 'changed' }}).exec();
	 *
	 * ####Note:
	 *
	 * Although values are casted to their appropriate types when using update, the following are *not* applied:
	 *
	 * - defaults
	 * - setters
	 * - validators
	 * - middleware
	 *
	 * If you need those features, use the traditional approach of first retrieving the document.
	 *
	 *     Model.findOne({ name: 'borne' }, function (err, doc) {
	 *       if (err) ..
	 *       doc.name = 'jason bourne';
	 *       doc.save(callback);
	 *     })
	 *
	 * @see strict http://mongoosejs.com/docs/guide.html#strict
	 * @see response http://docs.mongodb.org/v2.6/reference/command/update/#output
	 * @param {Object} conditions
	 * @param {Object} doc
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query}
	 * @api public
	 */
	
	Model.update = function update(conditions, doc, options, callback) {
	  return _update(this, 'update', conditions, doc, options, callback);
	};
	
	/**
	 * Same as `update()`, except MongoDB will update _all_ documents that match
	 * `criteria` (as opposed to just the first one) regardless of the value of
	 * the `multi` option.
	 *
	 * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`
	 * and `post('updateMany')` instead.
	 *
	 * This function triggers the following middleware:
	 * - `updateMany()`
	 *
	 * @param {Object} conditions
	 * @param {Object} doc
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query}
	 * @api public
	 */
	
	Model.updateMany = function updateMany(conditions, doc, options, callback) {
	  return _update(this, 'updateMany', conditions, doc, options, callback);
	};
	
	/**
	 * Same as `update()`, except MongoDB will update _only_ the first document that
	 * matches `criteria` regardless of the value of the `multi` option.
	 *
	 * This function triggers the following middleware:
	 * - `updateOne()`
	 *
	 * @param {Object} conditions
	 * @param {Object} doc
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query}
	 * @api public
	 */
	
	Model.updateOne = function updateOne(conditions, doc, options, callback) {
	  return _update(this, 'updateOne', conditions, doc, options, callback);
	};
	
	/**
	 * Same as `update()`, except MongoDB replace the existing document with the
	 * given document (no atomic operators like `$set`).
	 *
	 * This function triggers the following middleware:
	 * - `replaceOne()`
	 *
	 * @param {Object} conditions
	 * @param {Object} doc
	 * @param {Object} [options]
	 * @param {Function} [callback]
	 * @return {Query}
	 * @api public
	 */
	
	Model.replaceOne = function replaceOne(conditions, doc, options, callback) {
	  return _update(this, 'replaceOne', conditions, doc, options, callback);
	};
	
	/*!
	 * ignore
	 */
	
	function _update(model, op, conditions, doc, options, callback) {
	  var mq = new model.Query({}, {}, model, model.collection);
	  if (callback) {
	    callback = model.$wrapCallback(callback);
	  }
	  // gh-2406
	  // make local deep copy of conditions
	  if (conditions instanceof Document) {
	    conditions = conditions.toObject();
	  } else {
	    conditions = utils.clone(conditions, {retainKeyOrder: true});
	  }
	  options = typeof options === 'function' ? options : utils.clone(options);
	
	  if (model.schema.options.versionKey && options && options.upsert) {
	    if (options.overwrite) {
	      doc[model.schema.options.versionKey] = 0;
	    } else {
	      if (!doc.$setOnInsert) {
	        doc.$setOnInsert = {};
	      }
	      doc.$setOnInsert[model.schema.options.versionKey] = 0;
	    }
	  }
	
	  return mq[op](conditions, doc, options, callback);
	}
	
	/**
	 * Executes a mapReduce command.
	 *
	 * `o` is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver implementation. See [node-mongodb-native mapReduce() documentation](http://mongodb.github.io/node-mongodb-native/api-generated/collection.html#mapreduce) for more detail about options.
	 *
	 * This function does not trigger any middleware.
	 *
	 * ####Example:
	 *
	 *     var o = {};
	 *     o.map = function () { emit(this.name, 1) }
	 *     o.reduce = function (k, vals) { return vals.length }
	 *     User.mapReduce(o, function (err, results) {
	 *       console.log(results)
	 *     })
	 *
	 * ####Other options:
	 *
	 * - `query` {Object} query filter object.
	 * - `sort` {Object} sort input objects using this key
	 * - `limit` {Number} max number of documents
	 * - `keeptemp` {Boolean, default:false} keep temporary data
	 * - `finalize` {Function} finalize function
	 * - `scope` {Object} scope variables exposed to map/reduce/finalize during execution
	 * - `jsMode` {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X
	 * - `verbose` {Boolean, default:false} provide statistics on job execution time.
	 * - `readPreference` {String}
	 * - `out*` {Object, default: {inline:1}} sets the output target for the map reduce job.
	 *
	 * ####* out options:
	 *
	 * - `{inline:1}` the results are returned in an array
	 * - `{replace: 'collectionName'}` add the results to collectionName: the results replace the collection
	 * - `{reduce: 'collectionName'}` add the results to collectionName: if dups are detected, uses the reducer / finalize functions
	 * - `{merge: 'collectionName'}` add the results to collectionName: if dups exist the new docs overwrite the old
	 *
	 * If `options.out` is set to `replace`, `merge`, or `reduce`, a Model instance is returned that can be used for further querying. Queries run against this model are all executed with the `lean` option; meaning only the js object is returned and no Mongoose magic is applied (getters, setters, etc).
	 *
	 * ####Example:
	 *
	 *     var o = {};
	 *     o.map = function () { emit(this.name, 1) }
	 *     o.reduce = function (k, vals) { return vals.length }
	 *     o.out = { replace: 'createdCollectionNameForResults' }
	 *     o.verbose = true;
	 *
	 *     User.mapReduce(o, function (err, model, stats) {
	 *       console.log('map reduce took %d ms', stats.processtime)
	 *       model.find().where('value').gt(10).exec(function (err, docs) {
	 *         console.log(docs);
	 *       });
	 *     })
	 *
	 *     // `mapReduce()` returns a promise. However, ES6 promises can only
	 *     // resolve to exactly one value,
	 *     o.resolveToObject = true;
	 *     var promise = User.mapReduce(o);
	 *     promise.then(function (res) {
	 *       var model = res.model;
	 *       var stats = res.stats;
	 *       console.log('map reduce took %d ms', stats.processtime)
	 *       return model.find().where('value').gt(10).exec();
	 *     }).then(function (docs) {
	 *        console.log(docs);
	 *     }).then(null, handleError).end()
	 *
	 * @param {Object} o an object specifying map-reduce options
	 * @param {Function} [callback] optional callback
	 * @see http://www.mongodb.org/display/DOCS/MapReduce
	 * @return {Promise}
	 * @api public
	 */
	
	Model.mapReduce = function mapReduce(o, callback) {
	  var _this = this;
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	  var resolveToObject = o.resolveToObject;
	  var Promise = PromiseProvider.get();
	  return new Promise.ES6(function(resolve, reject) {
	    if (!Model.mapReduce.schema) {
	      var opts = {noId: true, noVirtualId: true, strict: false};
	      Model.mapReduce.schema = new Schema({}, opts);
	    }
	
	    if (!o.out) o.out = {inline: 1};
	    if (o.verbose !== false) o.verbose = true;
	
	    o.map = String(o.map);
	    o.reduce = String(o.reduce);
	
	    if (o.query) {
	      var q = new _this.Query(o.query);
	      q.cast(_this);
	      o.query = q._conditions;
	      q = undefined;
	    }
	
	    _this.collection.mapReduce(null, null, o, function(err, ret, stats) {
	      if (err) {
	        callback && callback(err);
	        reject(err);
	        return;
	      }
	
	      if (ret.findOne && ret.mapReduce) {
	        // returned a collection, convert to Model
	        var model = Model.compile(
	            '_mapreduce_' + ret.collectionName
	            , Model.mapReduce.schema
	            , ret.collectionName
	            , _this.db
	            , _this.base);
	
	        model._mapreduce = true;
	
	        callback && callback(null, model, stats);
	        return resolveToObject ? resolve({
	          model: model,
	          stats: stats
	        }) : resolve(model, stats);
	      }
	
	      callback && callback(null, ret, stats);
	      if (resolveToObject) {
	        return resolve({ model: ret, stats: stats });
	      }
	      resolve(ret, stats);
	    });
	  });
	};
	
	/**
	 * geoNear support for Mongoose
	 *
	 * This function does not trigger any middleware. In particular, this
	 * bypasses `find()` middleware.
	 *
	 * ####Options:
	 * - `lean` {Boolean} return the raw object
	 * - All options supported by the driver are also supported
	 *
	 * ####Example:
	 *
	 *     // Legacy point
	 *     Model.geoNear([1,3], { maxDistance : 5, spherical : true }, function(err, results, stats) {
	 *        console.log(results);
	 *     });
	 *
	 *     // geoJson
	 *     var point = { type : "Point", coordinates : [9,9] };
	 *     Model.geoNear(point, { maxDistance : 5, spherical : true }, function(err, results, stats) {
	 *        console.log(results);
	 *     });
	 *
	 * @param {Object|Array} GeoJSON point or legacy coordinate pair [x,y] to search near
	 * @param {Object} options for the query
	 * @param {Function} [callback] optional callback for the query
	 * @return {Promise}
	 * @see http://docs.mongodb.org/manual/core/2dsphere/
	 * @see http://mongodb.github.io/node-mongodb-native/api-generated/collection.html?highlight=geonear#geoNear
	 * @api public
	 */
	
	Model.geoNear = function(near, options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	
	  var _this = this;
	  var Promise = PromiseProvider.get();
	  if (!near) {
	    return new Promise.ES6(function(resolve, reject) {
	      var error = new Error('Must pass a near option to geoNear');
	      reject(error);
	      callback && callback(error);
	    });
	  }
	
	  var x, y;
	
	  return new Promise.ES6(function(resolve, reject) {
	    var handler = function(err, res) {
	      if (err) {
	        reject(err);
	        callback && callback(err);
	        return;
	      }
	      if (options.lean) {
	        resolve(res.results, res.stats);
	        callback && callback(null, res.results, res.stats);
	        return;
	      }
	
	      var count = res.results.length;
	      // if there are no results, fulfill the promise now
	      if (count === 0) {
	        resolve(res.results, res.stats);
	        callback && callback(null, res.results, res.stats);
	        return;
	      }
	
	      var errSeen = false;
	
	      function init(err) {
	        if (err && !errSeen) {
	          errSeen = true;
	          reject(err);
	          callback && callback(err);
	          return;
	        }
	        if (--count <= 0) {
	          resolve(res.results, res.stats);
	          callback && callback(null, res.results, res.stats);
	        }
	      }
	
	      for (var i = 0; i < res.results.length; i++) {
	        var temp = res.results[i].obj;
	        res.results[i].obj = new _this();
	        res.results[i].obj.init(temp, init);
	      }
	    };
	
	    if (Array.isArray(near)) {
	      if (near.length !== 2) {
	        var error = new Error('If using legacy coordinates, must be an array ' +
	            'of size 2 for geoNear');
	        reject(error);
	        callback && callback(error);
	        return;
	      }
	      x = near[0];
	      y = near[1];
	      _this.collection.geoNear(x, y, options, handler);
	    } else {
	      if (near.type !== 'Point' || !Array.isArray(near.coordinates)) {
	        error = new Error('Must pass either a legacy coordinate array or ' +
	            'GeoJSON Point to geoNear');
	        reject(error);
	        callback && callback(error);
	        return;
	      }
	
	      _this.collection.geoNear(near, options, handler);
	    }
	  });
	};
	
	/**
	 * Performs [aggregations](http://docs.mongodb.org/manual/applications/aggregation/) on the models collection.
	 *
	 * If a `callback` is passed, the `aggregate` is executed and a `Promise` is returned. If a callback is not passed, the `aggregate` itself is returned.
	 *
	 * This function does not trigger any middleware.
	 *
	 * ####Example:
	 *
	 *     // Find the max balance of all accounts
	 *     Users.aggregate(
	 *       { $group: { _id: null, maxBalance: { $max: '$balance' }}},
	 *       { $project: { _id: 0, maxBalance: 1 }},
	 *       function (err, res) {
	 *         if (err) return handleError(err);
	 *         console.log(res); // [ { maxBalance: 98000 } ]
	 *       });
	 *
	 *     // Or use the aggregation pipeline builder.
	 *     Users.aggregate()
	 *       .group({ _id: null, maxBalance: { $max: '$balance' } })
	 *       .select('-id maxBalance')
	 *       .exec(function (err, res) {
	 *         if (err) return handleError(err);
	 *         console.log(res); // [ { maxBalance: 98 } ]
	 *     });
	 *
	 * ####NOTE:
	 *
	 * - Arguments are not cast to the model's schema because `$project` operators allow redefining the "shape" of the documents at any stage of the pipeline, which may leave documents in an incompatible format.
	 * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).
	 * - Requires MongoDB >= 2.1
	 *
	 * @see Aggregate #aggregate_Aggregate
	 * @see MongoDB http://docs.mongodb.org/manual/applications/aggregation/
	 * @param {Object|Array} [...] aggregation pipeline operator(s) or operator array
	 * @param {Function} [callback]
	 * @return {Aggregate|Promise}
	 * @api public
	 */
	
	Model.aggregate = function aggregate() {
	  var args = [].slice.call(arguments),
	      aggregate,
	      callback;
	
	  if (typeof args[args.length - 1] === 'function') {
	    callback = args.pop();
	  }
	
	  if (args.length === 1 && util.isArray(args[0])) {
	    aggregate = new Aggregate(args[0]);
	  } else {
	    aggregate = new Aggregate(args);
	  }
	
	  aggregate.model(this);
	
	  if (typeof callback === 'undefined') {
	    return aggregate;
	  }
	
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	
	  aggregate.exec(callback);
	};
	
	/**
	 * Implements `$geoSearch` functionality for Mongoose
	 *
	 * This function does not trigger any middleware
	 *
	 * ####Example:
	 *
	 *     var options = { near: [10, 10], maxDistance: 5 };
	 *     Locations.geoSearch({ type : "house" }, options, function(err, res) {
	 *       console.log(res);
	 *     });
	 *
	 * ####Options:
	 * - `near` {Array} x,y point to search for
	 * - `maxDistance` {Number} the maximum distance from the point near that a result can be
	 * - `limit` {Number} The maximum number of results to return
	 * - `lean` {Boolean} return the raw object instead of the Mongoose Model
	 *
	 * @param {Object} conditions an object that specifies the match condition (required)
	 * @param {Object} options for the geoSearch, some (near, maxDistance) are required
	 * @param {Function} [callback] optional callback
	 * @return {Promise}
	 * @see http://docs.mongodb.org/manual/reference/command/geoSearch/
	 * @see http://docs.mongodb.org/manual/core/geohaystack/
	 * @api public
	 */
	
	Model.geoSearch = function(conditions, options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = {};
	  }
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	
	  var _this = this;
	  var Promise = PromiseProvider.get();
	  return new Promise.ES6(function(resolve, reject) {
	    var error;
	    if (conditions === undefined || !utils.isObject(conditions)) {
	      error = new Error('Must pass conditions to geoSearch');
	    } else if (!options.near) {
	      error = new Error('Must specify the near option in geoSearch');
	    } else if (!Array.isArray(options.near)) {
	      error = new Error('near option must be an array [x, y]');
	    }
	
	    if (error) {
	      callback && callback(error);
	      reject(error);
	      return;
	    }
	
	    // send the conditions in the options object
	    options.search = conditions;
	
	    _this.collection.geoHaystackSearch(options.near[0], options.near[1], options, function(err, res) {
	      // have to deal with driver problem. Should be fixed in a soon-ish release
	      // (7/8/2013)
	      if (err) {
	        callback && callback(err);
	        reject(err);
	        return;
	      }
	
	      var count = res.results.length;
	      if (options.lean || count === 0) {
	        callback && callback(null, res.results, res.stats);
	        resolve(res.results, res.stats);
	        return;
	      }
	
	      var errSeen = false;
	
	      function init(err) {
	        if (err && !errSeen) {
	          callback && callback(err);
	          reject(err);
	          return;
	        }
	
	        if (!--count && !errSeen) {
	          callback && callback(null, res.results, res.stats);
	          resolve(res.results, res.stats);
	        }
	      }
	
	      for (var i = 0; i < res.results.length; i++) {
	        var temp = res.results[i];
	        res.results[i] = new _this();
	        res.results[i].init(temp, {}, init);
	      }
	    });
	  });
	};
	
	/**
	 * Populates document references.
	 *
	 * ####Available options:
	 *
	 * - path: space delimited path(s) to populate
	 * - select: optional fields to select
	 * - match: optional query conditions to match
	 * - model: optional name of the model to use for population
	 * - options: optional query options like sort, limit, etc
	 *
	 * ####Examples:
	 *
	 *     // populates a single object
	 *     User.findById(id, function (err, user) {
	 *       var opts = [
	 *           { path: 'company', match: { x: 1 }, select: 'name' }
	 *         , { path: 'notes', options: { limit: 10 }, model: 'override' }
	 *       ]
	 *
	 *       User.populate(user, opts, function (err, user) {
	 *         console.log(user);
	 *       });
	 *     });
	 *
	 *     // populates an array of objects
	 *     User.find(match, function (err, users) {
	 *       var opts = [{ path: 'company', match: { x: 1 }, select: 'name' }]
	 *
	 *       var promise = User.populate(users, opts);
	 *       promise.then(console.log).end();
	 *     })
	 *
	 *     // imagine a Weapon model exists with two saved documents:
	 *     //   { _id: 389, name: 'whip' }
	 *     //   { _id: 8921, name: 'boomerang' }
	 *     // and this schema:
	 *     // new Schema({
	 *     //   name: String,
	 *     //   weapon: { type: ObjectId, ref: 'Weapon' }
	 *     // });
	 *
	 *     var user = { name: 'Indiana Jones', weapon: 389 }
	 *     Weapon.populate(user, { path: 'weapon', model: 'Weapon' }, function (err, user) {
	 *       console.log(user.weapon.name) // whip
	 *     })
	 *
	 *     // populate many plain objects
	 *     var users = [{ name: 'Indiana Jones', weapon: 389 }]
	 *     users.push({ name: 'Batman', weapon: 8921 })
	 *     Weapon.populate(users, { path: 'weapon' }, function (err, users) {
	 *       users.forEach(function (user) {
	 *         console.log('%s uses a %s', users.name, user.weapon.name)
	 *         // Indiana Jones uses a whip
	 *         // Batman uses a boomerang
	 *       });
	 *     });
	 *     // Note that we didn't need to specify the Weapon model because
	 *     // it is in the schema's ref
	 *
	 * @param {Document|Array} docs Either a single document or array of documents to populate.
	 * @param {Object} options A hash of key/val (path, options) used for population.
	 * @param {Function} [callback(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.
	 * @return {Promise}
	 * @api public
	 */
	
	Model.populate = function(docs, paths, callback) {
	  var _this = this;
	  if (callback) {
	    callback = this.$wrapCallback(callback);
	  }
	
	  // normalized paths
	  var noPromise = paths && !!paths.__noPromise;
	  paths = utils.populate(paths);
	
	  // data that should persist across subPopulate calls
	  var cache = {};
	
	  if (noPromise) {
	    _populate(this, docs, paths, cache, callback);
	  } else {
	    var Promise = PromiseProvider.get();
	    return new Promise.ES6(function(resolve, reject) {
	      _populate(_this, docs, paths, cache, function(error, docs) {
	        if (error) {
	          callback && callback(error);
	          reject(error);
	        } else {
	          callback && callback(null, docs);
	          resolve(docs);
	        }
	      });
	    });
	  }
	};
	
	/*!
	 * Populate helper
	 *
	 * @param {Model} model the model to use
	 * @param {Document|Array} docs Either a single document or array of documents to populate.
	 * @param {Object} paths
	 * @param {Function} [cb(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.
	 * @return {Function}
	 * @api private
	 */
	
	function _populate(model, docs, paths, cache, callback) {
	  var pending = paths.length;
	
	  if (pending === 0) {
	    return callback(null, docs);
	  }
	
	  // each path has its own query options and must be executed separately
	  var i = pending;
	  var path;
	  while (i--) {
	    path = paths[i];
	    populate(model, docs, path, next);
	  }
	
	  function next(err) {
	    if (err) {
	      return callback(err);
	    }
	    if (--pending) {
	      return;
	    }
	    callback(null, docs);
	  }
	}
	
	/*!
	 * Populates `docs`
	 */
	var excludeIdReg = /\s?-_id\s?/,
	    excludeIdRegGlobal = /\s?-_id\s?/g;
	
	function populate(model, docs, options, callback) {
	  var modelsMap;
	
	  // normalize single / multiple docs passed
	  if (!Array.isArray(docs)) {
	    docs = [docs];
	  }
	
	  if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {
	    return callback();
	  }
	
	  modelsMap = getModelsMapForPopulate(model, docs, options);
	  if (modelsMap instanceof Error) {
	    return setImmediate(function() {
	      callback(modelsMap);
	    });
	  }
	
	  var i, len = modelsMap.length,
	      mod, match, select, vals = [];
	
	  function flatten(item) {
	    // no need to include undefined values in our query
	    return undefined !== item;
	  }
	
	  var _remaining = len;
	  var hasOne = false;
	  for (i = 0; i < len; i++) {
	    mod = modelsMap[i];
	    select = mod.options.select;
	
	    if (mod.options.match) {
	      match = utils.object.shallowCopy(mod.options.match);
	    } else {
	      match = {};
	    }
	
	    var ids = utils.array.flatten(mod.ids, flatten);
	    ids = utils.array.unique(ids);
	
	    if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {
	      --_remaining;
	      continue;
	    }
	
	    hasOne = true;
	    if (mod.foreignField !== '_id' || !match['_id']) {
	      match[mod.foreignField] = { $in: ids };
	    }
	
	    var assignmentOpts = {};
	    assignmentOpts.sort = mod.options.options && mod.options.options.sort || undefined;
	    assignmentOpts.excludeId = excludeIdReg.test(select) || (select && select._id === 0);
	
	    if (assignmentOpts.excludeId) {
	      // override the exclusion from the query so we can use the _id
	      // for document matching during assignment. we'll delete the
	      // _id back off before returning the result.
	      if (typeof select === 'string') {
	        select = select.replace(excludeIdRegGlobal, ' ');
	      } else {
	        // preserve original select conditions by copying
	        select = utils.object.shallowCopy(select);
	        delete select._id;
	      }
	    }
	
	    if (mod.options.options && mod.options.options.limit) {
	      assignmentOpts.originalLimit = mod.options.options.limit;
	      mod.options.options.limit = mod.options.options.limit * ids.length;
	    }
	
	    var subPopulate = mod.options.populate;
	    var query = mod.Model.find(match, select, mod.options.options);
	
	    // If we're doing virtual populate and projection is inclusive and foreign
	    // field is not selected, automatically select it because mongoose needs it.
	    // If projection is exclusive and client explicitly unselected the foreign
	    // field, that's the client's fault.
	    if (mod.foreignField !== '_id' && query.selectedInclusively() &&
	      !isPathSelectedInclusive(query._fields, mod.foreignField)) {
	      query.select(mod.foreignField);
	    }
	
	    // If we need to sub-populate, call populate recursively
	    if (subPopulate) {
	      query.populate(subPopulate);
	    }
	
	    query.exec(next.bind(this, mod, assignmentOpts));
	  }
	
	  if (!hasOne) {
	    return callback();
	  }
	
	  function next(options, assignmentOpts, err, valsFromDb) {
	    if (mod.options.options && mod.options.options.limit) {
	      mod.options.options.limit = assignmentOpts.originalLimit;
	    }
	
	    if (err) return callback(err);
	    vals = vals.concat(valsFromDb);
	    _assign(null, vals, options, assignmentOpts);
	    if (--_remaining === 0) {
	      callback();
	    }
	  }
	
	  function _assign(err, vals, mod, assignmentOpts) {
	    if (err) return callback(err);
	
	    var options = mod.options;
	    var isVirtual = mod.isVirtual;
	    var justOne = mod.justOne;
	    var _val;
	    var lean = options.options && options.options.lean;
	    var len = vals.length;
	    var rawOrder = {};
	    var rawDocs = {};
	    var key;
	    var val;
	
	    // Clone because `assignRawDocsToIdStructure` will mutate the array
	    var allIds = [].concat(mod.allIds.map(function(v) {
	      if (Array.isArray(v)) {
	        return [].concat(v);
	      }
	      return v;
	    }));
	
	    // optimization:
	    // record the document positions as returned by
	    // the query result.
	    for (var i = 0; i < len; i++) {
	      val = vals[i];
	      if (val) {
	        _val = utils.getValue(mod.foreignField, val);
	        if (Array.isArray(_val)) {
	          var _valLength = _val.length;
	          for (var j = 0; j < _valLength; ++j) {
	            var __val = _val[j];
	            if (__val instanceof Document) {
	              __val = __val._id;
	            }
	            key = String(__val);
	            if (rawDocs[key]) {
	              if (Array.isArray(rawDocs[key])) {
	                rawDocs[key].push(val);
	                rawOrder[key].push(i);
	              } else {
	                rawDocs[key] = [rawDocs[key], val];
	                rawOrder[key] = [rawOrder[key], i];
	              }
	            } else {
	              if (isVirtual && !justOne) {
	                rawDocs[key] = [val];
	                rawOrder[key] = [i];
	              } else {
	                rawDocs[key] = val;
	                rawOrder[key] = i;
	              }
	            }
	          }
	        } else {
	          if (_val instanceof Document) {
	            _val = _val._id;
	          }
	          key = String(_val);
	          if (rawDocs[key]) {
	            if (Array.isArray(rawDocs[key])) {
	              rawDocs[key].push(val);
	              rawOrder[key].push(i);
	            } else {
	              rawDocs[key] = [rawDocs[key], val];
	              rawOrder[key] = [rawOrder[key], i];
	            }
	          } else {
	            rawDocs[key] = val;
	            rawOrder[key] = i;
	          }
	        }
	        // flag each as result of population
	        if (!lean) {
	          val.$__.wasPopulated = true;
	        }
	      }
	    }
	
	    assignVals({
	      originalModel: model,
	      rawIds: mod.allIds,
	      allIds: allIds,
	      localField: mod.localField,
	      foreignField: mod.foreignField,
	      rawDocs: rawDocs,
	      rawOrder: rawOrder,
	      docs: mod.docs,
	      path: options.path,
	      options: assignmentOpts,
	      justOne: mod.justOne,
	      isVirtual: mod.isVirtual,
	      allOptions: mod
	    });
	  }
	}
	
	/*!
	 * Assigns documents returned from a population query back
	 * to the original document path.
	 */
	
	function assignVals(o) {
	  // replace the original ids in our intermediate _ids structure
	  // with the documents found by query
	  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, o.options,
	    o.localField, o.foreignField);
	
	  // now update the original documents being populated using the
	  // result structure that contains real documents.
	
	  var docs = o.docs;
	  var rawIds = o.rawIds;
	  var options = o.options;
	
	  function setValue(val) {
	    return valueFilter(val, options);
	  }
	
	  for (var i = 0; i < docs.length; ++i) {
	    if (utils.getValue(o.path, docs[i]) == null &&
	      !o.originalModel.schema._getVirtual(o.path)) {
	      continue;
	    }
	
	    if (o.isVirtual && !o.justOne && !Array.isArray(rawIds[i])) {
	      if (rawIds[i] == null) {
	        rawIds[i] = [];
	      } else {
	        rawIds[i] = [rawIds[i]];
	      }
	    }
	
	    if (o.isVirtual && docs[i].constructor.name === 'model') {
	      // If virtual populate and doc is already init-ed, need to walk through
	      // the actual doc to set rather than setting `_doc` directly
	      mpath.set(o.path, rawIds[i], docs[i]);
	    } else {
	      var parts = o.path.split('.');
	      var cur = docs[i];
	      for (var j = 0; j < parts.length - 1; ++j) {
	        if (cur[parts[j]] == null) {
	          cur[parts[j]] = {};
	        }
	        cur = cur[parts[j]];
	      }
	      if (docs[i].$__) {
	        docs[i].populated(o.path, o.allIds[i], o.allOptions);
	      }
	      utils.setValue(o.path, rawIds[i], docs[i], setValue);
	    }
	  }
	}
	
	/*!
	 * Assign `vals` returned by mongo query to the `rawIds`
	 * structure returned from utils.getVals() honoring
	 * query sort order if specified by user.
	 *
	 * This can be optimized.
	 *
	 * Rules:
	 *
	 *   if the value of the path is not an array, use findOne rules, else find.
	 *   for findOne the results are assigned directly to doc path (including null results).
	 *   for find, if user specified sort order, results are assigned directly
	 *   else documents are put back in original order of array if found in results
	 *
	 * @param {Array} rawIds
	 * @param {Array} vals
	 * @param {Boolean} sort
	 * @api private
	 */
	
	function assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, localFields, foreignFields, recursed) {
	  // honor user specified sort order
	  var newOrder = [];
	  var sorting = options.sort && rawIds.length > 1;
	  var doc;
	  var sid;
	  var id;
	
	  for (var i = 0; i < rawIds.length; ++i) {
	    id = rawIds[i];
	
	    if (Array.isArray(id)) {
	      // handle [ [id0, id2], [id3] ]
	      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, localFields, foreignFields, true);
	      newOrder.push(id);
	      continue;
	    }
	
	    if (id === null && !sorting) {
	      // keep nulls for findOne unless sorting, which always
	      // removes them (backward compat)
	      newOrder.push(id);
	      continue;
	    }
	
	    sid = String(id);
	
	    if (recursed) {
	      // apply find behavior
	
	      // assign matching documents in original order unless sorting
	      doc = resultDocs[sid];
	      if (doc) {
	        if (sorting) {
	          newOrder[resultOrder[sid]] = doc;
	        } else {
	          newOrder.push(doc);
	        }
	      } else {
	        newOrder.push(id);
	      }
	    } else {
	      // apply findOne behavior - if document in results, assign, else assign null
	      newOrder[i] = doc = resultDocs[sid] || null;
	    }
	  }
	
	  rawIds.length = 0;
	  if (newOrder.length) {
	    // reassign the documents based on corrected order
	
	    // forEach skips over sparse entries in arrays so we
	    // can safely use this to our advantage dealing with sorted
	    // result sets too.
	    newOrder.forEach(function(doc, i) {
	      if (!doc) {
	        return;
	      }
	      rawIds[i] = doc;
	    });
	  }
	}
	
	function getModelsMapForPopulate(model, docs, options) {
	  var i, doc, len = docs.length,
	      available = {},
	      map = [],
	      modelNameFromQuery = options.model && options.model.modelName || options.model,
	      schema, refPath, Model, currentOptions, modelNames, modelName, discriminatorKey, modelForFindSchema;
	
	  var originalModel = options.model;
	  var isVirtual = false;
	  var isRefPathArray = false;
	
	  schema = model._getSchema(options.path);
	  var isUnderneathDocArray = schema && schema.$isUnderneathDocArray;
	  if (isUnderneathDocArray &&
	      options &&
	      options.options &&
	      options.options.sort) {
	    return new Error('Cannot populate with `sort` on path ' + options.path +
	      ' because it is a subproperty of a document array');
	  }
	
	  if (schema && schema.caster) {
	    schema = schema.caster;
	  }
	
	  if (!schema && model.discriminators) {
	    discriminatorKey = model.schema.discriminatorMapping.key;
	  }
	
	  refPath = schema && schema.options && schema.options.refPath;
	
	  for (i = 0; i < len; i++) {
	    doc = docs[i];
	
	    if (refPath) {
	      modelNames = utils.getValue(refPath, doc);
	      isRefPathArray = Array.isArray(modelNames);
	    } else {
	      if (!modelNameFromQuery) {
	        var modelForCurrentDoc = model;
	        var schemaForCurrentDoc;
	
	        if (!schema && discriminatorKey) {
	          modelForFindSchema = utils.getValue(discriminatorKey, doc);
	
	          if (modelForFindSchema) {
	            try {
	              modelForCurrentDoc = model.db.model(modelForFindSchema);
	            } catch (error) {
	              return error;
	            }
	
	            schemaForCurrentDoc = modelForCurrentDoc._getSchema(options.path);
	
	            if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {
	              schemaForCurrentDoc = schemaForCurrentDoc.caster;
	            }
	          }
	        } else {
	          schemaForCurrentDoc = schema;
	        }
	        var virtual = modelForCurrentDoc.schema._getVirtual(options.path);
	
	        if (schemaForCurrentDoc && schemaForCurrentDoc.options && schemaForCurrentDoc.options.ref) {
	          modelNames = [schemaForCurrentDoc.options.ref];
	        } else if (virtual && virtual.options && virtual.options.ref) {
	          modelNames = [virtual && virtual.options && virtual.options.ref];
	          isVirtual = true;
	        } else {
	          // We may have a discriminator, in which case we don't want to
	          // populate using the base model by default
	          modelNames = discriminatorKey ? null : [model.modelName];
	        }
	      } else {
	        modelNames = [modelNameFromQuery];  // query options
	      }
	    }
	
	    if (!modelNames) {
	      continue;
	    }
	
	    if (!Array.isArray(modelNames)) {
	      modelNames = [modelNames];
	    }
	
	    virtual = model.schema._getVirtual(options.path);
	    var localField = virtual && virtual.options ?
	      (virtual.$nestedSchemaPath ? virtual.$nestedSchemaPath + '.' : '') + virtual.options.localField :
	      options.path;
	    var foreignField = virtual && virtual.options ?
	      virtual.options.foreignField :
	      '_id';
	    var justOne = virtual && virtual.options && virtual.options.justOne;
	    if (virtual && virtual.options && virtual.options.ref) {
	      isVirtual = true;
	    }
	
	    if (virtual && (!localField || !foreignField)) {
	      throw new Error('If you are populating a virtual, you must set the ' +
	        'localField and foreignField options');
	    }
	
	    options.isVirtual = isVirtual;
	    var ret = convertTo_id(utils.getValue(localField, doc));
	    var id = String(utils.getValue(foreignField, doc));
	    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;
	
	    var k = modelNames.length;
	    while (k--) {
	      modelName = modelNames[k];
	      if (modelName == null) {
	        continue;
	      }
	      var _doc = Array.isArray(doc) && isRefPathArray ? doc[k] : doc;
	      var _ret = Array.isArray(ret) && isRefPathArray ? ret[k] : ret;
	      try {
	        Model = originalModel && originalModel.modelName ?
	          originalModel :
	          model.db.model(modelName);
	      } catch (error) {
	        return error;
	      }
	
	      if (!available[modelName]) {
	        currentOptions = {
	          model: Model
	        };
	
	        if (isVirtual && virtual.options && virtual.options.options) {
	          currentOptions.options = utils.clone(virtual.options.options, {
	            retainKeyOrder: true
	          });
	        }
	        utils.merge(currentOptions, options);
	        if (schema && !discriminatorKey) {
	          currentOptions.model = Model;
	        }
	        options.model = Model;
	
	        available[modelName] = {
	          Model: Model,
	          options: currentOptions,
	          docs: [_doc],
	          ids: [_ret],
	          allIds: [ret],
	          // Assume only 1 localField + foreignField
	          localField: localField,
	          foreignField: foreignField,
	          justOne: justOne,
	          isVirtual: isVirtual
	        };
	        map.push(available[modelName]);
	      } else {
	        available[modelName].docs.push(_doc);
	        available[modelName].ids.push(_ret);
	        available[modelName].allIds.push(ret);
	      }
	    }
	  }
	
	  return map;
	}
	
	/*!
	 * Retrieve the _id of `val` if a Document or Array of Documents.
	 *
	 * @param {Array|Document|Any} val
	 * @return {Array|Document|Any}
	 */
	
	function convertTo_id(val) {
	  if (val instanceof Model) return val._id;
	
	  if (Array.isArray(val)) {
	    for (var i = 0; i < val.length; ++i) {
	      if (val[i] instanceof Model) {
	        val[i] = val[i]._id;
	      }
	    }
	    if (val.isMongooseArray) {
	      return val._schema.cast(val, val._parent);
	    }
	
	    return [].concat(val);
	  }
	
	  return val;
	}
	
	/*!
	 * 1) Apply backwards compatible find/findOne behavior to sub documents
	 *
	 *    find logic:
	 *      a) filter out non-documents
	 *      b) remove _id from sub docs when user specified
	 *
	 *    findOne
	 *      a) if no doc found, set to null
	 *      b) remove _id from sub docs when user specified
	 *
	 * 2) Remove _ids when specified by users query.
	 *
	 * background:
	 * _ids are left in the query even when user excludes them so
	 * that population mapping can occur.
	 */
	
	function valueFilter(val, assignmentOpts) {
	  if (Array.isArray(val)) {
	    // find logic
	    var ret = [];
	    var numValues = val.length;
	    for (var i = 0; i < numValues; ++i) {
	      var subdoc = val[i];
	      if (!isDoc(subdoc)) continue;
	      maybeRemoveId(subdoc, assignmentOpts);
	      ret.push(subdoc);
	      if (assignmentOpts.originalLimit &&
	          ret.length >= assignmentOpts.originalLimit) {
	        break;
	      }
	    }
	
	    // Since we don't want to have to create a new mongoosearray, make sure to
	    // modify the array in place
	    while (val.length > ret.length) {
	      Array.prototype.pop.apply(val, []);
	    }
	    for (i = 0; i < ret.length; ++i) {
	      val[i] = ret[i];
	    }
	    return val;
	  }
	
	  // findOne
	  if (isDoc(val)) {
	    maybeRemoveId(val, assignmentOpts);
	    return val;
	  }
	
	  return null;
	}
	
	/*!
	 * Remove _id from `subdoc` if user specified "lean" query option
	 */
	
	function maybeRemoveId(subdoc, assignmentOpts) {
	  if (assignmentOpts.excludeId) {
	    if (typeof subdoc.setValue === 'function') {
	      delete subdoc._doc._id;
	    } else {
	      delete subdoc._id;
	    }
	  }
	}
	
	/*!
	 * Determine if `doc` is a document returned
	 * by a populate query.
	 */
	
	function isDoc(doc) {
	  if (doc == null) {
	    return false;
	  }
	
	  var type = typeof doc;
	  if (type === 'string') {
	    return false;
	  }
	
	  if (type === 'number') {
	    return false;
	  }
	
	  if (Buffer.isBuffer(doc)) {
	    return false;
	  }
	
	  if (doc.constructor.name === 'ObjectID') {
	    return false;
	  }
	
	  // only docs
	  return true;
	}
	
	/**
	 * Finds the schema for `path`. This is different than
	 * calling `schema.path` as it also resolves paths with
	 * positional selectors (something.$.another.$.path).
	 *
	 * @param {String} path
	 * @return {Schema}
	 * @api private
	 */
	
	Model._getSchema = function _getSchema(path) {
	  return this.schema._getSchema(path);
	};
	
	/*!
	 * Compiler utility.
	 *
	 * @param {String|Function} name model name or class extending Model
	 * @param {Schema} schema
	 * @param {String} collectionName
	 * @param {Connection} connection
	 * @param {Mongoose} base mongoose instance
	 */
	
	Model.compile = function compile(name, schema, collectionName, connection, base) {
	  var versioningEnabled = schema.options.versionKey !== false;
	
	  if (versioningEnabled && !schema.paths[schema.options.versionKey]) {
	    // add versioning to top level documents only
	    var o = {};
	    o[schema.options.versionKey] = Number;
	    schema.add(o);
	  }
	
	  var model;
	  if (typeof name === 'function' && name.prototype instanceof Model) {
	    model = name;
	    name = model.name;
	    schema.loadClass(model, false);
	    model.prototype.$isMongooseModelPrototype = true;
	  } else {
	    // generate new class
	    model = function model(doc, fields, skipId) {
	      if (!(this instanceof model)) {
	        return new model(doc, fields, skipId);
	      }
	      Model.call(this, doc, fields, skipId);
	    };
	  }
	
	  model.hooks = schema.s.hooks.clone();
	  model.base = base;
	  model.modelName = name;
	  if (!(model.prototype instanceof Model)) {
	    model.__proto__ = Model;
	    model.prototype.__proto__ = Model.prototype;
	  }
	  model.model = Model.prototype.model;
	  model.db = model.prototype.db = connection;
	  model.discriminators = model.prototype.discriminators = undefined;
	
	  model.prototype.$__setSchema(schema);
	
	  var collectionOptions = {
	    bufferCommands: schema.options.bufferCommands,
	    capped: schema.options.capped
	  };
	
	  model.prototype.collection = connection.collection(
	      collectionName
	      , collectionOptions
	  );
	
	  // apply methods and statics
	  applyMethods(model, schema);
	  applyStatics(model, schema);
	  applyHooks(model, schema);
	
	  model.schema = model.prototype.schema;
	  model.collection = model.prototype.collection;
	
	  // Create custom query constructor
	  model.Query = function() {
	    Query.apply(this, arguments);
	    this.options.retainKeyOrder = model.schema.options.retainKeyOrder;
	  };
	  model.Query.prototype = Object.create(Query.prototype);
	  model.Query.base = Query.base;
	  applyQueryMethods(model, schema.query);
	
	  var kareemOptions = {
	    useErrorHandlers: true,
	    numCallbackParams: 1
	  };
	  model.$__insertMany = model.hooks.createWrapper('insertMany',
	    model.insertMany, model, kareemOptions);
	  model.insertMany = function(arr, options, callback) {
	    var Promise = PromiseProvider.get();
	    if (typeof options === 'function') {
	      callback = options;
	      options = null;
	    }
	    return new Promise.ES6(function(resolve, reject) {
	      model.$__insertMany(arr, options, function(error, result) {
	        if (error) {
	          callback && callback(error);
	          return reject(error);
	        }
	        callback && callback(null, result);
	        resolve(result);
	      });
	    });
	  };
	
	  return model;
	};
	
	/*!
	 * Register custom query methods for this model
	 *
	 * @param {Model} model
	 * @param {Schema} schema
	 */
	
	function applyQueryMethods(model, methods) {
	  for (var i in methods) {
	    model.Query.prototype[i] = methods[i];
	  }
	}
	
	/*!
	 * Subclass this model with `conn`, `schema`, and `collection` settings.
	 *
	 * @param {Connection} conn
	 * @param {Schema} [schema]
	 * @param {String} [collection]
	 * @return {Model}
	 */
	
	Model.__subclass = function subclass(conn, schema, collection) {
	  // subclass model using this connection and collection name
	  var _this = this;
	
	  var Model = function Model(doc, fields, skipId) {
	    if (!(this instanceof Model)) {
	      return new Model(doc, fields, skipId);
	    }
	    _this.call(this, doc, fields, skipId);
	  };
	
	  Model.__proto__ = _this;
	  Model.prototype.__proto__ = _this.prototype;
	  Model.db = Model.prototype.db = conn;
	
	  var s = schema && typeof schema !== 'string'
	      ? schema
	      : _this.prototype.schema;
	
	  var options = s.options || {};
	
	  if (!collection) {
	    collection = _this.prototype.schema.get('collection')
	        || utils.toCollectionName(_this.modelName, options);
	  }
	
	  var collectionOptions = {
	    bufferCommands: s ? options.bufferCommands : true,
	    capped: s && options.capped
	  };
	
	  Model.prototype.collection = conn.collection(collection, collectionOptions);
	  Model.collection = Model.prototype.collection;
	  Model.init();
	  return Model;
	};
	
	Model.$wrapCallback = function(callback) {
	  var _this = this;
	  return function() {
	    try {
	      callback.apply(null, arguments);
	    } catch (error) {
	      _this.emit('error', error);
	    }
	  };
	};
	
	/*!
	 * Module exports.
	 */
	
	module.exports = exports = Model;


/***/ }),
/* 225 */
/***/ (function(module, exports) {

	'use strict';
	
	/*!
	 * ignore
	 */
	
	module.exports = function(schema) {
	  // ensure the documents receive an id getter unless disabled
	  var autoIdGetter = !schema.paths['id'] &&
	      (!schema.options.noVirtualId && schema.options.id);
	  if (autoIdGetter) {
	    schema.virtual('id').get(idGetter);
	  }
	};
	
	/*!
	 * Returns this documents _id cast to a string.
	 */
	
	function idGetter() {
	  if (this._id != null) {
	    return String(this._id);
	  }
	
	  return null;
	}


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var each = __webpack_require__(108);
	
	/*!
	 * ignore
	 */
	
	module.exports = function(schema) {
	  schema.callQueue.unshift(['pre', ['save', function(next) {
	    if (this.ownerDocument) {
	      next();
	      return;
	    }
	
	    var _this = this;
	    var subdocs = this.$__getAllSubdocs();
	
	    if (!subdocs.length) {
	      next();
	      return;
	    }
	
	    each(subdocs, function(subdoc, cb) {
	      subdoc.save(function(err) {
	        cb(err);
	      });
	    }, function(error) {
	      if (error) {
	        return _this.schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {
	          next(error);
	        });
	      }
	      next();
	    });
	  }]]);
	};


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(4);
	
	/*!
	 * ignore
	 */
	
	module.exports = function shardingPlugin(schema) {
	  schema.post('init', function() {
	    storeShard.call(this);
	    return this;
	  });
	  schema.pre('save', function(next) {
	    applyWhere.call(this);
	    next();
	  });
	  schema.post('save', function() {
	    storeShard.call(this);
	  });
	};
	
	/*!
	 * ignore
	 */
	
	function applyWhere() {
	  var paths;
	  var len;
	
	  if (this.$__.shardval) {
	    paths = Object.keys(this.$__.shardval);
	    len = paths.length;
	
	    this.$where = this.$where || {};
	    for (var i = 0; i < len; ++i) {
	      this.$where[paths[i]] = this.$__.shardval[paths[i]];
	    }
	  }
	}
	
	/*!
	 * ignore
	 */
	
	module.exports.storeShard = storeShard;
	
	/*!
	 * ignore
	 */
	
	function storeShard() {
	  // backwards compat
	  var key = this.schema.options.shardKey || this.schema.options.shardkey;
	  if (!(key && utils.getFunctionName(key.constructor) === 'Object')) {
	    return;
	  }
	
	  var orig = this.$__.shardval = {},
	      paths = Object.keys(key),
	      len = paths.length,
	      val;
	
	  for (var i = 0; i < len; ++i) {
	    val = this.getValue(paths[i]);
	    if (utils.isMongooseObject(val)) {
	      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});
	    } else if (val !== null && val !== undefined && val.valueOf &&
	          // Explicitly don't take value of dates
	        (!val.constructor || utils.getFunctionName(val.constructor) !== 'Date')) {
	      orig[paths[i]] = val.valueOf();
	    } else {
	      orig[paths[i]] = val;
	    }
	  }
	}


/***/ }),
/* 228 */
/***/ (function(module, exports) {

	'use strict';
	
	/*!
	 * ignore
	 */
	
	module.exports = function(schema) {
	  schema.callQueue.unshift(['pre', ['save', function(next, options) {
	    var _this = this;
	    // Nested docs have their own presave
	    if (this.ownerDocument) {
	      return next();
	    }
	
	    var hasValidateBeforeSaveOption = options &&
	        (typeof options === 'object') &&
	        ('validateBeforeSave' in options);
	
	    var shouldValidate;
	    if (hasValidateBeforeSaveOption) {
	      shouldValidate = !!options.validateBeforeSave;
	    } else {
	      shouldValidate = this.schema.options.validateBeforeSave;
	    }
	
	    // Validate
	    if (shouldValidate) {
	      // HACK: use $__original_validate to avoid promises so bluebird doesn't
	      // complain
	      if (this.$__original_validate) {
	        this.$__original_validate({__noPromise: true}, function(error) {
	          return _this.schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {
	            next(error);
	          });
	        });
	      } else {
	        this.validate({__noPromise: true}, function(error) {
	          return _this.schema.s.hooks.execPost('save:error', _this, [ _this], { error: error }, function(error) {
	            next(error);
	          });
	        });
	      }
	    } else {
	      next();
	    }
	  }]]);
	};


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies
	 */
	
	var MPromise = __webpack_require__(245);
	var util = __webpack_require__(1);
	
	/**
	 * Promise constructor.
	 *
	 * Promises are returned from executed queries. Example:
	 *
	 *     var query = Candy.find({ bar: true });
	 *     var promise = query.exec();
	 *
	 * DEPRECATED. Mongoose 5.0 will use native promises by default (or bluebird,
	 * if native promises are not present) but still
	 * support plugging in your own ES6-compatible promises library. Mongoose 5.0
	 * will **not** support mpromise.
	 *
	 * @param {Function} fn a function which will be called when the promise is resolved that accepts `fn(err, ...){}` as signature
	 * @inherits mpromise https://github.com/aheckmann/mpromise
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `err`: Emits when the promise is rejected
	 * @event `complete`: Emits when the promise is fulfilled
	 * @api public
	 * @deprecated
	 */
	
	function Promise(fn) {
	  MPromise.call(this, fn);
	}
	
	/**
	 * ES6-style promise constructor wrapper around mpromise.
	 *
	 * @param {Function} resolver
	 * @return {Promise} new promise
	 * @api public
	 */
	Promise.ES6 = function(resolver) {
	  var promise = new Promise();
	
	  // No try/catch for backwards compatibility
	  resolver(
	    function() {
	      promise.complete.apply(promise, arguments);
	    },
	    function(e) {
	      promise.error(e);
	    });
	
	  return promise;
	};
	
	/*!
	 * Inherit from mpromise
	 */
	
	Promise.prototype = Object.create(MPromise.prototype, {
	  constructor: {
	    value: Promise,
	    enumerable: false,
	    writable: true,
	    configurable: true
	  }
	});
	
	/*!
	 * ignore
	 */
	
	Promise.prototype.then = util.deprecate(Promise.prototype.then,
	  'Mongoose: mpromise (mongoose\'s default promise library) is deprecated, ' +
	  'plug in your own promise library instead: ' +
	  'http://mongoosejs.com/docs/promises.html');
	
	/**
	 * ES6-style `.catch()` shorthand
	 *
	 * @method catch
	 * @memberOf Promise
	 * @param {Function} onReject
	 * @return {Promise}
	 * @api public
	 */
	
	Promise.prototype.catch = function(onReject) {
	  return this.then(null, onReject);
	};
	
	/*!
	 * Override event names for backward compatibility.
	 */
	
	Promise.SUCCESS = 'complete';
	Promise.FAILURE = 'err';
	
	/**
	 * Adds `listener` to the `event`.
	 *
	 * If `event` is either the success or failure event and the event has already been emitted, the`listener` is called immediately and passed the results of the original emitted event.
	 *
	 * @see mpromise#on https://github.com/aheckmann/mpromise#on
	 * @method on
	 * @memberOf Promise
	 * @param {String} event
	 * @param {Function} listener
	 * @return {Promise} this
	 * @api public
	 */
	
	/**
	 * Rejects this promise with `reason`.
	 *
	 * If the promise has already been fulfilled or rejected, not action is taken.
	 *
	 * @see mpromise#reject https://github.com/aheckmann/mpromise#reject
	 * @method reject
	 * @memberOf Promise
	 * @param {Object|String|Error} reason
	 * @return {Promise} this
	 * @api public
	 */
	
	/**
	 * Rejects this promise with `err`.
	 *
	 * If the promise has already been fulfilled or rejected, not action is taken.
	 *
	 * Differs from [#reject](#promise_Promise-reject) by first casting `err` to an `Error` if it is not `instanceof Error`.
	 *
	 * @api public
	 * @param {Error|String} err
	 * @return {Promise} this
	 */
	
	Promise.prototype.error = function(err) {
	  if (!(err instanceof Error)) {
	    if (err instanceof Object) {
	      err = util.inspect(err);
	    }
	    err = new Error(err);
	  }
	  return this.reject(err);
	};
	
	/**
	 * Resolves this promise to a rejected state if `err` is passed or a fulfilled state if no `err` is passed.
	 *
	 * If the promise has already been fulfilled or rejected, not action is taken.
	 *
	 * `err` will be cast to an Error if not already instanceof Error.
	 *
	 * _NOTE: overrides [mpromise#resolve](https://github.com/aheckmann/mpromise#resolve) to provide error casting._
	 *
	 * @param {Error} [err] error or null
	 * @param {Object} [val] value to fulfill the promise with
	 * @api public
	 * @deprecated
	 */
	
	Promise.prototype.resolve = function(err) {
	  if (err) return this.error(err);
	  return this.fulfill.apply(this, Array.prototype.slice.call(arguments, 1));
	};
	
	/**
	 * Adds a single function as a listener to both err and complete.
	 *
	 * It will be executed with traditional node.js argument position when the promise is resolved.
	 *
	 *     promise.addBack(function (err, args...) {
	 *       if (err) return handleError(err);
	 *       console.log('success');
	 *     })
	 *
	 * Alias of [mpromise#onResolve](https://github.com/aheckmann/mpromise#onresolve).
	 *
	 * _Deprecated. Use `onResolve` instead._
	 *
	 * @method addBack
	 * @param {Function} listener
	 * @return {Promise} this
	 * @deprecated
	 */
	
	Promise.prototype.addBack = Promise.prototype.onResolve;
	
	/**
	 * Fulfills this promise with passed arguments.
	 *
	 * @method fulfill
	 * @receiver Promise
	 * @see https://github.com/aheckmann/mpromise#fulfill
	 * @param {any} args
	 * @api public
	 * @deprecated
	 */
	
	/**
	 * Fulfills this promise with passed arguments.
	 *
	 * Alias of [mpromise#fulfill](https://github.com/aheckmann/mpromise#fulfill).
	 *
	 * _Deprecated. Use `fulfill` instead._
	 *
	 * @method complete
	 * @receiver Promise
	 * @param {any} args
	 * @api public
	 * @deprecated
	 */
	
	Promise.prototype.complete = MPromise.prototype.fulfill;
	
	/**
	 * Adds a listener to the `complete` (success) event.
	 *
	 * Alias of [mpromise#onFulfill](https://github.com/aheckmann/mpromise#onfulfill).
	 *
	 * _Deprecated. Use `onFulfill` instead._
	 *
	 * @method addCallback
	 * @param {Function} listener
	 * @return {Promise} this
	 * @api public
	 * @deprecated
	 */
	
	Promise.prototype.addCallback = Promise.prototype.onFulfill;
	
	/**
	 * Adds a listener to the `err` (rejected) event.
	 *
	 * Alias of [mpromise#onReject](https://github.com/aheckmann/mpromise#onreject).
	 *
	 * _Deprecated. Use `onReject` instead._
	 *
	 * @method addErrback
	 * @param {Function} listener
	 * @return {Promise} this
	 * @api public
	 * @deprecated
	 */
	
	Promise.prototype.addErrback = Promise.prototype.onReject;
	
	/**
	 * Creates a new promise and returns it. If `onFulfill` or `onReject` are passed, they are added as SUCCESS/ERROR callbacks to this promise after the nextTick.
	 *
	 * Conforms to [promises/A+](https://github.com/promises-aplus/promises-spec) specification.
	 *
	 * ####Example:
	 *
	 *     var promise = Meetups.find({ tags: 'javascript' }).select('_id').exec();
	 *     promise.then(function (meetups) {
	 *       var ids = meetups.map(function (m) {
	 *         return m._id;
	 *       });
	 *       return People.find({ meetups: { $in: ids } }).exec();
	 *     }).then(function (people) {
	 *       if (people.length < 10000) {
	 *         throw new Error('Too few people!!!');
	 *       } else {
	 *         throw new Error('Still need more people!!!');
	 *       }
	 *     }).then(null, function (err) {
	 *       assert.ok(err instanceof Error);
	 *     });
	 *
	 * @see promises-A+ https://github.com/promises-aplus/promises-spec
	 * @see mpromise#then https://github.com/aheckmann/mpromise#then
	 * @method then
	 * @memberOf Promise
	 * @param {Function} onFulFill
	 * @param {Function} onReject
	 * @return {Promise} newPromise
	 * @deprecated
	 */
	
	/**
	 * Signifies that this promise was the last in a chain of `then()s`: if a handler passed to the call to `then` which produced this promise throws, the exception will go uncaught.
	 *
	 * ####Example:
	 *
	 *     var p = new Promise;
	 *     p.then(function(){ throw new Error('shucks') });
	 *     setTimeout(function () {
	 *       p.fulfill();
	 *       // error was caught and swallowed by the promise returned from
	 *       // p.then(). we either have to always register handlers on
	 *       // the returned promises or we can do the following...
	 *     }, 10);
	 *
	 *     // this time we use .end() which prevents catching thrown errors
	 *     var p = new Promise;
	 *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--
	 *     setTimeout(function () {
	 *       p.fulfill(); // throws "shucks"
	 *     }, 10);
	 *
	 * @api public
	 * @see mpromise#end https://github.com/aheckmann/mpromise#end
	 * @method end
	 * @memberOf Promise
	 * @deprecated
	 */
	
	/*!
	 * expose
	 */
	
	module.exports = Promise;


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint no-empty: 1 */
	
	/*!
	 * Module dependencies.
	 */
	
	var Stream = __webpack_require__(18).Stream;
	var utils = __webpack_require__(4);
	var helpers = __webpack_require__(63);
	var K = function(k) {
	  return k;
	};
	
	/**
	 * Provides a Node.js 0.8 style [ReadStream](http://nodejs.org/docs/v0.8.21/api/stream.html#stream_readable_stream) interface for Queries.
	 *
	 *     var stream = Model.find().stream();
	 *
	 *     stream.on('data', function (doc) {
	 *       // do something with the mongoose document
	 *     }).on('error', function (err) {
	 *       // handle the error
	 *     }).on('close', function () {
	 *       // the stream is closed
	 *     });
	 *
	 *
	 * The stream interface allows us to simply "plug-in" to other _Node.js 0.8_ style write streams.
	 *
	 *     Model.where('created').gte(twoWeeksAgo).stream().pipe(writeStream);
	 *
	 * ####Valid options
	 *
	 *   - `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data`.
	 *
	 * ####Example
	 *
	 *     // JSON.stringify all documents before emitting
	 *     var stream = Thing.find().stream({ transform: JSON.stringify });
	 *     stream.pipe(writeStream);
	 *
	 * _NOTE: plugging into an HTTP response will *not* work out of the box. Those streams expect only strings or buffers to be emitted, so first formatting our documents as strings/buffers is necessary._
	 *
	 * _NOTE: these streams are Node.js 0.8 style read streams which differ from Node.js 0.10 style. Node.js 0.10 streams are not well tested yet and are not guaranteed to work._
	 *
	 * @param {Query} query
	 * @param {Object} [options]
	 * @inherits NodeJS Stream http://nodejs.org/docs/v0.8.21/api/stream.html#stream_readable_stream
	 * @event `data`: emits a single Mongoose document
	 * @event `error`: emits when an error occurs during streaming. This will emit _before_ the `close` event.
	 * @event `close`: emits when the stream reaches the end of the cursor or an error occurs, or the stream is manually `destroy`ed. After this event, no more events are emitted.
	 * @api public
	 */
	
	function QueryStream(query, options) {
	  Stream.call(this);
	
	  this.query = query;
	  this.readable = true;
	  this.paused = false;
	  this._cursor = null;
	  this._destroyed = null;
	  this._fields = null;
	  this._buffer = null;
	  this._inline = T_INIT;
	  this._running = false;
	  this._transform = options && typeof options.transform === 'function'
	      ? options.transform
	      : K;
	
	  // give time to hook up events
	  var _this = this;
	  process.nextTick(function() {
	    _this._init();
	  });
	}
	
	/*!
	 * Inherit from Stream
	 */
	
	QueryStream.prototype.__proto__ = Stream.prototype;
	
	/**
	 * Flag stating whether or not this stream is readable.
	 *
	 * @property readable
	 * @api public
	 */
	
	QueryStream.prototype.readable;
	
	/**
	 * Flag stating whether or not this stream is paused.
	 *
	 * @property paused
	 * @api public
	 */
	
	QueryStream.prototype.paused;
	
	// trampoline flags
	var T_INIT = 0;
	var T_IDLE = 1;
	var T_CONT = 2;
	
	/**
	 * Initializes the query.
	 *
	 * @api private
	 */
	
	QueryStream.prototype._init = function() {
	  if (this._destroyed) {
	    return;
	  }
	
	  var query = this.query,
	      model = query.model,
	      options = query._optionsForExec(model),
	      _this = this;
	
	  try {
	    query.cast(model);
	  } catch (err) {
	    return _this.destroy(err);
	  }
	
	  _this._fields = utils.clone(query._fields);
	  options.fields = query._castFields(_this._fields);
	
	  model.collection.find(query._conditions, options, function(err, cursor) {
	    if (err) {
	      return _this.destroy(err);
	    }
	    _this._cursor = cursor;
	    _this._next();
	  });
	};
	
	/**
	 * Trampoline for pulling the next doc from cursor.
	 *
	 * @see QueryStream#__next #querystream_QueryStream-__next
	 * @api private
	 */
	
	QueryStream.prototype._next = function _next() {
	  if (this.paused || this._destroyed) {
	    this._running = false;
	    return this._running;
	  }
	
	  this._running = true;
	
	  if (this._buffer && this._buffer.length) {
	    var arg;
	    while (!this.paused && !this._destroyed && (arg = this._buffer.shift())) { // eslint-disable-line no-cond-assign
	      this._onNextObject.apply(this, arg);
	    }
	  }
	
	  // avoid stack overflows with large result sets.
	  // trampoline instead of recursion.
	  while (this.__next()) {
	  }
	};
	
	/**
	 * Pulls the next doc from the cursor.
	 *
	 * @see QueryStream#_next #querystream_QueryStream-_next
	 * @api private
	 */
	
	QueryStream.prototype.__next = function() {
	  if (this.paused || this._destroyed) {
	    this._running = false;
	    return this._running;
	  }
	
	  var _this = this;
	  _this._inline = T_INIT;
	
	  _this._cursor.nextObject(function cursorcb(err, doc) {
	    _this._onNextObject(err, doc);
	  });
	
	  // if onNextObject() was already called in this tick
	  // return ourselves to the trampoline.
	  if (T_CONT === this._inline) {
	    return true;
	  }
	  // onNextObject() hasn't fired yet. tell onNextObject
	  // that its ok to call _next b/c we are not within
	  // the trampoline anymore.
	  this._inline = T_IDLE;
	};
	
	/**
	 * Transforms raw `doc`s returned from the cursor into a model instance.
	 *
	 * @param {Error|null} err
	 * @param {Object} doc
	 * @api private
	 */
	
	QueryStream.prototype._onNextObject = function _onNextObject(err, doc) {
	  if (this._destroyed) {
	    return;
	  }
	
	  if (this.paused) {
	    this._buffer || (this._buffer = []);
	    this._buffer.push([err, doc]);
	    this._running = false;
	    return this._running;
	  }
	
	  if (err) {
	    return this.destroy(err);
	  }
	
	  // when doc is null we hit the end of the cursor
	  if (!doc) {
	    this.emit('end');
	    return this.destroy();
	  }
	
	  var opts = this.query._mongooseOptions;
	
	  if (!opts.populate) {
	    return opts.lean === true ?
	        emit(this, doc) :
	        createAndEmit(this, null, doc);
	  }
	
	  var _this = this;
	  var pop = helpers.preparePopulationOptionsMQ(_this.query, _this.query._mongooseOptions);
	
	  // Hack to work around gh-3108
	  pop.forEach(function(option) {
	    delete option.model;
	  });
	
	  pop.__noPromise = true;
	  _this.query.model.populate(doc, pop, function(err, doc) {
	    if (err) {
	      return _this.destroy(err);
	    }
	    return opts.lean === true ?
	        emit(_this, doc) :
	        createAndEmit(_this, pop, doc);
	  });
	};
	
	function createAndEmit(self, populatedIds, doc) {
	  var instance = helpers.createModel(self.query.model, doc, self._fields);
	  var opts = populatedIds ?
	    {populated: populatedIds} :
	    undefined;
	
	  instance.init(doc, opts, function(err) {
	    if (err) {
	      return self.destroy(err);
	    }
	    emit(self, instance);
	  });
	}
	
	/*!
	 * Emit a data event and manage the trampoline state
	 */
	
	function emit(self, doc) {
	  self.emit('data', self._transform(doc));
	
	  // trampoline management
	  if (T_IDLE === self._inline) {
	    // no longer in trampoline. restart it.
	    self._next();
	  } else {
	    // in a trampoline. tell __next that its
	    // ok to continue jumping.
	    self._inline = T_CONT;
	  }
	}
	
	/**
	 * Pauses this stream.
	 *
	 * @api public
	 */
	
	QueryStream.prototype.pause = function() {
	  this.paused = true;
	};
	
	/**
	 * Resumes this stream.
	 *
	 * @api public
	 */
	
	QueryStream.prototype.resume = function() {
	  this.paused = false;
	
	  if (!this._cursor) {
	    // cannot start if not initialized
	    return;
	  }
	
	  // are we within the trampoline?
	  if (T_INIT === this._inline) {
	    return;
	  }
	
	  if (!this._running) {
	    // outside QueryStream control, need manual restart
	    return this._next();
	  }
	};
	
	/**
	 * Destroys the stream, closing the underlying cursor, which emits the close event. No more events will be emitted after the close event.
	 *
	 * @param {Error} [err]
	 * @api public
	 */
	
	QueryStream.prototype.destroy = function(err) {
	  if (this._destroyed) {
	    return;
	  }
	  this._destroyed = true;
	  this._running = false;
	  this.readable = false;
	
	  if (this._cursor) {
	    this._cursor.close();
	  }
	
	  if (err) {
	    this.emit('error', err);
	  }
	
	  this.emit('close');
	};
	
	/**
	 * Pipes this query stream into another stream. This method is inherited from NodeJS Streams.
	 *
	 * ####Example:
	 *
	 *     query.stream().pipe(writeStream [, options])
	 *
	 * @method pipe
	 * @memberOf QueryStream
	 * @see NodeJS http://nodejs.org/api/stream.html
	 * @api public
	 */
	
	/*!
	 * Module exports
	 */
	
	module.exports = exports = QueryStream;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint no-empty: 1 */
	
	/*!
	 * Module dependencies.
	 */
	
	var SchemaType = __webpack_require__(12);
	var CastError = SchemaType.CastError;
	var Decimal128Type = __webpack_require__(102);
	var utils = __webpack_require__(4);
	var Document;
	
	/**
	 * Decimal128 SchemaType constructor.
	 *
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function Decimal128(key, options) {
	  SchemaType.call(this, key, options, 'Decimal128');
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	Decimal128.schemaName = 'Decimal128';
	
	/*!
	 * Inherits from SchemaType.
	 */
	Decimal128.prototype = Object.create(SchemaType.prototype);
	Decimal128.prototype.constructor = Decimal128;
	
	/**
	 * Check if the given value satisfies a required validator.
	 *
	 * @param {Any} value
	 * @param {Document} doc
	 * @return {Boolean}
	 * @api public
	 */
	
	Decimal128.prototype.checkRequired = function checkRequired(value, doc) {
	  if (SchemaType._isRef(this, value, doc, true)) {
	    return !!value;
	  }
	  return value instanceof Decimal128Type;
	};
	
	/**
	 * Casts to Decimal128
	 *
	 * @param {Object} value
	 * @param {Object} doc
	 * @param {Boolean} init whether this is an initialization cast
	 * @api private
	 */
	
	Decimal128.prototype.cast = function(value, doc, init) {
	  if (SchemaType._isRef(this, value, doc, init)) {
	    // wait! we may need to cast this to a document
	
	    if (value === null || value === undefined) {
	      return value;
	    }
	
	    // lazy load
	    Document || (Document = __webpack_require__(8));
	
	    if (value instanceof Document) {
	      value.$__.wasPopulated = true;
	      return value;
	    }
	
	    // setting a populated path
	    if (value instanceof Decimal128Type) {
	      return value;
	    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {
	      throw new CastError('Decimal128', value, this.path);
	    }
	
	    // Handle the case where user directly sets a populated
	    // path to a plain object; cast to the Model used in
	    // the population query.
	    var path = doc.$__fullPath(this.path);
	    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
	    var pop = owner.populated(path, true);
	    var ret = value;
	    if (!doc.$__.populated ||
	        !doc.$__.populated[path] ||
	        !doc.$__.populated[path].options ||
	        !doc.$__.populated[path].options.options ||
	        !doc.$__.populated[path].options.options.lean) {
	      ret = new pop.options.model(value);
	      ret.$__.wasPopulated = true;
	    }
	
	    return ret;
	  }
	
	  if (value == null) {
	    return value;
	  }
	
	  if (typeof value === 'object' && typeof value.$numberDecimal === 'string') {
	    return Decimal128Type.fromString(value.$numberDecimal);
	  }
	
	  if (value instanceof Decimal128Type) {
	    return value;
	  }
	
	  if (typeof value === 'string') {
	    return Decimal128Type.fromString(value);
	  }
	
	  if (Buffer.isBuffer(value)) {
	    return new Decimal128Type(value);
	  }
	
	  throw new CastError('Decimal128', value, this.path);
	};
	
	/*!
	 * ignore
	 */
	
	function handleSingle(val) {
	  return this.cast(val);
	}
	
	Decimal128.prototype.$conditionalHandlers =
	    utils.options(SchemaType.prototype.$conditionalHandlers, {
	      $gt: handleSingle,
	      $gte: handleSingle,
	      $lt: handleSingle,
	      $lte: handleSingle
	    });
	
	/*!
	 * Module exports.
	 */
	
	module.exports = Decimal128;


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint no-empty: 1 */
	
	/*!
	 * Module dependencies.
	 */
	
	var ArrayType = __webpack_require__(95);
	var CastError = __webpack_require__(44);
	var Document = __webpack_require__(8);
	var EventEmitter = __webpack_require__(6).EventEmitter;
	var MongooseDocumentArray = __webpack_require__(46);
	var SchemaType = __webpack_require__(12);
	var Subdocument = __webpack_require__(30);
	var discriminator = __webpack_require__(100);
	var util = __webpack_require__(1);
	var utils = __webpack_require__(4);
	
	/**
	 * SubdocsArray SchemaType constructor
	 *
	 * @param {String} key
	 * @param {Schema} schema
	 * @param {Object} options
	 * @inherits SchemaArray
	 * @api public
	 */
	
	function DocumentArray(key, schema, options) {
	  var EmbeddedDocument = _createConstructor(schema, options);
	
	  ArrayType.call(this, key, EmbeddedDocument, options);
	
	  this.schema = schema;
	  this.$isMongooseDocumentArray = true;
	  var fn = this.defaultValue;
	
	  if (!('defaultValue' in this) || fn !== void 0) {
	    this.default(function() {
	      var arr = fn.call(this);
	      if (!Array.isArray(arr)) {
	        arr = [arr];
	      }
	      // Leave it up to `cast()` to convert this to a documentarray
	      return arr;
	    });
	  }
	}
	
	/**
	 * This schema type's name, to defend against minifiers that mangle
	 * function names.
	 *
	 * @api public
	 */
	DocumentArray.schemaName = 'DocumentArray';
	
	/*!
	 * Inherits from ArrayType.
	 */
	DocumentArray.prototype = Object.create(ArrayType.prototype);
	DocumentArray.prototype.constructor = DocumentArray;
	
	/*!
	 * Ignore
	 */
	
	function _createConstructor(schema, options) {
	  // compile an embedded document for this schema
	  function EmbeddedDocument() {
	    Subdocument.apply(this, arguments);
	  }
	
	  EmbeddedDocument.prototype = Object.create(Subdocument.prototype);
	  EmbeddedDocument.prototype.$__setSchema(schema);
	  EmbeddedDocument.schema = schema;
	  EmbeddedDocument.prototype.constructor = EmbeddedDocument;
	  EmbeddedDocument.$isArraySubdocument = true;
	
	  // apply methods
	  for (var i in schema.methods) {
	    EmbeddedDocument.prototype[i] = schema.methods[i];
	  }
	
	  // apply statics
	  for (i in schema.statics) {
	    EmbeddedDocument[i] = schema.statics[i];
	  }
	
	  for (i in EventEmitter.prototype) {
	    EmbeddedDocument[i] = EventEmitter.prototype[i];
	  }
	
	  EmbeddedDocument.options = options;
	
	  return EmbeddedDocument;
	}
	
	/*!
	 * Ignore
	 */
	
	DocumentArray.prototype.discriminator = function(name, schema) {
	  if (typeof name === 'function') {
	    name = utils.getFunctionName(name);
	  }
	
	  schema = discriminator(this.casterConstructor, name, schema);
	
	  var EmbeddedDocument = _createConstructor(schema);
	  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;
	
	  try {
	    Object.defineProperty(EmbeddedDocument, 'name', {
	      value: name
	    });
	  } catch (error) {
	    // Ignore error, only happens on old versions of node
	  }
	
	  this.casterConstructor.discriminators[name] = EmbeddedDocument;
	
	  return this.casterConstructor.discriminators[name];
	};
	
	/**
	 * Performs local validations first, then validations on each embedded doc
	 *
	 * @api private
	 */
	
	DocumentArray.prototype.doValidate = function(array, fn, scope, options) {
	  var _this = this;
	  SchemaType.prototype.doValidate.call(this, array, function(err) {
	    if (err) {
	      return fn(err);
	    }
	
	    var count = array && array.length;
	    var error;
	
	    if (!count) {
	      return fn();
	    }
	    if (options && options.updateValidator) {
	      return fn();
	    }
	    if (!array.isMongooseDocumentArray) {
	      array = new MongooseDocumentArray(array, _this.path, scope);
	    }
	
	    // handle sparse arrays, do not use array.forEach which does not
	    // iterate over sparse elements yet reports array.length including
	    // them :(
	
	    function callback(err) {
	      if (err) {
	        error = err;
	      }
	      --count || fn(error);
	    }
	
	    for (var i = 0, len = count; i < len; ++i) {
	      // sidestep sparse entries
	      var doc = array[i];
	      if (!doc) {
	        --count || fn(error);
	        continue;
	      }
	
	      // If you set the array index directly, the doc might not yet be
	      // a full fledged mongoose subdoc, so make it into one.
	      if (!(doc instanceof Subdocument)) {
	        doc = array[i] = new _this.casterConstructor(doc, array, undefined,
	            undefined, i);
	      }
	
	      // HACK: use $__original_validate to avoid promises so bluebird doesn't
	      // complain
	      if (doc.$__original_validate) {
	        doc.$__original_validate({__noPromise: true}, callback);
	      } else {
	        doc.validate({__noPromise: true}, callback);
	      }
	    }
	  }, scope);
	};
	
	/**
	 * Performs local validations first, then validations on each embedded doc.
	 *
	 * ####Note:
	 *
	 * This method ignores the asynchronous validators.
	 *
	 * @return {MongooseError|undefined}
	 * @api private
	 */
	
	DocumentArray.prototype.doValidateSync = function(array, scope) {
	  var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);
	  if (schemaTypeError) {
	    return schemaTypeError;
	  }
	
	  var count = array && array.length,
	      resultError = null;
	
	  if (!count) {
	    return;
	  }
	
	  // handle sparse arrays, do not use array.forEach which does not
	  // iterate over sparse elements yet reports array.length including
	  // them :(
	
	  for (var i = 0, len = count; i < len; ++i) {
	    // only first error
	    if (resultError) {
	      break;
	    }
	    // sidestep sparse entries
	    var doc = array[i];
	    if (!doc) {
	      continue;
	    }
	
	    // If you set the array index directly, the doc might not yet be
	    // a full fledged mongoose subdoc, so make it into one.
	    if (!(doc instanceof Subdocument)) {
	      doc = array[i] = new this.casterConstructor(doc, array, undefined,
	        undefined, i);
	    }
	
	    var subdocValidateError = doc.validateSync();
	
	    if (subdocValidateError) {
	      resultError = subdocValidateError;
	    }
	  }
	
	  return resultError;
	};
	
	/**
	 * Casts contents
	 *
	 * @param {Object} value
	 * @param {Document} document that triggers the casting
	 * @api private
	 */
	
	DocumentArray.prototype.cast = function(value, doc, init, prev, options) {
	  var selected;
	  var subdoc;
	  var i;
	  var _opts = { transform: false, virtuals: false };
	
	  if (!Array.isArray(value)) {
	    // gh-2442 mark whole array as modified if we're initializing a doc from
	    // the db and the path isn't an array in the document
	    if (!!doc && init) {
	      doc.markModified(this.path);
	    }
	    return this.cast([value], doc, init, prev);
	  }
	
	  if (!(value && value.isMongooseDocumentArray) &&
	      (!options || !options.skipDocumentArrayCast)) {
	    value = new MongooseDocumentArray(value, this.path, doc);
	    if (prev && prev._handlers) {
	      for (var key in prev._handlers) {
	        doc.removeListener(key, prev._handlers[key]);
	      }
	    }
	  } else if (value && value.isMongooseDocumentArray) {
	    // We need to create a new array, otherwise change tracking will
	    // update the old doc (gh-4449)
	    value = new MongooseDocumentArray(value, this.path, doc);
	  }
	
	  i = value.length;
	
	  while (i--) {
	    if (!value[i]) {
	      continue;
	    }
	
	    var Constructor = this.casterConstructor;
	    if (Constructor.discriminators &&
	        typeof value[i][Constructor.schema.options.discriminatorKey] === 'string' &&
	        Constructor.discriminators[value[i][Constructor.schema.options.discriminatorKey]]) {
	      Constructor = Constructor.discriminators[value[i][Constructor.schema.options.discriminatorKey]];
	    }
	
	    // Check if the document has a different schema (re gh-3701)
	    if ((value[i] instanceof Document) &&
	        value[i].schema !== Constructor.schema) {
	      value[i] = value[i].toObject({ transform: false, virtuals: false });
	    }
	    if (!(value[i] instanceof Subdocument) && value[i]) {
	      if (init) {
	        if (doc) {
	          selected || (selected = scopePaths(this, doc.$__.selected, init));
	        } else {
	          selected = true;
	        }
	
	        subdoc = new Constructor(null, value, true, selected, i);
	        value[i] = subdoc.init(value[i]);
	      } else {
	        if (prev && (subdoc = prev.id(value[i]._id))) {
	          subdoc = prev.id(value[i]._id);
	        }
	
	        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_opts), value[i])) {
	          // handle resetting doc with existing id and same data
	          subdoc.set(value[i]);
	          // if set() is hooked it will have no return value
	          // see gh-746
	          value[i] = subdoc;
	        } else {
	          try {
	            subdoc = new Constructor(value[i], value, undefined,
	                undefined, i);
	            // if set() is hooked it will have no return value
	            // see gh-746
	            value[i] = subdoc;
	          } catch (error) {
	            var valueInErrorMessage = util.inspect(value[i]);
	            throw new CastError('embedded', valueInErrorMessage,
	              value._path, error);
	          }
	        }
	      }
	    }
	  }
	
	  return value;
	};
	
	/*!
	 * Scopes paths selected in a query to this array.
	 * Necessary for proper default application of subdocument values.
	 *
	 * @param {DocumentArray} array - the array to scope `fields` paths
	 * @param {Object|undefined} fields - the root fields selected in the query
	 * @param {Boolean|undefined} init - if we are being created part of a query result
	 */
	
	function scopePaths(array, fields, init) {
	  if (!(init && fields)) {
	    return undefined;
	  }
	
	  var path = array.path + '.';
	  var keys = Object.keys(fields);
	  var i = keys.length;
	  var selected = {};
	  var hasKeys;
	  var key;
	  var sub;
	
	  while (i--) {
	    key = keys[i];
	    if (key.indexOf(path) === 0) {
	      sub = key.substring(path.length);
	      if (sub === '$') {
	        continue;
	      }
	      if (sub.indexOf('$.') === 0) {
	        sub = sub.substr(2);
	      }
	      hasKeys || (hasKeys = true);
	      selected[sub] = fields[key];
	    }
	  }
	
	  return hasKeys && selected || undefined;
	}
	
	/*!
	 * Module exports.
	 */
	
	module.exports = DocumentArray;


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/*!
	 * Module dependencies.
	 */
	
	var $exists = __webpack_require__(98);
	var EventEmitter = __webpack_require__(6).EventEmitter;
	var SchemaType = __webpack_require__(12);
	var Subdocument = __webpack_require__(147);
	var castToNumber = __webpack_require__(65).castToNumber;
	var discriminator = __webpack_require__(100);
	var geospatial = __webpack_require__(141);
	
	module.exports = Embedded;
	
	/**
	 * Sub-schema schematype constructor
	 *
	 * @param {Schema} schema
	 * @param {String} key
	 * @param {Object} options
	 * @inherits SchemaType
	 * @api public
	 */
	
	function Embedded(schema, path, options) {
	  this.caster = _createConstructor(schema);
	  this.caster.prototype.$basePath = path;
	  this.schema = schema;
	  this.$isSingleNested = true;
	  SchemaType.call(this, path, options, 'Embedded');
	}
	
	/*!
	 * ignore
	 */
	
	Embedded.prototype = Object.create(SchemaType.prototype);
	
	/*!
	 * ignore
	 */
	
	function _createConstructor(schema) {
	  var _embedded = function SingleNested(value, path, parent) {
	    var _this = this;
	
	    this.$parent = parent;
	    Subdocument.apply(this, arguments);
	
	    if (parent) {
	      parent.on('save', function() {
	        _this.emit('save', _this);
	        _this.constructor.emit('save', _this);
	      });
	
	      parent.on('isNew', function(val) {
	        _this.isNew = val;
	        _this.emit('isNew', val);
	        _this.constructor.emit('isNew', val);
	      });
	    }
	  };
	  _embedded.prototype = Object.create(Subdocument.prototype);
	  _embedded.prototype.$__setSchema(schema);
	  _embedded.prototype.constructor = _embedded;
	  _embedded.schema = schema;
	  _embedded.$isSingleNested = true;
	  _embedded.prototype.toBSON = function() {
	    return this.toObject({
	      transform: false,
	      retainKeyOrder: true,
	      virtuals: false,
	      _skipDepopulateTopLevel: true,
	      depopulate: true,
	      flattenDecimals: false
	    });
	  };
	
	  // apply methods
	  for (var i in schema.methods) {
	    _embedded.prototype[i] = schema.methods[i];
	  }
	
	  // apply statics
	  for (i in schema.statics) {
	    _embedded[i] = schema.statics[i];
	  }
	
	  for (i in EventEmitter.prototype) {
	    _embedded[i] = EventEmitter.prototype[i];
	  }
	
	  return _embedded;
	}
	
	/*!
	 * Special case for when users use a common location schema to represent
	 * locations for use with $geoWithin.
	 * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/
	 *
	 * @param {Object} val
	 * @api private
	 */
	
	Embedded.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) {
	  return { $geometry: this.castForQuery(val.$geometry) };
	};
	
	/*!
	 * ignore
	 */
	
	Embedded.prototype.$conditionalHandlers.$near =
	Embedded.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;
	
	Embedded.prototype.$conditionalHandlers.$within =
	Embedded.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;
	
	Embedded.prototype.$conditionalHandlers.$geoIntersects =
	  geospatial.cast$geoIntersects;
	
	Embedded.prototype.$conditionalHandlers.$minDistance = castToNumber;
	Embedded.prototype.$conditionalHandlers.$maxDistance = castToNumber;
	
	Embedded.prototype.$conditionalHandlers.$exists = $exists;
	
	/**
	 * Casts contents
	 *
	 * @param {Object} value
	 * @api private
	 */
	
	Embedded.prototype.cast = function(val, doc, init, priorVal) {
	  if (val && val.$isSingleNested) {
	    return val;
	  }
	
	  var Constructor = this.caster;
	  var discriminatorKey = Constructor.schema.options.discriminatorKey;
	  if (val != null &&
	      Constructor.discriminators &&
	      typeof val[discriminatorKey] === 'string' &&
	      Constructor.discriminators[val[discriminatorKey]]) {
	    Constructor = Constructor.discriminators[val[discriminatorKey]];
	  }
	
	  var subdoc;
	  if (init) {
	    subdoc = new Constructor(void 0, doc ? doc.$__.selected : void 0, doc);
	    subdoc.init(val);
	  } else {
	    if (Object.keys(val).length === 0) {
	      return new Constructor({}, doc ? doc.$__.selected : void 0, doc);
	    }
	
	    return new Constructor(val, doc ? doc.$__.selected : void 0, doc, undefined, {
	      priorDoc: priorVal
	    });
	  }
	
	  return subdoc;
	};
	
	/**
	 * Casts contents for query
	 *
	 * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)
	 * @param {any} value
	 * @api private
	 */
	
	Embedded.prototype.castForQuery = function($conditional, val) {
	  var handler;
	  if (arguments.length === 2) {
	    handler = this.$conditionalHandlers[$conditional];
	    if (!handler) {
	      throw new Error('Can\'t use ' + $conditional);
	    }
	    return handler.call(this, val);
	  }
	  val = $conditional;
	  if (val == null) {
	    return val;
	  }
	
	  if (this.options.runSetters) {
	    val = this._applySetters(val);
	  }
	
	  return new this.caster(val);
	};
	
	/**
	 * Async validation on this single nested doc.
	 *
	 * @api private
	 */
	
	Embedded.prototype.doValidate = function(value, fn, scope) {
	  var Constructor = this.caster;
	  var discriminatorKey = Constructor.schema.options.discriminatorKey;
	  if (value != null &&
	      Constructor.discriminators &&
	      typeof value[discriminatorKey] === 'string' &&
	      Constructor.discriminators[value[discriminatorKey]]) {
	    Constructor = Constructor.discriminators[value[discriminatorKey]];
	  }
	
	  SchemaType.prototype.doValidate.call(this, value, function(error) {
	    if (error) {
	      return fn(error);
	    }
	    if (!value) {
	      return fn(null);
	    }
	
	    if (!(value instanceof Constructor)) {
	      value = new Constructor(value);
	    }
	    value.validate({__noPromise: true}, fn);
	  }, scope);
	};
	
	/**
	 * Synchronously validate this single nested doc
	 *
	 * @api private
	 */
	
	Embedded.prototype.doValidateSync = function(value, scope) {
	  var schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);
	  if (schemaTypeError) {
	    return schemaTypeError;
	  }
	  if (!value) {
	    return;
	  }
	  return value.validateSync();
	};
	
	/**
	 * Adds a discriminator to this property
	 *
	 * @param {String} name
	 * @param {Schema} schema fields to add to the schema for instances of this sub-class
	 * @api public
	 */
	
	Embedded.prototype.discriminator = function(name, schema) {
	  discriminator(this.caster, name, schema);
	
	  this.caster.discriminators[name] = _createConstructor(schema);
	  return this.caster.discriminators[name];
	};


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var PromiseProvider = __webpack_require__(14);
	var VersionError = __webpack_require__(5).VersionError;
	
	module.exports = applyHooks;
	
	/*!
	 * Register hooks for this model
	 *
	 * @param {Model} model
	 * @param {Schema} schema
	 */
	
	function applyHooks(model, schema) {
	  var q = schema && schema.callQueue;
	  var toWrapEl;
	  var len;
	  var i;
	  var j;
	  var pointCut;
	  var keys;
	  var newName;
	
	  model.$appliedHooks = true;
	  for (i = 0; i < schema.childSchemas.length; ++i) {
	    if (schema.childSchemas[i].model.$appliedHooks) {
	      continue;
	    }
	    applyHooks(schema.childSchemas[i].model, schema.childSchemas[i].schema);
	  }
	
	  if (!q.length) {
	    return;
	  }
	
	  // we are only interested in 'pre' hooks, and group by point-cut
	  var toWrap = { post: [] };
	  var pair;
	
	  for (i = 0; i < q.length; ++i) {
	    pair = q[i];
	    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {
	      continue;
	    }
	    var args = [].slice.call(pair[1]);
	    pointCut = pair[0] === 'on' ? 'post' : args[0];
	    if (!(pointCut in toWrap)) {
	      toWrap[pointCut] = {post: [], pre: []};
	    }
	    if (pair[0] === 'post') {
	      toWrap[pointCut].post.push(args);
	    } else if (pair[0] === 'on') {
	      toWrap[pointCut].push(args);
	    } else {
	      toWrap[pointCut].pre.push(args);
	    }
	  }
	
	  // 'post' hooks are simpler
	  len = toWrap.post.length;
	  toWrap.post.forEach(function(args) {
	    model.on.apply(model, args);
	  });
	  delete toWrap.post;
	
	  // 'init' should be synchronous on subdocuments
	  if (toWrap.init && (model.$isSingleNested || model.$isArraySubdocument)) {
	    if (toWrap.init.pre) {
	      toWrap.init.pre.forEach(function(args) {
	        model.prototype.$pre.apply(model.prototype, args);
	      });
	    }
	    if (toWrap.init.post) {
	      toWrap.init.post.forEach(function(args) {
	        model.prototype.$post.apply(model.prototype, args);
	      });
	    }
	    delete toWrap.init;
	  }
	  if (toWrap.set) {
	    // Set hooks also need to be sync re: gh-3479
	    newName = '$__original_set';
	    model.prototype[newName] = model.prototype.set;
	    if (toWrap.set.pre) {
	      toWrap.set.pre.forEach(function(args) {
	        model.prototype.$pre.apply(model.prototype, args);
	      });
	    }
	    if (toWrap.set.post) {
	      toWrap.set.post.forEach(function(args) {
	        model.prototype.$post.apply(model.prototype, args);
	      });
	    }
	    delete toWrap.set;
	  }
	
	  toWrap.validate = toWrap.validate || { pre: [], post: [] };
	
	  keys = Object.keys(toWrap);
	  len = keys.length;
	  for (i = 0; i < len; ++i) {
	    pointCut = keys[i];
	    // this is so we can wrap everything into a promise;
	    newName = ('$__original_' + pointCut);
	    if (!model.prototype[pointCut]) {
	      continue;
	    }
	    if (model.prototype[pointCut].$isWrapped) {
	      continue;
	    }
	    if (!model.prototype[pointCut].$originalFunction) {
	      model.prototype[newName] = model.prototype[pointCut];
	    }
	    model.prototype[pointCut] = (function(_newName) {
	      return function wrappedPointCut() {
	        var Promise = PromiseProvider.get();
	
	        var _this = this;
	        var args = [].slice.call(arguments);
	        var lastArg = args.pop();
	        var fn;
	        var originalError = new Error();
	        var $results;
	        if (lastArg && typeof lastArg !== 'function') {
	          args.push(lastArg);
	        } else {
	          fn = lastArg;
	        }
	
	        var promise = new Promise.ES6(function(resolve, reject) {
	          args.push(function(error) {
	            if (error) {
	              // gh-2633: since VersionError is very generic, take the
	              // stack trace of the original save() function call rather
	              // than the async trace
	              if (error instanceof VersionError) {
	                error.stack = originalError.stack;
	              }
	              if (!fn) {
	                _this.$__handleReject(error);
	              }
	              reject(error);
	              return;
	            }
	
	            // There may be multiple results and promise libs other than
	            // mpromise don't support passing multiple values to `resolve()`
	            $results = Array.prototype.slice.call(arguments, 1);
	            resolve.apply(promise, $results);
	          });
	
	          _this[_newName].apply(_this, args);
	        });
	        if (fn) {
	          if (this.constructor.$wrapCallback) {
	            fn = this.constructor.$wrapCallback(fn);
	          }
	          promise.then(
	            function() {
	              process.nextTick(function() {
	                fn.apply(null, [null].concat($results));
	              });
	            },
	            function(error) {
	              process.nextTick(function() {
	                fn(error);
	              });
	            });
	        }
	        return promise;
	      };
	    })(newName);
	    model.prototype[pointCut].$originalFunction = newName;
	    model.prototype[pointCut].$isWrapped = true;
	
	    toWrapEl = toWrap[pointCut];
	    var _len = toWrapEl.pre.length;
	    for (j = 0; j < _len; ++j) {
	      args = toWrapEl.pre[j];
	      args[0] = newName;
	      model.prototype.$pre.apply(model.prototype, args);
	    }
	
	    _len = toWrapEl.post.length;
	    for (j = 0; j < _len; ++j) {
	      args = toWrapEl.post[j];
	      args[0] = newName;
	      model.prototype.$post.apply(model.prototype, args);
	    }
	  }
	}


/***/ }),
/* 235 */
/***/ (function(module, exports) {

	'use strict';
	
	/*!
	 * Register methods for this model
	 *
	 * @param {Model} model
	 * @param {Schema} schema
	 */
	
	module.exports = function applyMethods(model, schema) {
	  function apply(method, schema) {
	    Object.defineProperty(model.prototype, method, {
	      get: function() {
	        var h = {};
	        for (var k in schema.methods[method]) {
	          h[k] = schema.methods[method][k].bind(this);
	        }
	        return h;
	      },
	      configurable: true
	    });
	  }
	  for (var method in schema.methods) {
	    if (schema.tree.hasOwnProperty(method)) {
	      throw new Error('You have a method and a property in your schema both ' +
	        'named "' + method + '"');
	    }
	    if (typeof schema.methods[method] === 'function') {
	      model.prototype[method] = schema.methods[method];
	    } else {
	      apply(method, schema);
	    }
	  }
	
	  // Recursively call `applyMethods()` on child schemas
	  model.$appliedMethods = true;
	  for (var i = 0; i < schema.childSchemas.length; ++i) {
	    if (schema.childSchemas[i].model.$appliedMethods) {
	      continue;
	    }
	    applyMethods(schema.childSchemas[i].model, schema.childSchemas[i].schema);
	  }
	};


/***/ }),
/* 236 */
/***/ (function(module, exports) {

	'use strict';
	
	/*!
	 * Register statics for this model
	 * @param {Model} model
	 * @param {Schema} schema
	 */
	module.exports = function applyStatics(model, schema) {
	  for (var i in schema.statics) {
	    model[i] = schema.statics[i];
	  }
	};


/***/ }),
/* 237 */
/***/ (function(module, exports) {

	'use strict';
	
	/*!
	 * ignore
	 */
	
	module.exports = function isPathSelectedInclusive(fields, path) {
	  var chunks = path.split('.');
	  var cur = '';
	  var j;
	  var keys;
	  var numKeys;
	  for (var i = 0; i < chunks.length; ++i) {
	    cur += cur.length ? '.' : '' + chunks[i];
	    if (fields[cur]) {
	      keys = Object.keys(fields);
	      numKeys = keys.length;
	      for (j = 0; j < numKeys; ++j) {
	        if (keys[i].indexOf(cur + '.') === 0 && keys[i].indexOf(path) !== 0) {
	          continue;
	        }
	      }
	      return true;
	    }
	  }
	
	  return false;
	};


/***/ }),
/* 238 */
/***/ (function(module, exports) {

	'use strict';
	
	/*!
	 * ignore
	 */
	
	module.exports = function(obj) {
	  var keys = Object.keys(obj);
	  var len = keys.length;
	  for (var i = 0; i < len; ++i) {
	    if (keys[i].charAt(0) === '$') {
	      return true;
	    }
	  }
	  return false;
	};


/***/ }),
/* 239 */
/***/ (function(module, exports) {

	'use strict';
	
	/*!
	 * ignore
	 */
	
	module.exports = function selectPopulatedFields(query) {
	  var opts = query._mongooseOptions;
	
	  if (opts.populate != null) {
	    var paths = Object.keys(opts.populate);
	    var i;
	    var userProvidedFields = query._userProvidedFields || {};
	    if (query.selectedInclusively()) {
	      for (i = 0; i < paths.length; ++i) {
	        if (userProvidedFields[paths[i]] == null) {
	          query.select(paths[i]);
	        }
	      }
	    } else if (query.selectedExclusively()) {
	      for (i = 0; i < paths.length; ++i) {
	        if (userProvidedFields[paths[i]] == null) {
	          delete query._fields[paths[i]];
	        }
	      }
	    }
	  }
	};


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var modifiedPaths = __webpack_require__(66).modifiedPaths;
	
	/**
	 * Applies defaults to update and findOneAndUpdate operations.
	 *
	 * @param {Query} query
	 * @param {Schema} schema
	 * @param {Object} castedDoc
	 * @param {Object} options
	 * @method setDefaultsOnInsert
	 * @api private
	 */
	
	module.exports = function(query, schema, castedDoc, options) {
	  var keys = Object.keys(castedDoc || {});
	  var updatedKeys = {};
	  var updatedValues = {};
	  var numKeys = keys.length;
	  var hasDollarUpdate = false;
	  var modified = {};
	
	  if (options && options.upsert) {
	    for (var i = 0; i < numKeys; ++i) {
	      if (keys[i].charAt(0) === '$') {
	        modifiedPaths(castedDoc[keys[i]], '', modified);
	        hasDollarUpdate = true;
	      }
	    }
	
	    if (!hasDollarUpdate) {
	      modifiedPaths(castedDoc, '', modified);
	    }
	
	    var paths = Object.keys(query._conditions);
	    var numPaths = paths.length;
	    for (i = 0; i < numPaths; ++i) {
	      var path = paths[i];
	      var condition = query._conditions[path];
	      if (condition && typeof condition === 'object') {
	        var conditionKeys = Object.keys(condition);
	        var numConditionKeys = conditionKeys.length;
	        var hasDollarKey = false;
	        for (var j = 0; j < numConditionKeys; ++j) {
	          if (conditionKeys[j].charAt(0) === '$') {
	            hasDollarKey = true;
	            break;
	          }
	        }
	        if (hasDollarKey) {
	          continue;
	        }
	      }
	      updatedKeys[path] = true;
	      modified[path] = true;
	    }
	
	    if (options && options.overwrite && !hasDollarUpdate) {
	      // Defaults will be set later, since we're overwriting we'll cast
	      // the whole update to a document
	      return castedDoc;
	    }
	
	    if (options.setDefaultsOnInsert) {
	      schema.eachPath(function(path, schemaType) {
	        if (path === '_id') {
	          // Ignore _id for now because it causes bugs in 2.4
	          return;
	        }
	        if (schemaType.$isSingleNested) {
	          // Only handle nested schemas 1-level deep to avoid infinite
	          // recursion re: https://github.com/mongodb-js/mongoose-autopopulate/issues/11
	          schemaType.schema.eachPath(function(_path, _schemaType) {
	            if (path === '_id') {
	              // Ignore _id for now because it causes bugs in 2.4
	              return;
	            }
	
	            var def = _schemaType.getDefault(null, true);
	            if (!isModified(modified, path + '.' + _path) &&
	                typeof def !== 'undefined') {
	              castedDoc = castedDoc || {};
	              castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};
	              castedDoc.$setOnInsert[path + '.' + _path] = def;
	              updatedValues[path + '.' + _path] = def;
	            }
	          });
	        } else {
	          var def = schemaType.getDefault(null, true);
	          if (!isModified(modified, path) && typeof def !== 'undefined') {
	            castedDoc = castedDoc || {};
	            castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};
	            castedDoc.$setOnInsert[path] = def;
	            updatedValues[path] = def;
	          }
	        }
	      });
	    }
	  }
	
	  return castedDoc;
	};
	
	function isModified(modified, path) {
	  if (modified[path]) {
	    return true;
	  }
	  var sp = path.split('.');
	  var cur = sp[0];
	  for (var i = 0; i < sp.length; ++i) {
	    if (modified[cur]) {
	      return true;
	    }
	    cur += '.' + sp[i];
	  }
	  return false;
	}


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var Mixed = __webpack_require__(64);
	var ValidationError = __webpack_require__(134);
	var parallel = __webpack_require__(114);
	var flatten = __webpack_require__(66).flatten;
	var modifiedPaths = __webpack_require__(66).modifiedPaths;
	
	/**
	 * Applies validators and defaults to update and findOneAndUpdate operations,
	 * specifically passing a null doc as `this` to validators and defaults
	 *
	 * @param {Query} query
	 * @param {Schema} schema
	 * @param {Object} castedDoc
	 * @param {Object} options
	 * @method runValidatorsOnUpdate
	 * @api private
	 */
	
	module.exports = function(query, schema, castedDoc, options) {
	  var _keys;
	  var keys = Object.keys(castedDoc || {});
	  var updatedKeys = {};
	  var updatedValues = {};
	  var arrayAtomicUpdates = {};
	  var numKeys = keys.length;
	  var hasDollarUpdate = false;
	  var modified = {};
	
	  for (var i = 0; i < numKeys; ++i) {
	    if (keys[i].charAt(0) === '$') {
	      if (keys[i] === '$push' || keys[i] === '$addToSet' ||
	          keys[i] === '$pull' || keys[i] === '$pullAll') {
	        _keys = Object.keys(castedDoc[keys[i]]);
	        for (var ii = 0; ii < _keys.length; ++ii) {
	          if (castedDoc[keys[i]][_keys[ii]].$each) {
	            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).
	              concat(castedDoc[keys[i]][_keys[ii]].$each);
	          } else {
	            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).
	              concat([castedDoc[keys[i]][_keys[ii]]]);
	          }
	        }
	        continue;
	      }
	      modifiedPaths(castedDoc[keys[i]], '', modified);
	      var flat = flatten(castedDoc[keys[i]]);
	      var paths = Object.keys(flat);
	      var numPaths = paths.length;
	      for (var j = 0; j < numPaths; ++j) {
	        var updatedPath = paths[j].replace('.$.', '.0.');
	        updatedPath = updatedPath.replace(/\.\$$/, '.0');
	        if (keys[i] === '$set' || keys[i] === '$setOnInsert') {
	          updatedValues[updatedPath] = flat[paths[j]];
	        } else if (keys[i] === '$unset') {
	          updatedValues[updatedPath] = undefined;
	        }
	        updatedKeys[updatedPath] = true;
	      }
	      hasDollarUpdate = true;
	    }
	  }
	
	  if (!hasDollarUpdate) {
	    modifiedPaths(castedDoc, '', modified);
	    updatedValues = flatten(castedDoc);
	    updatedKeys = Object.keys(updatedValues);
	  }
	
	  var updates = Object.keys(updatedValues);
	  var numUpdates = updates.length;
	  var validatorsToExecute = [];
	  var validationErrors = [];
	  function iter(i, v) {
	    var schemaPath = schema._getSchema(updates[i]);
	    if (schemaPath) {
	      // gh-4305: `_getSchema()` will report all sub-fields of a 'Mixed' path
	      // as 'Mixed', so avoid double validating them.
	      if (schemaPath instanceof Mixed && schemaPath.$fullPath !== updates[i]) {
	        return;
	      }
	      validatorsToExecute.push(function(callback) {
	        schemaPath.doValidate(
	            v,
	            function(err) {
	              if (err) {
	                err.path = updates[i];
	                validationErrors.push(err);
	              }
	              callback(null);
	            },
	            options && options.context === 'query' ? query : null,
	            {updateValidator: true});
	      });
	    }
	  }
	  for (i = 0; i < numUpdates; ++i) {
	    iter(i, updatedValues[updates[i]]);
	  }
	
	  var arrayUpdates = Object.keys(arrayAtomicUpdates);
	  var numArrayUpdates = arrayUpdates.length;
	  for (i = 0; i < numArrayUpdates; ++i) {
	    (function(i) {
	      var schemaPath = schema._getSchema(arrayUpdates[i]);
	      if (schemaPath && schemaPath.$isMongooseDocumentArray) {
	        validatorsToExecute.push(function(callback) {
	          schemaPath.doValidate(
	              arrayAtomicUpdates[arrayUpdates[i]],
	              function(err) {
	                if (err) {
	                  err.path = arrayUpdates[i];
	                  validationErrors.push(err);
	                }
	                callback(null);
	              },
	              options && options.context === 'query' ? query : null);
	        });
	      } else {
	        schemaPath = schema._getSchema(arrayUpdates[i] + '.0');
	        for (var j = 0; j < arrayAtomicUpdates[arrayUpdates[i]].length; ++j) {
	          (function(j) {
	            validatorsToExecute.push(function(callback) {
	              schemaPath.doValidate(
	                arrayAtomicUpdates[arrayUpdates[i]][j],
	                function(err) {
	                  if (err) {
	                    err.path = arrayUpdates[i];
	                    validationErrors.push(err);
	                  }
	                  callback(null);
	                },
	                options && options.context === 'query' ? query : null,
	                { updateValidator: true });
	            });
	          })(j);
	        }
	      }
	    })(i);
	  }
	
	  return function(callback) {
	    parallel(validatorsToExecute, function() {
	      if (validationErrors.length) {
	        var err = new ValidationError(null);
	        for (var i = 0; i < validationErrors.length; ++i) {
	          err.addError(validationErrors[i].path, validationErrors[i]);
	        }
	        return callback(err);
	      }
	      callback(null);
	    });
	  };
	};


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

	
	/*!
	 * Module dependencies.
	 */
	
	var utils = __webpack_require__(4);
	
	/*!
	 * StateMachine represents a minimal `interface` for the
	 * constructors it builds via StateMachine.ctor(...).
	 *
	 * @api private
	 */
	
	var StateMachine = module.exports = exports = function StateMachine() {
	};
	
	/*!
	 * StateMachine.ctor('state1', 'state2', ...)
	 * A factory method for subclassing StateMachine.
	 * The arguments are a list of states. For each state,
	 * the constructor's prototype gets state transition
	 * methods named after each state. These transition methods
	 * place their path argument into the given state.
	 *
	 * @param {String} state
	 * @param {String} [state]
	 * @return {Function} subclass constructor
	 * @private
	 */
	
	StateMachine.ctor = function() {
	  var states = utils.args(arguments);
	
	  var ctor = function() {
	    StateMachine.apply(this, arguments);
	    this.paths = {};
	    this.states = {};
	    this.stateNames = states;
	
	    var i = states.length,
	        state;
	
	    while (i--) {
	      state = states[i];
	      this.states[state] = {};
	    }
	  };
	
	  ctor.prototype = new StateMachine();
	
	  states.forEach(function(state) {
	    // Changes the `path`'s state to `state`.
	    ctor.prototype[state] = function(path) {
	      this._changeState(path, state);
	    };
	  });
	
	  return ctor;
	};
	
	/*!
	 * This function is wrapped by the state change functions:
	 *
	 * - `require(path)`
	 * - `modify(path)`
	 * - `init(path)`
	 *
	 * @api private
	 */
	
	StateMachine.prototype._changeState = function _changeState(path, nextState) {
	  var prevBucket = this.states[this.paths[path]];
	  if (prevBucket) delete prevBucket[path];
	
	  this.paths[path] = nextState;
	  this.states[nextState][path] = true;
	};
	
	/*!
	 * ignore
	 */
	
	StateMachine.prototype.clear = function clear(state) {
	  var keys = Object.keys(this.states[state]),
	      i = keys.length,
	      path;
	
	  while (i--) {
	    path = keys[i];
	    delete this.states[state][path];
	    delete this.paths[path];
	  }
	};
	
	/*!
	 * Checks to see if at least one path is in the states passed in via `arguments`
	 * e.g., this.some('required', 'inited')
	 *
	 * @param {String} state that we want to check for.
	 * @private
	 */
	
	StateMachine.prototype.some = function some() {
	  var _this = this;
	  var what = arguments.length ? arguments : this.stateNames;
	  return Array.prototype.some.call(what, function(state) {
	    return Object.keys(_this.states[state]).length;
	  });
	};
	
	/*!
	 * This function builds the functions that get assigned to `forEach` and `map`,
	 * since both of those methods share a lot of the same logic.
	 *
	 * @param {String} iterMethod is either 'forEach' or 'map'
	 * @return {Function}
	 * @api private
	 */
	
	StateMachine.prototype._iter = function _iter(iterMethod) {
	  return function() {
	    var numArgs = arguments.length,
	        states = utils.args(arguments, 0, numArgs - 1),
	        callback = arguments[numArgs - 1];
	
	    if (!states.length) states = this.stateNames;
	
	    var _this = this;
	
	    var paths = states.reduce(function(paths, state) {
	      return paths.concat(Object.keys(_this.states[state]));
	    }, []);
	
	    return paths[iterMethod](function(path, i, paths) {
	      return callback(path, i, paths);
	    });
	  };
	};
	
	/*!
	 * Iterates over the paths that belong to one of the parameter states.
	 *
	 * The function profile can look like:
	 * this.forEach(state1, fn);         // iterates over all paths in state1
	 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
	 * this.forEach(fn);                 // iterates over all paths in all states
	 *
	 * @param {String} [state]
	 * @param {String} [state]
	 * @param {Function} callback
	 * @private
	 */
	
	StateMachine.prototype.forEach = function forEach() {
	  this.forEach = this._iter('forEach');
	  return this.forEach.apply(this, arguments);
	};
	
	/*!
	 * Maps over the paths that belong to one of the parameter states.
	 *
	 * The function profile can look like:
	 * this.forEach(state1, fn);         // iterates over all paths in state1
	 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
	 * this.forEach(fn);                 // iterates over all paths in all states
	 *
	 * @param {String} [state]
	 * @param {String} [state]
	 * @param {Function} callback
	 * @return {Array}
	 * @private
	 */
	
	StateMachine.prototype.map = function map() {
	  this.map = this._iter('map');
	  return this.map.apply(this, arguments);
	};


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * Module dependencies.
	 */
	
	var Binary = __webpack_require__(29).Binary,
	    utils = __webpack_require__(4);
	
	/**
	 * Mongoose Buffer constructor.
	 *
	 * Values always have to be passed to the constructor to initialize.
	 *
	 * @param {Buffer} value
	 * @param {String} encode
	 * @param {Number} offset
	 * @api private
	 * @inherits Buffer
	 * @see http://bit.ly/f6CnZU
	 */
	
	function MongooseBuffer(value, encode, offset) {
	  var length = arguments.length;
	  var val;
	
	  if (length === 0 || arguments[0] === null || arguments[0] === undefined) {
	    val = 0;
	  } else {
	    val = value;
	  }
	
	  var encoding;
	  var path;
	  var doc;
	
	  if (Array.isArray(encode)) {
	    // internal casting
	    path = encode[0];
	    doc = encode[1];
	  } else {
	    encoding = encode;
	  }
	
	  var buf = new Buffer(val, encoding, offset);
	  utils.decorate(buf, MongooseBuffer.mixin);
	  buf.isMongooseBuffer = true;
	
	  // make sure these internal props don't show up in Object.keys()
	  Object.defineProperties(buf, {
	    validators: {value: []},
	    _path: {value: path},
	    _parent: {value: doc}
	  });
	
	  if (doc && typeof path === 'string') {
	    Object.defineProperty(buf, '_schema', {
	      value: doc.schema.path(path)
	    });
	  }
	
	  buf._subtype = 0;
	  return buf;
	}
	
	/*!
	 * Inherit from Buffer.
	 */
	
	// MongooseBuffer.prototype = new Buffer(0);
	
	MongooseBuffer.mixin = {
	
	  /**
	   * Parent owner document
	   *
	   * @api private
	   * @property _parent
	   * @receiver MongooseBuffer
	   */
	
	  _parent: undefined,
	
	  /**
	   * Default subtype for the Binary representing this Buffer
	   *
	   * @api private
	   * @property _subtype
	   * @receiver MongooseBuffer
	   */
	
	  _subtype: undefined,
	
	  /**
	   * Marks this buffer as modified.
	   *
	   * @api private
	   * @method _markModified
	   * @receiver MongooseBuffer
	   */
	
	  _markModified: function() {
	    var parent = this._parent;
	
	    if (parent) {
	      parent.markModified(this._path);
	    }
	    return this;
	  },
	
	  /**
	   * Writes the buffer.
	   *
	   * @api public
	   * @method write
	   * @receiver MongooseBuffer
	   */
	
	  write: function() {
	    var written = Buffer.prototype.write.apply(this, arguments);
	
	    if (written > 0) {
	      this._markModified();
	    }
	
	    return written;
	  },
	
	  /**
	   * Copies the buffer.
	   *
	   * ####Note:
	   *
	   * `Buffer#copy` does not mark `target` as modified so you must copy from a `MongooseBuffer` for it to work as expected. This is a work around since `copy` modifies the target, not this.
	   *
	   * @return {Number} The number of bytes copied.
	   * @param {Buffer} target
	   * @method copy
	   * @receiver MongooseBuffer
	   */
	
	  copy: function(target) {
	    var ret = Buffer.prototype.copy.apply(this, arguments);
	
	    if (target && target.isMongooseBuffer) {
	      target._markModified();
	    }
	
	    return ret;
	  }
	};
	
	/*!
	 * Compile other Buffer methods marking this buffer as modified.
	 */
	
	(
	// node < 0.5
	    'writeUInt8 writeUInt16 writeUInt32 writeInt8 writeInt16 writeInt32 ' +
	    'writeFloat writeDouble fill ' +
	    'utf8Write binaryWrite asciiWrite set ' +
	
	// node >= 0.5
	    'writeUInt16LE writeUInt16BE writeUInt32LE writeUInt32BE ' +
	    'writeInt16LE writeInt16BE writeInt32LE writeInt32BE ' +
	    'writeFloatLE writeFloatBE writeDoubleLE writeDoubleBE'
	).split(' ').forEach(function(method) {
	  if (!Buffer.prototype[method]) {
	    return;
	  }
	  MongooseBuffer.mixin[method] = function() {
	    var ret = Buffer.prototype[method].apply(this, arguments);
	    this._markModified();
	    return ret;
	  };
	});
	
	/**
	 * Converts this buffer to its Binary type representation.
	 *
	 * ####SubTypes:
	 *
	 *   var bson = require('bson')
	 *   bson.BSON_BINARY_SUBTYPE_DEFAULT
	 *   bson.BSON_BINARY_SUBTYPE_FUNCTION
	 *   bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY
	 *   bson.BSON_BINARY_SUBTYPE_UUID
	 *   bson.BSON_BINARY_SUBTYPE_MD5
	 *   bson.BSON_BINARY_SUBTYPE_USER_DEFINED
	 *
	 *   doc.buffer.toObject(bson.BSON_BINARY_SUBTYPE_USER_DEFINED);
	 *
	 * @see http://bsonspec.org/#/specification
	 * @param {Hex} [subtype]
	 * @return {Binary}
	 * @api public
	 * @method toObject
	 * @receiver MongooseBuffer
	 */
	
	MongooseBuffer.mixin.toObject = function(options) {
	  var subtype = typeof options === 'number'
	      ? options
	      : (this._subtype || 0);
	  return new Binary(this, subtype);
	};
	
	/**
	 * Converts this buffer for storage in MongoDB, including subtype
	 *
	 * @return {Binary}
	 * @api public
	 * @method toBSON
	 * @receiver MongooseBuffer
	 */
	
	MongooseBuffer.mixin.toBSON = function() {
	  return new Binary(this, this._subtype || 0);
	};
	
	/**
	 * Determines if this buffer is equals to `other` buffer
	 *
	 * @param {Buffer} other
	 * @return {Boolean}
	 * @method equals
	 * @receiver MongooseBuffer
	 */
	
	MongooseBuffer.mixin.equals = function(other) {
	  if (!Buffer.isBuffer(other)) {
	    return false;
	  }
	
	  if (this.length !== other.length) {
	    return false;
	  }
	
	  for (var i = 0; i < this.length; ++i) {
	    if (this[i] !== other[i]) {
	      return false;
	    }
	  }
	
	  return true;
	};
	
	/**
	 * Sets the subtype option and marks the buffer modified.
	 *
	 * ####SubTypes:
	 *
	 *   var bson = require('bson')
	 *   bson.BSON_BINARY_SUBTYPE_DEFAULT
	 *   bson.BSON_BINARY_SUBTYPE_FUNCTION
	 *   bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY
	 *   bson.BSON_BINARY_SUBTYPE_UUID
	 *   bson.BSON_BINARY_SUBTYPE_MD5
	 *   bson.BSON_BINARY_SUBTYPE_USER_DEFINED
	 *
	 *   doc.buffer.subtype(bson.BSON_BINARY_SUBTYPE_UUID);
	 *
	 * @see http://bsonspec.org/#/specification
	 * @param {Hex} subtype
	 * @api public
	 * @method subtype
	 * @receiver MongooseBuffer
	 */
	
	MongooseBuffer.mixin.subtype = function(subtype) {
	  if (typeof subtype !== 'number') {
	    throw new TypeError('Invalid subtype. Expected a number');
	  }
	
	  if (this._subtype !== subtype) {
	    this._markModified();
	  }
	
	  this._subtype = subtype;
	};
	
	/*!
	 * Module exports.
	 */
	
	MongooseBuffer.Binary = Binary;
	
	module.exports = MongooseBuffer;


/***/ }),
/* 244 */
/***/ (function(module, exports) {

	/**
	 * Returns the value of object `o` at the given `path`.
	 *
	 * ####Example:
	 *
	 *     var obj = {
	 *         comments: [
	 *             { title: 'exciting!', _doc: { title: 'great!' }}
	 *           , { title: 'number dos' }
	 *         ]
	 *     }
	 *
	 *     mpath.get('comments.0.title', o)         // 'exciting!'
	 *     mpath.get('comments.0.title', o, '_doc') // 'great!'
	 *     mpath.get('comments.title', o)           // ['exciting!', 'number dos']
	 *
	 *     // summary
	 *     mpath.get(path, o)
	 *     mpath.get(path, o, special)
	 *     mpath.get(path, o, map)
	 *     mpath.get(path, o, special, map)
	 *
	 * @param {String} path
	 * @param {Object} o
	 * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.
	 * @param {Function} [map] Optional function which receives each individual found value. The value returned from `map` is used in the original values place.
	 */
	
	exports.get = function (path, o, special, map) {
	  var lookup;
	
	  if ('function' == typeof special) {
	    if (special.length < 2) {
	      map = special;
	      special = undefined;
	    } else {
	      lookup = special;
	      special = undefined;
	    }
	  }
	
	  map || (map = K);
	
	  var parts = 'string' == typeof path
	    ? path.split('.')
	    : path
	
	  if (!Array.isArray(parts)) {
	    throw new TypeError('Invalid `path`. Must be either string or array');
	  }
	
	  var obj = o
	    , part;
	
	  for (var i = 0; i < parts.length; ++i) {
	    part = parts[i];
	
	    if (Array.isArray(obj) && !/^\d+$/.test(part)) {
	      // reading a property from the array items
	      var paths = parts.slice(i);
	
	      return obj.map(function (item) {
	        return item
	          ? exports.get(paths, item, special || lookup, map)
	          : map(undefined);
	      });
	    }
	
	    if (lookup) {
	      obj = lookup(obj, part);
	    } else {
	      obj = special && obj[special]
	        ? obj[special][part]
	        : obj[part];
	    }
	
	    if (!obj) return map(obj);
	  }
	
	  return map(obj);
	};
	
	/**
	 * Returns true if `in` returns true for every piece of the path
	 *
	 * @param {String} path
	 * @param {Object} o
	 */
	
	exports.has = function (path, o) {
	  var parts = typeof path === 'string' ?
	    path.split('.') :
	    path;
	
	  if (!Array.isArray(parts)) {
	    throw new TypeError('Invalid `path`. Must be either string or array');
	  }
	
	  var len = parts.length;
	  var cur = o;
	  for (var i = 0; i < len; ++i) {
	    if (cur == null || typeof cur !== 'object' || !(parts[i] in cur)) {
	      return false;
	    }
	    cur = cur[parts[i]];
	  }
	
	  return true;
	};
	
	/**
	 * Deletes the last piece of `path`
	 *
	 * @param {String} path
	 * @param {Object} o
	 */
	
	exports.unset = function (path, o) {
	  var parts = typeof path === 'string' ?
	    path.split('.') :
	    path;
	
	  if (!Array.isArray(parts)) {
	    throw new TypeError('Invalid `path`. Must be either string or array');
	  }
	
	  var len = parts.length;
	  var cur = o;
	  for (var i = 0; i < len; ++i) {
	    if (cur == null || typeof cur !== 'object' || !(parts[i] in cur)) {
	      return false;
	    }
	    if (i === len - 1) {
	      delete cur[parts[i]];
	      return true;
	    }
	    cur = cur[parts[i]];
	  }
	
	  return true;
	};
	
	/**
	 * Sets the `val` at the given `path` of object `o`.
	 *
	 * @param {String} path
	 * @param {Anything} val
	 * @param {Object} o
	 * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.
	 * @param {Function} [map] Optional function which is passed each individual value before setting it. The value returned from `map` is used in the original values place.
	 */
	
	exports.set = function (path, val, o, special, map, _copying) {
	  var lookup;
	
	  if ('function' == typeof special) {
	    if (special.length < 2) {
	      map = special;
	      special = undefined;
	    } else {
	      lookup = special;
	      special = undefined;
	    }
	  }
	
	  map || (map = K);
	
	  var parts = 'string' == typeof path
	    ? path.split('.')
	    : path
	
	  if (!Array.isArray(parts)) {
	    throw new TypeError('Invalid `path`. Must be either string or array');
	  }
	
	  if (null == o) return;
	
	  // the existance of $ in a path tells us if the user desires
	  // the copying of an array instead of setting each value of
	  // the array to the one by one to matching positions of the
	  // current array.
	  var copy = _copying || /\$/.test(path)
	    , obj = o
	    , part
	
	  for (var i = 0, len = parts.length - 1; i < len; ++i) {
	    part = parts[i];
	
	    if ('$' == part) {
	      if (i == len - 1) {
	        break;
	      } else {
	        continue;
	      }
	    }
	
	    if (Array.isArray(obj) && !/^\d+$/.test(part)) {
	      var paths = parts.slice(i);
	      if (!copy && Array.isArray(val)) {
	        for (var j = 0; j < obj.length && j < val.length; ++j) {
	          // assignment of single values of array
	          exports.set(paths, val[j], obj[j], special || lookup, map, copy);
	        }
	      } else {
	        for (var j = 0; j < obj.length; ++j) {
	          // assignment of entire value
	          exports.set(paths, val, obj[j], special || lookup, map, copy);
	        }
	      }
	      return;
	    }
	
	    if (lookup) {
	      obj = lookup(obj, part);
	    } else {
	      obj = special && obj[special]
	        ? obj[special][part]
	        : obj[part];
	    }
	
	    if (!obj) return;
	  }
	
	  // process the last property of the path
	
	  part = parts[len];
	
	  // use the special property if exists
	  if (special && obj[special]) {
	    obj = obj[special];
	  }
	
	  // set the value on the last branch
	  if (Array.isArray(obj) && !/^\d+$/.test(part)) {
	    if (!copy && Array.isArray(val)) {
	      for (var item, j = 0; j < obj.length && j < val.length; ++j) {
	        item = obj[j];
	        if (item) {
	          if (lookup) {
	            lookup(item, part, map(val[j]));
	          } else {
	            if (item[special]) item = item[special];
	            item[part] = map(val[j]);
	          }
	        }
	      }
	    } else {
	      for (var j = 0; j < obj.length; ++j) {
	        item = obj[j];
	        if (item) {
	          if (lookup) {
	            lookup(item, part, map(val));
	          } else {
	            if (item[special]) item = item[special];
	            item[part] = map(val);
	          }
	        }
	      }
	    }
	  } else {
	    if (lookup) {
	      lookup(obj, part, map(val));
	    } else {
	      obj[part] = map(val);
	    }
	  }
	}
	
	/*!
	 * Returns the value passed to it.
	 */
	
	function K (v) {
	  return v;
	}


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var util = __webpack_require__(1);
	var EventEmitter = __webpack_require__(6).EventEmitter;
	function toArray(arr, start, end) {
	  return Array.prototype.slice.call(arr, start, end)
	}
	function strongUnshift(x, arrLike) {
	  var arr = toArray(arrLike);
	  arr.unshift(x);
	  return arr;
	}
	
	
	/**
	 * MPromise constructor.
	 *
	 * _NOTE: The success and failure event names can be overridden by setting `Promise.SUCCESS` and `Promise.FAILURE` respectively._
	 *
	 * @param {Function} back a function that accepts `fn(err, ...){}` as signature
	 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
	 * @event `reject`: Emits when the promise is rejected (event name may be overridden)
	 * @event `fulfill`: Emits when the promise is fulfilled (event name may be overridden)
	 * @api public
	 */
	function Promise(back) {
	  this.emitter = new EventEmitter();
	  this.emitted = {};
	  this.ended = false;
	  if ('function' == typeof back) {
	    this.ended = true;
	    this.onResolve(back);
	  }
	}
	
	
	/*
	 * Module exports.
	 */
	module.exports = Promise;
	
	
	/*!
	 * event names
	 */
	Promise.SUCCESS = 'fulfill';
	Promise.FAILURE = 'reject';
	
	
	/**
	 * Adds `listener` to the `event`.
	 *
	 * If `event` is either the success or failure event and the event has already been emitted, the`listener` is called immediately and passed the results of the original emitted event.
	 *
	 * @param {String} event
	 * @param {Function} callback
	 * @return {MPromise} this
	 * @api private
	 */
	Promise.prototype.on = function (event, callback) {
	  if (this.emitted[event])
	    callback.apply(undefined, this.emitted[event]);
	  else
	    this.emitter.on(event, callback);
	
	  return this;
	};
	
	
	/**
	 * Keeps track of emitted events to run them on `on`.
	 *
	 * @api private
	 */
	Promise.prototype.safeEmit = function (event) {
	  // ensures a promise can't be fulfill() or reject() more than once
	  if (event == Promise.SUCCESS || event == Promise.FAILURE) {
	    if (this.emitted[Promise.SUCCESS] || this.emitted[Promise.FAILURE]) {
	      return this;
	    }
	    this.emitted[event] = toArray(arguments, 1);
	  }
	
	  this.emitter.emit.apply(this.emitter, arguments);
	  return this;
	};
	
	
	/**
	 * @api private
	 */
	Promise.prototype.hasRejectListeners = function () {
	  return EventEmitter.listenerCount(this.emitter, Promise.FAILURE) > 0;
	};
	
	
	/**
	 * Fulfills this promise with passed arguments.
	 *
	 * If this promise has already been fulfilled or rejected, no action is taken.
	 *
	 * @api public
	 */
	Promise.prototype.fulfill = function () {
	  return this.safeEmit.apply(this, strongUnshift(Promise.SUCCESS, arguments));
	};
	
	
	/**
	 * Rejects this promise with `reason`.
	 *
	 * If this promise has already been fulfilled or rejected, no action is taken.
	 *
	 * @api public
	 * @param {Object|String} reason
	 * @return {MPromise} this
	 */
	Promise.prototype.reject = function (reason) {
	  if (this.ended && !this.hasRejectListeners())
	    throw reason;
	  return this.safeEmit(Promise.FAILURE, reason);
	};
	
	
	/**
	 * Resolves this promise to a rejected state if `err` is passed or
	 * fulfilled state if no `err` is passed.
	 *
	 * @param {Error} [err] error or null
	 * @param {Object} [val] value to fulfill the promise with
	 * @api public
	 */
	Promise.prototype.resolve = function (err, val) {
	  if (err) return this.reject(err);
	  return this.fulfill(val);
	};
	
	
	/**
	 * Adds a listener to the SUCCESS event.
	 *
	 * @return {MPromise} this
	 * @api public
	 */
	Promise.prototype.onFulfill = function (fn) {
	  if (!fn) return this;
	  if ('function' != typeof fn) throw new TypeError("fn should be a function");
	  return this.on(Promise.SUCCESS, fn);
	};
	
	
	/**
	 * Adds a listener to the FAILURE event.
	 *
	 * @return {MPromise} this
	 * @api public
	 */
	Promise.prototype.onReject = function (fn) {
	  if (!fn) return this;
	  if ('function' != typeof fn) throw new TypeError("fn should be a function");
	  return this.on(Promise.FAILURE, fn);
	};
	
	
	/**
	 * Adds a single function as a listener to both SUCCESS and FAILURE.
	 *
	 * It will be executed with traditional node.js argument position:
	 * function (err, args...) {}
	 *
	 * Also marks the promise as `end`ed, since it's the common use-case, and yet has no
	 * side effects unless `fn` is undefined or null.
	 *
	 * @param {Function} fn
	 * @return {MPromise} this
	 */
	Promise.prototype.onResolve = function (fn) {
	  if (!fn) return this;
	  if ('function' != typeof fn) throw new TypeError("fn should be a function");
	  this.on(Promise.FAILURE, function (err) { fn.call(this, err); });
	  this.on(Promise.SUCCESS, function () { fn.apply(this, strongUnshift(null, arguments)); });
	  return this;
	};
	
	
	/**
	 * Creates a new promise and returns it. If `onFulfill` or
	 * `onReject` are passed, they are added as SUCCESS/ERROR callbacks
	 * to this promise after the next tick.
	 *
	 * Conforms to [promises/A+](https://github.com/promises-aplus/promises-spec) specification. Read for more detail how to use this method.
	 *
	 * ####Example:
	 *
	 *     var p = new Promise;
	 *     p.then(function (arg) {
	 *       return arg + 1;
	 *     }).then(function (arg) {
	 *       throw new Error(arg + ' is an error!');
	 *     }).then(null, function (err) {
	 *       assert.ok(err instanceof Error);
	 *       assert.equal('2 is an error', err.message);
	 *     });
	 *     p.complete(1);
	 *
	 * @see promises-A+ https://github.com/promises-aplus/promises-spec
	 * @param {Function} onFulfill
	 * @param {Function} [onReject]
	 * @return {MPromise} newPromise
	 */
	Promise.prototype.then = function (onFulfill, onReject) {
	  var newPromise = new Promise;
	
	  if ('function' == typeof onFulfill) {
	    this.onFulfill(handler(newPromise, onFulfill));
	  } else {
	    this.onFulfill(newPromise.fulfill.bind(newPromise));
	  }
	
	  if ('function' == typeof onReject) {
	    this.onReject(handler(newPromise, onReject));
	  } else {
	    this.onReject(newPromise.reject.bind(newPromise));
	  }
	
	  return newPromise;
	};
	
	
	function handler(promise, fn) {
	  function newTickHandler() {
	    var pDomain = promise.emitter.domain;
	    if (pDomain && pDomain !== process.domain) pDomain.enter();
	    try {
	      var x = fn.apply(undefined, boundHandler.args);
	    } catch (err) {
	      promise.reject(err);
	      return;
	    }
	    resolve(promise, x);
	  }
	  function boundHandler() {
	    boundHandler.args = arguments;
	    process.nextTick(newTickHandler);
	  }
	  return boundHandler;
	}
	
	
	function resolve(promise, x) {
	  function fulfillOnce() {
	    if (done++) return;
	    resolve.apply(undefined, strongUnshift(promise, arguments));
	  }
	  function rejectOnce(reason) {
	    if (done++) return;
	    promise.reject(reason);
	  }
	
	  if (promise === x) {
	    promise.reject(new TypeError("promise and x are the same"));
	    return;
	  }
	  var rest = toArray(arguments, 1);
	  var type = typeof x;
	  if ('undefined' == type || null == x || !('object' == type || 'function' == type)) {
	    promise.fulfill.apply(promise, rest);
	    return;
	  }
	
	  try {
	    var theThen = x.then;
	  } catch (err) {
	    promise.reject(err);
	    return;
	  }
	
	  if ('function' != typeof theThen) {
	    promise.fulfill.apply(promise, rest);
	    return;
	  }
	
	  var done = 0;
	  try {
	    var ret = theThen.call(x, fulfillOnce, rejectOnce);
	    return ret;
	  } catch (err) {
	    if (done++) return;
	    promise.reject(err);
	  }
	}
	
	
	/**
	 * Signifies that this promise was the last in a chain of `then()s`: if a handler passed to the call to `then` which produced this promise throws, the exception will go uncaught.
	 *
	 * ####Example:
	 *
	 *     var p = new Promise;
	 *     p.then(function(){ throw new Error('shucks') });
	 *     setTimeout(function () {
	 *       p.fulfill();
	 *       // error was caught and swallowed by the promise returned from
	 *       // p.then(). we either have to always register handlers on
	 *       // the returned promises or we can do the following...
	 *     }, 10);
	 *
	 *     // this time we use .end() which prevents catching thrown errors
	 *     var p = new Promise;
	 *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--
	 *     setTimeout(function () {
	 *       p.fulfill(); // throws "shucks"
	 *     }, 10);
	 *
	 * @api public
	 * @param {Function} [onReject]
	 * @return {MPromise} this
	 */
	Promise.prototype.end = Promise.prototype['catch'] = function (onReject) {
	  if (!onReject && !this.hasRejectListeners())
	    onReject = function idRejector(e) { throw e; };
	  this.onReject(onReject);
	  this.ended = true;
	  return this;
	};
	
	
	/**
	 * A debug utility function that adds handlers to a promise that will log some output to the `console`
	 *
	 * ####Example:
	 *
	 *     var p = new Promise;
	 *     p.then(function(){ throw new Error('shucks') });
	 *     setTimeout(function () {
	 *       p.fulfill();
	 *       // error was caught and swallowed by the promise returned from
	 *       // p.then(). we either have to always register handlers on
	 *       // the returned promises or we can do the following...
	 *     }, 10);
	 *
	 *     // this time we use .end() which prevents catching thrown errors
	 *     var p = new Promise;
	 *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--
	 *     setTimeout(function () {
	 *       p.fulfill(); // throws "shucks"
	 *     }, 10);
	 *
	 * @api public
	 * @param {MPromise} p
	 * @param {String} name
	 * @return {MPromise} this
	 */
	Promise.trace = function (p, name) {
	  p.then(
	    function () {
	      console.log("%s fulfill %j", name, toArray(arguments));
	    },
	    function () {
	      console.log("%s reject %j", name, toArray(arguments));
	    }
	  )
	};
	
	
	Promise.prototype.chain = function (p2) {
	  var p1 = this;
	  p1.onFulfill(p2.fulfill.bind(p2));
	  p1.onReject(p2.reject.bind(p2));
	  return p2;
	};
	
	
	Promise.prototype.all = function (promiseOfArr) {
	  var pRet = new Promise;
	  this.then(promiseOfArr).then(
	    function (promiseArr) {
	      var count = 0;
	      var ret = [];
	      var errSentinel;
	      if (!promiseArr.length) pRet.resolve();
	      promiseArr.forEach(function (promise, index) {
	        if (errSentinel) return;
	        count++;
	        promise.then(
	          function (val) {
	            if (errSentinel) return;
	            ret[index] = val;
	            --count;
	            if (count == 0) pRet.fulfill(ret);
	          },
	          function (err) {
	            if (errSentinel) return;
	            errSentinel = err;
	            pRet.reject(err);
	          }
	        );
	      });
	      return pRet;
	    }
	    , pRet.reject.bind(pRet)
	  );
	  return pRet;
	};
	
	
	Promise.hook = function (arr) {
	  var p1 = new Promise;
	  var pFinal = new Promise;
	  var signalP = function () {
	    --count;
	    if (count == 0)
	      pFinal.fulfill();
	    return pFinal;
	  };
	  var count = 1;
	  var ps = p1;
	  arr.forEach(function (hook) {
	    ps = ps.then(
	      function () {
	        var p = new Promise;
	        count++;
	        hook(p.resolve.bind(p), signalP);
	        return p;
	      }
	    )
	  });
	  ps = ps.then(signalP);
	  p1.resolve();
	  return ps;
	};
	
	
	/* This is for the A+ tests, but it's very useful as well */
	Promise.fulfilled = function fulfilled() { var p = new Promise; p.fulfill.apply(p, arguments); return p; };
	Promise.rejected = function rejected(reason) { return new Promise().reject(reason); };
	Promise.deferred = function deferred() {
	  var p = new Promise;
	  return {
	    promise: p,
	    reject: p.reject.bind(p),
	    resolve: p.fulfill.bind(p),
	    callback: p.resolve.bind(p)
	  }
	};
	/* End A+ tests adapter bit */


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var env = __webpack_require__(148)
	
	if ('unknown' == env.type) {
	  throw new Error('Unknown environment')
	}
	
	module.exports =
	  env.isNode ? __webpack_require__(247) :
	  env.isMongo ? __webpack_require__(68) :
	  __webpack_require__(68);
	


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Module dependencies
	 */
	
	var Collection = __webpack_require__(68);
	var utils = __webpack_require__(149);
	
	function NodeCollection (col) {
	  this.collection = col;
	  this.collectionName = col.collectionName;
	}
	
	/**
	 * inherit from collection base class
	 */
	
	utils.inherits(NodeCollection, Collection);
	
	/**
	 * find(match, options, function(err, docs))
	 */
	
	NodeCollection.prototype.find = function (match, options, cb) {
	  this.collection.find(match, options, function (err, cursor) {
	    if (err) return cb(err);
	
	    cursor.toArray(cb);
	  });
	}
	
	/**
	 * findOne(match, options, function(err, doc))
	 */
	
	NodeCollection.prototype.findOne = function (match, options, cb) {
	  this.collection.findOne(match, options, cb);
	}
	
	/**
	 * count(match, options, function(err, count))
	 */
	
	NodeCollection.prototype.count = function (match, options, cb) {
	  this.collection.count(match, options, cb);
	}
	
	/**
	 * distinct(prop, match, options, function(err, count))
	 */
	
	NodeCollection.prototype.distinct  = function (prop, match, options, cb) {
	  this.collection.distinct(prop, match, options, cb);
	}
	
	/**
	 * update(match, update, options, function(err[, result]))
	 */
	
	NodeCollection.prototype.update = function (match, update, options, cb) {
	  this.collection.update(match, update, options, cb);
	}
	
	/**
	 * update(match, update, options, function(err[, result]))
	 */
	
	NodeCollection.prototype.updateMany = function (match, update, options, cb) {
	  this.collection.updateMany(match, update, options, cb);
	}
	
	/**
	 * update(match, update, options, function(err[, result]))
	 */
	
	NodeCollection.prototype.updateOne = function (match, update, options, cb) {
	  this.collection.updateOne(match, update, options, cb);
	}
	
	/**
	 * replaceOne(match, update, options, function(err[, result]))
	 */
	
	NodeCollection.prototype.replaceOne = function (match, update, options, cb) {
	  this.collection.replaceOne(match, update, options, cb);
	}
	
	/**
	 * deleteOne(match, options, function(err[, result])
	 */
	
	NodeCollection.prototype.deleteOne = function (match, options, cb) {
	  this.collection.deleteOne(match, options, cb);
	}
	
	/**
	 * deleteMany(match, options, function(err[, result])
	 */
	
	NodeCollection.prototype.deleteMany = function (match, options, cb) {
	  this.collection.deleteMany(match, options, cb);
	}
	
	/**
	 * remove(match, options, function(err[, result])
	 */
	
	NodeCollection.prototype.remove = function (match, options, cb) {
	  this.collection.remove(match, options, cb);
	}
	
	/**
	 * findAndModify(match, update, options, function(err, doc))
	 */
	
	NodeCollection.prototype.findAndModify = function (match, update, options, cb) {
	  var sort = Array.isArray(options.sort) ? options.sort : [];
	  this.collection.findAndModify(match, sort, update, options, cb);
	}
	
	/**
	 * var stream = findStream(match, findOptions, streamOptions)
	 */
	
	NodeCollection.prototype.findStream = function(match, findOptions, streamOptions) {
	  return this.collection.find(match, findOptions);
	}
	
	/**
	 * var cursor = findCursor(match, findOptions)
	 */
	
	NodeCollection.prototype.findCursor = function(match, findOptions) {
	  return this.collection.find(match, findOptions);
	}
	
	/**
	 * aggregation(operators..., function(err, doc))
	 * TODO
	 */
	
	/**
	 * Expose
	 */
	
	module.exports = exports = NodeCollection;


/***/ }),
/* 248 */
/***/ (function(module, exports) {

	'use strict';
	
	var denied = exports;
	
	denied.distinct = function (self) {
	  if (self._fields && Object.keys(self._fields).length > 0) {
	    return 'field selection and slice'
	  }
	
	  var keys = Object.keys(denied.distinct);
	  var err;
	
	  keys.every(function (option) {
	    if (self.options[option]) {
	      err = option;
	      return false;
	    }
	    return true;
	  });
	
	  return err;
	};
	denied.distinct.select =
	denied.distinct.slice =
	denied.distinct.sort =
	denied.distinct.limit =
	denied.distinct.skip =
	denied.distinct.batchSize =
	denied.distinct.comment =
	denied.distinct.maxScan =
	denied.distinct.snapshot =
	denied.distinct.hint =
	denied.distinct.tailable = true;
	
	
	// aggregation integration
	
	
	denied.findOneAndUpdate =
	denied.findOneAndRemove = function (self) {
	  var keys = Object.keys(denied.findOneAndUpdate);
	  var err;
	
	  keys.every(function (option) {
	    if (self.options[option]) {
	      err = option;
	      return false;
	    }
	    return true;
	  });
	
	  return err;
	}
	denied.findOneAndUpdate.limit =
	denied.findOneAndUpdate.skip =
	denied.findOneAndUpdate.batchSize =
	denied.findOneAndUpdate.maxScan =
	denied.findOneAndUpdate.snapshot =
	denied.findOneAndUpdate.hint =
	denied.findOneAndUpdate.tailable =
	denied.findOneAndUpdate.comment = true;
	
	
	denied.count = function (self) {
	  if (self._fields && Object.keys(self._fields).length > 0) {
	    return 'field selection and slice'
	  }
	
	  var keys = Object.keys(denied.count);
	  var err;
	
	  keys.every(function (option) {
	    if (self.options[option]) {
	      err = option;
	      return false;
	    }
	    return true;
	  });
	
	  return err;
	}
	
	denied.count.slice =
	denied.count.batchSize =
	denied.count.comment =
	denied.count.maxScan =
	denied.count.snapshot =
	denied.count.tailable = true;


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = exports = __webpack_require__(250);


/***/ }),
/* 250 */
/***/ (function(module, exports) {

	
	/**
	 * An Array.prototype.slice.call(arguments) alternative
	 *
	 * @param {Object} args something with a length
	 * @param {Number} slice
	 * @param {Number} sliceEnd
	 * @api public
	 */
	
	module.exports = function (args, slice, sliceEnd) {
	  var ret = [];
	  var len = args.length;
	
	  if (0 === len) return ret;
	
	  var start = slice < 0
	    ? Math.max(0, slice + len)
	    : slice || 0;
	
	  if (sliceEnd !== undefined) {
	    len = sliceEnd < 0
	      ? sliceEnd + len
	      : sliceEnd
	  }
	
	  while (len-- > start) {
	    ret[len - start] = args[len];
	  }
	
	  return ret;
	}
	


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = exports = __webpack_require__(252);


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

	// muri
	
	/**
	 * MongoDB URI parser as described here:
	 * http://www.mongodb.org/display/DOCS/Connections
	 */
	
	/**
	 * Module dependencies
	 */
	
	var qs = __webpack_require__(155);
	
	/**
	 * Defaults
	 */
	
	var DEFAULT_PORT = 27017;
	var DEFAULT_DB = 'test';
	var ADMIN_DB = 'admin';
	
	/**
	 * Muri
	 */
	
	module.exports = exports = function muri (str) {
	  if (!/^mongodb:\/\//.test(str)) {
	    throw new Error('Invalid mongodb uri. Must begin with "mongodb://"'
	                  + '\n  Received: ' + str);
	  }
	
	  var ret = {
	      hosts: []
	    , db: DEFAULT_DB
	    , options: {}
	  }
	
	  var match = /^mongodb:\/\/([^?]+)(\??.*)$/.exec(str);
	  if (!match || '/' == match[1]) {
	    throw new Error('Invalid mongodb uri. Missing hostname');
	  }
	
	  var uris = match[1];
	  var path = match[2];
	  var db;
	
	  uris.split(',').forEach(function (uri) {
	    var o = parse(uri);
	
	    if (o.host) {
	      ret.hosts.push({
	          host: o.host
	        , port: parseInt(o.port, 10)
	      })
	
	      if (!db && o.db) {
	        db = o.db;
	      }
	    } else if (o.ipc) {
	      ret.hosts.push({ ipc: o.ipc });
	    }
	
	    if (o.auth) {
	      ret.auth = {
	          user: o.auth.user ? (o.auth.user) : void 0
	        , pass: o.auth.pass ? (o.auth.pass) : void 0
	      }
	    }
	  })
	
	  if (!ret.hosts.length) {
	    throw new Error('Invalid mongodb uri. Missing hostname');
	  }
	
	  var parts = path.split('?');
	
	  if (!db) {
	    if (parts[0]) {
	      db = parts[0].replace(/^\//, '');
	    } else {
	      // deal with ipc formats
	      db = /\/([^\.]+)$/.exec(match[1]);
	      if (db && db[1]) {
	        db = db[1];
	      }
	    }
	  }
	
	  if (db) {
	    ret.db = db;
	  } else if (ret.auth) {
	    ret.db = ADMIN_DB;
	  }
	
	  if (parts[1]) {
	    ret.options = options(parts[1]);
	  }
	
	  return ret;
	}
	
	/**
	 * Parse str into key/val pairs casting values appropriately.
	 */
	
	function options (str) {
	  var sep = /;/.test(str)
	    ? ';'
	    : '&';
	
	  var ret = qs.parse(str, sep);
	
	  Object.keys(ret).forEach(function (key) {
	    var val = ret[key];
	    if ('readPreferenceTags' == key) {
	      val = readPref(val);
	      if (val) {
	        ret[key] = Array.isArray(val)
	          ? val
	          : [val];
	      }
	    } else {
	      ret[key] = format(val);
	    }
	  });
	
	  return ret;
	}
	
	function format (val) {
	  var num;
	
	  if ('true' == val) {
	    return true;
	  } else if ('false' == val) {
	    return false;
	  } else {
	    num = parseInt(+val, 10);
	    if (!isNaN(num)) {
	      return num;
	    }
	  }
	
	  return val;
	}
	
	function readPref (val) {
	  var ret;
	
	  if (Array.isArray(val)) {
	    ret = val.map(readPref).filter(Boolean);
	    return ret.length
	      ? ret
	      : undefined
	  }
	
	  var pair = val.split(',');
	  var hasKeys;
	  ret = {};
	
	  pair.forEach(function (kv) {
	    kv = (kv || '').trim();
	    if (!kv) return;
	    hasKeys = true;
	    var split = kv.split(':');
	    ret[split[0]] = format(split[1]);
	  });
	
	  return hasKeys && ret;
	}
	
	var ipcRgx = /\.sock/;
	
	function parse (uriString) {
	  // do not use require('url').parse b/c it can't handle # in username or pwd
	  // mongo uris are strange
	
	  var uri = uriString;
	  var ret = {};
	  var parts;
	  var auth;
	  var ipcs;
	
	  // skip protocol
	  uri = uri.replace(/^mongodb:\/\//, '');
	
	  // auth
	  if (/@/.test(uri)) {
	    parts = uri.split(/@/);
	    auth = parts[0];
	    uri = parts[1];
	
	    parts = auth.split(':');
	    ret.auth = {};
	    ret.auth.user = decodeURIComponent(parts[0]);
	    ret.auth.pass = parts[1] ? decodeURIComponent(parts[1]) : void 0;
	  }
	
	  // unix domain sockets
	  if (ipcRgx.test(uri)) {
	    ipcs = uri.split(ipcRgx);
	    ret.ipc = ipcs[0] + '.sock';
	
	    // included a database?
	    if (ipcs[1]) {
	      // strip leading / from database name
	      ipcs[1] = ipcs[1].replace(/^\//, '');
	
	      if (ipcs[1]) {
	        ret.db = ipcs[1];
	      }
	    }
	
	    return ret;
	  }
	
	  // database name
	  parts = uri.split('/');
	  if (parts[1]) ret.db = parts[1];
	
	  // ipv6, [ip]:host
	  if (/^\[[^\]]+\]:\d+/.test(parts[0])) {
	    ret.host = parts[0].substring(1, parts[0].indexOf(']:'));
	    ret.port = parts[0].substring(parts[0].indexOf(']:') + ']:'.length);
	  } else {
	    // host:port
	    parts = parts[0].split(':');
	    ret.host = parts[0];
	    ret.port = parts[1] || DEFAULT_PORT;
	  }
	
	  return ret;
	}
	
	/**
	 * Version
	 */
	
	module.exports.version = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../package.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).version;


/***/ }),
/* 253 */
/***/ (function(module, exports) {

	
	/**
	 * An Array.prototype.slice.call(arguments) alternative
	 *
	 * @param {Object} args something with a length
	 * @param {Number} slice
	 * @param {Number} sliceEnd
	 * @api public
	 */
	
	module.exports = function (args, slice, sliceEnd) {
	  var ret = [];
	  var len = args.length;
	
	  if (0 === len) return ret;
	
	  var start = slice < 0
	    ? Math.max(0, slice + len)
	    : slice || 0;
	
	  if (sliceEnd !== undefined) {
	    len = sliceEnd < 0
	      ? sliceEnd + len
	      : sliceEnd
	  }
	
	  while (len-- > start) {
	    ret[len - start] = args[len];
	  }
	
	  return ret;
	}
	


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _Post = __webpack_require__(255);
	
	var _Post2 = _interopRequireDefault(_Post);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = {
	  create: function create(req, res, next) {
	    var postProps = req.body;
	
	    _Post2.default.create(postProps).then(function (post) {
	      return res.send(post);
	    }).catch(next);
	  },
	  edit: function edit(req, res, next) {
	    var postId = req.params.id;
	    var postProps = req.body;
	
	    _Post2.default.findByIdAndUpdate({ _id: postId }, postProps).then(function () {
	      return _Post2.default.findById({ _id: postId });
	    }).then(function (post) {
	      return res.send(post);
	    }).catch(next);
	  },
	  delete: function _delete(req, res, next) {
	    var postId = req.params.id;
	
	    _Post2.default.findByIdAndRemove({ _id: postId }).then(function (post) {
	      return res.status(204).send(post);
	    }).catch(next);
	  },
	  getposts: function getposts(req, res, next) {
	    _Post2.default.find({}).then(function (posts) {
	      return res.send(posts);
	    }).catch(next);
	  },
	  getpost: function getpost(req, res, next) {
	    var postId = req.params.id;
	    _Post2.default.findOne({ _id: postId }).then(function (post) {
	      return res.send(post);
	    }).catch(next);
	  }
	};
	;

	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	}();

	;

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _mongoose = __webpack_require__(206);
	
	var _mongoose2 = _interopRequireDefault(_mongoose);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PostSchema = new _mongoose.Schema({
	  title: String,
	  content: String
	});
	
	var Post = _mongoose2.default.model('post', PostSchema);
	
	module.exports = Post;
	;
	
	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	
	  __REACT_HOT_LOADER__.register(PostSchema, 'PostSchema', '/Users/byronhsu/Desktop/webpack-react-redux/server/api/models/Post.js');
	
	  __REACT_HOT_LOADER__.register(Post, 'Post', '/Users/byronhsu/Desktop/webpack-react-redux/server/api/models/Post.js');
	}();

	;

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _posts_controller = __webpack_require__(254);
	
	var _posts_controller2 = _interopRequireDefault(_posts_controller);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = function (server) {
	  server.post('/api/posts', _posts_controller2.default.create);
	  server.put('/api/posts/:id', _posts_controller2.default.edit);
	  server.delete('/api/posts/:id', _posts_controller2.default.delete);
	  server.get('/api/posts', _posts_controller2.default.getposts);
	  server.get('/api/posts/:id', _posts_controller2.default.getpost);
	};
	;

	var _temp = function () {
	  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	    return;
	  }
	}();

	;

/***/ }),
/* 257 */
/***/ (function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var env = process.env;
	
	var nodeEnv = exports.nodeEnv = env.NODE_ENV || 'development';
	
	var _default = {
	    mongodbUri: 'mongodb://localhost:27017/test',
	    port: env.PORT || 3000,
	    host: env.HOST || '0.0.0.0',
	    get serverUrl() {
	        return 'http://' + this.host + ':' + this.port;
	    }
	};
	exports.default = _default;
	;
	
	var _temp = function () {
	    if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	        return;
	    }
	
	    __REACT_HOT_LOADER__.register(env, 'env', '/Users/byronhsu/Desktop/webpack-react-redux/server/config.js');
	
	    __REACT_HOT_LOADER__.register(nodeEnv, 'nodeEnv', '/Users/byronhsu/Desktop/webpack-react-redux/server/config.js');
	
	    __REACT_HOT_LOADER__.register(_default, 'default', '/Users/byronhsu/Desktop/webpack-react-redux/server/config.js');
	}();

	;

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var path = __webpack_require__(69);
	var webpack = __webpack_require__(107);
	var HtmlWebpackPlugin = __webpack_require__(272);
	var DashboardPlugin = __webpack_require__(264);
	
	module.exports = {
	    devtool: 'eval-source-map',
	    entry: ['babel-polyfill', 'webpack-hot-middleware/client', 'react-hot-loader/patch', path.join(__dirname, 'app/index.js')],
	    output: {
	        path: path.join(__dirname, '/dist/'),
	        filename: '[name].js',
	        publicPath: '/'
	    },
	    plugins: [new HtmlWebpackPlugin({
	        template: 'app/index.tpl.html',
	        inject: 'body',
	        filename: 'index.html'
	    }), new webpack.optimize.OccurenceOrderPlugin(), new webpack.HotModuleReplacementPlugin(), new webpack.NoErrorsPlugin(), new webpack.DefinePlugin({
	        'process.env.NODE_ENV': JSON.stringify('development')
	    }), new DashboardPlugin()],
	    eslint: {
	        configFile: '.eslintrc',
	        failOnWarning: false,
	        failOnError: false
	    },
	    module: {
	        preLoaders: [{
	            test: /\.js$/,
	            exclude: /node_modules/,
	            loader: 'eslint'
	        }],
	        loaders: [{
	            test: /\.js?$/,
	            exclude: /node_modules/,
	            loader: 'babel'
	        }, {
	            test: /\.json?$/,
	            loader: 'json'
	        }, {
	            test: /\.scss$/,
	            loader: 'style!css?modules&localIdentName=[name]---[local]---[hash:base64:5]!sass'
	        }, { test: /\.woff(2)?(\?[a-z0-9#=&.]+)?$/, loader: 'url?limit=10000&mimetype=application/font-woff' }, { test: /\.(ttf|eot|svg)(\?[a-z0-9#=&.]+)?$/, loader: 'file' }]
	    }
	};
	;

	var _temp = function () {
	    if (typeof __REACT_HOT_LOADER__ === 'undefined') {
	        return;
	    }
	}();

	;

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(263).runInContext();
	module.exports = __webpack_require__(260)(_, _);


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

	var mapping = __webpack_require__(261),
	    fallbackHolder = __webpack_require__(262);
	
	/** Built-in value reference. */
	var push = Array.prototype.push;
	
	/**
	 * Creates a function, with an arity of `n`, that invokes `func` with the
	 * arguments it receives.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} n The arity of the new function.
	 * @returns {Function} Returns the new function.
	 */
	function baseArity(func, n) {
	  return n == 2
	    ? function(a, b) { return func.apply(undefined, arguments); }
	    : function(a) { return func.apply(undefined, arguments); };
	}
	
	/**
	 * Creates a function that invokes `func`, with up to `n` arguments, ignoring
	 * any additional arguments.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @param {number} n The arity cap.
	 * @returns {Function} Returns the new function.
	 */
	function baseAry(func, n) {
	  return n == 2
	    ? function(a, b) { return func(a, b); }
	    : function(a) { return func(a); };
	}
	
	/**
	 * Creates a clone of `array`.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the cloned array.
	 */
	function cloneArray(array) {
	  var length = array ? array.length : 0,
	      result = Array(length);
	
	  while (length--) {
	    result[length] = array[length];
	  }
	  return result;
	}
	
	/**
	 * Creates a function that clones a given object using the assignment `func`.
	 *
	 * @private
	 * @param {Function} func The assignment function.
	 * @returns {Function} Returns the new cloner function.
	 */
	function createCloner(func) {
	  return function(object) {
	    return func({}, object);
	  };
	}
	
	/**
	 * A specialized version of `_.spread` which flattens the spread array into
	 * the arguments of the invoked `func`.
	 *
	 * @private
	 * @param {Function} func The function to spread arguments over.
	 * @param {number} start The start position of the spread.
	 * @returns {Function} Returns the new function.
	 */
	function flatSpread(func, start) {
	  return function() {
	    var length = arguments.length,
	        lastIndex = length - 1,
	        args = Array(length);
	
	    while (length--) {
	      args[length] = arguments[length];
	    }
	    var array = args[start],
	        otherArgs = args.slice(0, start);
	
	    if (array) {
	      push.apply(otherArgs, array);
	    }
	    if (start != lastIndex) {
	      push.apply(otherArgs, args.slice(start + 1));
	    }
	    return func.apply(this, otherArgs);
	  };
	}
	
	/**
	 * Creates a function that wraps `func` and uses `cloner` to clone the first
	 * argument it receives.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} cloner The function to clone arguments.
	 * @returns {Function} Returns the new immutable function.
	 */
	function wrapImmutable(func, cloner) {
	  return function() {
	    var length = arguments.length;
	    if (!length) {
	      return;
	    }
	    var args = Array(length);
	    while (length--) {
	      args[length] = arguments[length];
	    }
	    var result = args[0] = cloner.apply(undefined, args);
	    func.apply(undefined, args);
	    return result;
	  };
	}
	
	/**
	 * The base implementation of `convert` which accepts a `util` object of methods
	 * required to perform conversions.
	 *
	 * @param {Object} util The util object.
	 * @param {string} name The name of the function to convert.
	 * @param {Function} func The function to convert.
	 * @param {Object} [options] The options object.
	 * @param {boolean} [options.cap=true] Specify capping iteratee arguments.
	 * @param {boolean} [options.curry=true] Specify currying.
	 * @param {boolean} [options.fixed=true] Specify fixed arity.
	 * @param {boolean} [options.immutable=true] Specify immutable operations.
	 * @param {boolean} [options.rearg=true] Specify rearranging arguments.
	 * @returns {Function|Object} Returns the converted function or object.
	 */
	function baseConvert(util, name, func, options) {
	  var setPlaceholder,
	      isLib = typeof name == 'function',
	      isObj = name === Object(name);
	
	  if (isObj) {
	    options = func;
	    func = name;
	    name = undefined;
	  }
	  if (func == null) {
	    throw new TypeError;
	  }
	  options || (options = {});
	
	  var config = {
	    'cap': 'cap' in options ? options.cap : true,
	    'curry': 'curry' in options ? options.curry : true,
	    'fixed': 'fixed' in options ? options.fixed : true,
	    'immutable': 'immutable' in options ? options.immutable : true,
	    'rearg': 'rearg' in options ? options.rearg : true
	  };
	
	  var forceCurry = ('curry' in options) && options.curry,
	      forceFixed = ('fixed' in options) && options.fixed,
	      forceRearg = ('rearg' in options) && options.rearg,
	      placeholder = isLib ? func : fallbackHolder,
	      pristine = isLib ? func.runInContext() : undefined;
	
	  var helpers = isLib ? func : {
	    'ary': util.ary,
	    'assign': util.assign,
	    'clone': util.clone,
	    'curry': util.curry,
	    'forEach': util.forEach,
	    'isArray': util.isArray,
	    'isFunction': util.isFunction,
	    'iteratee': util.iteratee,
	    'keys': util.keys,
	    'rearg': util.rearg,
	    'toInteger': util.toInteger,
	    'toPath': util.toPath
	  };
	
	  var ary = helpers.ary,
	      assign = helpers.assign,
	      clone = helpers.clone,
	      curry = helpers.curry,
	      each = helpers.forEach,
	      isArray = helpers.isArray,
	      isFunction = helpers.isFunction,
	      keys = helpers.keys,
	      rearg = helpers.rearg,
	      toInteger = helpers.toInteger,
	      toPath = helpers.toPath;
	
	  var aryMethodKeys = keys(mapping.aryMethod);
	
	  var wrappers = {
	    'castArray': function(castArray) {
	      return function() {
	        var value = arguments[0];
	        return isArray(value)
	          ? castArray(cloneArray(value))
	          : castArray.apply(undefined, arguments);
	      };
	    },
	    'iteratee': function(iteratee) {
	      return function() {
	        var func = arguments[0],
	            arity = arguments[1],
	            result = iteratee(func, arity),
	            length = result.length;
	
	        if (config.cap && typeof arity == 'number') {
	          arity = arity > 2 ? (arity - 2) : 1;
	          return (length && length <= arity) ? result : baseAry(result, arity);
	        }
	        return result;
	      };
	    },
	    'mixin': function(mixin) {
	      return function(source) {
	        var func = this;
	        if (!isFunction(func)) {
	          return mixin(func, Object(source));
	        }
	        var pairs = [];
	        each(keys(source), function(key) {
	          if (isFunction(source[key])) {
	            pairs.push([key, func.prototype[key]]);
	          }
	        });
	
	        mixin(func, Object(source));
	
	        each(pairs, function(pair) {
	          var value = pair[1];
	          if (isFunction(value)) {
	            func.prototype[pair[0]] = value;
	          } else {
	            delete func.prototype[pair[0]];
	          }
	        });
	        return func;
	      };
	    },
	    'nthArg': function(nthArg) {
	      return function(n) {
	        var arity = n < 0 ? 1 : (toInteger(n) + 1);
	        return curry(nthArg(n), arity);
	      };
	    },
	    'rearg': function(rearg) {
	      return function(func, indexes) {
	        var arity = indexes ? indexes.length : 0;
	        return curry(rearg(func, indexes), arity);
	      };
	    },
	    'runInContext': function(runInContext) {
	      return function(context) {
	        return baseConvert(util, runInContext(context), options);
	      };
	    }
	  };
	
	  /*--------------------------------------------------------------------------*/
	
	  /**
	   * Casts `func` to a function with an arity capped iteratee if needed.
	   *
	   * @private
	   * @param {string} name The name of the function to inspect.
	   * @param {Function} func The function to inspect.
	   * @returns {Function} Returns the cast function.
	   */
	  function castCap(name, func) {
	    if (config.cap) {
	      var indexes = mapping.iterateeRearg[name];
	      if (indexes) {
	        return iterateeRearg(func, indexes);
	      }
	      var n = !isLib && mapping.iterateeAry[name];
	      if (n) {
	        return iterateeAry(func, n);
	      }
	    }
	    return func;
	  }
	
	  /**
	   * Casts `func` to a curried function if needed.
	   *
	   * @private
	   * @param {string} name The name of the function to inspect.
	   * @param {Function} func The function to inspect.
	   * @param {number} n The arity of `func`.
	   * @returns {Function} Returns the cast function.
	   */
	  function castCurry(name, func, n) {
	    return (forceCurry || (config.curry && n > 1))
	      ? curry(func, n)
	      : func;
	  }
	
	  /**
	   * Casts `func` to a fixed arity function if needed.
	   *
	   * @private
	   * @param {string} name The name of the function to inspect.
	   * @param {Function} func The function to inspect.
	   * @param {number} n The arity cap.
	   * @returns {Function} Returns the cast function.
	   */
	  function castFixed(name, func, n) {
	    if (config.fixed && (forceFixed || !mapping.skipFixed[name])) {
	      var data = mapping.methodSpread[name],
	          start = data && data.start;
	
	      return start  === undefined ? ary(func, n) : flatSpread(func, start);
	    }
	    return func;
	  }
	
	  /**
	   * Casts `func` to an rearged function if needed.
	   *
	   * @private
	   * @param {string} name The name of the function to inspect.
	   * @param {Function} func The function to inspect.
	   * @param {number} n The arity of `func`.
	   * @returns {Function} Returns the cast function.
	   */
	  function castRearg(name, func, n) {
	    return (config.rearg && n > 1 && (forceRearg || !mapping.skipRearg[name]))
	      ? rearg(func, mapping.methodRearg[name] || mapping.aryRearg[n])
	      : func;
	  }
	
	  /**
	   * Creates a clone of `object` by `path`.
	   *
	   * @private
	   * @param {Object} object The object to clone.
	   * @param {Array|string} path The path to clone by.
	   * @returns {Object} Returns the cloned object.
	   */
	  function cloneByPath(object, path) {
	    path = toPath(path);
	
	    var index = -1,
	        length = path.length,
	        lastIndex = length - 1,
	        result = clone(Object(object)),
	        nested = result;
	
	    while (nested != null && ++index < length) {
	      var key = path[index],
	          value = nested[key];
	
	      if (value != null) {
	        nested[path[index]] = clone(index == lastIndex ? value : Object(value));
	      }
	      nested = nested[key];
	    }
	    return result;
	  }
	
	  /**
	   * Converts `lodash` to an immutable auto-curried iteratee-first data-last
	   * version with conversion `options` applied.
	   *
	   * @param {Object} [options] The options object. See `baseConvert` for more details.
	   * @returns {Function} Returns the converted `lodash`.
	   */
	  function convertLib(options) {
	    return _.runInContext.convert(options)(undefined);
	  }
	
	  /**
	   * Create a converter function for `func` of `name`.
	   *
	   * @param {string} name The name of the function to convert.
	   * @param {Function} func The function to convert.
	   * @returns {Function} Returns the new converter function.
	   */
	  function createConverter(name, func) {
	    var realName = mapping.aliasToReal[name] || name,
	        methodName = mapping.remap[realName] || realName,
	        oldOptions = options;
	
	    return function(options) {
	      var newUtil = isLib ? pristine : helpers,
	          newFunc = isLib ? pristine[methodName] : func,
	          newOptions = assign(assign({}, oldOptions), options);
	
	      return baseConvert(newUtil, realName, newFunc, newOptions);
	    };
	  }
	
	  /**
	   * Creates a function that wraps `func` to invoke its iteratee, with up to `n`
	   * arguments, ignoring any additional arguments.
	   *
	   * @private
	   * @param {Function} func The function to cap iteratee arguments for.
	   * @param {number} n The arity cap.
	   * @returns {Function} Returns the new function.
	   */
	  function iterateeAry(func, n) {
	    return overArg(func, function(func) {
	      return typeof func == 'function' ? baseAry(func, n) : func;
	    });
	  }
	
	  /**
	   * Creates a function that wraps `func` to invoke its iteratee with arguments
	   * arranged according to the specified `indexes` where the argument value at
	   * the first index is provided as the first argument, the argument value at
	   * the second index is provided as the second argument, and so on.
	   *
	   * @private
	   * @param {Function} func The function to rearrange iteratee arguments for.
	   * @param {number[]} indexes The arranged argument indexes.
	   * @returns {Function} Returns the new function.
	   */
	  function iterateeRearg(func, indexes) {
	    return overArg(func, function(func) {
	      var n = indexes.length;
	      return baseArity(rearg(baseAry(func, n), indexes), n);
	    });
	  }
	
	  /**
	   * Creates a function that invokes `func` with its first argument transformed.
	   *
	   * @private
	   * @param {Function} func The function to wrap.
	   * @param {Function} transform The argument transform.
	   * @returns {Function} Returns the new function.
	   */
	  function overArg(func, transform) {
	    return function() {
	      var length = arguments.length;
	      if (!length) {
	        return func();
	      }
	      var args = Array(length);
	      while (length--) {
	        args[length] = arguments[length];
	      }
	      var index = config.rearg ? 0 : (length - 1);
	      args[index] = transform(args[index]);
	      return func.apply(undefined, args);
	    };
	  }
	
	  /**
	   * Creates a function that wraps `func` and applys the conversions
	   * rules by `name`.
	   *
	   * @private
	   * @param {string} name The name of the function to wrap.
	   * @param {Function} func The function to wrap.
	   * @returns {Function} Returns the converted function.
	   */
	  function wrap(name, func) {
	    var result,
	        realName = mapping.aliasToReal[name] || name,
	        wrapped = func,
	        wrapper = wrappers[realName];
	
	    if (wrapper) {
	      wrapped = wrapper(func);
	    }
	    else if (config.immutable) {
	      if (mapping.mutate.array[realName]) {
	        wrapped = wrapImmutable(func, cloneArray);
	      }
	      else if (mapping.mutate.object[realName]) {
	        wrapped = wrapImmutable(func, createCloner(func));
	      }
	      else if (mapping.mutate.set[realName]) {
	        wrapped = wrapImmutable(func, cloneByPath);
	      }
	    }
	    each(aryMethodKeys, function(aryKey) {
	      each(mapping.aryMethod[aryKey], function(otherName) {
	        if (realName == otherName) {
	          var data = mapping.methodSpread[realName],
	              afterRearg = data && data.afterRearg;
	
	          result = afterRearg
	            ? castFixed(realName, castRearg(realName, wrapped, aryKey), aryKey)
	            : castRearg(realName, castFixed(realName, wrapped, aryKey), aryKey);
	
	          result = castCap(realName, result);
	          result = castCurry(realName, result, aryKey);
	          return false;
	        }
	      });
	      return !result;
	    });
	
	    result || (result = wrapped);
	    if (result == func) {
	      result = forceCurry ? curry(result, 1) : function() {
	        return func.apply(this, arguments);
	      };
	    }
	    result.convert = createConverter(realName, func);
	    if (mapping.placeholder[realName]) {
	      setPlaceholder = true;
	      result.placeholder = func.placeholder = placeholder;
	    }
	    return result;
	  }
	
	  /*--------------------------------------------------------------------------*/
	
	  if (!isObj) {
	    return wrap(name, func);
	  }
	  var _ = func;
	
	  // Convert methods by ary cap.
	  var pairs = [];
	  each(aryMethodKeys, function(aryKey) {
	    each(mapping.aryMethod[aryKey], function(key) {
	      var func = _[mapping.remap[key] || key];
	      if (func) {
	        pairs.push([key, wrap(key, func)]);
	      }
	    });
	  });
	
	  // Convert remaining methods.
	  each(keys(_), function(key) {
	    var func = _[key];
	    if (typeof func == 'function') {
	      var length = pairs.length;
	      while (length--) {
	        if (pairs[length][0] == key) {
	          return;
	        }
	      }
	      func.convert = createConverter(key, func);
	      pairs.push([key, func]);
	    }
	  });
	
	  // Assign to `_` leaving `_.prototype` unchanged to allow chaining.
	  each(pairs, function(pair) {
	    _[pair[0]] = pair[1];
	  });
	
	  _.convert = convertLib;
	  if (setPlaceholder) {
	    _.placeholder = placeholder;
	  }
	  // Assign aliases.
	  each(keys(_), function(key) {
	    each(mapping.realToAlias[key] || [], function(alias) {
	      _[alias] = _[key];
	    });
	  });
	
	  return _;
	}
	
	module.exports = baseConvert;


/***/ }),
/* 261 */
/***/ (function(module, exports) {

	/** Used to map aliases to their real names. */
	exports.aliasToReal = {
	
	  // Lodash aliases.
	  'each': 'forEach',
	  'eachRight': 'forEachRight',
	  'entries': 'toPairs',
	  'entriesIn': 'toPairsIn',
	  'extend': 'assignIn',
	  'extendAll': 'assignInAll',
	  'extendAllWith': 'assignInAllWith',
	  'extendWith': 'assignInWith',
	  'first': 'head',
	
	  // Methods that are curried variants of others.
	  'conforms': 'conformsTo',
	  'matches': 'isMatch',
	  'property': 'get',
	
	  // Ramda aliases.
	  '__': 'placeholder',
	  'F': 'stubFalse',
	  'T': 'stubTrue',
	  'all': 'every',
	  'allPass': 'overEvery',
	  'always': 'constant',
	  'any': 'some',
	  'anyPass': 'overSome',
	  'apply': 'spread',
	  'assoc': 'set',
	  'assocPath': 'set',
	  'complement': 'negate',
	  'compose': 'flowRight',
	  'contains': 'includes',
	  'dissoc': 'unset',
	  'dissocPath': 'unset',
	  'dropLast': 'dropRight',
	  'dropLastWhile': 'dropRightWhile',
	  'equals': 'isEqual',
	  'identical': 'eq',
	  'indexBy': 'keyBy',
	  'init': 'initial',
	  'invertObj': 'invert',
	  'juxt': 'over',
	  'omitAll': 'omit',
	  'nAry': 'ary',
	  'path': 'get',
	  'pathEq': 'matchesProperty',
	  'pathOr': 'getOr',
	  'paths': 'at',
	  'pickAll': 'pick',
	  'pipe': 'flow',
	  'pluck': 'map',
	  'prop': 'get',
	  'propEq': 'matchesProperty',
	  'propOr': 'getOr',
	  'props': 'at',
	  'symmetricDifference': 'xor',
	  'symmetricDifferenceBy': 'xorBy',
	  'symmetricDifferenceWith': 'xorWith',
	  'takeLast': 'takeRight',
	  'takeLastWhile': 'takeRightWhile',
	  'unapply': 'rest',
	  'unnest': 'flatten',
	  'useWith': 'overArgs',
	  'where': 'conformsTo',
	  'whereEq': 'isMatch',
	  'zipObj': 'zipObject'
	};
	
	/** Used to map ary to method names. */
	exports.aryMethod = {
	  '1': [
	    'assignAll', 'assignInAll', 'attempt', 'castArray', 'ceil', 'create',
	    'curry', 'curryRight', 'defaultsAll', 'defaultsDeepAll', 'floor', 'flow',
	    'flowRight', 'fromPairs', 'invert', 'iteratee', 'memoize', 'method', 'mergeAll',
	    'methodOf', 'mixin', 'nthArg', 'over', 'overEvery', 'overSome','rest', 'reverse',
	    'round', 'runInContext', 'spread', 'template', 'trim', 'trimEnd', 'trimStart',
	    'uniqueId', 'words', 'zipAll'
	  ],
	  '2': [
	    'add', 'after', 'ary', 'assign', 'assignAllWith', 'assignIn', 'assignInAllWith',
	    'at', 'before', 'bind', 'bindAll', 'bindKey', 'chunk', 'cloneDeepWith',
	    'cloneWith', 'concat', 'conformsTo', 'countBy', 'curryN', 'curryRightN',
	    'debounce', 'defaults', 'defaultsDeep', 'defaultTo', 'delay', 'difference',
	    'divide', 'drop', 'dropRight', 'dropRightWhile', 'dropWhile', 'endsWith', 'eq',
	    'every', 'filter', 'find', 'findIndex', 'findKey', 'findLast', 'findLastIndex',
	    'findLastKey', 'flatMap', 'flatMapDeep', 'flattenDepth', 'forEach',
	    'forEachRight', 'forIn', 'forInRight', 'forOwn', 'forOwnRight', 'get',
	    'groupBy', 'gt', 'gte', 'has', 'hasIn', 'includes', 'indexOf', 'intersection',
	    'invertBy', 'invoke', 'invokeMap', 'isEqual', 'isMatch', 'join', 'keyBy',
	    'lastIndexOf', 'lt', 'lte', 'map', 'mapKeys', 'mapValues', 'matchesProperty',
	    'maxBy', 'meanBy', 'merge', 'mergeAllWith', 'minBy', 'multiply', 'nth', 'omit',
	    'omitBy', 'overArgs', 'pad', 'padEnd', 'padStart', 'parseInt', 'partial',
	    'partialRight', 'partition', 'pick', 'pickBy', 'propertyOf', 'pull', 'pullAll',
	    'pullAt', 'random', 'range', 'rangeRight', 'rearg', 'reject', 'remove',
	    'repeat', 'restFrom', 'result', 'sampleSize', 'some', 'sortBy', 'sortedIndex',
	    'sortedIndexOf', 'sortedLastIndex', 'sortedLastIndexOf', 'sortedUniqBy',
	    'split', 'spreadFrom', 'startsWith', 'subtract', 'sumBy', 'take', 'takeRight',
	    'takeRightWhile', 'takeWhile', 'tap', 'throttle', 'thru', 'times', 'trimChars',
	    'trimCharsEnd', 'trimCharsStart', 'truncate', 'union', 'uniqBy', 'uniqWith',
	    'unset', 'unzipWith', 'without', 'wrap', 'xor', 'zip', 'zipObject',
	    'zipObjectDeep'
	  ],
	  '3': [
	    'assignInWith', 'assignWith', 'clamp', 'differenceBy', 'differenceWith',
	    'findFrom', 'findIndexFrom', 'findLastFrom', 'findLastIndexFrom', 'getOr',
	    'includesFrom', 'indexOfFrom', 'inRange', 'intersectionBy', 'intersectionWith',
	    'invokeArgs', 'invokeArgsMap', 'isEqualWith', 'isMatchWith', 'flatMapDepth',
	    'lastIndexOfFrom', 'mergeWith', 'orderBy', 'padChars', 'padCharsEnd',
	    'padCharsStart', 'pullAllBy', 'pullAllWith', 'rangeStep', 'rangeStepRight',
	    'reduce', 'reduceRight', 'replace', 'set', 'slice', 'sortedIndexBy',
	    'sortedLastIndexBy', 'transform', 'unionBy', 'unionWith', 'update', 'xorBy',
	    'xorWith', 'zipWith'
	  ],
	  '4': [
	    'fill', 'setWith', 'updateWith'
	  ]
	};
	
	/** Used to map ary to rearg configs. */
	exports.aryRearg = {
	  '2': [1, 0],
	  '3': [2, 0, 1],
	  '4': [3, 2, 0, 1]
	};
	
	/** Used to map method names to their iteratee ary. */
	exports.iterateeAry = {
	  'dropRightWhile': 1,
	  'dropWhile': 1,
	  'every': 1,
	  'filter': 1,
	  'find': 1,
	  'findFrom': 1,
	  'findIndex': 1,
	  'findIndexFrom': 1,
	  'findKey': 1,
	  'findLast': 1,
	  'findLastFrom': 1,
	  'findLastIndex': 1,
	  'findLastIndexFrom': 1,
	  'findLastKey': 1,
	  'flatMap': 1,
	  'flatMapDeep': 1,
	  'flatMapDepth': 1,
	  'forEach': 1,
	  'forEachRight': 1,
	  'forIn': 1,
	  'forInRight': 1,
	  'forOwn': 1,
	  'forOwnRight': 1,
	  'map': 1,
	  'mapKeys': 1,
	  'mapValues': 1,
	  'partition': 1,
	  'reduce': 2,
	  'reduceRight': 2,
	  'reject': 1,
	  'remove': 1,
	  'some': 1,
	  'takeRightWhile': 1,
	  'takeWhile': 1,
	  'times': 1,
	  'transform': 2
	};
	
	/** Used to map method names to iteratee rearg configs. */
	exports.iterateeRearg = {
	  'mapKeys': [1],
	  'reduceRight': [1, 0]
	};
	
	/** Used to map method names to rearg configs. */
	exports.methodRearg = {
	  'assignInAllWith': [1, 0],
	  'assignInWith': [1, 2, 0],
	  'assignAllWith': [1, 0],
	  'assignWith': [1, 2, 0],
	  'differenceBy': [1, 2, 0],
	  'differenceWith': [1, 2, 0],
	  'getOr': [2, 1, 0],
	  'intersectionBy': [1, 2, 0],
	  'intersectionWith': [1, 2, 0],
	  'isEqualWith': [1, 2, 0],
	  'isMatchWith': [2, 1, 0],
	  'mergeAllWith': [1, 0],
	  'mergeWith': [1, 2, 0],
	  'padChars': [2, 1, 0],
	  'padCharsEnd': [2, 1, 0],
	  'padCharsStart': [2, 1, 0],
	  'pullAllBy': [2, 1, 0],
	  'pullAllWith': [2, 1, 0],
	  'rangeStep': [1, 2, 0],
	  'rangeStepRight': [1, 2, 0],
	  'setWith': [3, 1, 2, 0],
	  'sortedIndexBy': [2, 1, 0],
	  'sortedLastIndexBy': [2, 1, 0],
	  'unionBy': [1, 2, 0],
	  'unionWith': [1, 2, 0],
	  'updateWith': [3, 1, 2, 0],
	  'xorBy': [1, 2, 0],
	  'xorWith': [1, 2, 0],
	  'zipWith': [1, 2, 0]
	};
	
	/** Used to map method names to spread configs. */
	exports.methodSpread = {
	  'assignAll': { 'start': 0 },
	  'assignAllWith': { 'start': 0 },
	  'assignInAll': { 'start': 0 },
	  'assignInAllWith': { 'start': 0 },
	  'defaultsAll': { 'start': 0 },
	  'defaultsDeepAll': { 'start': 0 },
	  'invokeArgs': { 'start': 2 },
	  'invokeArgsMap': { 'start': 2 },
	  'mergeAll': { 'start': 0 },
	  'mergeAllWith': { 'start': 0 },
	  'partial': { 'start': 1 },
	  'partialRight': { 'start': 1 },
	  'without': { 'start': 1 },
	  'zipAll': { 'start': 0 }
	};
	
	/** Used to identify methods which mutate arrays or objects. */
	exports.mutate = {
	  'array': {
	    'fill': true,
	    'pull': true,
	    'pullAll': true,
	    'pullAllBy': true,
	    'pullAllWith': true,
	    'pullAt': true,
	    'remove': true,
	    'reverse': true
	  },
	  'object': {
	    'assign': true,
	    'assignAll': true,
	    'assignAllWith': true,
	    'assignIn': true,
	    'assignInAll': true,
	    'assignInAllWith': true,
	    'assignInWith': true,
	    'assignWith': true,
	    'defaults': true,
	    'defaultsAll': true,
	    'defaultsDeep': true,
	    'defaultsDeepAll': true,
	    'merge': true,
	    'mergeAll': true,
	    'mergeAllWith': true,
	    'mergeWith': true,
	  },
	  'set': {
	    'set': true,
	    'setWith': true,
	    'unset': true,
	    'update': true,
	    'updateWith': true
	  }
	};
	
	/** Used to track methods with placeholder support */
	exports.placeholder = {
	  'bind': true,
	  'bindKey': true,
	  'curry': true,
	  'curryRight': true,
	  'partial': true,
	  'partialRight': true
	};
	
	/** Used to map real names to their aliases. */
	exports.realToAlias = (function() {
	  var hasOwnProperty = Object.prototype.hasOwnProperty,
	      object = exports.aliasToReal,
	      result = {};
	
	  for (var key in object) {
	    var value = object[key];
	    if (hasOwnProperty.call(result, value)) {
	      result[value].push(key);
	    } else {
	      result[value] = [key];
	    }
	  }
	  return result;
	}());
	
	/** Used to map method names to other names. */
	exports.remap = {
	  'assignAll': 'assign',
	  'assignAllWith': 'assignWith',
	  'assignInAll': 'assignIn',
	  'assignInAllWith': 'assignInWith',
	  'curryN': 'curry',
	  'curryRightN': 'curryRight',
	  'defaultsAll': 'defaults',
	  'defaultsDeepAll': 'defaultsDeep',
	  'findFrom': 'find',
	  'findIndexFrom': 'findIndex',
	  'findLastFrom': 'findLast',
	  'findLastIndexFrom': 'findLastIndex',
	  'getOr': 'get',
	  'includesFrom': 'includes',
	  'indexOfFrom': 'indexOf',
	  'invokeArgs': 'invoke',
	  'invokeArgsMap': 'invokeMap',
	  'lastIndexOfFrom': 'lastIndexOf',
	  'mergeAll': 'merge',
	  'mergeAllWith': 'mergeWith',
	  'padChars': 'pad',
	  'padCharsEnd': 'padEnd',
	  'padCharsStart': 'padStart',
	  'propertyOf': 'get',
	  'rangeStep': 'range',
	  'rangeStepRight': 'rangeRight',
	  'restFrom': 'rest',
	  'spreadFrom': 'spread',
	  'trimChars': 'trim',
	  'trimCharsEnd': 'trimEnd',
	  'trimCharsStart': 'trimStart',
	  'zipAll': 'zip'
	};
	
	/** Used to track methods that skip fixing their arity. */
	exports.skipFixed = {
	  'castArray': true,
	  'flow': true,
	  'flowRight': true,
	  'iteratee': true,
	  'mixin': true,
	  'rearg': true,
	  'runInContext': true
	};
	
	/** Used to track methods that skip rearranging arguments. */
	exports.skipRearg = {
	  'add': true,
	  'assign': true,
	  'assignIn': true,
	  'bind': true,
	  'bindKey': true,
	  'concat': true,
	  'difference': true,
	  'divide': true,
	  'eq': true,
	  'gt': true,
	  'gte': true,
	  'isEqual': true,
	  'lt': true,
	  'lte': true,
	  'matchesProperty': true,
	  'merge': true,
	  'multiply': true,
	  'overArgs': true,
	  'partial': true,
	  'partialRight': true,
	  'propertyOf': true,
	  'random': true,
	  'range': true,
	  'rangeRight': true,
	  'subtract': true,
	  'zip': true,
	  'zipObject': true,
	  'zipObjectDeep': true
	};


/***/ }),
/* 262 */
/***/ (function(module, exports) {

	/**
	 * The default argument placeholder value for methods.
	 *
	 * @type {Object}
	 */
	module.exports = {};


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {/**
	 * @license
	 * Lodash lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE
	 */
	;(function(){function n(n,t){return n.set(t[0],t[1]),n}function t(n,t){return n.add(t),n}function r(n,t,r){switch(r.length){case 0:return n.call(t);case 1:return n.call(t,r[0]);case 2:return n.call(t,r[0],r[1]);case 3:return n.call(t,r[0],r[1],r[2])}return n.apply(t,r)}function e(n,t,r,e){for(var u=-1,i=null==n?0:n.length;++u<i;){var o=n[u];t(e,o,r(o),n)}return e}function u(n,t){for(var r=-1,e=null==n?0:n.length;++r<e&&false!==t(n[r],r,n););return n}function i(n,t){for(var r=null==n?0:n.length;r--&&false!==t(n[r],r,n););
	return n}function o(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(!t(n[r],r,n))return false;return true}function f(n,t){for(var r=-1,e=null==n?0:n.length,u=0,i=[];++r<e;){var o=n[r];t(o,r,n)&&(i[u++]=o)}return i}function c(n,t){return!(null==n||!n.length)&&-1<d(n,t,0)}function a(n,t,r){for(var e=-1,u=null==n?0:n.length;++e<u;)if(r(t,n[e]))return true;return false}function l(n,t){for(var r=-1,e=null==n?0:n.length,u=Array(e);++r<e;)u[r]=t(n[r],r,n);return u}function s(n,t){for(var r=-1,e=t.length,u=n.length;++r<e;)n[u+r]=t[r];
	return n}function h(n,t,r,e){var u=-1,i=null==n?0:n.length;for(e&&i&&(r=n[++u]);++u<i;)r=t(r,n[u],u,n);return r}function p(n,t,r,e){var u=null==n?0:n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r}function _(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(t(n[r],r,n))return true;return false}function v(n,t,r){var e;return r(n,function(n,r,u){if(t(n,r,u))return e=r,false}),e}function g(n,t,r,e){var u=n.length;for(r+=e?1:-1;e?r--:++r<u;)if(t(n[r],r,n))return r;return-1}function d(n,t,r){if(t===t)n:{
	--r;for(var e=n.length;++r<e;)if(n[r]===t){n=r;break n}n=-1}else n=g(n,b,r);return n}function y(n,t,r,e){--r;for(var u=n.length;++r<u;)if(e(n[r],t))return r;return-1}function b(n){return n!==n}function x(n,t){var r=null==n?0:n.length;return r?k(n,t)/r:P}function j(n){return function(t){return null==t?F:t[n]}}function w(n){return function(t){return null==n?F:n[t]}}function m(n,t,r,e,u){return u(n,function(n,u,i){r=e?(e=false,n):t(r,n,u,i)}),r}function A(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].c;
	return n}function k(n,t){for(var r,e=-1,u=n.length;++e<u;){var i=t(n[e]);i!==F&&(r=r===F?i:r+i)}return r}function E(n,t){for(var r=-1,e=Array(n);++r<n;)e[r]=t(r);return e}function O(n,t){return l(t,function(t){return[t,n[t]]})}function S(n){return function(t){return n(t)}}function I(n,t){return l(t,function(t){return n[t]})}function R(n,t){return n.has(t)}function z(n,t){for(var r=-1,e=n.length;++r<e&&-1<d(t,n[r],0););return r}function W(n,t){for(var r=n.length;r--&&-1<d(t,n[r],0););return r}function B(n){
	return"\\"+Tn[n]}function L(n){var t=-1,r=Array(n.size);return n.forEach(function(n,e){r[++t]=[e,n]}),r}function U(n,t){return function(r){return n(t(r))}}function C(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r];o!==t&&"__lodash_placeholder__"!==o||(n[r]="__lodash_placeholder__",i[u++]=r)}return i}function D(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=n}),r}function M(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=[n,n]}),r}function T(n){if(Bn.test(n)){
	for(var t=zn.lastIndex=0;zn.test(n);)++t;n=t}else n=tt(n);return n}function $(n){return Bn.test(n)?n.match(zn)||[]:n.split("")}var F,N=1/0,P=NaN,Z=[["ary",128],["bind",1],["bindKey",2],["curry",8],["curryRight",16],["flip",512],["partial",32],["partialRight",64],["rearg",256]],q=/\b__p\+='';/g,V=/\b(__p\+=)''\+/g,K=/(__e\(.*?\)|\b__t\))\+'';/g,G=/&(?:amp|lt|gt|quot|#39);/g,H=/[&<>"']/g,J=RegExp(G.source),Y=RegExp(H.source),Q=/<%-([\s\S]+?)%>/g,X=/<%([\s\S]+?)%>/g,nn=/<%=([\s\S]+?)%>/g,tn=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,rn=/^\w*$/,en=/^\./,un=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,on=/[\\^$.*+?()[\]{}|]/g,fn=RegExp(on.source),cn=/^\s+|\s+$/g,an=/^\s+/,ln=/\s+$/,sn=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,hn=/\{\n\/\* \[wrapped with (.+)\] \*/,pn=/,? & /,_n=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,vn=/\\(\\)?/g,gn=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,dn=/\w*$/,yn=/^[-+]0x[0-9a-f]+$/i,bn=/^0b[01]+$/i,xn=/^\[object .+?Constructor\]$/,jn=/^0o[0-7]+$/i,wn=/^(?:0|[1-9]\d*)$/,mn=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,An=/($^)/,kn=/['\n\r\u2028\u2029\\]/g,En="[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?)*",On="(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])"+En,Sn="(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]?|[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])",In=RegExp("['\u2019]","g"),Rn=RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]","g"),zn=RegExp("\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|"+Sn+En,"g"),Wn=RegExp(["[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+(?:['\u2019](?:d|ll|m|re|s|t|ve))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde]|$)|(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde](?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])|$)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?(?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:d|ll|m|re|s|t|ve))?|[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?|\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)|\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)|\\d+",On].join("|"),"g"),Bn=RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"),Ln=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,Un="Array Buffer DataView Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Math Object Promise RegExp Set String Symbol TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap _ clearTimeout isFinite parseInt setTimeout".split(" "),Cn={};
	Cn["[object Float32Array]"]=Cn["[object Float64Array]"]=Cn["[object Int8Array]"]=Cn["[object Int16Array]"]=Cn["[object Int32Array]"]=Cn["[object Uint8Array]"]=Cn["[object Uint8ClampedArray]"]=Cn["[object Uint16Array]"]=Cn["[object Uint32Array]"]=true,Cn["[object Arguments]"]=Cn["[object Array]"]=Cn["[object ArrayBuffer]"]=Cn["[object Boolean]"]=Cn["[object DataView]"]=Cn["[object Date]"]=Cn["[object Error]"]=Cn["[object Function]"]=Cn["[object Map]"]=Cn["[object Number]"]=Cn["[object Object]"]=Cn["[object RegExp]"]=Cn["[object Set]"]=Cn["[object String]"]=Cn["[object WeakMap]"]=false;
	var Dn={};Dn["[object Arguments]"]=Dn["[object Array]"]=Dn["[object ArrayBuffer]"]=Dn["[object DataView]"]=Dn["[object Boolean]"]=Dn["[object Date]"]=Dn["[object Float32Array]"]=Dn["[object Float64Array]"]=Dn["[object Int8Array]"]=Dn["[object Int16Array]"]=Dn["[object Int32Array]"]=Dn["[object Map]"]=Dn["[object Number]"]=Dn["[object Object]"]=Dn["[object RegExp]"]=Dn["[object Set]"]=Dn["[object String]"]=Dn["[object Symbol]"]=Dn["[object Uint8Array]"]=Dn["[object Uint8ClampedArray]"]=Dn["[object Uint16Array]"]=Dn["[object Uint32Array]"]=true,
	Dn["[object Error]"]=Dn["[object Function]"]=Dn["[object WeakMap]"]=false;var Mn,Tn={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},$n=parseFloat,Fn=parseInt,Nn=typeof global=="object"&&global&&global.Object===Object&&global,Pn=typeof self=="object"&&self&&self.Object===Object&&self,Zn=Nn||Pn||Function("return this")(),qn=typeof exports=="object"&&exports&&!exports.nodeType&&exports,Vn=qn&&typeof module=="object"&&module&&!module.nodeType&&module,Kn=Vn&&Vn.exports===qn,Gn=Kn&&Nn.process;
	n:{try{Mn=Gn&&Gn.binding&&Gn.binding("util");break n}catch(n){}Mn=void 0}var Hn=Mn&&Mn.isArrayBuffer,Jn=Mn&&Mn.isDate,Yn=Mn&&Mn.isMap,Qn=Mn&&Mn.isRegExp,Xn=Mn&&Mn.isSet,nt=Mn&&Mn.isTypedArray,tt=j("length"),rt=w({"\xc0":"A","\xc1":"A","\xc2":"A","\xc3":"A","\xc4":"A","\xc5":"A","\xe0":"a","\xe1":"a","\xe2":"a","\xe3":"a","\xe4":"a","\xe5":"a","\xc7":"C","\xe7":"c","\xd0":"D","\xf0":"d","\xc8":"E","\xc9":"E","\xca":"E","\xcb":"E","\xe8":"e","\xe9":"e","\xea":"e","\xeb":"e","\xcc":"I","\xcd":"I","\xce":"I",
	"\xcf":"I","\xec":"i","\xed":"i","\xee":"i","\xef":"i","\xd1":"N","\xf1":"n","\xd2":"O","\xd3":"O","\xd4":"O","\xd5":"O","\xd6":"O","\xd8":"O","\xf2":"o","\xf3":"o","\xf4":"o","\xf5":"o","\xf6":"o","\xf8":"o","\xd9":"U","\xda":"U","\xdb":"U","\xdc":"U","\xf9":"u","\xfa":"u","\xfb":"u","\xfc":"u","\xdd":"Y","\xfd":"y","\xff":"y","\xc6":"Ae","\xe6":"ae","\xde":"Th","\xfe":"th","\xdf":"ss","\u0100":"A","\u0102":"A","\u0104":"A","\u0101":"a","\u0103":"a","\u0105":"a","\u0106":"C","\u0108":"C","\u010a":"C",
	"\u010c":"C","\u0107":"c","\u0109":"c","\u010b":"c","\u010d":"c","\u010e":"D","\u0110":"D","\u010f":"d","\u0111":"d","\u0112":"E","\u0114":"E","\u0116":"E","\u0118":"E","\u011a":"E","\u0113":"e","\u0115":"e","\u0117":"e","\u0119":"e","\u011b":"e","\u011c":"G","\u011e":"G","\u0120":"G","\u0122":"G","\u011d":"g","\u011f":"g","\u0121":"g","\u0123":"g","\u0124":"H","\u0126":"H","\u0125":"h","\u0127":"h","\u0128":"I","\u012a":"I","\u012c":"I","\u012e":"I","\u0130":"I","\u0129":"i","\u012b":"i","\u012d":"i",
	"\u012f":"i","\u0131":"i","\u0134":"J","\u0135":"j","\u0136":"K","\u0137":"k","\u0138":"k","\u0139":"L","\u013b":"L","\u013d":"L","\u013f":"L","\u0141":"L","\u013a":"l","\u013c":"l","\u013e":"l","\u0140":"l","\u0142":"l","\u0143":"N","\u0145":"N","\u0147":"N","\u014a":"N","\u0144":"n","\u0146":"n","\u0148":"n","\u014b":"n","\u014c":"O","\u014e":"O","\u0150":"O","\u014d":"o","\u014f":"o","\u0151":"o","\u0154":"R","\u0156":"R","\u0158":"R","\u0155":"r","\u0157":"r","\u0159":"r","\u015a":"S","\u015c":"S",
	"\u015e":"S","\u0160":"S","\u015b":"s","\u015d":"s","\u015f":"s","\u0161":"s","\u0162":"T","\u0164":"T","\u0166":"T","\u0163":"t","\u0165":"t","\u0167":"t","\u0168":"U","\u016a":"U","\u016c":"U","\u016e":"U","\u0170":"U","\u0172":"U","\u0169":"u","\u016b":"u","\u016d":"u","\u016f":"u","\u0171":"u","\u0173":"u","\u0174":"W","\u0175":"w","\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017b":"Z","\u017d":"Z","\u017a":"z","\u017c":"z","\u017e":"z","\u0132":"IJ","\u0133":"ij","\u0152":"Oe","\u0153":"oe",
	"\u0149":"'n","\u017f":"s"}),et=w({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}),ut=w({"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"}),it=function w(En){function On(n){if(xu(n)&&!af(n)&&!(n instanceof Mn)){if(n instanceof zn)return n;if(ci.call(n,"__wrapped__"))return Pe(n)}return new zn(n)}function Sn(){}function zn(n,t){this.__wrapped__=n,this.__actions__=[],this.__chain__=!!t,this.__index__=0,this.__values__=F}function Mn(n){this.__wrapped__=n,this.__actions__=[],this.__dir__=1,
	this.__filtered__=false,this.__iteratees__=[],this.__takeCount__=4294967295,this.__views__=[]}function Tn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Nn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Pn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function qn(n){var t=-1,r=null==n?0:n.length;for(this.__data__=new Pn;++t<r;)this.add(n[t])}function Vn(n){
	this.size=(this.__data__=new Nn(n)).size}function Gn(n,t){var r,e=af(n),u=!e&&cf(n),i=!e&&!u&&sf(n),o=!e&&!u&&!i&&gf(n),u=(e=e||u||i||o)?E(n.length,ri):[],f=u.length;for(r in n)!t&&!ci.call(n,r)||e&&("length"==r||i&&("offset"==r||"parent"==r)||o&&("buffer"==r||"byteLength"==r||"byteOffset"==r)||Re(r,f))||u.push(r);return u}function tt(n){var t=n.length;return t?n[cr(0,t-1)]:F}function ot(n,t){return Te(Mr(n),gt(t,0,n.length))}function ft(n){return Te(Mr(n))}function ct(n,t,r){(r===F||hu(n[t],r))&&(r!==F||t in n)||_t(n,t,r);
	}function at(n,t,r){var e=n[t];ci.call(n,t)&&hu(e,r)&&(r!==F||t in n)||_t(n,t,r)}function lt(n,t){for(var r=n.length;r--;)if(hu(n[r][0],t))return r;return-1}function st(n,t,r,e){return oo(n,function(n,u,i){t(e,n,r(n),i)}),e}function ht(n,t){return n&&Tr(t,Lu(t),n)}function pt(n,t){return n&&Tr(t,Uu(t),n)}function _t(n,t,r){"__proto__"==t&&Ei?Ei(n,t,{configurable:true,enumerable:true,value:r,writable:true}):n[t]=r}function vt(n,t){for(var r=-1,e=t.length,u=Hu(e),i=null==n;++r<e;)u[r]=i?F:Wu(n,t[r]);return u;
	}function gt(n,t,r){return n===n&&(r!==F&&(n=n<=r?n:r),t!==F&&(n=n>=t?n:t)),n}function dt(n,t,r,e,i,o){var f,c=1&t,a=2&t,l=4&t;if(r&&(f=i?r(n,e,i,o):r(n)),f!==F)return f;if(!bu(n))return n;if(e=af(n)){if(f=Ee(n),!c)return Mr(n,f)}else{var s=yo(n),h="[object Function]"==s||"[object GeneratorFunction]"==s;if(sf(n))return Wr(n,c);if("[object Object]"==s||"[object Arguments]"==s||h&&!i){if(f=a||h?{}:Oe(n),!c)return a?Fr(n,pt(f,n)):$r(n,ht(f,n))}else{if(!Dn[s])return i?n:{};f=Se(n,s,dt,c)}}if(o||(o=new Vn),
	i=o.get(n))return i;o.set(n,f);var a=l?a?ye:de:a?Uu:Lu,p=e?F:a(n);return u(p||n,function(e,u){p&&(u=e,e=n[u]),at(f,u,dt(e,t,r,u,n,o))}),f}function yt(n){var t=Lu(n);return function(r){return bt(r,n,t)}}function bt(n,t,r){var e=r.length;if(null==n)return!e;for(n=ni(n);e--;){var u=r[e],i=t[u],o=n[u];if(o===F&&!(u in n)||!i(o))return false}return true}function xt(n,t,r){if(typeof n!="function")throw new ei("Expected a function");return jo(function(){n.apply(F,r)},t)}function jt(n,t,r,e){var u=-1,i=c,o=true,f=n.length,s=[],h=t.length;
	if(!f)return s;r&&(t=l(t,S(r))),e?(i=a,o=false):200<=t.length&&(i=R,o=false,t=new qn(t));n:for(;++u<f;){var p=n[u],_=null==r?p:r(p),p=e||0!==p?p:0;if(o&&_===_){for(var v=h;v--;)if(t[v]===_)continue n;s.push(p)}else i(t,_,e)||s.push(p)}return s}function wt(n,t){var r=true;return oo(n,function(n,e,u){return r=!!t(n,e,u)}),r}function mt(n,t,r){for(var e=-1,u=n.length;++e<u;){var i=n[e],o=t(i);if(null!=o&&(f===F?o===o&&!Au(o):r(o,f)))var f=o,c=i}return c}function At(n,t){var r=[];return oo(n,function(n,e,u){
	t(n,e,u)&&r.push(n)}),r}function kt(n,t,r,e,u){var i=-1,o=n.length;for(r||(r=Ie),u||(u=[]);++i<o;){var f=n[i];0<t&&r(f)?1<t?kt(f,t-1,r,e,u):s(u,f):e||(u[u.length]=f)}return u}function Et(n,t){return n&&co(n,t,Lu)}function Ot(n,t){return n&&ao(n,t,Lu)}function St(n,t){return f(t,function(t){return gu(n[t])})}function It(n,t){t=Rr(t,n);for(var r=0,e=t.length;null!=n&&r<e;)n=n[$e(t[r++])];return r&&r==e?n:F}function Rt(n,t,r){return t=t(n),af(n)?t:s(t,r(n))}function zt(n){if(null==n)n=n===F?"[object Undefined]":"[object Null]";else if(ki&&ki in ni(n)){
	var t=ci.call(n,ki),r=n[ki];try{n[ki]=F;var e=true}catch(n){}var u=si.call(n);e&&(t?n[ki]=r:delete n[ki]),n=u}else n=si.call(n);return n}function Wt(n,t){return n>t}function Bt(n,t){return null!=n&&ci.call(n,t)}function Lt(n,t){return null!=n&&t in ni(n)}function Ut(n,t,r){for(var e=r?a:c,u=n[0].length,i=n.length,o=i,f=Hu(i),s=1/0,h=[];o--;){var p=n[o];o&&t&&(p=l(p,S(t))),s=Mi(p.length,s),f[o]=!r&&(t||120<=u&&120<=p.length)?new qn(o&&p):F}var p=n[0],_=-1,v=f[0];n:for(;++_<u&&h.length<s;){var g=p[_],d=t?t(g):g,g=r||0!==g?g:0;
	if(v?!R(v,d):!e(h,d,r)){for(o=i;--o;){var y=f[o];if(y?!R(y,d):!e(n[o],d,r))continue n}v&&v.push(d),h.push(g)}}return h}function Ct(n,t,r){var e={};return Et(n,function(n,u,i){t(e,r(n),u,i)}),e}function Dt(n,t,e){return t=Rr(t,n),n=2>t.length?n:It(n,vr(t,0,-1)),t=null==n?n:n[$e(Ge(t))],null==t?F:r(t,n,e)}function Mt(n){return xu(n)&&"[object Arguments]"==zt(n)}function Tt(n){return xu(n)&&"[object ArrayBuffer]"==zt(n)}function $t(n){return xu(n)&&"[object Date]"==zt(n)}function Ft(n,t,r,e,u){if(n===t)t=true;else if(null==n||null==t||!xu(n)&&!xu(t))t=n!==n&&t!==t;else n:{
	var i=af(n),o=af(t),f=i?"[object Array]":yo(n),c=o?"[object Array]":yo(t),f="[object Arguments]"==f?"[object Object]":f,c="[object Arguments]"==c?"[object Object]":c,a="[object Object]"==f,o="[object Object]"==c;if((c=f==c)&&sf(n)){if(!sf(t)){t=false;break n}i=true,a=false}if(c&&!a)u||(u=new Vn),t=i||gf(n)?_e(n,t,r,e,Ft,u):ve(n,t,f,r,e,Ft,u);else{if(!(1&r)&&(i=a&&ci.call(n,"__wrapped__"),f=o&&ci.call(t,"__wrapped__"),i||f)){n=i?n.value():n,t=f?t.value():t,u||(u=new Vn),t=Ft(n,t,r,e,u);break n}if(c)t:if(u||(u=new Vn),
	i=1&r,f=de(n),o=f.length,c=de(t).length,o==c||i){for(a=o;a--;){var l=f[a];if(!(i?l in t:ci.call(t,l))){t=false;break t}}if((c=u.get(n))&&u.get(t))t=c==t;else{c=true,u.set(n,t),u.set(t,n);for(var s=i;++a<o;){var l=f[a],h=n[l],p=t[l];if(e)var _=i?e(p,h,l,t,n,u):e(h,p,l,n,t,u);if(_===F?h!==p&&!Ft(h,p,r,e,u):!_){c=false;break}s||(s="constructor"==l)}c&&!s&&(r=n.constructor,e=t.constructor,r!=e&&"constructor"in n&&"constructor"in t&&!(typeof r=="function"&&r instanceof r&&typeof e=="function"&&e instanceof e)&&(c=false)),
	u.delete(n),u.delete(t),t=c}}else t=false;else t=false}}return t}function Nt(n){return xu(n)&&"[object Map]"==yo(n)}function Pt(n,t,r,e){var u=r.length,i=u,o=!e;if(null==n)return!i;for(n=ni(n);u--;){var f=r[u];if(o&&f[2]?f[1]!==n[f[0]]:!(f[0]in n))return false}for(;++u<i;){var f=r[u],c=f[0],a=n[c],l=f[1];if(o&&f[2]){if(a===F&&!(c in n))return false}else{if(f=new Vn,e)var s=e(a,l,c,n,t,f);if(s===F?!Ft(l,a,3,e,f):!s)return false}}return true}function Zt(n){return!(!bu(n)||li&&li in n)&&(gu(n)?_i:xn).test(Fe(n))}function qt(n){
	return xu(n)&&"[object RegExp]"==zt(n)}function Vt(n){return xu(n)&&"[object Set]"==yo(n)}function Kt(n){return xu(n)&&yu(n.length)&&!!Cn[zt(n)]}function Gt(n){return typeof n=="function"?n:null==n?Nu:typeof n=="object"?af(n)?Xt(n[0],n[1]):Qt(n):Vu(n)}function Ht(n){if(!Le(n))return Ci(n);var t,r=[];for(t in ni(n))ci.call(n,t)&&"constructor"!=t&&r.push(t);return r}function Jt(n,t){return n<t}function Yt(n,t){var r=-1,e=pu(n)?Hu(n.length):[];return oo(n,function(n,u,i){e[++r]=t(n,u,i)}),e}function Qt(n){
	var t=me(n);return 1==t.length&&t[0][2]?Ue(t[0][0],t[0][1]):function(r){return r===n||Pt(r,n,t)}}function Xt(n,t){return We(n)&&t===t&&!bu(t)?Ue($e(n),t):function(r){var e=Wu(r,n);return e===F&&e===t?Bu(r,n):Ft(t,e,3)}}function nr(n,t,r,e,u){n!==t&&co(t,function(i,o){if(bu(i)){u||(u=new Vn);var f=u,c=n[o],a=t[o],l=f.get(a);if(l)ct(n,o,l);else{var l=e?e(c,a,o+"",n,t,f):F,s=l===F;if(s){var h=af(a),p=!h&&sf(a),_=!h&&!p&&gf(a),l=a;h||p||_?af(c)?l=c:_u(c)?l=Mr(c):p?(s=false,l=Wr(a,true)):_?(s=false,l=Lr(a,true)):l=[]:wu(a)||cf(a)?(l=c,
	cf(c)?l=Ru(c):(!bu(c)||r&&gu(c))&&(l=Oe(a))):s=false}s&&(f.set(a,l),nr(l,a,r,e,f),f.delete(a)),ct(n,o,l)}}else f=e?e(n[o],i,o+"",n,t,u):F,f===F&&(f=i),ct(n,o,f)},Uu)}function tr(n,t){var r=n.length;if(r)return t+=0>t?r:0,Re(t,r)?n[t]:F}function rr(n,t,r){var e=-1;return t=l(t.length?t:[Nu],S(je())),n=Yt(n,function(n){return{a:l(t,function(t){return t(n)}),b:++e,c:n}}),A(n,function(n,t){var e;n:{e=-1;for(var u=n.a,i=t.a,o=u.length,f=r.length;++e<o;){var c=Ur(u[e],i[e]);if(c){e=e>=f?c:c*("desc"==r[e]?-1:1);
	break n}}e=n.b-t.b}return e})}function er(n,t){return ur(n,t,function(t,r){return Bu(n,r)})}function ur(n,t,r){for(var e=-1,u=t.length,i={};++e<u;){var o=t[e],f=It(n,o);r(f,o)&&pr(i,Rr(o,n),f)}return i}function ir(n){return function(t){return It(t,n)}}function or(n,t,r,e){var u=e?y:d,i=-1,o=t.length,f=n;for(n===t&&(t=Mr(t)),r&&(f=l(n,S(r)));++i<o;)for(var c=0,a=t[i],a=r?r(a):a;-1<(c=u(f,a,c,e));)f!==n&&wi.call(f,c,1),wi.call(n,c,1);return n}function fr(n,t){for(var r=n?t.length:0,e=r-1;r--;){var u=t[r];
	if(r==e||u!==i){var i=u;Re(u)?wi.call(n,u,1):mr(n,u)}}}function cr(n,t){return n+zi(Fi()*(t-n+1))}function ar(n,t){var r="";if(!n||1>t||9007199254740991<t)return r;do t%2&&(r+=n),(t=zi(t/2))&&(n+=n);while(t);return r}function lr(n,t){return wo(Ce(n,t,Nu),n+"")}function sr(n){return tt(Du(n))}function hr(n,t){var r=Du(n);return Te(r,gt(t,0,r.length))}function pr(n,t,r,e){if(!bu(n))return n;t=Rr(t,n);for(var u=-1,i=t.length,o=i-1,f=n;null!=f&&++u<i;){var c=$e(t[u]),a=r;if(u!=o){var l=f[c],a=e?e(l,c,f):F;
	a===F&&(a=bu(l)?l:Re(t[u+1])?[]:{})}at(f,c,a),f=f[c]}return n}function _r(n){return Te(Du(n))}function vr(n,t,r){var e=-1,u=n.length;for(0>t&&(t=-t>u?0:u+t),r=r>u?u:r,0>r&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0,r=Hu(u);++e<u;)r[e]=n[e+t];return r}function gr(n,t){var r;return oo(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function dr(n,t,r){var e=0,u=null==n?e:n.length;if(typeof t=="number"&&t===t&&2147483647>=u){for(;e<u;){var i=e+u>>>1,o=n[i];null!==o&&!Au(o)&&(r?o<=t:o<t)?e=i+1:u=i}return u}return yr(n,t,Nu,r);
	}function yr(n,t,r,e){t=r(t);for(var u=0,i=null==n?0:n.length,o=t!==t,f=null===t,c=Au(t),a=t===F;u<i;){var l=zi((u+i)/2),s=r(n[l]),h=s!==F,p=null===s,_=s===s,v=Au(s);(o?e||_:a?_&&(e||h):f?_&&h&&(e||!p):c?_&&h&&!p&&(e||!v):p||v?0:e?s<=t:s<t)?u=l+1:i=l}return Mi(i,4294967294)}function br(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r],f=t?t(o):o;if(!r||!hu(f,c)){var c=f;i[u++]=0===o?0:o}}return i}function xr(n){return typeof n=="number"?n:Au(n)?P:+n}function jr(n){if(typeof n=="string")return n;
	if(af(n))return l(n,jr)+"";if(Au(n))return uo?uo.call(n):"";var t=n+"";return"0"==t&&1/n==-N?"-0":t}function wr(n,t,r){var e=-1,u=c,i=n.length,o=true,f=[],l=f;if(r)o=false,u=a;else if(200<=i){if(u=t?null:po(n))return D(u);o=false,u=R,l=new qn}else l=t?[]:f;n:for(;++e<i;){var s=n[e],h=t?t(s):s,s=r||0!==s?s:0;if(o&&h===h){for(var p=l.length;p--;)if(l[p]===h)continue n;t&&l.push(h),f.push(s)}else u(l,h,r)||(l!==f&&l.push(h),f.push(s))}return f}function mr(n,t){return t=Rr(t,n),n=2>t.length?n:It(n,vr(t,0,-1)),
	null==n||delete n[$e(Ge(t))]}function Ar(n,t,r,e){for(var u=n.length,i=e?u:-1;(e?i--:++i<u)&&t(n[i],i,n););return r?vr(n,e?0:i,e?i+1:u):vr(n,e?i+1:0,e?u:i)}function kr(n,t){var r=n;return r instanceof Mn&&(r=r.value()),h(t,function(n,t){return t.func.apply(t.thisArg,s([n],t.args))},r)}function Er(n,t,r){var e=n.length;if(2>e)return e?wr(n[0]):[];for(var u=-1,i=Hu(e);++u<e;)for(var o=n[u],f=-1;++f<e;)f!=u&&(i[u]=jt(i[u]||o,n[f],t,r));return wr(kt(i,1),t,r)}function Or(n,t,r){for(var e=-1,u=n.length,i=t.length,o={};++e<u;)r(o,n[e],e<i?t[e]:F);
	return o}function Sr(n){return _u(n)?n:[]}function Ir(n){return typeof n=="function"?n:Nu}function Rr(n,t){return af(n)?n:We(n,t)?[n]:mo(zu(n))}function zr(n,t,r){var e=n.length;return r=r===F?e:r,!t&&r>=e?n:vr(n,t,r)}function Wr(n,t){if(t)return n.slice();var r=n.length,r=yi?yi(r):new n.constructor(r);return n.copy(r),r}function Br(n){var t=new n.constructor(n.byteLength);return new di(t).set(new di(n)),t}function Lr(n,t){return new n.constructor(t?Br(n.buffer):n.buffer,n.byteOffset,n.length)}function Ur(n,t){
	if(n!==t){var r=n!==F,e=null===n,u=n===n,i=Au(n),o=t!==F,f=null===t,c=t===t,a=Au(t);if(!f&&!a&&!i&&n>t||i&&o&&c&&!f&&!a||e&&o&&c||!r&&c||!u)return 1;if(!e&&!i&&!a&&n<t||a&&r&&u&&!e&&!i||f&&r&&u||!o&&u||!c)return-1}return 0}function Cr(n,t,r,e){var u=-1,i=n.length,o=r.length,f=-1,c=t.length,a=Di(i-o,0),l=Hu(c+a);for(e=!e;++f<c;)l[f]=t[f];for(;++u<o;)(e||u<i)&&(l[r[u]]=n[u]);for(;a--;)l[f++]=n[u++];return l}function Dr(n,t,r,e){var u=-1,i=n.length,o=-1,f=r.length,c=-1,a=t.length,l=Di(i-f,0),s=Hu(l+a);
	for(e=!e;++u<l;)s[u]=n[u];for(l=u;++c<a;)s[l+c]=t[c];for(;++o<f;)(e||u<i)&&(s[l+r[o]]=n[u++]);return s}function Mr(n,t){var r=-1,e=n.length;for(t||(t=Hu(e));++r<e;)t[r]=n[r];return t}function Tr(n,t,r,e){var u=!r;r||(r={});for(var i=-1,o=t.length;++i<o;){var f=t[i],c=e?e(r[f],n[f],f,r,n):F;c===F&&(c=n[f]),u?_t(r,f,c):at(r,f,c)}return r}function $r(n,t){return Tr(n,vo(n),t)}function Fr(n,t){return Tr(n,go(n),t)}function Nr(n,t){return function(r,u){var i=af(r)?e:st,o=t?t():{};return i(r,n,je(u,2),o);
	}}function Pr(n){return lr(function(t,r){var e=-1,u=r.length,i=1<u?r[u-1]:F,o=2<u?r[2]:F,i=3<n.length&&typeof i=="function"?(u--,i):F;for(o&&ze(r[0],r[1],o)&&(i=3>u?F:i,u=1),t=ni(t);++e<u;)(o=r[e])&&n(t,o,e,i);return t})}function Zr(n,t){return function(r,e){if(null==r)return r;if(!pu(r))return n(r,e);for(var u=r.length,i=t?u:-1,o=ni(r);(t?i--:++i<u)&&false!==e(o[i],i,o););return r}}function qr(n){return function(t,r,e){var u=-1,i=ni(t);e=e(t);for(var o=e.length;o--;){var f=e[n?o:++u];if(false===r(i[f],f,i))break;
	}return t}}function Vr(n,t,r){function e(){return(this&&this!==Zn&&this instanceof e?i:n).apply(u?r:this,arguments)}var u=1&t,i=Hr(n);return e}function Kr(n){return function(t){t=zu(t);var r=Bn.test(t)?$(t):F,e=r?r[0]:t.charAt(0);return t=r?zr(r,1).join(""):t.slice(1),e[n]()+t}}function Gr(n){return function(t){return h($u(Tu(t).replace(In,"")),n,"")}}function Hr(n){return function(){var t=arguments;switch(t.length){case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:
	return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:return new n(t[0],t[1],t[2],t[3],t[4]);case 6:return new n(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new n(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var r=io(n.prototype),t=n.apply(r,t);return bu(t)?t:r}}function Jr(n,t,e){function u(){for(var o=arguments.length,f=Hu(o),c=o,a=xe(u);c--;)f[c]=arguments[c];return c=3>o&&f[0]!==a&&f[o-1]!==a?[]:C(f,a),o-=c.length,o<e?fe(n,t,Xr,u.placeholder,F,f,c,F,F,e-o):r(this&&this!==Zn&&this instanceof u?i:n,this,f);
	}var i=Hr(n);return u}function Yr(n){return function(t,r,e){var u=ni(t);if(!pu(t)){var i=je(r,3);t=Lu(t),r=function(n){return i(u[n],n,u)}}return r=n(t,r,e),-1<r?u[i?t[r]:r]:F}}function Qr(n){return ge(function(t){var r=t.length,e=r,u=zn.prototype.thru;for(n&&t.reverse();e--;){var i=t[e];if(typeof i!="function")throw new ei("Expected a function");if(u&&!o&&"wrapper"==be(i))var o=new zn([],true)}for(e=o?e:r;++e<r;)var i=t[e],u=be(i),f="wrapper"==u?_o(i):F,o=f&&Be(f[0])&&424==f[1]&&!f[4].length&&1==f[9]?o[be(f[0])].apply(o,f[3]):1==i.length&&Be(i)?o[u]():o.thru(i);
	return function(){var n=arguments,e=n[0];if(o&&1==n.length&&af(e))return o.plant(e).value();for(var u=0,n=r?t[u].apply(this,n):e;++u<r;)n=t[u].call(this,n);return n}})}function Xr(n,t,r,e,u,i,o,f,c,a){function l(){for(var d=arguments.length,y=Hu(d),b=d;b--;)y[b]=arguments[b];if(_){var x,j=xe(l),b=y.length;for(x=0;b--;)y[b]===j&&++x}if(e&&(y=Cr(y,e,u,_)),i&&(y=Dr(y,i,o,_)),d-=x,_&&d<a)return j=C(y,j),fe(n,t,Xr,l.placeholder,r,y,j,f,c,a-d);if(j=h?r:this,b=p?j[n]:n,d=y.length,f){x=y.length;for(var w=Mi(f.length,x),m=Mr(y);w--;){
	var A=f[w];y[w]=Re(A,x)?m[A]:F}}else v&&1<d&&y.reverse();return s&&c<d&&(y.length=c),this&&this!==Zn&&this instanceof l&&(b=g||Hr(b)),b.apply(j,y)}var s=128&t,h=1&t,p=2&t,_=24&t,v=512&t,g=p?F:Hr(n);return l}function ne(n,t){return function(r,e){return Ct(r,n,t(e))}}function te(n,t){return function(r,e){var u;if(r===F&&e===F)return t;if(r!==F&&(u=r),e!==F){if(u===F)return e;typeof r=="string"||typeof e=="string"?(r=jr(r),e=jr(e)):(r=xr(r),e=xr(e)),u=n(r,e)}return u}}function re(n){return ge(function(t){
	return t=l(t,S(je())),lr(function(e){var u=this;return n(t,function(n){return r(n,u,e)})})})}function ee(n,t){t=t===F?" ":jr(t);var r=t.length;return 2>r?r?ar(t,n):t:(r=ar(t,Ri(n/T(t))),Bn.test(t)?zr($(r),0,n).join(""):r.slice(0,n))}function ue(n,t,e,u){function i(){for(var t=-1,c=arguments.length,a=-1,l=u.length,s=Hu(l+c),h=this&&this!==Zn&&this instanceof i?f:n;++a<l;)s[a]=u[a];for(;c--;)s[a++]=arguments[++t];return r(h,o?e:this,s)}var o=1&t,f=Hr(n);return i}function ie(n){return function(t,r,e){
	e&&typeof e!="number"&&ze(t,r,e)&&(r=e=F),t=Eu(t),r===F?(r=t,t=0):r=Eu(r),e=e===F?t<r?1:-1:Eu(e);var u=-1;r=Di(Ri((r-t)/(e||1)),0);for(var i=Hu(r);r--;)i[n?r:++u]=t,t+=e;return i}}function oe(n){return function(t,r){return typeof t=="string"&&typeof r=="string"||(t=Iu(t),r=Iu(r)),n(t,r)}}function fe(n,t,r,e,u,i,o,f,c,a){var l=8&t,s=l?o:F;o=l?F:o;var h=l?i:F;return i=l?F:i,t=(t|(l?32:64))&~(l?64:32),4&t||(t&=-4),u=[n,t,u,h,s,i,o,f,c,a],r=r.apply(F,u),Be(n)&&xo(r,u),r.placeholder=e,De(r,n,t)}function ce(n){
	var t=Xu[n];return function(n,r){if(n=Iu(n),r=null==r?0:Mi(Ou(r),292)){var e=(zu(n)+"e").split("e"),e=t(e[0]+"e"+(+e[1]+r)),e=(zu(e)+"e").split("e");return+(e[0]+"e"+(+e[1]-r))}return t(n)}}function ae(n){return function(t){var r=yo(t);return"[object Map]"==r?L(t):"[object Set]"==r?M(t):O(t,n(t))}}function le(n,t,r,e,u,i,o,f){var c=2&t;if(!c&&typeof n!="function")throw new ei("Expected a function");var a=e?e.length:0;if(a||(t&=-97,e=u=F),o=o===F?o:Di(Ou(o),0),f=f===F?f:Ou(f),a-=u?u.length:0,64&t){
	var l=e,s=u;e=u=F}var h=c?F:_o(n);return i=[n,t,r,e,u,l,s,i,o,f],h&&(r=i[1],n=h[1],t=r|n,e=128==n&&8==r||128==n&&256==r&&i[7].length<=h[8]||384==n&&h[7].length<=h[8]&&8==r,131>t||e)&&(1&n&&(i[2]=h[2],t|=1&r?0:4),(r=h[3])&&(e=i[3],i[3]=e?Cr(e,r,h[4]):r,i[4]=e?C(i[3],"__lodash_placeholder__"):h[4]),(r=h[5])&&(e=i[5],i[5]=e?Dr(e,r,h[6]):r,i[6]=e?C(i[5],"__lodash_placeholder__"):h[6]),(r=h[7])&&(i[7]=r),128&n&&(i[8]=null==i[8]?h[8]:Mi(i[8],h[8])),null==i[9]&&(i[9]=h[9]),i[0]=h[0],i[1]=t),n=i[0],t=i[1],
	r=i[2],e=i[3],u=i[4],f=i[9]=i[9]===F?c?0:n.length:Di(i[9]-a,0),!f&&24&t&&(t&=-25),De((h?lo:xo)(t&&1!=t?8==t||16==t?Jr(n,t,f):32!=t&&33!=t||u.length?Xr.apply(F,i):ue(n,t,r,e):Vr(n,t,r),i),n,t)}function se(n,t,r,e){return n===F||hu(n,ii[r])&&!ci.call(e,r)?t:n}function he(n,t,r,e,u,i){return bu(n)&&bu(t)&&(i.set(t,n),nr(n,t,F,he,i),i.delete(t)),n}function pe(n){return wu(n)?F:n}function _e(n,t,r,e,u,i){var o=1&r,f=n.length,c=t.length;if(f!=c&&!(o&&c>f))return false;if((c=i.get(n))&&i.get(t))return c==t;var c=-1,a=true,l=2&r?new qn:F;
	for(i.set(n,t),i.set(t,n);++c<f;){var s=n[c],h=t[c];if(e)var p=o?e(h,s,c,t,n,i):e(s,h,c,n,t,i);if(p!==F){if(p)continue;a=false;break}if(l){if(!_(t,function(n,t){if(!R(l,t)&&(s===n||u(s,n,r,e,i)))return l.push(t)})){a=false;break}}else if(s!==h&&!u(s,h,r,e,i)){a=false;break}}return i.delete(n),i.delete(t),a}function ve(n,t,r,e,u,i,o){switch(r){case"[object DataView]":if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)break;n=n.buffer,t=t.buffer;case"[object ArrayBuffer]":if(n.byteLength!=t.byteLength||!i(new di(n),new di(t)))break;
	return true;case"[object Boolean]":case"[object Date]":case"[object Number]":return hu(+n,+t);case"[object Error]":return n.name==t.name&&n.message==t.message;case"[object RegExp]":case"[object String]":return n==t+"";case"[object Map]":var f=L;case"[object Set]":if(f||(f=D),n.size!=t.size&&!(1&e))break;return(r=o.get(n))?r==t:(e|=2,o.set(n,t),t=_e(f(n),f(t),e,u,i,o),o.delete(n),t);case"[object Symbol]":if(eo)return eo.call(n)==eo.call(t)}return false}function ge(n){return wo(Ce(n,F,Ve),n+"")}function de(n){
	return Rt(n,Lu,vo)}function ye(n){return Rt(n,Uu,go)}function be(n){for(var t=n.name+"",r=Ji[t],e=ci.call(Ji,t)?r.length:0;e--;){var u=r[e],i=u.func;if(null==i||i==n)return u.name}return t}function xe(n){return(ci.call(On,"placeholder")?On:n).placeholder}function je(){var n=On.iteratee||Pu,n=n===Pu?Gt:n;return arguments.length?n(arguments[0],arguments[1]):n}function we(n,t){var r=n.__data__,e=typeof t;return("string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t)?r[typeof t=="string"?"string":"hash"]:r.map;
	}function me(n){for(var t=Lu(n),r=t.length;r--;){var e=t[r],u=n[e];t[r]=[e,u,u===u&&!bu(u)]}return t}function Ae(n,t){var r=null==n?F:n[t];return Zt(r)?r:F}function ke(n,t,r){t=Rr(t,n);for(var e=-1,u=t.length,i=false;++e<u;){var o=$e(t[e]);if(!(i=null!=n&&r(n,o)))break;n=n[o]}return i||++e!=u?i:(u=null==n?0:n.length,!!u&&yu(u)&&Re(o,u)&&(af(n)||cf(n)))}function Ee(n){var t=n.length,r=n.constructor(t);return t&&"string"==typeof n[0]&&ci.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function Oe(n){
	return typeof n.constructor!="function"||Le(n)?{}:io(bi(n))}function Se(r,e,u,i){var o=r.constructor;switch(e){case"[object ArrayBuffer]":return Br(r);case"[object Boolean]":case"[object Date]":return new o(+r);case"[object DataView]":return e=i?Br(r.buffer):r.buffer,new r.constructor(e,r.byteOffset,r.byteLength);case"[object Float32Array]":case"[object Float64Array]":case"[object Int8Array]":case"[object Int16Array]":case"[object Int32Array]":case"[object Uint8Array]":case"[object Uint8ClampedArray]":
	case"[object Uint16Array]":case"[object Uint32Array]":return Lr(r,i);case"[object Map]":return e=i?u(L(r),1):L(r),h(e,n,new r.constructor);case"[object Number]":case"[object String]":return new o(r);case"[object RegExp]":return e=new r.constructor(r.source,dn.exec(r)),e.lastIndex=r.lastIndex,e;case"[object Set]":return e=i?u(D(r),1):D(r),h(e,t,new r.constructor);case"[object Symbol]":return eo?ni(eo.call(r)):{}}}function Ie(n){return af(n)||cf(n)||!!(mi&&n&&n[mi])}function Re(n,t){return t=null==t?9007199254740991:t,
	!!t&&(typeof n=="number"||wn.test(n))&&-1<n&&0==n%1&&n<t}function ze(n,t,r){if(!bu(r))return false;var e=typeof t;return!!("number"==e?pu(r)&&Re(t,r.length):"string"==e&&t in r)&&hu(r[t],n)}function We(n,t){if(af(n))return false;var r=typeof n;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=n&&!Au(n))||(rn.test(n)||!tn.test(n)||null!=t&&n in ni(t))}function Be(n){var t=be(n),r=On[t];return typeof r=="function"&&t in Mn.prototype&&(n===r||(t=_o(r),!!t&&n===t[0]))}function Le(n){var t=n&&n.constructor;
	return n===(typeof t=="function"&&t.prototype||ii)}function Ue(n,t){return function(r){return null!=r&&(r[n]===t&&(t!==F||n in ni(r)))}}function Ce(n,t,e){return t=Di(t===F?n.length-1:t,0),function(){for(var u=arguments,i=-1,o=Di(u.length-t,0),f=Hu(o);++i<o;)f[i]=u[t+i];for(i=-1,o=Hu(t+1);++i<t;)o[i]=u[i];return o[t]=e(f),r(n,this,o)}}function De(n,t,r){var e=t+"";t=wo;var u,i=Ne;return u=(u=e.match(hn))?u[1].split(pn):[],r=i(u,r),(i=r.length)&&(u=i-1,r[u]=(1<i?"& ":"")+r[u],r=r.join(2<i?", ":" "),
	e=e.replace(sn,"{\n/* [wrapped with "+r+"] */\n")),t(n,e)}function Me(n){var t=0,r=0;return function(){var e=Ti(),u=16-(e-r);if(r=e,0<u){if(800<=++t)return arguments[0]}else t=0;return n.apply(F,arguments)}}function Te(n,t){var r=-1,e=n.length,u=e-1;for(t=t===F?e:t;++r<t;){var e=cr(r,u),i=n[e];n[e]=n[r],n[r]=i}return n.length=t,n}function $e(n){if(typeof n=="string"||Au(n))return n;var t=n+"";return"0"==t&&1/n==-N?"-0":t}function Fe(n){if(null!=n){try{return fi.call(n)}catch(n){}return n+""}return"";
	}function Ne(n,t){return u(Z,function(r){var e="_."+r[0];t&r[1]&&!c(n,e)&&n.push(e)}),n.sort()}function Pe(n){if(n instanceof Mn)return n.clone();var t=new zn(n.__wrapped__,n.__chain__);return t.__actions__=Mr(n.__actions__),t.__index__=n.__index__,t.__values__=n.__values__,t}function Ze(n,t,r){var e=null==n?0:n.length;return e?(r=null==r?0:Ou(r),0>r&&(r=Di(e+r,0)),g(n,je(t,3),r)):-1}function qe(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e-1;return r!==F&&(u=Ou(r),u=0>r?Di(e+u,0):Mi(u,e-1)),
	g(n,je(t,3),u,true)}function Ve(n){return(null==n?0:n.length)?kt(n,1):[]}function Ke(n){return n&&n.length?n[0]:F}function Ge(n){var t=null==n?0:n.length;return t?n[t-1]:F}function He(n,t){return n&&n.length&&t&&t.length?or(n,t):n}function Je(n){return null==n?n:Ni.call(n)}function Ye(n){if(!n||!n.length)return[];var t=0;return n=f(n,function(n){if(_u(n))return t=Di(n.length,t),true}),E(t,function(t){return l(n,j(t))})}function Qe(n,t){if(!n||!n.length)return[];var e=Ye(n);return null==t?e:l(e,function(n){
	return r(t,F,n)})}function Xe(n){return n=On(n),n.__chain__=true,n}function nu(n,t){return t(n)}function tu(){return this}function ru(n,t){return(af(n)?u:oo)(n,je(t,3))}function eu(n,t){return(af(n)?i:fo)(n,je(t,3))}function uu(n,t){return(af(n)?l:Yt)(n,je(t,3))}function iu(n,t,r){return t=r?F:t,t=n&&null==t?n.length:t,le(n,128,F,F,F,F,t)}function ou(n,t){var r;if(typeof t!="function")throw new ei("Expected a function");return n=Ou(n),function(){return 0<--n&&(r=t.apply(this,arguments)),1>=n&&(t=F),
	r}}function fu(n,t,r){return t=r?F:t,n=le(n,8,F,F,F,F,F,t),n.placeholder=fu.placeholder,n}function cu(n,t,r){return t=r?F:t,n=le(n,16,F,F,F,F,F,t),n.placeholder=cu.placeholder,n}function au(n,t,r){function e(t){var r=c,e=a;return c=a=F,_=t,s=n.apply(e,r)}function u(n){var r=n-p;return n-=_,p===F||r>=t||0>r||g&&n>=l}function i(){var n=Jo();if(u(n))return o(n);var r,e=jo;r=n-_,n=t-(n-p),r=g?Mi(n,l-r):n,h=e(i,r)}function o(n){return h=F,d&&c?e(n):(c=a=F,s)}function f(){var n=Jo(),r=u(n);if(c=arguments,
	a=this,p=n,r){if(h===F)return _=n=p,h=jo(i,t),v?e(n):s;if(g)return h=jo(i,t),e(p)}return h===F&&(h=jo(i,t)),s}var c,a,l,s,h,p,_=0,v=false,g=false,d=true;if(typeof n!="function")throw new ei("Expected a function");return t=Iu(t)||0,bu(r)&&(v=!!r.leading,l=(g="maxWait"in r)?Di(Iu(r.maxWait)||0,t):l,d="trailing"in r?!!r.trailing:d),f.cancel=function(){h!==F&&ho(h),_=0,c=p=a=h=F},f.flush=function(){return h===F?s:o(Jo())},f}function lu(n,t){function r(){var e=arguments,u=t?t.apply(this,e):e[0],i=r.cache;return i.has(u)?i.get(u):(e=n.apply(this,e),
	r.cache=i.set(u,e)||i,e)}if(typeof n!="function"||null!=t&&typeof t!="function")throw new ei("Expected a function");return r.cache=new(lu.Cache||Pn),r}function su(n){if(typeof n!="function")throw new ei("Expected a function");return function(){var t=arguments;switch(t.length){case 0:return!n.call(this);case 1:return!n.call(this,t[0]);case 2:return!n.call(this,t[0],t[1]);case 3:return!n.call(this,t[0],t[1],t[2])}return!n.apply(this,t)}}function hu(n,t){return n===t||n!==n&&t!==t}function pu(n){return null!=n&&yu(n.length)&&!gu(n);
	}function _u(n){return xu(n)&&pu(n)}function vu(n){if(!xu(n))return false;var t=zt(n);return"[object Error]"==t||"[object DOMException]"==t||typeof n.message=="string"&&typeof n.name=="string"&&!wu(n)}function gu(n){return!!bu(n)&&(n=zt(n),"[object Function]"==n||"[object GeneratorFunction]"==n||"[object AsyncFunction]"==n||"[object Proxy]"==n)}function du(n){return typeof n=="number"&&n==Ou(n)}function yu(n){return typeof n=="number"&&-1<n&&0==n%1&&9007199254740991>=n}function bu(n){var t=typeof n;return null!=n&&("object"==t||"function"==t);
	}function xu(n){return null!=n&&typeof n=="object"}function ju(n){return typeof n=="number"||xu(n)&&"[object Number]"==zt(n)}function wu(n){return!(!xu(n)||"[object Object]"!=zt(n))&&(n=bi(n),null===n||(n=ci.call(n,"constructor")&&n.constructor,typeof n=="function"&&n instanceof n&&fi.call(n)==hi))}function mu(n){return typeof n=="string"||!af(n)&&xu(n)&&"[object String]"==zt(n)}function Au(n){return typeof n=="symbol"||xu(n)&&"[object Symbol]"==zt(n)}function ku(n){if(!n)return[];if(pu(n))return mu(n)?$(n):Mr(n);
	if(Ai&&n[Ai]){n=n[Ai]();for(var t,r=[];!(t=n.next()).done;)r.push(t.value);return r}return t=yo(n),("[object Map]"==t?L:"[object Set]"==t?D:Du)(n)}function Eu(n){return n?(n=Iu(n),n===N||n===-N?1.7976931348623157e308*(0>n?-1:1):n===n?n:0):0===n?n:0}function Ou(n){n=Eu(n);var t=n%1;return n===n?t?n-t:n:0}function Su(n){return n?gt(Ou(n),0,4294967295):0}function Iu(n){if(typeof n=="number")return n;if(Au(n))return P;if(bu(n)&&(n=typeof n.valueOf=="function"?n.valueOf():n,n=bu(n)?n+"":n),typeof n!="string")return 0===n?n:+n;
	n=n.replace(cn,"");var t=bn.test(n);return t||jn.test(n)?Fn(n.slice(2),t?2:8):yn.test(n)?P:+n}function Ru(n){return Tr(n,Uu(n))}function zu(n){return null==n?"":jr(n)}function Wu(n,t,r){return n=null==n?F:It(n,t),n===F?r:n}function Bu(n,t){return null!=n&&ke(n,t,Lt)}function Lu(n){return pu(n)?Gn(n):Ht(n)}function Uu(n){if(pu(n))n=Gn(n,true);else if(bu(n)){var t,r=Le(n),e=[];for(t in n)("constructor"!=t||!r&&ci.call(n,t))&&e.push(t);n=e}else{if(t=[],null!=n)for(r in ni(n))t.push(r);n=t}return n}function Cu(n,t){
	if(null==n)return{};var r=l(ye(n),function(n){return[n]});return t=je(t),ur(n,r,function(n,r){return t(n,r[0])})}function Du(n){return null==n?[]:I(n,Lu(n))}function Mu(n){return Nf(zu(n).toLowerCase())}function Tu(n){return(n=zu(n))&&n.replace(mn,rt).replace(Rn,"")}function $u(n,t,r){return n=zu(n),t=r?F:t,t===F?Ln.test(n)?n.match(Wn)||[]:n.match(_n)||[]:n.match(t)||[]}function Fu(n){return function(){return n}}function Nu(n){return n}function Pu(n){return Gt(typeof n=="function"?n:dt(n,1))}function Zu(n,t,r){
	var e=Lu(t),i=St(t,e);null!=r||bu(t)&&(i.length||!e.length)||(r=t,t=n,n=this,i=St(t,Lu(t)));var o=!(bu(r)&&"chain"in r&&!r.chain),f=gu(n);return u(i,function(r){var e=t[r];n[r]=e,f&&(n.prototype[r]=function(){var t=this.__chain__;if(o||t){var r=n(this.__wrapped__);return(r.__actions__=Mr(this.__actions__)).push({func:e,args:arguments,thisArg:n}),r.__chain__=t,r}return e.apply(n,s([this.value()],arguments))})}),n}function qu(){}function Vu(n){return We(n)?j($e(n)):ir(n)}function Ku(){return[]}function Gu(){
	return false}En=null==En?Zn:it.defaults(Zn.Object(),En,it.pick(Zn,Un));var Hu=En.Array,Ju=En.Date,Yu=En.Error,Qu=En.Function,Xu=En.Math,ni=En.Object,ti=En.RegExp,ri=En.String,ei=En.TypeError,ui=Hu.prototype,ii=ni.prototype,oi=En["__core-js_shared__"],fi=Qu.prototype.toString,ci=ii.hasOwnProperty,ai=0,li=function(){var n=/[^.]+$/.exec(oi&&oi.keys&&oi.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:""}(),si=ii.toString,hi=fi.call(ni),pi=Zn._,_i=ti("^"+fi.call(ci).replace(on,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),vi=Kn?En.Buffer:F,gi=En.Symbol,di=En.Uint8Array,yi=vi?vi.f:F,bi=U(ni.getPrototypeOf,ni),xi=ni.create,ji=ii.propertyIsEnumerable,wi=ui.splice,mi=gi?gi.isConcatSpreadable:F,Ai=gi?gi.iterator:F,ki=gi?gi.toStringTag:F,Ei=function(){
	try{var n=Ae(ni,"defineProperty");return n({},"",{}),n}catch(n){}}(),Oi=En.clearTimeout!==Zn.clearTimeout&&En.clearTimeout,Si=Ju&&Ju.now!==Zn.Date.now&&Ju.now,Ii=En.setTimeout!==Zn.setTimeout&&En.setTimeout,Ri=Xu.ceil,zi=Xu.floor,Wi=ni.getOwnPropertySymbols,Bi=vi?vi.isBuffer:F,Li=En.isFinite,Ui=ui.join,Ci=U(ni.keys,ni),Di=Xu.max,Mi=Xu.min,Ti=Ju.now,$i=En.parseInt,Fi=Xu.random,Ni=ui.reverse,Pi=Ae(En,"DataView"),Zi=Ae(En,"Map"),qi=Ae(En,"Promise"),Vi=Ae(En,"Set"),Ki=Ae(En,"WeakMap"),Gi=Ae(ni,"create"),Hi=Ki&&new Ki,Ji={},Yi=Fe(Pi),Qi=Fe(Zi),Xi=Fe(qi),no=Fe(Vi),to=Fe(Ki),ro=gi?gi.prototype:F,eo=ro?ro.valueOf:F,uo=ro?ro.toString:F,io=function(){
	function n(){}return function(t){return bu(t)?xi?xi(t):(n.prototype=t,t=new n,n.prototype=F,t):{}}}();On.templateSettings={escape:Q,evaluate:X,interpolate:nn,variable:"",imports:{_:On}},On.prototype=Sn.prototype,On.prototype.constructor=On,zn.prototype=io(Sn.prototype),zn.prototype.constructor=zn,Mn.prototype=io(Sn.prototype),Mn.prototype.constructor=Mn,Tn.prototype.clear=function(){this.__data__=Gi?Gi(null):{},this.size=0},Tn.prototype.delete=function(n){return n=this.has(n)&&delete this.__data__[n],
	this.size-=n?1:0,n},Tn.prototype.get=function(n){var t=this.__data__;return Gi?(n=t[n],"__lodash_hash_undefined__"===n?F:n):ci.call(t,n)?t[n]:F},Tn.prototype.has=function(n){var t=this.__data__;return Gi?t[n]!==F:ci.call(t,n)},Tn.prototype.set=function(n,t){var r=this.__data__;return this.size+=this.has(n)?0:1,r[n]=Gi&&t===F?"__lodash_hash_undefined__":t,this},Nn.prototype.clear=function(){this.__data__=[],this.size=0},Nn.prototype.delete=function(n){var t=this.__data__;return n=lt(t,n),!(0>n)&&(n==t.length-1?t.pop():wi.call(t,n,1),
	--this.size,true)},Nn.prototype.get=function(n){var t=this.__data__;return n=lt(t,n),0>n?F:t[n][1]},Nn.prototype.has=function(n){return-1<lt(this.__data__,n)},Nn.prototype.set=function(n,t){var r=this.__data__,e=lt(r,n);return 0>e?(++this.size,r.push([n,t])):r[e][1]=t,this},Pn.prototype.clear=function(){this.size=0,this.__data__={hash:new Tn,map:new(Zi||Nn),string:new Tn}},Pn.prototype.delete=function(n){return n=we(this,n).delete(n),this.size-=n?1:0,n},Pn.prototype.get=function(n){return we(this,n).get(n);
	},Pn.prototype.has=function(n){return we(this,n).has(n)},Pn.prototype.set=function(n,t){var r=we(this,n),e=r.size;return r.set(n,t),this.size+=r.size==e?0:1,this},qn.prototype.add=qn.prototype.push=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this},qn.prototype.has=function(n){return this.__data__.has(n)},Vn.prototype.clear=function(){this.__data__=new Nn,this.size=0},Vn.prototype.delete=function(n){var t=this.__data__;return n=t.delete(n),this.size=t.size,n},Vn.prototype.get=function(n){
	return this.__data__.get(n)},Vn.prototype.has=function(n){return this.__data__.has(n)},Vn.prototype.set=function(n,t){var r=this.__data__;if(r instanceof Nn){var e=r.__data__;if(!Zi||199>e.length)return e.push([n,t]),this.size=++r.size,this;r=this.__data__=new Pn(e)}return r.set(n,t),this.size=r.size,this};var oo=Zr(Et),fo=Zr(Ot,true),co=qr(),ao=qr(true),lo=Hi?function(n,t){return Hi.set(n,t),n}:Nu,so=Ei?function(n,t){return Ei(n,"toString",{configurable:true,enumerable:false,value:Fu(t),writable:true})}:Nu,ho=Oi||function(n){
	return Zn.clearTimeout(n)},po=Vi&&1/D(new Vi([,-0]))[1]==N?function(n){return new Vi(n)}:qu,_o=Hi?function(n){return Hi.get(n)}:qu,vo=Wi?function(n){return null==n?[]:(n=ni(n),f(Wi(n),function(t){return ji.call(n,t)}))}:Ku,go=Wi?function(n){for(var t=[];n;)s(t,vo(n)),n=bi(n);return t}:Ku,yo=zt;(Pi&&"[object DataView]"!=yo(new Pi(new ArrayBuffer(1)))||Zi&&"[object Map]"!=yo(new Zi)||qi&&"[object Promise]"!=yo(qi.resolve())||Vi&&"[object Set]"!=yo(new Vi)||Ki&&"[object WeakMap]"!=yo(new Ki))&&(yo=function(n){
	var t=zt(n);if(n=(n="[object Object]"==t?n.constructor:F)?Fe(n):"")switch(n){case Yi:return"[object DataView]";case Qi:return"[object Map]";case Xi:return"[object Promise]";case no:return"[object Set]";case to:return"[object WeakMap]"}return t});var bo=oi?gu:Gu,xo=Me(lo),jo=Ii||function(n,t){return Zn.setTimeout(n,t)},wo=Me(so),mo=function(n){n=lu(n,function(n){return 500===t.size&&t.clear(),n});var t=n.cache;return n}(function(n){var t=[];return en.test(n)&&t.push(""),n.replace(un,function(n,r,e,u){
	t.push(e?u.replace(vn,"$1"):r||n)}),t}),Ao=lr(function(n,t){return _u(n)?jt(n,kt(t,1,_u,true)):[]}),ko=lr(function(n,t){var r=Ge(t);return _u(r)&&(r=F),_u(n)?jt(n,kt(t,1,_u,true),je(r,2)):[]}),Eo=lr(function(n,t){var r=Ge(t);return _u(r)&&(r=F),_u(n)?jt(n,kt(t,1,_u,true),F,r):[]}),Oo=lr(function(n){var t=l(n,Sr);return t.length&&t[0]===n[0]?Ut(t):[]}),So=lr(function(n){var t=Ge(n),r=l(n,Sr);return t===Ge(r)?t=F:r.pop(),r.length&&r[0]===n[0]?Ut(r,je(t,2)):[]}),Io=lr(function(n){var t=Ge(n),r=l(n,Sr);return(t=typeof t=="function"?t:F)&&r.pop(),
	r.length&&r[0]===n[0]?Ut(r,F,t):[]}),Ro=lr(He),zo=ge(function(n,t){var r=null==n?0:n.length,e=vt(n,t);return fr(n,l(t,function(n){return Re(n,r)?+n:n}).sort(Ur)),e}),Wo=lr(function(n){return wr(kt(n,1,_u,true))}),Bo=lr(function(n){var t=Ge(n);return _u(t)&&(t=F),wr(kt(n,1,_u,true),je(t,2))}),Lo=lr(function(n){var t=Ge(n),t=typeof t=="function"?t:F;return wr(kt(n,1,_u,true),F,t)}),Uo=lr(function(n,t){return _u(n)?jt(n,t):[]}),Co=lr(function(n){return Er(f(n,_u))}),Do=lr(function(n){var t=Ge(n);return _u(t)&&(t=F),
	Er(f(n,_u),je(t,2))}),Mo=lr(function(n){var t=Ge(n),t=typeof t=="function"?t:F;return Er(f(n,_u),F,t)}),To=lr(Ye),$o=lr(function(n){var t=n.length,t=1<t?n[t-1]:F,t=typeof t=="function"?(n.pop(),t):F;return Qe(n,t)}),Fo=ge(function(n){function t(t){return vt(t,n)}var r=n.length,e=r?n[0]:0,u=this.__wrapped__;return!(1<r||this.__actions__.length)&&u instanceof Mn&&Re(e)?(u=u.slice(e,+e+(r?1:0)),u.__actions__.push({func:nu,args:[t],thisArg:F}),new zn(u,this.__chain__).thru(function(n){return r&&!n.length&&n.push(F),
	n})):this.thru(t)}),No=Nr(function(n,t,r){ci.call(n,r)?++n[r]:_t(n,r,1)}),Po=Yr(Ze),Zo=Yr(qe),qo=Nr(function(n,t,r){ci.call(n,r)?n[r].push(t):_t(n,r,[t])}),Vo=lr(function(n,t,e){var u=-1,i=typeof t=="function",o=pu(n)?Hu(n.length):[];return oo(n,function(n){o[++u]=i?r(t,n,e):Dt(n,t,e)}),o}),Ko=Nr(function(n,t,r){_t(n,r,t)}),Go=Nr(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),Ho=lr(function(n,t){if(null==n)return[];var r=t.length;return 1<r&&ze(n,t[0],t[1])?t=[]:2<r&&ze(t[0],t[1],t[2])&&(t=[t[0]]),
	rr(n,kt(t,1),[])}),Jo=Si||function(){return Zn.Date.now()},Yo=lr(function(n,t,r){var e=1;if(r.length)var u=C(r,xe(Yo)),e=32|e;return le(n,e,t,r,u)}),Qo=lr(function(n,t,r){var e=3;if(r.length)var u=C(r,xe(Qo)),e=32|e;return le(t,e,n,r,u)}),Xo=lr(function(n,t){return xt(n,1,t)}),nf=lr(function(n,t,r){return xt(n,Iu(t)||0,r)});lu.Cache=Pn;var tf=lr(function(n,t){t=1==t.length&&af(t[0])?l(t[0],S(je())):l(kt(t,1),S(je()));var e=t.length;return lr(function(u){for(var i=-1,o=Mi(u.length,e);++i<o;)u[i]=t[i].call(this,u[i]);
	return r(n,this,u)})}),rf=lr(function(n,t){return le(n,32,F,t,C(t,xe(rf)))}),ef=lr(function(n,t){return le(n,64,F,t,C(t,xe(ef)))}),uf=ge(function(n,t){return le(n,256,F,F,F,t)}),of=oe(Wt),ff=oe(function(n,t){return n>=t}),cf=Mt(function(){return arguments}())?Mt:function(n){return xu(n)&&ci.call(n,"callee")&&!ji.call(n,"callee")},af=Hu.isArray,lf=Hn?S(Hn):Tt,sf=Bi||Gu,hf=Jn?S(Jn):$t,pf=Yn?S(Yn):Nt,_f=Qn?S(Qn):qt,vf=Xn?S(Xn):Vt,gf=nt?S(nt):Kt,df=oe(Jt),yf=oe(function(n,t){return n<=t}),bf=Pr(function(n,t){
	if(Le(t)||pu(t))Tr(t,Lu(t),n);else for(var r in t)ci.call(t,r)&&at(n,r,t[r])}),xf=Pr(function(n,t){Tr(t,Uu(t),n)}),jf=Pr(function(n,t,r,e){Tr(t,Uu(t),n,e)}),wf=Pr(function(n,t,r,e){Tr(t,Lu(t),n,e)}),mf=ge(vt),Af=lr(function(n){return n.push(F,se),r(jf,F,n)}),kf=lr(function(n){return n.push(F,he),r(Rf,F,n)}),Ef=ne(function(n,t,r){n[t]=r},Fu(Nu)),Of=ne(function(n,t,r){ci.call(n,t)?n[t].push(r):n[t]=[r]},je),Sf=lr(Dt),If=Pr(function(n,t,r){nr(n,t,r)}),Rf=Pr(function(n,t,r,e){nr(n,t,r,e)}),zf=ge(function(n,t){
	var r={};if(null==n)return r;var e=false;t=l(t,function(t){return t=Rr(t,n),e||(e=1<t.length),t}),Tr(n,ye(n),r),e&&(r=dt(r,7,pe));for(var u=t.length;u--;)mr(r,t[u]);return r}),Wf=ge(function(n,t){return null==n?{}:er(n,t)}),Bf=ae(Lu),Lf=ae(Uu),Uf=Gr(function(n,t,r){return t=t.toLowerCase(),n+(r?Mu(t):t)}),Cf=Gr(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Df=Gr(function(n,t,r){return n+(r?" ":"")+t.toLowerCase()}),Mf=Kr("toLowerCase"),Tf=Gr(function(n,t,r){return n+(r?"_":"")+t.toLowerCase();
	}),$f=Gr(function(n,t,r){return n+(r?" ":"")+Nf(t)}),Ff=Gr(function(n,t,r){return n+(r?" ":"")+t.toUpperCase()}),Nf=Kr("toUpperCase"),Pf=lr(function(n,t){try{return r(n,F,t)}catch(n){return vu(n)?n:new Yu(n)}}),Zf=ge(function(n,t){return u(t,function(t){t=$e(t),_t(n,t,Yo(n[t],n))}),n}),qf=Qr(),Vf=Qr(true),Kf=lr(function(n,t){return function(r){return Dt(r,n,t)}}),Gf=lr(function(n,t){return function(r){return Dt(n,r,t)}}),Hf=re(l),Jf=re(o),Yf=re(_),Qf=ie(),Xf=ie(true),nc=te(function(n,t){return n+t},0),tc=ce("ceil"),rc=te(function(n,t){
	return n/t},1),ec=ce("floor"),uc=te(function(n,t){return n*t},1),ic=ce("round"),oc=te(function(n,t){return n-t},0);return On.after=function(n,t){if(typeof t!="function")throw new ei("Expected a function");return n=Ou(n),function(){if(1>--n)return t.apply(this,arguments)}},On.ary=iu,On.assign=bf,On.assignIn=xf,On.assignInWith=jf,On.assignWith=wf,On.at=mf,On.before=ou,On.bind=Yo,On.bindAll=Zf,On.bindKey=Qo,On.castArray=function(){if(!arguments.length)return[];var n=arguments[0];return af(n)?n:[n]},
	On.chain=Xe,On.chunk=function(n,t,r){if(t=(r?ze(n,t,r):t===F)?1:Di(Ou(t),0),r=null==n?0:n.length,!r||1>t)return[];for(var e=0,u=0,i=Hu(Ri(r/t));e<r;)i[u++]=vr(n,e,e+=t);return i},On.compact=function(n){for(var t=-1,r=null==n?0:n.length,e=0,u=[];++t<r;){var i=n[t];i&&(u[e++]=i)}return u},On.concat=function(){var n=arguments.length;if(!n)return[];for(var t=Hu(n-1),r=arguments[0];n--;)t[n-1]=arguments[n];return s(af(r)?Mr(r):[r],kt(t,1))},On.cond=function(n){var t=null==n?0:n.length,e=je();return n=t?l(n,function(n){
	if("function"!=typeof n[1])throw new ei("Expected a function");return[e(n[0]),n[1]]}):[],lr(function(e){for(var u=-1;++u<t;){var i=n[u];if(r(i[0],this,e))return r(i[1],this,e)}})},On.conforms=function(n){return yt(dt(n,1))},On.constant=Fu,On.countBy=No,On.create=function(n,t){var r=io(n);return null==t?r:ht(r,t)},On.curry=fu,On.curryRight=cu,On.debounce=au,On.defaults=Af,On.defaultsDeep=kf,On.defer=Xo,On.delay=nf,On.difference=Ao,On.differenceBy=ko,On.differenceWith=Eo,On.drop=function(n,t,r){var e=null==n?0:n.length;
	return e?(t=r||t===F?1:Ou(t),vr(n,0>t?0:t,e)):[]},On.dropRight=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===F?1:Ou(t),t=e-t,vr(n,0,0>t?0:t)):[]},On.dropRightWhile=function(n,t){return n&&n.length?Ar(n,je(t,3),true,true):[]},On.dropWhile=function(n,t){return n&&n.length?Ar(n,je(t,3),true):[]},On.fill=function(n,t,r,e){var u=null==n?0:n.length;if(!u)return[];for(r&&typeof r!="number"&&ze(n,t,r)&&(r=0,e=u),u=n.length,r=Ou(r),0>r&&(r=-r>u?0:u+r),e=e===F||e>u?u:Ou(e),0>e&&(e+=u),e=r>e?0:Su(e);r<e;)n[r++]=t;
	return n},On.filter=function(n,t){return(af(n)?f:At)(n,je(t,3))},On.flatMap=function(n,t){return kt(uu(n,t),1)},On.flatMapDeep=function(n,t){return kt(uu(n,t),N)},On.flatMapDepth=function(n,t,r){return r=r===F?1:Ou(r),kt(uu(n,t),r)},On.flatten=Ve,On.flattenDeep=function(n){return(null==n?0:n.length)?kt(n,N):[]},On.flattenDepth=function(n,t){return null!=n&&n.length?(t=t===F?1:Ou(t),kt(n,t)):[]},On.flip=function(n){return le(n,512)},On.flow=qf,On.flowRight=Vf,On.fromPairs=function(n){for(var t=-1,r=null==n?0:n.length,e={};++t<r;){
	var u=n[t];e[u[0]]=u[1]}return e},On.functions=function(n){return null==n?[]:St(n,Lu(n))},On.functionsIn=function(n){return null==n?[]:St(n,Uu(n))},On.groupBy=qo,On.initial=function(n){return(null==n?0:n.length)?vr(n,0,-1):[]},On.intersection=Oo,On.intersectionBy=So,On.intersectionWith=Io,On.invert=Ef,On.invertBy=Of,On.invokeMap=Vo,On.iteratee=Pu,On.keyBy=Ko,On.keys=Lu,On.keysIn=Uu,On.map=uu,On.mapKeys=function(n,t){var r={};return t=je(t,3),Et(n,function(n,e,u){_t(r,t(n,e,u),n)}),r},On.mapValues=function(n,t){
	var r={};return t=je(t,3),Et(n,function(n,e,u){_t(r,e,t(n,e,u))}),r},On.matches=function(n){return Qt(dt(n,1))},On.matchesProperty=function(n,t){return Xt(n,dt(t,1))},On.memoize=lu,On.merge=If,On.mergeWith=Rf,On.method=Kf,On.methodOf=Gf,On.mixin=Zu,On.negate=su,On.nthArg=function(n){return n=Ou(n),lr(function(t){return tr(t,n)})},On.omit=zf,On.omitBy=function(n,t){return Cu(n,su(je(t)))},On.once=function(n){return ou(2,n)},On.orderBy=function(n,t,r,e){return null==n?[]:(af(t)||(t=null==t?[]:[t]),
	r=e?F:r,af(r)||(r=null==r?[]:[r]),rr(n,t,r))},On.over=Hf,On.overArgs=tf,On.overEvery=Jf,On.overSome=Yf,On.partial=rf,On.partialRight=ef,On.partition=Go,On.pick=Wf,On.pickBy=Cu,On.property=Vu,On.propertyOf=function(n){return function(t){return null==n?F:It(n,t)}},On.pull=Ro,On.pullAll=He,On.pullAllBy=function(n,t,r){return n&&n.length&&t&&t.length?or(n,t,je(r,2)):n},On.pullAllWith=function(n,t,r){return n&&n.length&&t&&t.length?or(n,t,F,r):n},On.pullAt=zo,On.range=Qf,On.rangeRight=Xf,On.rearg=uf,On.reject=function(n,t){
	return(af(n)?f:At)(n,su(je(t,3)))},On.remove=function(n,t){var r=[];if(!n||!n.length)return r;var e=-1,u=[],i=n.length;for(t=je(t,3);++e<i;){var o=n[e];t(o,e,n)&&(r.push(o),u.push(e))}return fr(n,u),r},On.rest=function(n,t){if(typeof n!="function")throw new ei("Expected a function");return t=t===F?t:Ou(t),lr(n,t)},On.reverse=Je,On.sampleSize=function(n,t,r){return t=(r?ze(n,t,r):t===F)?1:Ou(t),(af(n)?ot:hr)(n,t)},On.set=function(n,t,r){return null==n?n:pr(n,t,r)},On.setWith=function(n,t,r,e){return e=typeof e=="function"?e:F,
	null==n?n:pr(n,t,r,e)},On.shuffle=function(n){return(af(n)?ft:_r)(n)},On.slice=function(n,t,r){var e=null==n?0:n.length;return e?(r&&typeof r!="number"&&ze(n,t,r)?(t=0,r=e):(t=null==t?0:Ou(t),r=r===F?e:Ou(r)),vr(n,t,r)):[]},On.sortBy=Ho,On.sortedUniq=function(n){return n&&n.length?br(n):[]},On.sortedUniqBy=function(n,t){return n&&n.length?br(n,je(t,2)):[]},On.split=function(n,t,r){return r&&typeof r!="number"&&ze(n,t,r)&&(t=r=F),r=r===F?4294967295:r>>>0,r?(n=zu(n))&&(typeof t=="string"||null!=t&&!_f(t))&&(t=jr(t),
	!t&&Bn.test(n))?zr($(n),0,r):n.split(t,r):[]},On.spread=function(n,t){if(typeof n!="function")throw new ei("Expected a function");return t=null==t?0:Di(Ou(t),0),lr(function(e){var u=e[t];return e=zr(e,0,t),u&&s(e,u),r(n,this,e)})},On.tail=function(n){var t=null==n?0:n.length;return t?vr(n,1,t):[]},On.take=function(n,t,r){return n&&n.length?(t=r||t===F?1:Ou(t),vr(n,0,0>t?0:t)):[]},On.takeRight=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===F?1:Ou(t),t=e-t,vr(n,0>t?0:t,e)):[]},On.takeRightWhile=function(n,t){
	return n&&n.length?Ar(n,je(t,3),false,true):[]},On.takeWhile=function(n,t){return n&&n.length?Ar(n,je(t,3)):[]},On.tap=function(n,t){return t(n),n},On.throttle=function(n,t,r){var e=true,u=true;if(typeof n!="function")throw new ei("Expected a function");return bu(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),au(n,t,{leading:e,maxWait:t,trailing:u})},On.thru=nu,On.toArray=ku,On.toPairs=Bf,On.toPairsIn=Lf,On.toPath=function(n){return af(n)?l(n,$e):Au(n)?[n]:Mr(mo(zu(n)))},On.toPlainObject=Ru,
	On.transform=function(n,t,r){var e=af(n),i=e||sf(n)||gf(n);if(t=je(t,4),null==r){var o=n&&n.constructor;r=i?e?new o:[]:bu(n)&&gu(o)?io(bi(n)):{}}return(i?u:Et)(n,function(n,e,u){return t(r,n,e,u)}),r},On.unary=function(n){return iu(n,1)},On.union=Wo,On.unionBy=Bo,On.unionWith=Lo,On.uniq=function(n){return n&&n.length?wr(n):[]},On.uniqBy=function(n,t){return n&&n.length?wr(n,je(t,2)):[]},On.uniqWith=function(n,t){return t=typeof t=="function"?t:F,n&&n.length?wr(n,F,t):[]},On.unset=function(n,t){return null==n||mr(n,t);
	},On.unzip=Ye,On.unzipWith=Qe,On.update=function(n,t,r){return null==n?n:pr(n,t,Ir(r)(It(n,t)),void 0)},On.updateWith=function(n,t,r,e){return e=typeof e=="function"?e:F,null!=n&&(n=pr(n,t,Ir(r)(It(n,t)),e)),n},On.values=Du,On.valuesIn=function(n){return null==n?[]:I(n,Uu(n))},On.without=Uo,On.words=$u,On.wrap=function(n,t){return rf(Ir(t),n)},On.xor=Co,On.xorBy=Do,On.xorWith=Mo,On.zip=To,On.zipObject=function(n,t){return Or(n||[],t||[],at)},On.zipObjectDeep=function(n,t){return Or(n||[],t||[],pr);
	},On.zipWith=$o,On.entries=Bf,On.entriesIn=Lf,On.extend=xf,On.extendWith=jf,Zu(On,On),On.add=nc,On.attempt=Pf,On.camelCase=Uf,On.capitalize=Mu,On.ceil=tc,On.clamp=function(n,t,r){return r===F&&(r=t,t=F),r!==F&&(r=Iu(r),r=r===r?r:0),t!==F&&(t=Iu(t),t=t===t?t:0),gt(Iu(n),t,r)},On.clone=function(n){return dt(n,4)},On.cloneDeep=function(n){return dt(n,5)},On.cloneDeepWith=function(n,t){return t=typeof t=="function"?t:F,dt(n,5,t)},On.cloneWith=function(n,t){return t=typeof t=="function"?t:F,dt(n,4,t)},
	On.conformsTo=function(n,t){return null==t||bt(n,t,Lu(t))},On.deburr=Tu,On.defaultTo=function(n,t){return null==n||n!==n?t:n},On.divide=rc,On.endsWith=function(n,t,r){n=zu(n),t=jr(t);var e=n.length,e=r=r===F?e:gt(Ou(r),0,e);return r-=t.length,0<=r&&n.slice(r,e)==t},On.eq=hu,On.escape=function(n){return(n=zu(n))&&Y.test(n)?n.replace(H,et):n},On.escapeRegExp=function(n){return(n=zu(n))&&fn.test(n)?n.replace(on,"\\$&"):n},On.every=function(n,t,r){var e=af(n)?o:wt;return r&&ze(n,t,r)&&(t=F),e(n,je(t,3));
	},On.find=Po,On.findIndex=Ze,On.findKey=function(n,t){return v(n,je(t,3),Et)},On.findLast=Zo,On.findLastIndex=qe,On.findLastKey=function(n,t){return v(n,je(t,3),Ot)},On.floor=ec,On.forEach=ru,On.forEachRight=eu,On.forIn=function(n,t){return null==n?n:co(n,je(t,3),Uu)},On.forInRight=function(n,t){return null==n?n:ao(n,je(t,3),Uu)},On.forOwn=function(n,t){return n&&Et(n,je(t,3))},On.forOwnRight=function(n,t){return n&&Ot(n,je(t,3))},On.get=Wu,On.gt=of,On.gte=ff,On.has=function(n,t){return null!=n&&ke(n,t,Bt);
	},On.hasIn=Bu,On.head=Ke,On.identity=Nu,On.includes=function(n,t,r,e){return n=pu(n)?n:Du(n),r=r&&!e?Ou(r):0,e=n.length,0>r&&(r=Di(e+r,0)),mu(n)?r<=e&&-1<n.indexOf(t,r):!!e&&-1<d(n,t,r)},On.indexOf=function(n,t,r){var e=null==n?0:n.length;return e?(r=null==r?0:Ou(r),0>r&&(r=Di(e+r,0)),d(n,t,r)):-1},On.inRange=function(n,t,r){return t=Eu(t),r===F?(r=t,t=0):r=Eu(r),n=Iu(n),n>=Mi(t,r)&&n<Di(t,r)},On.invoke=Sf,On.isArguments=cf,On.isArray=af,On.isArrayBuffer=lf,On.isArrayLike=pu,On.isArrayLikeObject=_u,
	On.isBoolean=function(n){return true===n||false===n||xu(n)&&"[object Boolean]"==zt(n)},On.isBuffer=sf,On.isDate=hf,On.isElement=function(n){return xu(n)&&1===n.nodeType&&!wu(n)},On.isEmpty=function(n){if(null==n)return true;if(pu(n)&&(af(n)||typeof n=="string"||typeof n.splice=="function"||sf(n)||gf(n)||cf(n)))return!n.length;var t=yo(n);if("[object Map]"==t||"[object Set]"==t)return!n.size;if(Le(n))return!Ht(n).length;for(var r in n)if(ci.call(n,r))return false;return true},On.isEqual=function(n,t){return Ft(n,t);
	},On.isEqualWith=function(n,t,r){var e=(r=typeof r=="function"?r:F)?r(n,t):F;return e===F?Ft(n,t,F,r):!!e},On.isError=vu,On.isFinite=function(n){return typeof n=="number"&&Li(n)},On.isFunction=gu,On.isInteger=du,On.isLength=yu,On.isMap=pf,On.isMatch=function(n,t){return n===t||Pt(n,t,me(t))},On.isMatchWith=function(n,t,r){return r=typeof r=="function"?r:F,Pt(n,t,me(t),r)},On.isNaN=function(n){return ju(n)&&n!=+n},On.isNative=function(n){if(bo(n))throw new Yu("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
	return Zt(n)},On.isNil=function(n){return null==n},On.isNull=function(n){return null===n},On.isNumber=ju,On.isObject=bu,On.isObjectLike=xu,On.isPlainObject=wu,On.isRegExp=_f,On.isSafeInteger=function(n){return du(n)&&-9007199254740991<=n&&9007199254740991>=n},On.isSet=vf,On.isString=mu,On.isSymbol=Au,On.isTypedArray=gf,On.isUndefined=function(n){return n===F},On.isWeakMap=function(n){return xu(n)&&"[object WeakMap]"==yo(n)},On.isWeakSet=function(n){return xu(n)&&"[object WeakSet]"==zt(n)},On.join=function(n,t){
	return null==n?"":Ui.call(n,t)},On.kebabCase=Cf,On.last=Ge,On.lastIndexOf=function(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e;if(r!==F&&(u=Ou(r),u=0>u?Di(e+u,0):Mi(u,e-1)),t===t){for(r=u+1;r--&&n[r]!==t;);n=r}else n=g(n,b,u,true);return n},On.lowerCase=Df,On.lowerFirst=Mf,On.lt=df,On.lte=yf,On.max=function(n){return n&&n.length?mt(n,Nu,Wt):F},On.maxBy=function(n,t){return n&&n.length?mt(n,je(t,2),Wt):F},On.mean=function(n){return x(n,Nu)},On.meanBy=function(n,t){return x(n,je(t,2))},On.min=function(n){
	return n&&n.length?mt(n,Nu,Jt):F},On.minBy=function(n,t){return n&&n.length?mt(n,je(t,2),Jt):F},On.stubArray=Ku,On.stubFalse=Gu,On.stubObject=function(){return{}},On.stubString=function(){return""},On.stubTrue=function(){return true},On.multiply=uc,On.nth=function(n,t){return n&&n.length?tr(n,Ou(t)):F},On.noConflict=function(){return Zn._===this&&(Zn._=pi),this},On.noop=qu,On.now=Jo,On.pad=function(n,t,r){n=zu(n);var e=(t=Ou(t))?T(n):0;return!t||e>=t?n:(t=(t-e)/2,ee(zi(t),r)+n+ee(Ri(t),r))},On.padEnd=function(n,t,r){
	n=zu(n);var e=(t=Ou(t))?T(n):0;return t&&e<t?n+ee(t-e,r):n},On.padStart=function(n,t,r){n=zu(n);var e=(t=Ou(t))?T(n):0;return t&&e<t?ee(t-e,r)+n:n},On.parseInt=function(n,t,r){return r||null==t?t=0:t&&(t=+t),$i(zu(n).replace(an,""),t||0)},On.random=function(n,t,r){if(r&&typeof r!="boolean"&&ze(n,t,r)&&(t=r=F),r===F&&(typeof t=="boolean"?(r=t,t=F):typeof n=="boolean"&&(r=n,n=F)),n===F&&t===F?(n=0,t=1):(n=Eu(n),t===F?(t=n,n=0):t=Eu(t)),n>t){var e=n;n=t,t=e}return r||n%1||t%1?(r=Fi(),Mi(n+r*(t-n+$n("1e-"+((r+"").length-1))),t)):cr(n,t);
	},On.reduce=function(n,t,r){var e=af(n)?h:m,u=3>arguments.length;return e(n,je(t,4),r,u,oo)},On.reduceRight=function(n,t,r){var e=af(n)?p:m,u=3>arguments.length;return e(n,je(t,4),r,u,fo)},On.repeat=function(n,t,r){return t=(r?ze(n,t,r):t===F)?1:Ou(t),ar(zu(n),t)},On.replace=function(){var n=arguments,t=zu(n[0]);return 3>n.length?t:t.replace(n[1],n[2])},On.result=function(n,t,r){t=Rr(t,n);var e=-1,u=t.length;for(u||(u=1,n=F);++e<u;){var i=null==n?F:n[$e(t[e])];i===F&&(e=u,i=r),n=gu(i)?i.call(n):i;
	}return n},On.round=ic,On.runInContext=w,On.sample=function(n){return(af(n)?tt:sr)(n)},On.size=function(n){if(null==n)return 0;if(pu(n))return mu(n)?T(n):n.length;var t=yo(n);return"[object Map]"==t||"[object Set]"==t?n.size:Ht(n).length},On.snakeCase=Tf,On.some=function(n,t,r){var e=af(n)?_:gr;return r&&ze(n,t,r)&&(t=F),e(n,je(t,3))},On.sortedIndex=function(n,t){return dr(n,t)},On.sortedIndexBy=function(n,t,r){return yr(n,t,je(r,2))},On.sortedIndexOf=function(n,t){var r=null==n?0:n.length;if(r){
	var e=dr(n,t);if(e<r&&hu(n[e],t))return e}return-1},On.sortedLastIndex=function(n,t){return dr(n,t,true)},On.sortedLastIndexBy=function(n,t,r){return yr(n,t,je(r,2),true)},On.sortedLastIndexOf=function(n,t){if(null==n?0:n.length){var r=dr(n,t,true)-1;if(hu(n[r],t))return r}return-1},On.startCase=$f,On.startsWith=function(n,t,r){return n=zu(n),r=null==r?0:gt(Ou(r),0,n.length),t=jr(t),n.slice(r,r+t.length)==t},On.subtract=oc,On.sum=function(n){return n&&n.length?k(n,Nu):0},On.sumBy=function(n,t){return n&&n.length?k(n,je(t,2)):0;
	},On.template=function(n,t,r){var e=On.templateSettings;r&&ze(n,t,r)&&(t=F),n=zu(n),t=jf({},t,e,se),r=jf({},t.imports,e.imports,se);var u,i,o=Lu(r),f=I(r,o),c=0;r=t.interpolate||An;var a="__p+='";r=ti((t.escape||An).source+"|"+r.source+"|"+(r===nn?gn:An).source+"|"+(t.evaluate||An).source+"|$","g");var l="sourceURL"in t?"//# sourceURL="+t.sourceURL+"\n":"";if(n.replace(r,function(t,r,e,o,f,l){return e||(e=o),a+=n.slice(c,l).replace(kn,B),r&&(u=true,a+="'+__e("+r+")+'"),f&&(i=true,a+="';"+f+";\n__p+='"),
	e&&(a+="'+((__t=("+e+"))==null?'':__t)+'"),c=l+t.length,t}),a+="';",(t=t.variable)||(a="with(obj){"+a+"}"),a=(i?a.replace(q,""):a).replace(V,"$1").replace(K,"$1;"),a="function("+(t||"obj")+"){"+(t?"":"obj||(obj={});")+"var __t,__p=''"+(u?",__e=_.escape":"")+(i?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}":";")+a+"return __p}",t=Pf(function(){return Qu(o,l+"return "+a).apply(F,f)}),t.source=a,vu(t))throw t;return t},On.times=function(n,t){if(n=Ou(n),1>n||9007199254740991<n)return[];
	var r=4294967295,e=Mi(n,4294967295);for(t=je(t),n-=4294967295,e=E(e,t);++r<n;)t(r);return e},On.toFinite=Eu,On.toInteger=Ou,On.toLength=Su,On.toLower=function(n){return zu(n).toLowerCase()},On.toNumber=Iu,On.toSafeInteger=function(n){return n?gt(Ou(n),-9007199254740991,9007199254740991):0===n?n:0},On.toString=zu,On.toUpper=function(n){return zu(n).toUpperCase()},On.trim=function(n,t,r){return(n=zu(n))&&(r||t===F)?n.replace(cn,""):n&&(t=jr(t))?(n=$(n),r=$(t),t=z(n,r),r=W(n,r)+1,zr(n,t,r).join("")):n;
	},On.trimEnd=function(n,t,r){return(n=zu(n))&&(r||t===F)?n.replace(ln,""):n&&(t=jr(t))?(n=$(n),t=W(n,$(t))+1,zr(n,0,t).join("")):n},On.trimStart=function(n,t,r){return(n=zu(n))&&(r||t===F)?n.replace(an,""):n&&(t=jr(t))?(n=$(n),t=z(n,$(t)),zr(n,t).join("")):n},On.truncate=function(n,t){var r=30,e="...";if(bu(t))var u="separator"in t?t.separator:u,r="length"in t?Ou(t.length):r,e="omission"in t?jr(t.omission):e;n=zu(n);var i=n.length;if(Bn.test(n))var o=$(n),i=o.length;if(r>=i)return n;if(i=r-T(e),1>i)return e;
	if(r=o?zr(o,0,i).join(""):n.slice(0,i),u===F)return r+e;if(o&&(i+=r.length-i),_f(u)){if(n.slice(i).search(u)){var f=r;for(u.global||(u=ti(u.source,zu(dn.exec(u))+"g")),u.lastIndex=0;o=u.exec(f);)var c=o.index;r=r.slice(0,c===F?i:c)}}else n.indexOf(jr(u),i)!=i&&(u=r.lastIndexOf(u),-1<u&&(r=r.slice(0,u)));return r+e},On.unescape=function(n){return(n=zu(n))&&J.test(n)?n.replace(G,ut):n},On.uniqueId=function(n){var t=++ai;return zu(n)+t},On.upperCase=Ff,On.upperFirst=Nf,On.each=ru,On.eachRight=eu,On.first=Ke,
	Zu(On,function(){var n={};return Et(On,function(t,r){ci.call(On.prototype,r)||(n[r]=t)}),n}(),{chain:false}),On.VERSION="4.17.4",u("bind bindKey curry curryRight partial partialRight".split(" "),function(n){On[n].placeholder=On}),u(["drop","take"],function(n,t){Mn.prototype[n]=function(r){r=r===F?1:Di(Ou(r),0);var e=this.__filtered__&&!t?new Mn(this):this.clone();return e.__filtered__?e.__takeCount__=Mi(r,e.__takeCount__):e.__views__.push({size:Mi(r,4294967295),type:n+(0>e.__dir__?"Right":"")}),e},Mn.prototype[n+"Right"]=function(t){
	return this.reverse()[n](t).reverse()}}),u(["filter","map","takeWhile"],function(n,t){var r=t+1,e=1==r||3==r;Mn.prototype[n]=function(n){var t=this.clone();return t.__iteratees__.push({iteratee:je(n,3),type:r}),t.__filtered__=t.__filtered__||e,t}}),u(["head","last"],function(n,t){var r="take"+(t?"Right":"");Mn.prototype[n]=function(){return this[r](1).value()[0]}}),u(["initial","tail"],function(n,t){var r="drop"+(t?"":"Right");Mn.prototype[n]=function(){return this.__filtered__?new Mn(this):this[r](1);
	}}),Mn.prototype.compact=function(){return this.filter(Nu)},Mn.prototype.find=function(n){return this.filter(n).head()},Mn.prototype.findLast=function(n){return this.reverse().find(n)},Mn.prototype.invokeMap=lr(function(n,t){return typeof n=="function"?new Mn(this):this.map(function(r){return Dt(r,n,t)})}),Mn.prototype.reject=function(n){return this.filter(su(je(n)))},Mn.prototype.slice=function(n,t){n=Ou(n);var r=this;return r.__filtered__&&(0<n||0>t)?new Mn(r):(0>n?r=r.takeRight(-n):n&&(r=r.drop(n)),
	t!==F&&(t=Ou(t),r=0>t?r.dropRight(-t):r.take(t-n)),r)},Mn.prototype.takeRightWhile=function(n){return this.reverse().takeWhile(n).reverse()},Mn.prototype.toArray=function(){return this.take(4294967295)},Et(Mn.prototype,function(n,t){var r=/^(?:filter|find|map|reject)|While$/.test(t),e=/^(?:head|last)$/.test(t),u=On[e?"take"+("last"==t?"Right":""):t],i=e||/^find/.test(t);u&&(On.prototype[t]=function(){function t(n){return n=u.apply(On,s([n],f)),e&&h?n[0]:n}var o=this.__wrapped__,f=e?[1]:arguments,c=o instanceof Mn,a=f[0],l=c||af(o);
	l&&r&&typeof a=="function"&&1!=a.length&&(c=l=false);var h=this.__chain__,p=!!this.__actions__.length,a=i&&!h,c=c&&!p;return!i&&l?(o=c?o:new Mn(this),o=n.apply(o,f),o.__actions__.push({func:nu,args:[t],thisArg:F}),new zn(o,h)):a&&c?n.apply(this,f):(o=this.thru(t),a?e?o.value()[0]:o.value():o)})}),u("pop push shift sort splice unshift".split(" "),function(n){var t=ui[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:pop|shift)$/.test(n);On.prototype[n]=function(){var n=arguments;if(e&&!this.__chain__){
	var u=this.value();return t.apply(af(u)?u:[],n)}return this[r](function(r){return t.apply(af(r)?r:[],n)})}}),Et(Mn.prototype,function(n,t){var r=On[t];if(r){var e=r.name+"";(Ji[e]||(Ji[e]=[])).push({name:t,func:r})}}),Ji[Xr(F,2).name]=[{name:"wrapper",func:F}],Mn.prototype.clone=function(){var n=new Mn(this.__wrapped__);return n.__actions__=Mr(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=Mr(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=Mr(this.__views__),
	n},Mn.prototype.reverse=function(){if(this.__filtered__){var n=new Mn(this);n.__dir__=-1,n.__filtered__=true}else n=this.clone(),n.__dir__*=-1;return n},Mn.prototype.value=function(){var n,t=this.__wrapped__.value(),r=this.__dir__,e=af(t),u=0>r,i=e?t.length:0;n=i;for(var o=this.__views__,f=0,c=-1,a=o.length;++c<a;){var l=o[c],s=l.size;switch(l.type){case"drop":f+=s;break;case"dropRight":n-=s;break;case"take":n=Mi(n,f+s);break;case"takeRight":f=Di(f,n-s)}}if(n={start:f,end:n},o=n.start,f=n.end,n=f-o,
	o=u?f:o-1,f=this.__iteratees__,c=f.length,a=0,l=Mi(n,this.__takeCount__),!e||!u&&i==n&&l==n)return kr(t,this.__actions__);e=[];n:for(;n--&&a<l;){for(o+=r,u=-1,i=t[o];++u<c;){var h=f[u],s=h.type,h=(0,h.iteratee)(i);if(2==s)i=h;else if(!h){if(1==s)continue n;break n}}e[a++]=i}return e},On.prototype.at=Fo,On.prototype.chain=function(){return Xe(this)},On.prototype.commit=function(){return new zn(this.value(),this.__chain__)},On.prototype.next=function(){this.__values__===F&&(this.__values__=ku(this.value()));
	var n=this.__index__>=this.__values__.length;return{done:n,value:n?F:this.__values__[this.__index__++]}},On.prototype.plant=function(n){for(var t,r=this;r instanceof Sn;){var e=Pe(r);e.__index__=0,e.__values__=F,t?u.__wrapped__=e:t=e;var u=e,r=r.__wrapped__}return u.__wrapped__=n,t},On.prototype.reverse=function(){var n=this.__wrapped__;return n instanceof Mn?(this.__actions__.length&&(n=new Mn(this)),n=n.reverse(),n.__actions__.push({func:nu,args:[Je],thisArg:F}),new zn(n,this.__chain__)):this.thru(Je);
	},On.prototype.toJSON=On.prototype.valueOf=On.prototype.value=function(){return kr(this.__wrapped__,this.__actions__)},On.prototype.first=On.prototype.head,Ai&&(On.prototype[Ai]=tu),On}(); true?(Zn._=it, !(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return it}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))):Vn?((Vn.exports=it)._=it,qn._=it):Zn._=it}).call(this);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(47)(module)))

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint-disable max-params, no-unexpected-multiline, no-console, max-statements */
	'use strict';
	
	const _ = __webpack_require__(259);
	const os = __webpack_require__(49);
	const path = __webpack_require__(69);
	const most = __webpack_require__(274);
	const webpack = __webpack_require__(107);
	const SocketIOClient = __webpack_require__(279);
	const InspectpackDaemon = __webpack_require__(273).daemon;
	
	const serializeError = __webpack_require__(265).serializeError;
	
	const DEFAULT_PORT = 9838;
	const ONE_SECOND = 1000;
	const INSPECTPACK_PROBLEM_ACTIONS = ['versions', 'duplicates'];
	const INSPECTPACK_PROBLEM_TYPE = 'problems';
	
	const cacheDir = path.resolve(os.homedir(), '.webpack-dashboard-cache');
	
	function noop() {}
	
	function getTimeMessage(timer) {
	  let time = Date.now() - timer;
	
	  if (time >= ONE_SECOND) {
	    time /= ONE_SECOND;
	    time = Math.round(time);
	    time += 's';
	  } else {
	    time += 'ms';
	  }
	
	  return ` (${time})`;
	}
	
	function observeBundleMetrics(stats, inspectpack) {
	  const bundlesToObserve = Object.keys(stats.compilation.assets)
	    .filter(
	      bundlePath =>
	        // Don't include hot reload assets, they break everything
	        // and the updates are already included in the new assets
	        bundlePath.indexOf('.hot-update.') === -1 &&
	        // Don't parse sourcemaps!
	        path.extname(bundlePath) === '.js'
	    )
	    .map(bundlePath => ({
	      path: bundlePath,
	      context: stats.compilation.options.context,
	      source: stats.compilation.assets[bundlePath].source(),
	    }));
	
	  const getSizes = bundles =>
	    Promise.all(
	      bundles.map(bundle =>
	        inspectpack
	          .sizes({
	            code: bundle.source,
	            root: bundle.context,
	            format: 'object',
	            minified: true,
	            gzip: true,
	          })
	          .then(metrics => ({
	            path: bundle.path,
	            metrics,
	          }))
	      )
	    )
	      .then(bundle => ({
	        type: 'sizes',
	        value: bundle,
	      }))
	      .catch(err => ({
	        type: 'sizes',
	        error: true,
	        value: serializeError(err),
	      }));
	
	  const getProblems = bundles =>
	    Promise.all(
	      INSPECTPACK_PROBLEM_ACTIONS.map(action =>
	        Promise.all(
	          bundles.map(bundle =>
	            inspectpack
	              [action]({
	                code: bundle.source,
	                root: bundle.context,
	                duplicates: true,
	                format: 'object',
	                minified: true,
	                gzip: true,
	              })
	              .then(metrics => ({
	                path: bundle.path,
	                [action]: metrics,
	              }))
	          )
	        )
	      )
	    )
	      .then(bundle => ({
	        type: INSPECTPACK_PROBLEM_TYPE,
	        value: _.flatten(bundle),
	      }))
	      .catch(err => ({
	        type: INSPECTPACK_PROBLEM_TYPE,
	        error: true,
	        value: serializeError(err),
	      }));
	
	  const sizesStream = most.of(bundlesToObserve).map(getSizes);
	  const problemsStream = most.of(bundlesToObserve).map(getProblems);
	
	  return most.mergeArray([sizesStream, problemsStream]).chain(most.fromPromise);
	}
	
	class DashboardPlugin {
	  constructor(options) {
	    if (typeof options === 'function') {
	      this.handler = options;
	    } else {
	      options = options || {};
	      this.port = options.port || DEFAULT_PORT;
	      this.handler = options.handler || null;
	    }
	
	    this.cleanup = this.cleanup.bind(this);
	
	    this.watching = false;
	
	    InspectpackDaemon.init({ cacheDir }).then(inspectpack => {
	      this.inspectpack = inspectpack;
	    });
	  }
	
	  cleanup() {
	    if (!this.watching && this.socket) {
	      this.handler = null;
	      this.socket.close();
	      this.inspectpack.terminate();
	    }
	  }
	
	  apply(compiler) {
	    let handler = this.handler;
	    let timer;
	
	    // Enable pathinfo for inspectpack support
	    compiler.options.output.pathinfo = true;
	
	    if (!handler) {
	      handler = noop;
	      const port = this.port;
	      const host = '127.0.0.1';
	      this.socket = new SocketIOClient(`http://${host}:${port}`);
	      this.socket.on('connect', () => {
	        handler = this.socket.emit.bind(this.socket, 'message');
	      });
	    }
	
	    compiler.apply(
	      new webpack.ProgressPlugin((percent, msg) => {
	        handler([
	          {
	            type: 'status',
	            value: 'Compiling',
	          },
	          {
	            type: 'progress',
	            value: percent,
	          },
	          {
	            type: 'operations',
	            value: msg + getTimeMessage(timer),
	          },
	        ]);
	      })
	    );
	
	    compiler.plugin('watch-run', (c, done) => {
	      this.watching = true;
	      done();
	    });
	
	    compiler.plugin('run', (c, done) => {
	      this.watching = false;
	      done();
	    });
	
	    compiler.plugin('compile', () => {
	      timer = Date.now();
	      handler([
	        {
	          type: 'status',
	          value: 'Compiling',
	        },
	      ]);
	    });
	
	    compiler.plugin('invalid', () => {
	      handler([
	        {
	          type: 'status',
	          value: 'Invalidated',
	        },
	        {
	          type: 'progress',
	          value: 0,
	        },
	        {
	          type: 'operations',
	          value: 'idle',
	        },
	        {
	          type: 'clear',
	        },
	      ]);
	    });
	
	    compiler.plugin('failed', () => {
	      handler([
	        {
	          type: 'status',
	          value: 'Failed',
	        },
	        {
	          type: 'operations',
	          value: `idle${getTimeMessage(timer)}`,
	        },
	      ]);
	    });
	
	    compiler.plugin('done', stats => {
	      const options = stats.compilation.options;
	      const statsOptions = (options.devServer && options.devServer.stats) ||
	      options.stats || { colors: true };
	
	      handler([
	        {
	          type: 'status',
	          value: 'Success',
	        },
	        {
	          type: 'progress',
	          value: 0,
	        },
	        {
	          type: 'operations',
	          value: `idle${getTimeMessage(timer)}`,
	        },
	        {
	          type: 'stats',
	          value: {
	            errors: stats.hasErrors(),
	            warnings: stats.hasWarnings(),
	            data: stats.toJson(),
	          },
	        },
	        {
	          type: 'log',
	          value: stats.toString(statsOptions),
	        },
	      ]);
	
	      observeBundleMetrics(stats, this.inspectpack).subscribe({
	        next: message => handler([message]),
	        error: err => {
	          console.log('Error from inspectpack:', err);
	          this.cleanup();
	        },
	        complete: this.cleanup,
	      });
	    });
	  }
	}
	
	module.exports = DashboardPlugin;


/***/ }),
/* 265 */
/***/ (function(module, exports) {

	"use strict";
	
	const serializeError = err => ({
	  code: err.code,
	  message: err.message,
	  stack: err.stack
	});
	
	const deserializeError = serializedError => {
	  const err = new Error();
	  err.code = serializedError.code;
	  err.message = serializedError.message;
	  err.stack = serializedError.stack;
	  return err;
	};
	
	module.exports = {
	  serializeError,
	  deserializeError
	};


/***/ }),
/* 266 */
/***/ (function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ }),
/* 267 */
/***/ (function(module, exports) {

	module.exports = require("async");

/***/ }),
/* 268 */
/***/ (function(module, exports) {

	module.exports = require("bluebird");

/***/ }),
/* 269 */
/***/ (function(module, exports) {

	module.exports = require("body-parser");

/***/ }),
/* 270 */
/***/ (function(module, exports) {

	module.exports = require("debug");

/***/ }),
/* 271 */
/***/ (function(module, exports) {

	module.exports = require("express");

/***/ }),
/* 272 */
/***/ (function(module, exports) {

	module.exports = require("html-webpack-plugin");

/***/ }),
/* 273 */
/***/ (function(module, exports) {

	module.exports = require("inspectpack");

/***/ }),
/* 274 */
/***/ (function(module, exports) {

	module.exports = require("most");

/***/ }),
/* 275 */
/***/ (function(module, exports) {

	module.exports = require("ms");

/***/ }),
/* 276 */
/***/ (function(module, exports) {

	module.exports = require("net");

/***/ }),
/* 277 */
/***/ (function(module, exports) {

	module.exports = require("resolve-from");

/***/ }),
/* 278 */
/***/ (function(module, exports) {

	module.exports = require("semver");

/***/ }),
/* 279 */
/***/ (function(module, exports) {

	module.exports = require("socket.io-client");

/***/ }),
/* 280 */
/***/ (function(module, exports) {

	module.exports = require("tls");

/***/ }),
/* 281 */
/***/ (function(module, exports) {

	module.exports = require("url");

/***/ }),
/* 282 */
/***/ (function(module, exports) {

	module.exports = require("webpack-dev-middleware");

/***/ }),
/* 283 */
/***/ (function(module, exports) {

	module.exports = require("webpack-hot-middleware");

/***/ })
/******/ ]);
//# sourceMappingURL=server.js.map